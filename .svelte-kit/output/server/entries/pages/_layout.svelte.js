import {
  n as noop,
  a as set_current_component,
  r as run_all,
  b as current_component,
  s as setContext,
  g as getContext,
  o as onDestroy,
  c as create_ssr_component,
  d as subscribe,
  v as validate_component,
  e as add_attribute,
  f as get_current_component,
  h as compute_rest_props,
  i as identity,
  j as createEventDispatcher,
  k as spread,
  l as escape_attribute_value,
  p as escape_object,
  q as escape$1,
  t as assign,
  u as compute_slots,
} from "../../chunks/ssr.js";
import "../../chunks/client.js";
import {
  d as derived,
  w as writable,
  r as readable,
} from "../../chunks/index.js";
import mitt from "mitt";
import "yoga-layout";
import { twMerge } from "tailwind-merge";
import { F as Frame } from "../../chunks/Frame.js";
import { c as currentUser } from "../../chunks/pocketbase.js";
import { createNoise3D } from "simplex-noise";
import { shaderStructs, shaderIntersectFunction } from "three-mesh-bvh";
import "@tweakpane/core";
import "tweakpane";
import "fast-copy";
import "@tweakpane/core/dist/input-binding/point-2d/model/point-2d.js";
import "@tweakpane/core/dist/input-binding/point-3d/model/point-3d.js";
import "@tweakpane/core/dist/input-binding/point-4d/model/point-4d.js";
import colors from "tailwindcss/colors.js";
import RAPIER, { EventQueue, RigidBodyType } from "@dimforge/rapier3d-compat";
import { b as base } from "../../chunks/paths.js";
const is_client = typeof window !== "undefined";
let now$1 = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0) raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0) raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add((task = { c: callback, f: fulfill }));
    }),
    abort() {
      tasks.delete(task);
    },
  };
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = "162";
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const ConstantColorFactor = 211;
const OneMinusConstantColorFactor = 212;
const ConstantAlphaFactor = 213;
const OneMinusConstantAlphaFactor = 214;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;
const AgXToneMapping = 6;
const NeutralToneMapping = 7;
const AttachedBindMode = "attached";
const DetachedBindMode = "detached";
const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const RepeatWrapping = 1e3;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBAIntegerFormat = 1033;
const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const RGB_BPTC_SIGNED_Format = 36494;
const RGB_BPTC_UNSIGNED_Format = 36495;
const RED_RGTC1_Format = 36283;
const SIGNED_RED_RGTC1_Format = 36284;
const RED_GREEN_RGTC2_Format = 36285;
const SIGNED_RED_GREEN_RGTC2_Format = 36286;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;
const NoColorSpace = "";
const SRGBColorSpace = "srgb";
const LinearSRGBColorSpace = "srgb-linear";
const DisplayP3ColorSpace = "display-p3";
const LinearDisplayP3ColorSpace = "display-p3-linear";
const LinearTransfer = "linear";
const SRGBTransfer = "srgb";
const Rec709Primaries = "rec709";
const P3Primaries = "p3";
const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;
const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;
const NeverCompare = 512;
const LessCompare = 513;
const EqualCompare = 514;
const LessEqualCompare = 515;
const GreaterCompare = 516;
const NotEqualCompare = 517;
const GreaterEqualCompare = 518;
const AlwaysCompare = 519;
const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;
const GLSL1 = "100";
const GLSL3 = "300 es";
const _SRGBAFormat = 1035;
const WebGLCoordinateSystem = 2e3;
const WebGPUCoordinateSystem = 2001;
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0) return false;
    const listeners = this._listeners;
    return (
      listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1
    );
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
}
const _lut = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let _seed = 1234567;
const DEG2RAD$1 = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = (Math.random() * 4294967295) | 0;
  const d1 = (Math.random() * 4294967295) | 0;
  const d2 = (Math.random() * 4294967295) | 0;
  const d3 = (Math.random() * 4294967295) | 0;
  const uuid =
    _lut[d0 & 255] +
    _lut[(d0 >> 8) & 255] +
    _lut[(d0 >> 16) & 255] +
    _lut[(d0 >> 24) & 255] +
    "-" +
    _lut[d1 & 255] +
    _lut[(d1 >> 8) & 255] +
    "-" +
    _lut[((d1 >> 16) & 15) | 64] +
    _lut[(d1 >> 24) & 255] +
    "-" +
    _lut[(d2 & 63) | 128] +
    _lut[(d2 >> 8) & 255] +
    "-" +
    _lut[(d2 >> 16) & 255] +
    _lut[(d2 >> 24) & 255] +
    _lut[d3 & 255] +
    _lut[(d3 >> 8) & 255] +
    _lut[(d3 >> 16) & 255] +
    _lut[(d3 >> 24) & 255];
  return uuid.toLowerCase();
}
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return ((n % m) + m) % m;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);
}
function inverseLerp(x, y2, value) {
  if (x !== y2) {
    return (value - x) / (y2 - x);
  } else {
    return 0;
  }
}
function lerp(x, y2, t) {
  return (1 - t) * x + t * y2;
}
function damp(x, y2, lambda, dt) {
  return lerp(x, y2, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
}
function smoothstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
  if (x <= min) return 0;
  if (x >= max) return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0) _seed = s;
  let t = (_seed += 1831565813);
  t = Math.imul(t ^ (t >>> 15), t | 1);
  t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
  return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD$1;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & (value - 1)) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b / 2);
  const s2 = sin(b / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          order,
      );
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const MathUtils = {
  DEG2RAD: DEG2RAD$1,
  RAD2DEG,
  generateUUID,
  clamp: clamp$1,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize,
};
class Vector2 {
  constructor(x = 0, y2 = 0) {
    Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y2) {
    this.x = x;
    this.y = y2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x,
      y2 = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y2 + e[6];
    this.y = e[1] * x + e[4] * y2 + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length)),
    );
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$1(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x,
      dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle),
      s = Math.sin(angle);
    const x = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x * c - y2 * s + center.x;
    this.y = x * s + y2 * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
}
class Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    Matrix3.prototype.isMatrix3 = true;
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
      a12 = ae[3],
      a13 = ae[6];
    const a21 = ae[1],
      a22 = ae[4],
      a23 = ae[7];
    const a31 = ae[2],
      a32 = ae[5],
      a33 = ae[8];
    const b11 = be[0],
      b12 = be[3],
      b13 = be[6];
    const b21 = be[1],
      b22 = be[4],
      b23 = be[7];
    const b31 = be[2],
      b32 = be[5],
      b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0],
      b = te[1],
      c = te[2],
      d = te[3],
      e = te[4],
      f = te[5],
      g = te[6],
      h = te[7],
      i = te[8];
    return (
      a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g
    );
  }
  invert() {
    const te = this.elements,
      n11 = te[0],
      n21 = te[1],
      n31 = te[2],
      n12 = te[3],
      n22 = te[4],
      n32 = te[5],
      n13 = te[6],
      n23 = te[7],
      n33 = te[8],
      t11 = n33 * n22 - n32 * n23,
      t12 = n32 * n13 - n33 * n12,
      t13 = n23 * n12 - n22 * n13,
      det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m = this.elements;
    tmp2 = m[1];
    m[1] = m[3];
    m[3] = tmp2;
    tmp2 = m[2];
    m[2] = m[6];
    m[6] = tmp2;
    tmp2 = m[5];
    m[5] = m[7];
    m[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1,
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x, y2) {
    if (x.isVector2) {
      this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
    } else {
      this.set(1, 0, x, 0, 1, y2, 0, 0, 1);
    }
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(c, -s, 0, s, c, 0, 0, 0, 1);
    return this;
  }
  makeScale(x, y2) {
    this.set(x, 0, 0, 0, y2, 0, 0, 0, 1);
    return this;
  }
  //
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const _m3 = /* @__PURE__ */ new Matrix3();
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535) return true;
  }
  return false;
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
const _cache = {};
function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}
const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = /* @__PURE__ */ new Matrix3().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199,
);
const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = /* @__PURE__ */ new Matrix3().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735,
);
const COLOR_SPACES = {
  [LinearSRGBColorSpace]: {
    transfer: LinearTransfer,
    primaries: Rec709Primaries,
    toReference: (color) => color,
    fromReference: (color) => color,
  },
  [SRGBColorSpace]: {
    transfer: SRGBTransfer,
    primaries: Rec709Primaries,
    toReference: (color) => color.convertSRGBToLinear(),
    fromReference: (color) => color.convertLinearToSRGB(),
  },
  [LinearDisplayP3ColorSpace]: {
    transfer: LinearTransfer,
    primaries: P3Primaries,
    toReference: (color) =>
      color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color) =>
      color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3),
  },
  [DisplayP3ColorSpace]: {
    transfer: SRGBTransfer,
    primaries: P3Primaries,
    toReference: (color) =>
      color
        .convertSRGBToLinear()
        .applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color) =>
      color
        .applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
        .convertLinearToSRGB(),
  },
};
const SUPPORTED_WORKING_COLOR_SPACES = /* @__PURE__ */ new Set([
  LinearSRGBColorSpace,
  LinearDisplayP3ColorSpace,
]);
const ColorManagement = {
  enabled: true,
  _workingColorSpace: LinearSRGBColorSpace,
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(colorSpace) {
    if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
      throw new Error(`Unsupported working color space, "${colorSpace}".`);
    }
    this._workingColorSpace = colorSpace;
  },
  convert: function (color, sourceColorSpace, targetColorSpace) {
    if (
      this.enabled === false ||
      sourceColorSpace === targetColorSpace ||
      !sourceColorSpace ||
      !targetColorSpace
    ) {
      return color;
    }
    const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
    const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
    return targetFromReference(sourceToReference(color));
  },
  fromWorkingColorSpace: function (color, targetColorSpace) {
    return this.convert(color, this._workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function (color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this._workingColorSpace);
  },
  getPrimaries: function (colorSpace) {
    return COLOR_SPACES[colorSpace].primaries;
  },
  getTransfer: function (colorSpace) {
    if (colorSpace === NoColorSpace) return LinearTransfer;
    return COLOR_SPACES[colorSpace].transfer;
  },
};
function SRGBToLinear(c) {
  return c < 0.04045
    ? c * 0.0773993808
    : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
let _canvas;
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn(
        "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
        image,
      );
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (
      (typeof HTMLImageElement !== "undefined" &&
        image instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement !== "undefined" &&
        image instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap)
    ) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear(data[i] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
        } else {
          data[i] = SRGBToLinear(data[i]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height,
      };
    } else {
      console.warn(
        "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.",
      );
      return image;
    }
  }
}
let _sourceId = 0;
class Source {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.dataReady = true;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: "",
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i = 0, l = data.length; i < l; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image));
          } else {
            url.push(serializeImage(data[i]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
}
function serializeImage(image) {
  if (
    (typeof HTMLImageElement !== "undefined" &&
      image instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement !== "undefined" &&
      image instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap)
  ) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name,
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
let _textureId = 0;
class Texture extends EventDispatcher {
  constructor(
    image = Texture.DEFAULT_IMAGE,
    mapping = Texture.DEFAULT_MAPPING,
    wrapS = ClampToEdgeWrapping,
    wrapT = ClampToEdgeWrapping,
    magFilter = LinearFilter,
    minFilter = LinearMipmapLinearFilter,
    format = RGBAFormat,
    type = UnsignedByteType,
    anisotropy = Texture.DEFAULT_ANISOTROPY,
    colorSpace = NoColorSpace,
  ) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON",
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    if (Object.keys(this.userData).length > 0) output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
}
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
class Vector4 {
  constructor(x = 0, y2 = 0, z = 0, w = 1) {
    Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y2;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y2, z, w) {
    this.x = x;
    this.y = y2;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x,
      y2 = this.y,
      z = this.z,
      w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y2 + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y2 + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y2 + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y2 + e[11] * z + e[15] * w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y2, z;
    const epsilon = 0.01,
      epsilon2 = 0.1,
      te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10];
    if (
      Math.abs(m12 - m21) < epsilon &&
      Math.abs(m13 - m31) < epsilon &&
      Math.abs(m23 - m32) < epsilon
    ) {
      if (
        Math.abs(m12 + m21) < epsilon2 &&
        Math.abs(m13 + m31) < epsilon2 &&
        Math.abs(m23 + m32) < epsilon2 &&
        Math.abs(m11 + m22 + m33 - 3) < epsilon2
      ) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y2 = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y2 = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y2 = 0;
          z = 0.707106781;
        } else {
          y2 = Math.sqrt(yy);
          x = xy / y2;
          z = yz / y2;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y2 = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y2 = yz / z;
        }
      }
      this.set(x, y2, z, angle);
      return this;
    }
    let s = Math.sqrt(
      (m32 - m23) * (m32 - m23) +
        (m13 - m31) * (m13 - m31) +
        (m21 - m12) * (m21 - m12),
    );
    if (Math.abs(s) < 1e-3) s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length)),
    );
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
}
class RenderTarget extends EventDispatcher {
  constructor(width = 1, height = 1, options = {}) {
    super();
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: 1 };
    options = Object.assign(
      {
        generateMipmaps: false,
        internalFormat: null,
        minFilter: LinearFilter,
        depthBuffer: true,
        stencilBuffer: false,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      options,
    );
    const texture = new Texture(
      image,
      options.mapping,
      options.wrapS,
      options.wrapT,
      options.magFilter,
      options.minFilter,
      options.format,
      options.type,
      options.anisotropy,
      options.colorSpace,
    );
    texture.flipY = false;
    texture.generateMipmaps = options.generateMipmaps;
    texture.internalFormat = options.internalFormat;
    this.textures = [];
    const count = options.count;
    for (let i = 0; i < count; i++) {
      this.textures[i] = texture.clone();
      this.textures[i].isRenderTargetTexture = true;
    }
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
  }
  get texture() {
    return this.textures[0];
  }
  set texture(value) {
    this.textures[0] = value;
  }
  setSize(width, height, depth = 1) {
    if (
      this.width !== width ||
      this.height !== height ||
      this.depth !== depth
    ) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i = 0, il = this.textures.length; i < il; i++) {
        this.textures[i].image.width = width;
        this.textures[i].image.height = height;
        this.textures[i].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.textures.length = 0;
    for (let i = 0, il = source.textures.length; i < il; i++) {
      this.textures[i] = source.textures[i].clone();
      this.textures[i].isRenderTargetTexture = true;
    }
    const image = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
}
class DataArrayTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class WebGLArrayRenderTarget extends WebGLRenderTarget {
  constructor(width = 1, height = 1, depth = 1, options = {}) {
    super(width, height, options);
    this.isWebGLArrayRenderTarget = true;
    this.depth = depth;
    this.texture = new DataArrayTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
class Data3DTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
class WebGL3DRenderTarget extends WebGLRenderTarget {
  constructor(width = 1, height = 1, depth = 1, options = {}) {
    super(width, height, options);
    this.isWebGL3DRenderTarget = true;
    this.depth = depth;
    this.texture = new Data3DTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
}
let Quaternion$1 = class Quaternion {
  constructor(x = 0, y2 = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y2;
    this._z = z;
    this._w = w;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0],
      y0 = src0[srcOffset0 + 1],
      z0 = src0[srcOffset0 + 2],
      w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0],
      y1 = src1[srcOffset1 + 1],
      z1 = src1[srcOffset1 + 2],
      w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
        dir = cos >= 0 ? 1 : -1,
        sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
          len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(
    dst,
    dstOffset,
    src0,
    srcOffset0,
    src1,
    srcOffset1,
  ) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y2, z, w) {
    this._x = x;
    this._y = y2;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update2 = true) {
    const x = euler._x,
      y2 = euler._y,
      z = euler._z,
      order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
            order,
        );
    }
    if (update2 === true) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2,
      s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10],
      trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp$1(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w,
    );
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x,
      qay = a._y,
      qaz = a._z,
      qaw = a._w;
    const qbx = b._x,
      qby = b._y,
      qbz = b._z,
      qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    const x = this._x,
      y2 = this._y,
      z = this._z,
      w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y2 * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y2;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y2 + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
      ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2),
    );
  }
  equals(quaternion) {
    return (
      quaternion._x === this._x &&
      quaternion._y === this._y &&
      quaternion._z === this._z &&
      quaternion._w === this._w
    );
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    this._onChangeCallback();
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
};
let Vector3$1 = class Vector3 {
  constructor(x = 0, y2 = 0, z = 0) {
    Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  set(x, y2, z) {
    if (z === void 0) z = this.z;
    this.x = x;
    this.y = y2;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x,
      y2 = this.y,
      z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y2 + e[6] * z;
    this.y = e[1] * x + e[4] * y2 + e[7] * z;
    this.z = e[2] * x + e[5] * y2 + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x,
      y2 = this.y,
      z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y2 + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y2 + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y2 + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y2 + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const vx = this.x,
      vy = this.y,
      vz = this.z;
    const qx = q.x,
      qy = q.y,
      qz = q.z,
      qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(
      camera.projectionMatrix,
    );
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(
      camera.matrixWorld,
    );
  }
  transformDirection(m) {
    const x = this.x,
      y2 = this.y,
      z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y2 + e[8] * z;
    this.y = e[1] * x + e[5] * y2 + e[9] * z;
    this.z = e[2] * x + e[6] * y2 + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length)),
    );
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x,
      ay = a.y,
      az = a.z;
    const bx = b.x,
      by = b.y,
      bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  reflect(normal) {
    return this.sub(
      _vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)),
    );
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp$1(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x,
      dy = this.y - v.y,
      dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return (
      Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
    );
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u = Math.random() * 2 - 1;
    const c = Math.sqrt(1 - u * u);
    this.x = c * Math.cos(theta);
    this.y = u;
    this.z = c * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
const _vector$c = /* @__PURE__ */ new Vector3$1();
const _quaternion$4 = /* @__PURE__ */ new Quaternion$1();
class Box3 {
  constructor(
    min = new Vector3$1(Infinity, Infinity, Infinity),
    max = new Vector3$1(-Infinity, -Infinity, -Infinity),
  ) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    this.makeEmpty();
    for (let i = 0, il = array.length; i < il; i += 3) {
      this.expandByPoint(_vector$b.fromArray(array, i));
    }
    return this;
  }
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i = 0, il = attribute.count; i < il; i++) {
      this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
    }
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (
        precise === true &&
        positionAttribute !== void 0 &&
        object.isInstancedMesh !== true
      ) {
        for (let i = 0, l = positionAttribute.count; i < l; i++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i, _vector$b);
          } else {
            _vector$b.fromBufferAttribute(positionAttribute, i);
          }
          _vector$b.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$4.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$4.copy(geometry.boundingBox);
        }
        _box$4.applyMatrix4(object.matrixWorld);
        this.union(_box$4);
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x ||
      point.x > this.max.x ||
      point.y < this.min.y ||
      point.y > this.max.y ||
      point.z < this.min.z ||
      point.z > this.max.z
      ? false
      : true;
  }
  containsBox(box) {
    return (
      this.min.x <= box.min.x &&
      box.max.x <= this.max.x &&
      this.min.y <= box.min.y &&
      box.max.y <= this.max.y &&
      this.min.z <= box.min.z &&
      box.max.z <= this.max.z
    );
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z),
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x ||
      box.min.x > this.max.x ||
      box.max.y < this.min.y ||
      box.min.y > this.max.y ||
      box.max.z < this.min.z ||
      box.min.z > this.max.z
      ? false
      : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return (
      _vector$b.distanceToSquared(sphere.center) <=
      sphere.radius * sphere.radius
    );
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0,
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$b).distanceTo(point);
  }
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
    }
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
const _points = [
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
  /* @__PURE__ */ new Vector3$1(),
];
const _vector$b = /* @__PURE__ */ new Vector3$1();
const _box$4 = /* @__PURE__ */ new Box3();
const _v0$2 = /* @__PURE__ */ new Vector3$1();
const _v1$7 = /* @__PURE__ */ new Vector3$1();
const _v2$4 = /* @__PURE__ */ new Vector3$1();
const _f0 = /* @__PURE__ */ new Vector3$1();
const _f1 = /* @__PURE__ */ new Vector3$1();
const _f2 = /* @__PURE__ */ new Vector3$1();
const _center = /* @__PURE__ */ new Vector3$1();
const _extents = /* @__PURE__ */ new Vector3$1();
const _triangleNormal = /* @__PURE__ */ new Vector3$1();
const _testAxis = /* @__PURE__ */ new Vector3$1();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r =
      extents.x * Math.abs(_testAxis.x) +
      extents.y * Math.abs(_testAxis.y) +
      extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
const _box$3 = /* @__PURE__ */ new Box3();
const _v1$6 = /* @__PURE__ */ new Vector3$1();
const _v2$3 = /* @__PURE__ */ new Vector3$1();
class Sphere {
  constructor(center = new Vector3$1(), radius = -1) {
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$3.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return (
      sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
    );
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq = _v1$6.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$a = /* @__PURE__ */ new Vector3$1();
const _segCenter = /* @__PURE__ */ new Vector3$1();
const _segDir = /* @__PURE__ */ new Vector3$1();
const _diff = /* @__PURE__ */ new Vector3$1();
const _edge1 = /* @__PURE__ */ new Vector3$1();
const _edge2 = /* @__PURE__ */ new Vector3$1();
const _normal$1 = /* @__PURE__ */ new Vector3$1();
class Ray {
  constructor(origin = new Vector3$1(), direction = new Vector3$1(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target
      .copy(this.origin)
      .addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a
      .subVectors(point, this.origin)
      .dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a
      .copy(this.origin)
      .addScaledVector(this.direction, directionDistance);
    return _vector$a.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist =
              s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 =
            s0 > 0
              ? -segExtent
              : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 =
            s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return (
      this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius
    );
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 =
      sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray) {
    return (
      ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor(
    n11,
    n12,
    n13,
    n14,
    n21,
    n22,
    n23,
    n24,
    n31,
    n32,
    n33,
    n34,
    n41,
    n42,
    n43,
    n44,
  ) {
    Matrix4.prototype.isMatrix4 = true;
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    if (n11 !== void 0) {
      this.set(
        n11,
        n12,
        n13,
        n14,
        n21,
        n22,
        n23,
        n24,
        n31,
        n32,
        n33,
        n34,
        n41,
        n42,
        n43,
        n44,
      );
    }
  }
  set(
    n11,
    n12,
    n13,
    n14,
    n21,
    n22,
    n23,
    n24,
    n31,
    n32,
    n33,
    n34,
    n41,
    n42,
    n43,
    n44,
  ) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements,
      me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1,
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1,
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x,
      y2 = euler.y,
      z = euler.z;
    const a = Math.cos(x),
      b = Math.sin(x);
    const c = Math.cos(y2),
      d = Math.sin(y2);
    const e = Math.cos(z),
      f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0],
      a12 = ae[4],
      a13 = ae[8],
      a14 = ae[12];
    const a21 = ae[1],
      a22 = ae[5],
      a23 = ae[9],
      a24 = ae[13];
    const a31 = ae[2],
      a32 = ae[6],
      a33 = ae[10],
      a34 = ae[14];
    const a41 = ae[3],
      a42 = ae[7],
      a43 = ae[11],
      a44 = ae[15];
    const b11 = be[0],
      b12 = be[4],
      b13 = be[8],
      b14 = be[12];
    const b21 = be[1],
      b22 = be[5],
      b23 = be[9],
      b24 = be[13];
    const b31 = be[2],
      b32 = be[6],
      b33 = be[10],
      b34 = be[14];
    const b41 = be[3],
      b42 = be[7],
      b43 = be[11],
      b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0],
      n12 = te[4],
      n13 = te[8],
      n14 = te[12];
    const n21 = te[1],
      n22 = te[5],
      n23 = te[9],
      n24 = te[13];
    const n31 = te[2],
      n32 = te[6],
      n33 = te[10],
      n34 = te[14];
    const n41 = te[3],
      n42 = te[7],
      n43 = te[11],
      n44 = te[15];
    return (
      n41 *
        (+n14 * n23 * n32 -
          n13 * n24 * n32 -
          n14 * n22 * n33 +
          n12 * n24 * n33 +
          n13 * n22 * n34 -
          n12 * n23 * n34) +
      n42 *
        (+n11 * n23 * n34 -
          n11 * n24 * n33 +
          n14 * n21 * n33 -
          n13 * n21 * n34 +
          n13 * n24 * n31 -
          n14 * n23 * n31) +
      n43 *
        (+n11 * n24 * n32 -
          n11 * n22 * n34 -
          n14 * n21 * n32 +
          n12 * n21 * n34 +
          n14 * n22 * n31 -
          n12 * n24 * n31) +
      n44 *
        (-n13 * n22 * n31 -
          n11 * n23 * n32 +
          n11 * n22 * n33 +
          n13 * n21 * n32 -
          n12 * n21 * n33 +
          n12 * n23 * n31)
    );
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x, y2, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y2;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements,
      n11 = te[0],
      n21 = te[1],
      n31 = te[2],
      n41 = te[3],
      n12 = te[4],
      n22 = te[5],
      n32 = te[6],
      n42 = te[7],
      n13 = te[8],
      n23 = te[9],
      n33 = te[10],
      n43 = te[11],
      n14 = te[12],
      n24 = te[13],
      n34 = te[14],
      n44 = te[15],
      t11 =
        n23 * n34 * n42 -
        n24 * n33 * n42 +
        n24 * n32 * n43 -
        n22 * n34 * n43 -
        n23 * n32 * n44 +
        n22 * n33 * n44,
      t12 =
        n14 * n33 * n42 -
        n13 * n34 * n42 -
        n14 * n32 * n43 +
        n12 * n34 * n43 +
        n13 * n32 * n44 -
        n12 * n33 * n44,
      t13 =
        n13 * n24 * n42 -
        n14 * n23 * n42 +
        n14 * n22 * n43 -
        n12 * n24 * n43 -
        n13 * n22 * n44 +
        n12 * n23 * n44,
      t14 =
        n14 * n23 * n32 -
        n13 * n24 * n32 -
        n14 * n22 * n33 +
        n12 * n24 * n33 +
        n13 * n22 * n34 -
        n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] =
      (n24 * n33 * n41 -
        n23 * n34 * n41 -
        n24 * n31 * n43 +
        n21 * n34 * n43 +
        n23 * n31 * n44 -
        n21 * n33 * n44) *
      detInv;
    te[2] =
      (n22 * n34 * n41 -
        n24 * n32 * n41 +
        n24 * n31 * n42 -
        n21 * n34 * n42 -
        n22 * n31 * n44 +
        n21 * n32 * n44) *
      detInv;
    te[3] =
      (n23 * n32 * n41 -
        n22 * n33 * n41 -
        n23 * n31 * n42 +
        n21 * n33 * n42 +
        n22 * n31 * n43 -
        n21 * n32 * n43) *
      detInv;
    te[4] = t12 * detInv;
    te[5] =
      (n13 * n34 * n41 -
        n14 * n33 * n41 +
        n14 * n31 * n43 -
        n11 * n34 * n43 -
        n13 * n31 * n44 +
        n11 * n33 * n44) *
      detInv;
    te[6] =
      (n14 * n32 * n41 -
        n12 * n34 * n41 -
        n14 * n31 * n42 +
        n11 * n34 * n42 +
        n12 * n31 * n44 -
        n11 * n32 * n44) *
      detInv;
    te[7] =
      (n12 * n33 * n41 -
        n13 * n32 * n41 +
        n13 * n31 * n42 -
        n11 * n33 * n42 -
        n12 * n31 * n43 +
        n11 * n32 * n43) *
      detInv;
    te[8] = t13 * detInv;
    te[9] =
      (n14 * n23 * n41 -
        n13 * n24 * n41 -
        n14 * n21 * n43 +
        n11 * n24 * n43 +
        n13 * n21 * n44 -
        n11 * n23 * n44) *
      detInv;
    te[10] =
      (n12 * n24 * n41 -
        n14 * n22 * n41 +
        n14 * n21 * n42 -
        n11 * n24 * n42 -
        n12 * n21 * n44 +
        n11 * n22 * n44) *
      detInv;
    te[11] =
      (n13 * n22 * n41 -
        n12 * n23 * n41 -
        n13 * n21 * n42 +
        n11 * n23 * n42 +
        n12 * n21 * n43 -
        n11 * n22 * n43) *
      detInv;
    te[12] = t14 * detInv;
    te[13] =
      (n13 * n24 * n31 -
        n14 * n23 * n31 +
        n14 * n21 * n33 -
        n11 * n24 * n33 -
        n13 * n21 * n34 +
        n11 * n23 * n34) *
      detInv;
    te[14] =
      (n14 * n22 * n31 -
        n12 * n24 * n31 -
        n14 * n21 * n32 +
        n11 * n24 * n32 +
        n12 * n21 * n34 -
        n11 * n22 * n34) *
      detInv;
    te[15] =
      (n12 * n23 * n31 -
        n13 * n22 * n31 +
        n13 * n21 * n32 -
        n11 * n23 * n32 -
        n12 * n21 * n33 +
        n11 * n22 * n33) *
      detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x,
      y2 = v.y,
      z = v.z;
    te[0] *= x;
    te[4] *= y2;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y2;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y2;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y2;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y2, z) {
    if (x.isVector3) {
      this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
    } else {
      this.set(1, 0, 0, x, 0, 1, 0, y2, 0, 0, 1, z, 0, 0, 0, 1);
    }
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta),
      s = Math.sin(theta);
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta),
      s = Math.sin(theta);
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta),
      s = Math.sin(theta);
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x,
      y2 = axis.y,
      z = axis.z;
    const tx = t * x,
      ty = t * y2;
    this.set(
      tx * x + c,
      tx * y2 - s * z,
      tx * z + s * y2,
      0,
      tx * y2 + s * z,
      ty * y2 + c,
      ty * z - s * x,
      0,
      tx * z - s * y2,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1,
    );
    return this;
  }
  makeScale(x, y2, z) {
    this.set(x, 0, 0, 0, 0, y2, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x,
      y2 = quaternion._y,
      z = quaternion._z,
      w = quaternion._w;
    const x2 = x + x,
      y22 = y2 + y2,
      z2 = z + z;
    const xx = x * x2,
      xy = x * y22,
      xz = x * z2;
    const yy = y2 * y22,
      yz = y2 * z2,
      zz = z * z2;
    const wx = w * x2,
      wy = w * y22,
      wz = w * z2;
    const sx = scale.x,
      sy = scale.y,
      sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$4.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$4.elements[0] *= invSX;
    _m1$4.elements[1] *= invSX;
    _m1$4.elements[2] *= invSX;
    _m1$4.elements[4] *= invSY;
    _m1$4.elements[5] *= invSY;
    _m1$4.elements[6] *= invSY;
    _m1$4.elements[8] *= invSZ;
    _m1$4.elements[9] *= invSZ;
    _m1$4.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$4);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(
    left,
    right,
    top,
    bottom,
    near,
    far,
    coordinateSystem = WebGLCoordinateSystem,
  ) {
    const te = this.elements;
    const x = (2 * near) / (right - left);
    const y2 = (2 * near) / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = (-2 * far * near) / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = (-far * near) / (far - near);
    } else {
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
          coordinateSystem,
      );
    }
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y2;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(
    left,
    right,
    top,
    bottom,
    near,
    far,
    coordinateSystem = WebGLCoordinateSystem,
  ) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y2 = (top + bottom) * h;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
          coordinateSystem,
      );
    }
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y2;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
}
const _v1$5 = /* @__PURE__ */ new Vector3$1();
const _m1$4 = /* @__PURE__ */ new Matrix4();
const _zero = /* @__PURE__ */ new Vector3$1(0, 0, 0);
const _one = /* @__PURE__ */ new Vector3$1(1, 1, 1);
const _x = /* @__PURE__ */ new Vector3$1();
const _y = /* @__PURE__ */ new Vector3$1();
const _z = /* @__PURE__ */ new Vector3$1();
const _matrix$2 = /* @__PURE__ */ new Matrix4();
const _quaternion$3 = /* @__PURE__ */ new Quaternion$1();
let Euler$1 = class Euler {
  constructor(x = 0, y2 = 0, z = 0, order = Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y2;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y2, z, order = this._order) {
    this._x = x;
    this._y = y2;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update2 = true) {
    const te = m.elements;
    const m11 = te[0],
      m12 = te[4],
      m13 = te[8];
    const m21 = te[1],
      m22 = te[5],
      m23 = te[9];
    const m31 = te[2],
      m32 = te[6],
      m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp$1(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp$1(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp$1(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp$1(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp$1(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp$1(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            order,
        );
    }
    this._order = order;
    if (update2 === true) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update2) {
    _matrix$2.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix$2, order, update2);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return (
      euler._x === this._x &&
      euler._y === this._y &&
      euler._z === this._z &&
      euler._order === this._order
    );
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
};
Euler$1.DEFAULT_ORDER = "XYZ";
class Layers {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = ((1 << channel) | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= (1 << channel) | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= (1 << channel) | 0;
  }
  disable(channel) {
    this.mask &= ~((1 << channel) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & ((1 << channel) | 0)) !== 0;
  }
}
let _object3DId = 0;
const _v1$4 = /* @__PURE__ */ new Vector3$1();
const _q1 = /* @__PURE__ */ new Quaternion$1();
const _m1$3 = /* @__PURE__ */ new Matrix4();
const _target = /* @__PURE__ */ new Vector3$1();
const _position$3 = /* @__PURE__ */ new Vector3$1();
const _scale$2 = /* @__PURE__ */ new Vector3$1();
const _quaternion$2 = /* @__PURE__ */ new Quaternion$1();
const _xAxis = /* @__PURE__ */ new Vector3$1(1, 0, 0);
const _yAxis = /* @__PURE__ */ new Vector3$1(0, 1, 0);
const _zAxis = /* @__PURE__ */ new Vector3$1(0, 0, 1);
const _addedEvent = { type: "added" };
const _removedEvent = { type: "removed" };
const _childaddedEvent = { type: "childadded", child: null };
const _childremovedEvent = { type: "childremoved", child: null };
class Object3D extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DEFAULT_UP.clone();
    const position = new Vector3$1();
    const rotation = new Euler$1();
    const quaternion = new Quaternion$1();
    const scale = new Vector3$1(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position,
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation,
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion,
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale,
      },
      modelViewMatrix: {
        value: new Matrix4(),
      },
      normalMatrix: {
        value: new Matrix3(),
      },
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert());
  }
  lookAt(x, y2, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y2, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$3.lookAt(_position$3, _target, this.up);
    } else {
      _m1$3.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$3);
    if (parent) {
      _m1$3.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$3);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error(
        "THREE.Object3D.add: object can't be added as a child of itself.",
        object,
      );
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      console.error(
        "THREE.Object3D.add: object not an instance of THREE.Object3D.",
        object,
      );
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$3.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$3.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$3);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name, value, result = []) {
    if (this[name] === value) result.push(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].getObjectsByProperty(name, value, result);
    }
    return result;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {}
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];
      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (
      updateParents === true &&
      parent !== null &&
      parent.matrixWorldAutoUpdate === true
    ) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.visibility = this._visibility;
      object.active = this._active;
      object.bounds = this._bounds.map((bound) => ({
        boxInitialized: bound.boxInitialized,
        boxMin: bound.box.min.toArray(),
        boxMax: bound.box.max.toArray(),
        sphereInitialized: bound.sphereInitialized,
        sphereRadius: bound.sphere.radius,
        sphereCenter: bound.sphere.center.toArray(),
      }));
      object.maxGeometryCount = this._maxGeometryCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.geometryCount = this._geometryCount;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      if (this.boundingSphere !== null) {
        object.boundingSphere = {
          center: object.boundingSphere.center.toArray(),
          radius: object.boundingSphere.radius,
        };
      }
      if (this.boundingBox !== null) {
        object.boundingBox = {
          min: object.boundingBox.min.toArray(),
          max: object.boundingBox.max.toArray(),
        };
      }
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (
        this.environment &&
        this.environment.isTexture &&
        this.environment.isRenderTargetTexture !== true
      ) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key2 in cache) {
        const data = cache[key2];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
}
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3$1(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const _v0$1 = /* @__PURE__ */ new Vector3$1();
const _v1$3 = /* @__PURE__ */ new Vector3$1();
const _v2$2 = /* @__PURE__ */ new Vector3$1();
const _v3$2 = /* @__PURE__ */ new Vector3$1();
const _vab = /* @__PURE__ */ new Vector3$1();
const _vac = /* @__PURE__ */ new Vector3$1();
const _vbc = /* @__PURE__ */ new Vector3$1();
const _vap = /* @__PURE__ */ new Vector3$1();
const _vbp = /* @__PURE__ */ new Vector3$1();
const _vcp = /* @__PURE__ */ new Vector3$1();
class Triangle {
  constructor(a = new Vector3$1(), b = new Vector3$1(), c = new Vector3$1()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target) {
    target.subVectors(c, b);
    _v0$1.subVectors(a, b);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a, b, c, target) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      target.set(0, 0, 0);
      return null;
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
      return false;
    }
    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
      target.x = 0;
      target.y = 0;
      if ("z" in target) target.z = 0;
      if ("w" in target) target.w = 0;
      return null;
    }
    target.setScalar(0);
    target.addScaledVector(v1, _v3$2.x);
    target.addScaledVector(v2, _v3$2.y);
    target.addScaledVector(v3, _v3$2.z);
    return target;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getInterpolation(point, v1, v2, v3, target) {
    return Triangle.getInterpolation(
      point,
      this.a,
      this.b,
      this.c,
      v1,
      v2,
      v3,
      target,
    );
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target) {
    const a = this.a,
      b = this.b,
      c = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle) {
    return (
      triangle.a.equals(this.a) &&
      triangle.b.equals(this.b) &&
      triangle.c.equals(this.c)
    );
  }
}
const _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074,
};
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
class Color {
  constructor(r, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  set(r, g, b) {
    if (g === void 0 && b === void 0) {
      const value = r;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r, g, b);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = ((hex >> 16) & 255) / 255;
    this.g = ((hex >> 8) & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
    h = euclideanModulo(h, 1);
    s = clamp$1(s, 0, 1);
    l = clamp$1(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0) return;
      if (parseFloat(string) < 1) {
        console.warn(
          "THREE.Color: Alpha component of " + style + " will be ignored.",
        );
      }
    }
    let m;
    if ((m = /^(\w+)\(([^\)]*)\)/.exec(style))) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (
            (color =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                components,
              ))
          ) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(255, parseInt(color[1], 10)) / 255,
              Math.min(255, parseInt(color[2], 10)) / 255,
              Math.min(255, parseInt(color[3], 10)) / 255,
              colorSpace,
            );
          }
          if (
            (color =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                components,
              ))
          ) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(100, parseInt(color[1], 10)) / 100,
              Math.min(100, parseInt(color[2], 10)) / 100,
              Math.min(100, parseInt(color[3], 10)) / 100,
              colorSpace,
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (
            (color =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                components,
              ))
          ) {
            handleAlpha(color[4]);
            return this.setHSL(
              parseFloat(color[1]) / 360,
              parseFloat(color[2]) / 100,
              parseFloat(color[3]) / 100,
              colorSpace,
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if ((m = /^\#([A-Fa-f\d]+)$/.exec(style))) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace,
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return (
      Math.round(clamp$1(_color.r * 255, 0, 255)) * 65536 +
      Math.round(clamp$1(_color.g * 255, 0, 255)) * 256 +
      Math.round(clamp$1(_color.b * 255, 0, 255))
    );
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r,
      g = _color.g,
      b = _color.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation =
        lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r,
      g = _color.g,
      b = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  setFromVector3(v) {
    this.r = v.x;
    this.g = v.y;
    this.b = v.z;
    return this;
  }
  applyMatrix3(m) {
    const r = this.r,
      g = this.g,
      b = this.b;
    const e = m.elements;
    this.r = e[0] * r + e[3] * g + e[6] * b;
    this.g = e[1] * r + e[4] * g + e[7] * b;
    this.b = e[2] * r + e[5] * g + e[8] * b;
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
}
const _color = /* @__PURE__ */ new Color();
Color.NAMES = _colorKeywords;
let _materialId = 0;
class Material extends EventDispatcher {
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0) return;
    for (const key2 in values) {
      const newValue = values[key2];
      if (newValue === void 0) {
        console.warn(
          `THREE.Material: parameter '${key2}' has value of undefined.`,
        );
        continue;
      }
      const currentValue = this[key2];
      if (currentValue === void 0) {
        console.warn(
          `THREE.Material: '${key2}' is not a property of THREE.${this.type}.`,
        );
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (
        currentValue &&
        currentValue.isVector3 &&
        newValue &&
        newValue.isVector3
      ) {
        currentValue.copy(newValue);
      } else {
        this[key2] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {},
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen !== void 0) data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.iridescence !== void 0) data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0)
      data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0)
      data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (
      this.iridescenceThicknessMap &&
      this.iridescenceThicknessMap.isTexture
    ) {
      data.iridescenceThicknessMap =
        this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0)
      data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapRotation !== void 0)
      data.envMapRotation = this.envMapRotation.toArray();
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (
      this.attenuationDistance !== void 0 &&
      this.attenuationDistance !== Infinity
    )
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors === true) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation)
      data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null)
      data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor)
      data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
    if (this.depthTest === false) data.depthTest = this.depthTest;
    if (this.depthWrite === false) data.depthWrite = this.depthWrite;
    if (this.colorWrite === false) data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255)
      data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc)
      data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255)
      data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp)
      data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp)
      data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaHash === true) data.alphaHash = true;
    if (this.alphaToCoverage === true) data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
    if (this.forceSinglePass === true) data.forceSinglePass = true;
    if (this.wireframe === true) data.wireframe = true;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = true;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (this.fog === false) data.fog = false;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key2 in cache) {
        const data2 = cache[key2];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
}
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler$1();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
const _tables = /* @__PURE__ */ _generateTables();
function _generateTables() {
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);
  for (let i = 0; i < 256; ++i) {
    const e = i - 127;
    if (e < -27) {
      baseTable[i] = 0;
      baseTable[i | 256] = 32768;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else if (e < -14) {
      baseTable[i] = 1024 >> (-e - 14);
      baseTable[i | 256] = (1024 >> (-e - 14)) | 32768;
      shiftTable[i] = -e - 1;
      shiftTable[i | 256] = -e - 1;
    } else if (e <= 15) {
      baseTable[i] = (e + 15) << 10;
      baseTable[i | 256] = ((e + 15) << 10) | 32768;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    } else if (e < 128) {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    }
  }
  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e -= 8388608;
    }
    m &= ~8388608;
    e += 947912704;
    mantissaTable[i] = m | e;
  }
  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 939524096 + ((i - 1024) << 13);
  }
  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 2147483648 + ((i - 32) << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable,
  };
}
function toHalfFloat(val) {
  if (Math.abs(val) > 65504)
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");
  val = clamp$1(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f = _tables.uint32View[0];
  const e = (f >> 23) & 511;
  return _tables.baseTable[e] + ((f & 8388607) >> _tables.shiftTable[e]);
}
function fromHalfFloat(val) {
  const m = val >> 10;
  _tables.uint32View[0] =
    _tables.mantissaTable[_tables.offsetTable[m] + (val & 1023)] +
    _tables.exponentTable[m];
  return _tables.floatView[0];
}
const DataUtils = {
  toHalfFloat,
  fromHalfFloat,
};
const _vector$9 = /* @__PURE__ */ new Vector3$1();
const _vector2$1 = /* @__PURE__ */ new Vector2();
class BufferAttribute {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array.",
      );
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this._updateRange = { offset: 0, count: -1 };
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  onUploadCallback() {}
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  get updateRange() {
    warnOnce(
      "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.",
    );
    return this._updateRange;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$9.fromBufferAttribute(this, i);
        _vector$9.applyMatrix3(m);
        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyMatrix4(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.applyNormalMatrix(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$9.fromBufferAttribute(this, i);
      _vector$9.transformDirection(m);
      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized) value = normalize(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  setX(index, x) {
    if (this.normalized) x = normalize(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }
  getY(index) {
    let y2 = this.array[index * this.itemSize + 1];
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  setY(index, y2) {
    if (this.normalized) y2 = normalize(y2, this.array);
    this.array[index * this.itemSize + 1] = y2;
    return this;
  }
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  setW(index, w) {
    if (this.normalized) w = normalize(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }
  setXY(index, x, y2) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y2 = normalize(y2, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x, y2, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y2;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y2, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
      w = normalize(w, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y2;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    return data;
  }
}
class Int8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized);
  }
}
class Uint8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized);
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized);
  }
}
class Int16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized);
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
}
class Int32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized);
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
    this.isFloat16BufferAttribute = true;
  }
  getX(index) {
    let x = fromHalfFloat(this.array[index * this.itemSize]);
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  setX(index, x) {
    if (this.normalized) x = normalize(x, this.array);
    this.array[index * this.itemSize] = toHalfFloat(x);
    return this;
  }
  getY(index) {
    let y2 = fromHalfFloat(this.array[index * this.itemSize + 1]);
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  setY(index, y2) {
    if (this.normalized) y2 = normalize(y2, this.array);
    this.array[index * this.itemSize + 1] = toHalfFloat(y2);
    return this;
  }
  getZ(index) {
    let z = fromHalfFloat(this.array[index * this.itemSize + 2]);
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize(z, this.array);
    this.array[index * this.itemSize + 2] = toHalfFloat(z);
    return this;
  }
  getW(index) {
    let w = fromHalfFloat(this.array[index * this.itemSize + 3]);
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  setW(index, w) {
    if (this.normalized) w = normalize(w, this.array);
    this.array[index * this.itemSize + 3] = toHalfFloat(w);
    return this;
  }
  setXY(index, x, y2) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y2 = normalize(y2, this.array);
    }
    this.array[index + 0] = toHalfFloat(x);
    this.array[index + 1] = toHalfFloat(y2);
    return this;
  }
  setXYZ(index, x, y2, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
    }
    this.array[index + 0] = toHalfFloat(x);
    this.array[index + 1] = toHalfFloat(y2);
    this.array[index + 2] = toHalfFloat(z);
    return this;
  }
  setXYZW(index, x, y2, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
      w = normalize(w, this.array);
    }
    this.array[index + 0] = toHalfFloat(x);
    this.array[index + 1] = toHalfFloat(y2);
    this.array[index + 2] = toHalfFloat(z);
    this.array[index + 3] = toHalfFloat(w);
    return this;
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
}
let _id$2 = 0;
const _m1$2 = /* @__PURE__ */ new Matrix4();
const _obj = /* @__PURE__ */ new Object3D();
const _offset = /* @__PURE__ */ new Vector3$1();
const _box$2 = /* @__PURE__ */ new Box3();
const _boxMorphTargets = /* @__PURE__ */ new Box3();
const _vector$8 = /* @__PURE__ */ new Vector3$1();
class BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (
        arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute
      )(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex,
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1$2.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateX(angle) {
    _m1$2.makeRotationX(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateY(angle) {
    _m1$2.makeRotationY(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  rotateZ(angle) {
    _m1$2.makeRotationZ(angle);
    this.applyMatrix4(_m1$2);
    return this;
  }
  translate(x, y2, z) {
    _m1$2.makeTranslation(x, y2, z);
    this.applyMatrix4(_m1$2);
    return this;
  }
  scale(x, y2, z) {
    _m1$2.makeScale(x, y2, z);
    this.applyMatrix4(_m1$2);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this,
      );
      this.boundingBox.set(
        new Vector3$1(-Infinity, -Infinity, -Infinity),
        new Vector3$1(Infinity, Infinity, Infinity),
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (
      isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)
    ) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      );
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this,
      );
      this.boundingSphere.set(new Vector3$1(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$8);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$8.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(
          maxRadiusSq,
          center.distanceToSquared(_vector$8),
        );
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$8.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(
              maxRadiusSq,
              center.distanceToSquared(_vector$8),
            );
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
          this,
        );
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (
      index === null ||
      attributes.position === void 0 ||
      attributes.normal === void 0 ||
      attributes.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)",
      );
      return;
    }
    const positionAttribute = attributes.position;
    const normalAttribute = attributes.normal;
    const uvAttribute = attributes.uv;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute(
        "tangent",
        new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4),
      );
    }
    const tangentAttribute = this.getAttribute("tangent");
    const tan1 = [],
      tan2 = [];
    for (let i = 0; i < positionAttribute.count; i++) {
      tan1[i] = new Vector3$1();
      tan2[i] = new Vector3$1();
    }
    const vA = new Vector3$1(),
      vB = new Vector3$1(),
      vC = new Vector3$1(),
      uvA = new Vector2(),
      uvB = new Vector2(),
      uvC = new Vector2(),
      sdir = new Vector3$1(),
      tdir = new Vector3$1();
    function handleTriangle(a, b, c) {
      vA.fromBufferAttribute(positionAttribute, a);
      vB.fromBufferAttribute(positionAttribute, b);
      vC.fromBufferAttribute(positionAttribute, c);
      uvA.fromBufferAttribute(uvAttribute, a);
      uvB.fromBufferAttribute(uvAttribute, b);
      uvC.fromBufferAttribute(uvAttribute, c);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r)) return;
      sdir
        .copy(vB)
        .multiplyScalar(uvC.y)
        .addScaledVector(vC, -uvB.y)
        .multiplyScalar(r);
      tdir
        .copy(vC)
        .multiplyScalar(uvB.x)
        .addScaledVector(vB, -uvC.x)
        .multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [
        {
          start: 0,
          count: index.count,
        },
      ];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));
      }
    }
    const tmp2 = new Vector3$1(),
      tmp22 = new Vector3$1();
    const n = new Vector3$1(),
      n2 = new Vector3$1();
    function handleVertex(v) {
      n.fromBufferAttribute(normalAttribute, v);
      n2.copy(n);
      const t = tan1[v];
      tmp2.copy(t);
      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp22.crossVectors(n2, t);
      const test = tmp22.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangentAttribute.setXYZW(v, tmp2.x, tmp2.y, tmp2.z, w);
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(index.getX(j + 0));
        handleVertex(index.getX(j + 1));
        handleVertex(index.getX(j + 2));
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(
          new Float32Array(positionAttribute.count * 3),
          3,
        );
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector3$1(),
        pB = new Vector3$1(),
        pC = new Vector3$1();
      const nA = new Vector3$1(),
        nB = new Vector3$1(),
        nC = new Vector3$1();
      const cb = new Vector3$1(),
        ab = new Vector3$1();
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$8.fromBufferAttribute(normals, i);
      _vector$8.normalize();
      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0,
        index2 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn(
        "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.",
      );
      return this;
    }
    const geometry2 = new BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key2 in parameters) {
        if (parameters[key2] !== void 0) data[key2] = parameters[key2];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array),
      };
    }
    const attributes = this.attributes;
    for (const key2 in attributes) {
      const attribute = attributes[key2];
      data.data.attributes[key2] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key2 in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key2];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key2] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius,
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
const _ray$3 = /* @__PURE__ */ new Ray();
const _sphere$6 = /* @__PURE__ */ new Sphere();
const _sphereHitAt = /* @__PURE__ */ new Vector3$1();
const _vA$1 = /* @__PURE__ */ new Vector3$1();
const _vB$1 = /* @__PURE__ */ new Vector3$1();
const _vC$1 = /* @__PURE__ */ new Vector3$1();
const _tempA = /* @__PURE__ */ new Vector3$1();
const _morphA = /* @__PURE__ */ new Vector3$1();
const _uvA$1 = /* @__PURE__ */ new Vector2();
const _uvB$1 = /* @__PURE__ */ new Vector2();
const _uvC$1 = /* @__PURE__ */ new Vector2();
const _normalA = /* @__PURE__ */ new Vector3$1();
const _normalB = /* @__PURE__ */ new Vector3$1();
const _normalC = /* @__PURE__ */ new Vector3$1();
const _intersectionPoint = /* @__PURE__ */ new Vector3$1();
const _intersectionPointWorld = /* @__PURE__ */ new Vector3$1();
class Mesh extends Object3D {
  constructor(
    geometry = new BufferGeometry(),
    material = new MeshBasicMaterial(),
  ) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign(
        {},
        source.morphTargetDictionary,
      );
    }
    this.material = Array.isArray(source.material)
      ? source.material.slice()
      : source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
  getVertexPosition(index, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$6.copy(geometry.boundingSphere);
    _sphere$6.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$6.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
      if (
        _ray$3.origin.distanceToSquared(_sphereHitAt) >
        (raycaster.far - raycaster.near) ** 2
      )
        return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$3);
  }
  _computeIntersections(raycaster, intersects2, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(
            index.count,
            Math.min(
              group.start + group.count,
              drawRange.start + drawRange.count,
            ),
          );
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = index.getX(j);
            const b = index.getX(j + 1);
            const c = index.getX(j + 2);
            intersection = checkGeometryIntersection(
              this,
              groupMaterial,
              raycaster,
              rayLocalSpace,
              uv,
              uv1,
              normal,
              a,
              b,
              c,
            );
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = index.getX(i);
          const b = index.getX(i + 1);
          const c = index.getX(i + 2);
          intersection = checkGeometryIntersection(
            this,
            material,
            raycaster,
            rayLocalSpace,
            uv,
            uv1,
            normal,
            a,
            b,
            c,
          );
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(
            position.count,
            Math.min(
              group.start + group.count,
              drawRange.start + drawRange.count,
            ),
          );
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = j;
            const b = j + 1;
            const c = j + 2;
            intersection = checkGeometryIntersection(
              this,
              groupMaterial,
              raycaster,
              rayLocalSpace,
              uv,
              uv1,
              normal,
              a,
              b,
              c,
            );
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = i;
          const b = i + 1;
          const c = i + 2;
          intersection = checkGeometryIntersection(
            this,
            material,
            raycaster,
            rayLocalSpace,
            uv,
            uv1,
            normal,
            a,
            b,
            c,
          );
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    }
  }
}
function checkIntersection(
  object,
  material,
  raycaster,
  ray,
  pA,
  pB,
  pC,
  point,
) {
  let intersect2;
  if (material.side === BackSide) {
    intersect2 = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect2 = ray.intersectTriangle(
      pA,
      pB,
      pC,
      material.side === FrontSide,
      point,
    );
  }
  if (intersect2 === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object,
  };
}
function checkGeometryIntersection(
  object,
  material,
  raycaster,
  ray,
  uv,
  uv1,
  normal,
  a,
  b,
  c,
) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c, _vC$1);
  const intersection = checkIntersection(
    object,
    material,
    raycaster,
    ray,
    _vA$1,
    _vB$1,
    _vC$1,
    _intersectionPoint,
  );
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b);
      _uvC$1.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(
        _intersectionPoint,
        _vA$1,
        _vB$1,
        _vC$1,
        _uvA$1,
        _uvB$1,
        _uvC$1,
        new Vector2(),
      );
    }
    if (uv1) {
      _uvA$1.fromBufferAttribute(uv1, a);
      _uvB$1.fromBufferAttribute(uv1, b);
      _uvC$1.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(
        _intersectionPoint,
        _vA$1,
        _vB$1,
        _vC$1,
        _uvA$1,
        _uvB$1,
        _uvC$1,
        new Vector2(),
      );
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(
        _intersectionPoint,
        _vA$1,
        _vB$1,
        _vC$1,
        _normalA,
        _normalB,
        _normalC,
        new Vector3$1(),
      );
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3$1(),
      materialIndex: 0,
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
class BoxGeometry extends BufferGeometry {
  constructor(
    width = 1,
    height = 1,
    depth = 1,
    widthSegments = 1,
    heightSegments = 1,
    depthSegments = 1,
  ) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments,
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane(
      "z",
      "y",
      "x",
      -1,
      -1,
      depth,
      height,
      width,
      depthSegments,
      heightSegments,
      0,
    );
    buildPlane(
      "z",
      "y",
      "x",
      1,
      -1,
      depth,
      height,
      -width,
      depthSegments,
      heightSegments,
      1,
    );
    buildPlane(
      "x",
      "z",
      "y",
      1,
      1,
      width,
      depth,
      height,
      widthSegments,
      depthSegments,
      2,
    );
    buildPlane(
      "x",
      "z",
      "y",
      1,
      -1,
      width,
      depth,
      -height,
      widthSegments,
      depthSegments,
      3,
    );
    buildPlane(
      "x",
      "y",
      "z",
      1,
      -1,
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      4,
    );
    buildPlane(
      "x",
      "y",
      "z",
      -1,
      -1,
      width,
      height,
      -depth,
      widthSegments,
      heightSegments,
      5,
    );
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(
      u,
      v,
      w,
      udir,
      vdir,
      width2,
      height2,
      depth2,
      gridX,
      gridY,
      materialIndex,
    ) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3$1();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y2 * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new BoxGeometry(
      data.width,
      data.height,
      data.depth,
      data.widthSegments,
      data.heightSegments,
      data.depthSegments,
    );
  }
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (
        property &&
        (property.isColor ||
          property.isMatrix3 ||
          property.isMatrix4 ||
          property.isVector2 ||
          property.isVector3 ||
          property.isVector4 ||
          property.isTexture ||
          property.isQuaternion)
      ) {
        if (property.isRenderTargetTexture) {
          console.warn(
            "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().",
          );
          dst[u][p] = null;
        } else {
          dst[u][p] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u = 0; u < src.length; u++) {
    dst.push(src[u].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  if (renderer.getRenderTarget() === null) {
    return renderer.outputColorSpace;
  }
  return ColorManagement.workingColorSpace;
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex =
  "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment =
  "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
class ShaderMaterial extends Material {
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      derivatives: false,
      // set to use derivatives
      fragDepth: false,
      // set to use fragment depth values
      drawBuffers: false,
      // set to use draw buffers
      shaderTextureLOD: false,
      // set to use shader texture LOD
      clipCullDistance: false,
      // set to use vertex shader clipping
      multiDraw: false,
      // set to use vertex shader multi_draw / enable gl_DrawID
    };
    this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0],
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid,
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex(),
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray(),
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray(),
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray(),
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray(),
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray(),
        };
      } else {
        data.uniforms[name] = {
          value,
        };
      }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions = {};
    for (const key2 in this.extensions) {
      if (this.extensions[key2] === true) extensions[key2] = true;
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  }
}
class Camera extends Object3D {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _v3$1 = /* @__PURE__ */ new Vector3$1();
const _minTarget = /* @__PURE__ */ new Vector2();
const _maxTarget = /* @__PURE__ */ new Vector2();
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = (0.5 * this.getFilmHeight()) / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD$1 * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / vExtentSlope;
  }
  getEffectiveFOV() {
    return (
      RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD$1 * 0.5 * this.fov) / this.zoom)
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
   */
  getViewBounds(distance, minTarget, maxTarget) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   * Copies the result into the target Vector2, where x is width and y is height.
   */
  getViewSize(distance, target) {
    this.getViewBounds(distance, _minTarget, _maxTarget);
    return target.subVectors(_maxTarget, _minTarget);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = (near * Math.tan(DEG2RAD$1 * 0.5 * this.fov)) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth,
        fullHeight = view.fullHeight;
      left += (view.offsetX * width) / fullWidth;
      top -= (view.offsetY * height) / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += (near * skew) / this.getFilmWidth();
    this.projectionMatrix.makePerspective(
      left,
      left + width,
      top,
      top - height,
      near,
      this.far,
      this.coordinateSystem,
    );
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
}
const fov = -90;
const aspect = 1;
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    this.activeMipmapLevel = 0;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] =
      cameras;
    for (const camera of cameras) this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          coordinateSystem,
      );
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  update(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const { renderTarget, activeMipmapLevel } = this;
    if (this.coordinateSystem !== renderer.coordinateSystem) {
      this.coordinateSystem = renderer.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] =
      this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentActiveCubeFace = renderer.getActiveCubeFace();
    const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
    const currentXrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(
      currentRenderTarget,
      currentActiveCubeFace,
      currentActiveMipmapLevel,
    );
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
}
class CubeTexture extends Texture {
  constructor(
    images,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    format,
    type,
    anisotropy,
    colorSpace,
  ) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(
      images,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
      colorSpace,
    );
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    this.texture = new CubeTexture(
      images,
      options.mapping,
      options.wrapS,
      options.wrapT,
      options.magFilter,
      options.minFilter,
      options.format,
      options.type,
      options.anisotropy,
      options.colorSpace,
    );
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps =
      options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter =
      options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.colorSpace = texture.colorSpace;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null },
      },
      vertexShader:
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader:
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending,
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
}
const _vector1 = /* @__PURE__ */ new Vector3$1();
const _vector2 = /* @__PURE__ */ new Vector3$1();
const _normalMatrix = /* @__PURE__ */ new Matrix3();
class Plane {
  constructor(normal = new Vector3$1(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y2, z, w) {
    this.normal.set(x, y2, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1
      .subVectors(c, b)
      .cross(_vector2.subVectors(a, b))
      .normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target
      .copy(point)
      .addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix =
      optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _sphere$5 = /* @__PURE__ */ new Sphere();
const _vector$7 = /* @__PURE__ */ new Vector3$1();
class Frustum {
  constructor(
    p0 = new Plane(),
    p1 = new Plane(),
    p2 = new Plane(),
    p3 = new Plane(),
    p4 = new Plane(),
    p5 = new Plane(),
  ) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0],
      me1 = me[1],
      me2 = me[2],
      me3 = me[3];
    const me4 = me[4],
      me5 = me[5],
      me6 = me[6],
      me7 = me[7];
    const me8 = me[8],
      me9 = me[9],
      me10 = me[10],
      me11 = me[11];
    const me12 = me[12],
      me13 = me[13],
      me14 = me[14],
      me15 = me[15];
    planes[0]
      .setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12)
      .normalize();
    planes[1]
      .setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12)
      .normalize();
    planes[2]
      .setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13)
      .normalize();
    planes[3]
      .setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13)
      .normalize();
    planes[4]
      .setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14)
      .normalize();
    if (coordinateSystem === WebGLCoordinateSystem) {
      planes[5]
        .setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14)
        .normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      planes[5].setComponents(me2, me6, me10, me14).normalize();
    } else {
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          coordinateSystem,
      );
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null) object.computeBoundingSphere();
      _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSprite(sprite) {
    _sphere$5.center.set(0, 0, 0);
    _sphere$5.radius = 0.7071067811865476;
    _sphere$5.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$5);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$7) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function () {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function () {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function (callback) {
      animationLoop = callback;
    },
    setContext: function (value) {
      context = value;
    },
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const size = array.byteLength;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = gl.HALF_FLOAT;
        } else {
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.",
          );
        }
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + array,
      );
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
      size,
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute._updateRange;
    const updateRanges = attribute.updateRanges;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1 && updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array);
    }
    if (updateRanges.length !== 0) {
      for (let i = 0, l = updateRanges.length; i < l; i++) {
        const range = updateRanges[i];
        if (isWebGL2) {
          gl.bufferSubData(
            bufferType,
            range.start * array.BYTES_PER_ELEMENT,
            array,
            range.start,
            range.count,
          );
        } else {
          gl.bufferSubData(
            bufferType,
            range.start * array.BYTES_PER_ELEMENT,
            array.subarray(range.start, range.start + range.count),
          );
        }
      }
      attribute.clearUpdateRanges();
    }
    if (updateRange.count !== -1) {
      if (isWebGL2) {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array,
          updateRange.offset,
          updateRange.count,
        );
      } else {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array.subarray(
            updateRange.offset,
            updateRange.offset + updateRange.count,
          ),
        );
      }
      updateRange.count = -1;
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update2(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version,
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      if (data.size !== attribute.array.byteLength) {
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.",
        );
      }
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update: update2,
  };
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments,
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PlaneGeometry(
      data.width,
      data.height,
      data.widthSegments,
      data.heightSegments,
    );
  }
}
var alphahash_fragment =
  "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment =
  "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
var alphamap_fragment =
  "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment =
  "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment =
  "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
var alphatest_pars_fragment =
  "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment =
  "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment =
  "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var batching_pars_vertex =
  "#ifdef USE_BATCHING\n	attribute float batchId;\n	uniform highp sampler2D batchingTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
var batching_vertex =
  "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif";
var begin_vertex =
  "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
var beginnormal_vertex =
  "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs =
  "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment =
  "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment =
  "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment =
  "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
var clipping_planes_pars_fragment =
  "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex =
  "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex =
  "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment =
  "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment =
  "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex =
  "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex =
  "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common =
  "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment =
  "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex =
  "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex =
  "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex =
  "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment =
  "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment =
  "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment =
  "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return sRGBTransferOETF( value );\n}";
var envmap_fragment =
  "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment =
  "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment =
  "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex =
  "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex =
  "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment =
  "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment =
  "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment =
  "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_fragment =
  "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment =
  "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment =
  "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment =
  "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin =
  "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment =
  "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment =
  "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment =
  "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment =
  "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment =
  "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment =
  "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment =
  "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin =
  "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps =
  "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end =
  "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment =
  "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment =
  "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex =
  "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex =
  "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment =
  "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment =
  "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment =
  "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment =
  "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment =
  "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphinstance_vertex =
  "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[MORPHTARGETS_COUNT];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
var morphcolor_vertex =
  "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex =
  "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex =
  "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n	#endif\n	#ifdef MORPHTARGETS_TEXTURE\n		#ifndef USE_INSTANCING_MORPH\n			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		#endif\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex =
  "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin =
  "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps =
  "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment =
  "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex =
  "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex =
  "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment =
  "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin =
  "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps =
  "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment =
  "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment =
  "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment =
  "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing =
  "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment =
  "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex =
  "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment =
  "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment =
  "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment =
  "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment =
  "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment =
  "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex =
  "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex =
  "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment =
  "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex =
  "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex =
  "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
var skinning_vertex =
  "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex =
  "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment =
  "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment =
  "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment =
  "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment =
  "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	float startCompression = 0.8 - 0.04;\n	float desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min(color.r, min(color.g, color.b));\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max(color.r, max(color.g, color.b));\n	if (peak < startCompression) return color;\n	float d = 1. - startCompression;\n	float newPeak = 1. - d * d / (peak + d - startCompression);\n	color *= newPeak / peak;\n	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n	return mix(color, vec3(1, 1, 1), g);\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment =
  "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment =
  "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment =
  "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex =
  "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex =
  "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex =
  "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
const vertex$h =
  "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
const fragment$h =
  "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$g =
  "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$g =
  "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$f =
  "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
const fragment$f =
  "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$e =
  "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
const fragment$e =
  "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
const vertex$d =
  "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
const fragment$d =
  "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
const vertex$c =
  "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
const fragment$c =
  "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
const vertex$b =
  "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$b =
  "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$a =
  "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$a =
  "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$9 =
  "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$9 =
  "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$8 =
  "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
const fragment$8 =
  "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$7 =
  "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
const fragment$7 =
  "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
const vertex$6 =
  "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$6 =
  "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$5 =
  "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
const fragment$5 =
  "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$4 =
  "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$4 =
  "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
const vertex$3 =
  "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
const fragment$3 =
  "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
const vertex$2 =
  "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
const fragment$2 =
  "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const vertex$1 =
  "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
const fragment$1 =
  "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
const ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  batching_pars_vertex,
  batching_vertex,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphinstance_vertex,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1,
};
const UniformsLib = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 },
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Matrix3() },
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 },
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Matrix3() },
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Matrix3() },
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    bumpScale: { value: 1 },
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 },
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() },
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
  },
  gradientmap: {
    gradientMap: { value: null },
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Color(16777215) },
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {},
      },
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
      },
    },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {},
      },
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
      },
    },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {},
      },
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {},
      },
    },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {},
      },
    },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {},
      },
    },
    ltc_1: { value: null },
    ltc_2: { value: null },
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() },
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 },
  },
};
const ShaderLib = {
  basic: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog,
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag,
  },
  lambert: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
      },
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag,
  },
  phong: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        specular: { value: /* @__PURE__ */ new Color(1118481) },
        shininess: { value: 30 },
      },
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag,
  },
  standard: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 },
        // temporary
      },
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag,
  },
  toon: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
      },
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag,
  },
  matcap: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null },
      },
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag,
  },
  points: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog,
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag,
  },
  dashed: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 },
      },
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag,
  },
  depth: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag,
  },
  normal: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 },
      },
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag,
  },
  sprite: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog,
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag,
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Matrix3() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 },
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag,
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Matrix3() },
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag,
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 },
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag,
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null },
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag,
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Vector3$1() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 },
      },
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag,
  },
  shadow: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: /* @__PURE__ */ new Color(0) },
        opacity: { value: 1 },
      },
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag,
  },
};
ShaderLib.physical = {
  uniforms: /* @__PURE__ */ mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: {
        value: /* @__PURE__ */ new Matrix3(),
      },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Color(0) },
      specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    },
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag,
};
const _rgb = { r: 0, b: 0, g: 0 };
const _e1$1 = /* @__PURE__ */ new Euler$1();
const _m1$1 = /* @__PURE__ */ new Matrix4();
function WebGLBackground(
  renderer,
  cubemaps,
  cubeuvmaps,
  state,
  objects,
  alpha,
  premultipliedAlpha,
) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(
        renderer.autoClearColor,
        renderer.autoClearDepth,
        renderer.autoClearStencil,
      );
    }
    if (
      background &&
      (background.isCubeTexture ||
        background.mapping === CubeUVReflectionMapping)
    ) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false,
          }),
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function (renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function () {
            return this.uniforms.envMap.value;
          },
        });
        objects.update(boxMesh);
      }
      _e1$1.copy(scene.backgroundRotation);
      _e1$1.x *= -1;
      _e1$1.y *= -1;
      _e1$1.z *= -1;
      if (
        background.isCubeTexture &&
        background.isRenderTargetTexture === false
      ) {
        _e1$1.y *= -1;
        _e1$1.z *= -1;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value =
        background.isCubeTexture && background.isRenderTargetTexture === false
          ? -1
          : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value =
        scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value =
        scene.backgroundIntensity;
      boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(
        _m1$1.makeRotationFromEuler(_e1$1),
      );
      boxMesh.material.toneMapped =
        ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (
        currentBackground !== background ||
        currentBackgroundVersion !== background.version ||
        currentTonemapping !== renderer.toneMapping
      ) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(
        boxMesh,
        boxMesh.geometry,
        boxMesh.material,
        0,
        0,
        null,
      );
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false,
          }),
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function () {
            return this.uniforms.t2D.value;
          },
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value =
        scene.backgroundIntensity;
      planeMesh.material.toneMapped =
        ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (
        currentBackground !== background ||
        currentBackgroundVersion !== background.version ||
        currentTonemapping !== renderer.toneMapping
      ) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(
        planeMesh,
        planeMesh.geometry,
        planeMesh.material,
        0,
        0,
        null,
      );
    }
  }
  function setClear(color, alpha2) {
    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(
      _rgb.r,
      _rgb.g,
      _rgb.b,
      alpha2,
      premultipliedAlpha,
    );
  }
  return {
    getClearColor: function () {
      return clearColor;
    },
    setClearColor: function (color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function () {
      return clearAlpha;
    },
    setClearAlpha: function (alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render,
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const extension = capabilities.isWebGL2
    ? null
    : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(object, geometry, program, index);
      if (updateBuffers) saveCache(object, geometry, program, index);
    } else {
      const wireframe = material.wireframe === true;
      if (
        currentState.geometry !== geometry.id ||
        currentState.program !== program.id ||
        currentState.wireframe !== wireframe
      ) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2) return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null,
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0) return true;
        if (cachedAttribute.attribute !== geometryAttribute) return true;
        if (
          geometryAttribute &&
          cachedAttribute.data !== geometryAttribute.data
        )
          return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2
        ? gl
        : extensions.get("ANGLE_instanced_arrays");
      extension2[
        capabilities.isWebGL2
          ? "vertexAttribDivisor"
          : "vertexAttribDivisorANGLE"
      ](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(
    index,
    size,
    type,
    normalized,
    stride,
    offset,
    integer,
  ) {
    if (integer === true) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (
      capabilities.isWebGL2 === false &&
      (object.isInstancedMesh || geometry.isInstancedBufferGeometry)
    ) {
      if (extensions.get("ANGLE_instanced_arrays") === null) return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer =
            capabilities.isWebGL2 === true &&
            (type === gl.INT ||
              type === gl.UNSIGNED_INT ||
              geometryAttribute.gpuType === IntType);
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(
                  programAttribute.location + i,
                  data.meshPerAttribute,
                );
              }
              if (
                object.isInstancedMesh !== true &&
                geometry._maxInstanceCount === void 0
              ) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + (size / programAttribute.locationSize) * i) *
                  bytesPerElement,
                integer,
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(
                  programAttribute.location + i,
                  geometryAttribute.meshPerAttribute,
                );
              }
              if (
                object.isInstancedMesh !== true &&
                geometry._maxInstanceCount === void 0
              ) {
                geometry._maxInstanceCount =
                  geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                (size / programAttribute.locationSize) * i * bytesPerElement,
                integer,
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes,
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error(
          "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
        );
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < drawCount; i++) {
        this.render(starts[i], counts[i]);
      }
    } else {
      extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (
        gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision >
          0 &&
        gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT)
          .precision > 0
      ) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (
        gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT)
          .precision > 0 &&
        gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT)
          .precision > 0
      ) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 =
    typeof WebGL2RenderingContext !== "undefined" &&
    gl.constructor.name === "WebGL2RenderingContext";
  let precision =
    parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn(
      "THREE.WebGLRenderer:",
      precision,
      "not supported, using",
      maxPrecision,
      "instead.",
    );
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples,
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null,
    numGlobalPlanes = 0,
    localClippingEnabled = false,
    renderingShadows = false;
  const plane = new Plane(),
    viewNormalMatrix = new Matrix3(),
    uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function (planes, enableLocalClipping) {
    const enabled =
      planes.length !== 0 ||
      enableLocalClipping || // enable state of previous frame - the clipping code has to
      // run another frame in order to reset the state:
      numGlobalPlanes !== 0 ||
      localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function () {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function () {
    renderingShadows = false;
  };
  this.setGlobalState = function (planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function (material, camera, useCache) {
    const planes = material.clippingPlanes,
      clipIntersection = material.clipIntersection,
      clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (
      !localClippingEnabled ||
      planes === null ||
      planes.length === 0 ||
      (renderingShadows && !clipShadows)
    ) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
        lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4,
          viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (
        mapping === EquirectangularReflectionMapping ||
        mapping === EquirectangularRefractionMapping
      ) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose,
  };
}
class OrthographicCamera extends Camera {
  constructor(
    left = -1,
    right = 1,
    top = 1,
    bottom = -1,
    near = 0.1,
    far = 2e3,
  ) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH =
        (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(
      left,
      right,
      top,
      bottom,
      this.near,
      this.far,
      this.coordinateSystem,
    );
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
}
const LOD_MIN = 4;
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
const MAX_SAMPLES = 20;
const _flatCamera = /* @__PURE__ */ new OrthographicCamera();
const _clearColor = /* @__PURE__ */ new Color();
let _oldTarget = null;
let _oldActiveCubeFace = 0;
let _oldActiveMipmapLevel = 0;
const PHI = (1 + Math.sqrt(5)) / 2;
const INV_PHI = 1 / PHI;
const _axisDirections = [
  /* @__PURE__ */ new Vector3$1(1, 1, 1),
  /* @__PURE__ */ new Vector3$1(-1, 1, 1),
  /* @__PURE__ */ new Vector3$1(1, 1, -1),
  /* @__PURE__ */ new Vector3$1(-1, 1, -1),
  /* @__PURE__ */ new Vector3$1(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3$1(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3$1(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3$1(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3$1(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3$1(-PHI, INV_PHI, 0),
];
class PMREMGenerator {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported equirectangular image size is 64 x 32.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   * The smallest supported cube size is 16 x 16.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(
      _oldTarget,
      _oldActiveCubeFace,
      _oldActiveMipmapLevel,
    );
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (
      texture.mapping === CubeReflectionMapping ||
      texture.mapping === CubeRefractionMapping
    ) {
      this._setSize(
        texture.image.length === 0
          ? 16
          : texture.image[0].width || texture.image[0].image.width,
      );
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace,
      depthBuffer: false,
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== width ||
      this._pingPongRenderTarget.height !== height
    ) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false,
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(
        cubeUVRenderTarget,
        col * size,
        i > 2 ? size : 0,
        size,
        size,
      );
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture =
      texture.mapping === CubeReflectionMapping ||
      texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value =
        texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture
      ? this._cubemapMaterial
      : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const sigma = Math.sqrt(
        this._sigmas[i] * this._sigmas[i] -
          this._sigmas[i - 1] * this._sigmas[i - 1],
      );
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis,
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis,
    );
  }
  _halfBlur(
    targetIn,
    targetOut,
    lodIn,
    lodOut,
    sigmaRadians,
    direction,
    poleAxis,
  ) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!",
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians)
      ? Math.PI / (2 * pixels)
      : (2 * Math.PI) / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians)
      ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels)
      : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(
        `sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`,
      );
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp((-x2 * x2) / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x =
      3 *
      outputSize *
      (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y2 = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = ((face % 3) * 2) / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y2,
        0,
        x + 2 / 3,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2 + 1,
        0,
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute(
      "position",
      new BufferAttribute(position, positionSize),
    );
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute(
      "faceIndex",
      new BufferAttribute(faceIndex, faceIndexSize),
    );
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y2, width, height) {
  target.viewport.set(x, y2, width, height);
  target.scissor.set(x, y2, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3$1(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      n: MAX_SAMPLES,
      CUBEUV_TEXEL_WIDTH: 1 / width,
      CUBEUV_TEXEL_HEIGHT: 1 / height,
      CUBEUV_MAX_MIP: `${lodMax}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: weights },
      latitudinal: { value: false },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: poleAxis },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false,
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: { value: null },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false,
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader:
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false,
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap =
        mapping === EquirectangularReflectionMapping ||
        mapping === EquirectangularRefractionMapping;
      const isCubeMap =
        mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (
          texture.isRenderTargetTexture &&
          texture.needsPMREMUpdate === true
        ) {
          texture.needsPMREMUpdate = false;
          let renderTarget = cubeUVmaps.get(texture);
          if (pmremGenerator === null)
            pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap
            ? pmremGenerator.fromEquirectangular(texture, renderTarget)
            : pmremGenerator.fromCubemap(texture, renderTarget);
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture;
          } else {
            const image = texture.image;
            if (
              (isEquirectMap && image && image.height > 0) ||
              (isCubeMap && image && isCubeTextureComplete(image))
            ) {
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer);
              const renderTarget = isEquirectMap
                ? pmremGenerator.fromEquirectangular(texture)
                : pmremGenerator.fromCubemap(texture);
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i = 0; i < length; i++) {
      if (image[i] !== void 0) count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose,
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension =
          gl.getExtension("WEBGL_depth_texture") ||
          gl.getExtension("MOZ_WEBGL_depth_texture") ||
          gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension =
          gl.getExtension("EXT_texture_filter_anisotropic") ||
          gl.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension =
          gl.getExtension("WEBGL_compressed_texture_s3tc") ||
          gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension =
          gl.getExtension("WEBGL_compressed_texture_pvrtc") ||
          gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function (name) {
      return getExtension(name) !== null;
    },
    init: function (capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
        getExtension("WEBGL_clip_cull_distance");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function (name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn(
          "THREE.WebGLRenderer: " + name + " extension not supported.",
        );
      }
      return extension;
    },
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    for (const name in geometry.morphAttributes) {
      const array = geometry.morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.remove(array[i]);
      }
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update2(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], gl.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else if (geometryPosition !== void 0) {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    } else {
      return;
    }
    const attribute = new (
      arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute
    )(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update: update2,
    getWireframeAttribute,
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error(
          "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
        );
        return;
      }
    }
    extension[methodName](
      mode,
      count,
      type,
      start * bytesPerElement,
      primcount,
    );
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < drawCount; i++) {
        this.render(starts[i] / bytesPerElement, counts[i]);
      }
    } else {
      extension.multiDrawElementsWEBGL(
        mode,
        counts,
        0,
        type,
        starts,
        0,
        drawCount,
      );
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0,
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0,
  };
  function update2(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update: update2,
  };
}
function numericalSort(a, b) {
  return a[0] - b[0];
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  const workInfluences = [];
  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }
  function update2(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const morphAttribute =
        geometry.morphAttributes.position ||
        geometry.morphAttributes.normal ||
        geometry.morphAttributes.color;
      const morphTargetsCount =
        morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function () {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== void 0) entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true) vertexDataCount = 1;
        if (hasMorphNormals === true) vertexDataCount = 2;
        if (hasMorphColors === true) vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture = new DataArrayTexture(
          buffer,
          width,
          height,
          morphTargetsCount,
        );
        texture.type = FloatType;
        texture.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i = 0; i < morphTargetsCount; i++) {
          const morphTarget = morphTargets[i];
          const morphNormal = morphNormals[i];
          const morphColor = morphColors[i];
          const offset = width * height * 4 * i;
          for (let j = 0; j < morphTarget.count; j++) {
            const stride = j * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] =
                morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector2(width, height),
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      if (object.isInstancedMesh === true && object.morphTexture !== null) {
        program
          .getUniforms()
          .setValue(gl, "morphTexture", object.morphTexture, textures);
      } else {
        let morphInfluencesSum = 0;
        for (let i = 0; i < objectInfluences.length; i++) {
          morphInfluencesSum += objectInfluences[i];
        }
        const morphBaseInfluence = geometry.morphTargetsRelative
          ? 1
          : 1 - morphInfluencesSum;
        program
          .getUniforms()
          .setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program
          .getUniforms()
          .setValue(gl, "morphTargetInfluences", objectInfluences);
      }
      program
        .getUniforms()
        .setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i = 0; i < length; i++) {
          influences[i] = [i, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i = 0; i < length; i++) {
        const influence = influences[i];
        influence[0] = i;
        influence[1] = objectInfluences[i];
      }
      influences.sort(absNumericalSort);
      for (let i = 0; i < 8; i++) {
        if (i < length && influences[i][1]) {
          workInfluences[i][0] = influences[i][0];
          workInfluences[i][1] = influences[i][1];
        } else {
          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i = 0; i < 8; i++) {
        const influence = workInfluences[i];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (
            morphTargets &&
            geometry.getAttribute("morphTarget" + i) !== morphTargets[index]
          ) {
            geometry.setAttribute("morphTarget" + i, morphTargets[index]);
          }
          if (
            morphNormals &&
            geometry.getAttribute("morphNormal" + i) !== morphNormals[index]
          ) {
            geometry.setAttribute("morphNormal" + i, morphNormals[index]);
          }
          morphInfluences[i] = value;
          morphInfluencesSum += value;
        } else {
          if (
            morphTargets &&
            geometry.hasAttribute("morphTarget" + i) === true
          ) {
            geometry.deleteAttribute("morphTarget" + i);
          }
          if (
            morphNormals &&
            geometry.hasAttribute("morphNormal" + i) === true
          ) {
            geometry.deleteAttribute("morphNormal" + i);
          }
          morphInfluences[i] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative
        ? 1
        : 1 - morphInfluencesSum;
      program
        .getUniforms()
        .setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program
        .getUniforms()
        .setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update: update2,
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update2(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (
        object.hasEventListener("dispose", onInstancedMeshDispose) === false
      ) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update: update2,
    dispose,
  };
}
class DepthTexture extends Texture {
  constructor(
    width,
    height,
    type,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    anisotropy,
    format,
  ) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat",
      );
    }
    if (type === void 0 && format === DepthFormat) type = UnsignedIntType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(
      null,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
    );
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null)
      data.compareFunction = this.compareFunction;
    return data;
  }
}
const emptyTexture = /* @__PURE__ */ new Texture();
const emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
emptyShadowTexture.compareFunction = LessEqualCompare;
const emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
const empty3dTexture = /* @__PURE__ */ new Data3DTexture();
const emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
const arrayCacheF32 = [];
const arrayCacheI32 = [];
const mat4array = new Float32Array(16);
const mat3array = new Float32Array(9);
const mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (
      cache[0] !== v.x ||
      cache[1] !== v.y ||
      cache[2] !== v.z ||
      cache[3] !== v.w
    ) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2i(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3i(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (
      cache[0] !== v.x ||
      cache[1] !== v.y ||
      cache[2] !== v.z ||
      cache[3] !== v.w
    ) {
      gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v) return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function setValueV2ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2ui(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3ui(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (
      cache[0] !== v.x ||
      cache[1] !== v.y ||
      cache[2] !== v.z ||
      cache[3] !== v.w
    ) {
      gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v)) return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  const emptyTexture2D =
    this.type === gl.SAMPLER_2D_SHADOW ? emptyShadowTexture : emptyTexture;
  textures.setTexture2D(v || emptyTexture2D, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT3DArray(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture3D(v[i] || empty3dTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
class SingleUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.setValue = getSingularSetter(activeInfo.type);
  }
}
class PureArrayUniform {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
}
class StructuredUniform {
  constructor(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  setValue(gl, value, textures) {
    const seq = this.seq;
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name,
    pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path),
      matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]",
      subscript = match[3];
    if (idIsIndex) id = id | 0;
    if (
      subscript === void 0 ||
      (subscript === "[" && matchEnd + 2 === pathLength)
    ) {
      addUniform(
        container,
        subscript === void 0
          ? new SingleUniform(id, activeInfo, addr)
          : new PureArrayUniform(id, activeInfo, addr),
      );
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
class WebGLUniforms {
  constructor(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const info = gl.getActiveUniform(program, i),
        addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0) u.setValue(gl, value, textures);
  }
  setOptional(gl, object, name) {
    const v = object[name];
    if (v !== void 0) this.setValue(gl, name, v);
  }
  static upload(gl, seq, values, textures) {
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i],
        v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r = [];
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      if (u.id in values) r.push(u);
    }
    return r;
  }
}
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
const COMPLETION_STATUS_KHR = 37297;
let programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i = from; i < to; i++) {
    const line = i + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
  }
  return lines2.join("\n");
}
function getEncodingComponents(colorSpace) {
  const workingPrimaries = ColorManagement.getPrimaries(
    ColorManagement.workingColorSpace,
  );
  const encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
  let gamutMapping;
  if (workingPrimaries === encodingPrimaries) {
    gamutMapping = "";
  } else if (
    workingPrimaries === P3Primaries &&
    encodingPrimaries === Rec709Primaries
  ) {
    gamutMapping = "LinearDisplayP3ToLinearSRGB";
  } else if (
    workingPrimaries === Rec709Primaries &&
    encodingPrimaries === P3Primaries
  ) {
    gamutMapping = "LinearSRGBToLinearDisplayP3";
  }
  switch (colorSpace) {
    case LinearSRGBColorSpace:
    case LinearDisplayP3ColorSpace:
      return [gamutMapping, "LinearTransferOETF"];
    case SRGBColorSpace:
    case DisplayP3ColorSpace:
      return [gamutMapping, "sRGBTransferOETF"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace);
      return [gamutMapping, "LinearTransferOETF"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "") return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return (
      type.toUpperCase() +
      "\n\n" +
      errors +
      "\n\n" +
      handleSource(gl.getShaderSource(shader), errorLine)
    );
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return `vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`;
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case AgXToneMapping:
      toneMappingName = "AgX";
      break;
    case NeutralToneMapping:
      toneMappingName = "Neutral";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return (
    "vec3 " +
    functionName +
    "( vec3 color ) { return " +
    toneMappingName +
    "ToneMapping( color ); }"
  );
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives ||
    !!parameters.envMapCubeUVHeight ||
    parameters.bumpMap ||
    parameters.normalMapTangentSpace ||
    parameters.clearcoatNormalMap ||
    parameters.flatShading ||
    parameters.alphaToCoverage ||
    parameters.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) &&
    parameters.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (parameters.extensionShaderTextureLOD ||
      parameters.envMap ||
      parameters.transmission) &&
    parameters.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateVertexExtensions(parameters) {
  const chunks = [
    parameters.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    parameters.extensionMultiDraw
      ? "#extension GL_ANGLE_multi_draw : require"
      : "",
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl.FLOAT_MAT2) locationSize = 2;
    if (info.type === gl.FLOAT_MAT3) locationSize = 3;
    if (info.type === gl.FLOAT_MAT4) locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize,
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  const numSpotLightCoords =
    parameters.numSpotLightShadows +
    parameters.numSpotLightMaps -
    parameters.numSpotLightShadowsWithMaps;
  return string
    .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords)
    .replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)
    .replace(
      /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
      parameters.numSpotLightShadowsWithMaps,
    )
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string
    .replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      parameters.numClippingPlanes - parameters.numClipIntersection,
    );
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
const shaderChunkMap = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"],
  // @deprecated, r154
]);
function includeReplacer(match, include) {
  let string = ShaderChunk[include];
  if (string === void 0) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== void 0) {
      string = ShaderChunk[newInclude];
      console.warn(
        'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
        include,
        newInclude,
      );
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string);
}
const unrollLoopPattern =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet
      .replace(/\[\s*i\s*\]/g, "[ " + i + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	`;
  if (parameters.isWebGL2) {
    precisionstring += `precision ${parameters.precision} sampler3D;
		precision ${parameters.precision} sampler2DArray;
		precision ${parameters.precision} sampler2DShadow;
		precision ${parameters.precision} samplerCubeShadow;
		precision ${parameters.precision} sampler2DArrayShadow;
		precision ${parameters.precision} isampler2D;
		precision ${parameters.precision} isampler3D;
		precision ${parameters.precision} isamplerCube;
		precision ${parameters.precision} isampler2DArray;
		precision ${parameters.precision} usampler2D;
		precision ${parameters.precision} usampler3D;
		precision ${parameters.precision} usamplerCube;
		precision ${parameters.precision} usampler2DArray;
		`;
  }
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customExtensions = parameters.isWebGL2
    ? ""
    : generateExtensions(parameters);
  const customVertexExtensions = generateVertexExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion
    ? "#version " + parameters.glslVersion + "\n"
    : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
    ]
      .filter(filterEmptyLine)
      .join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
    ]
      .filter(filterEmptyLine)
      .join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      parameters.batching ? "#define USE_BATCHING" : "",
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace
        ? "#define USE_NORMALMAP_OBJECTSPACE"
        : "",
      parameters.normalMapTangentSpace
        ? "#define USE_NORMALMAP_TANGENTSPACE"
        : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap
        ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
        : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap
        ? "#define USE_IRIDESCENCE_THICKNESSMAP"
        : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap
        ? "#define USE_SPECULAR_INTENSITYMAP"
        : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv
        ? "#define ALPHAMAP_UV " + parameters.alphaMapUv
        : "",
      parameters.lightMapUv
        ? "#define LIGHTMAP_UV " + parameters.lightMapUv
        : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv
        ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv
        : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv
        ? "#define NORMALMAP_UV " + parameters.normalMapUv
        : "",
      parameters.displacementMapUv
        ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv
        : "",
      parameters.metalnessMapUv
        ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv
        : "",
      parameters.roughnessMapUv
        ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv
        : "",
      parameters.anisotropyMapUv
        ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv
        : "",
      parameters.clearcoatMapUv
        ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv
        : "",
      parameters.clearcoatNormalMapUv
        ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv
        : "",
      parameters.clearcoatRoughnessMapUv
        ? "#define CLEARCOAT_ROUGHNESSMAP_UV " +
          parameters.clearcoatRoughnessMapUv
        : "",
      parameters.iridescenceMapUv
        ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv
        : "",
      parameters.iridescenceThicknessMapUv
        ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
          parameters.iridescenceThicknessMapUv
        : "",
      parameters.sheenColorMapUv
        ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv
        : "",
      parameters.sheenRoughnessMapUv
        ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv
        : "",
      parameters.specularMapUv
        ? "#define SPECULARMAP_UV " + parameters.specularMapUv
        : "",
      parameters.specularColorMapUv
        ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv
        : "",
      parameters.specularIntensityMapUv
        ? "#define SPECULAR_INTENSITYMAP_UV " +
          parameters.specularIntensityMapUv
        : "",
      parameters.transmissionMapUv
        ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv
        : "",
      parameters.thicknessMapUv
        ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv
        : "",
      //
      parameters.vertexTangents && parameters.flatShading === false
        ? "#define USE_TANGENT"
        : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false
        ? "#define USE_MORPHNORMALS"
        : "",
      parameters.morphColors && parameters.isWebGL2
        ? "#define USE_MORPHCOLORS"
        : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2
        ? "#define MORPHTARGETS_TEXTURE"
        : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2
        ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride
        : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2
        ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount
        : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth
        ? "#define USE_LOGDEPTHBUF_EXT"
        : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n",
    ]
      .filter(filterEmptyLine)
      .join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize
        ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth
        : "",
      envMapCubeUVSize
        ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight
        : "",
      envMapCubeUVSize
        ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0"
        : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace
        ? "#define USE_NORMALMAP_OBJECTSPACE"
        : "",
      parameters.normalMapTangentSpace
        ? "#define USE_NORMALMAP_TANGENTSPACE"
        : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap
        ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
        : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap
        ? "#define USE_IRIDESCENCE_THICKNESSMAP"
        : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap
        ? "#define USE_SPECULAR_INTENSITYMAP"
        : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false
        ? "#define USE_TANGENT"
        : "",
      parameters.vertexColors || parameters.instancingColor
        ? "#define USE_COLOR"
        : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth
        ? "#define USE_LOGDEPTHBUF_EXT"
        : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping
        ? ShaderChunk["tonemapping_pars_fragment"]
        : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping
        ? getToneMappingFunction("toneMapping", parameters.toneMapping)
        : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction(
        "linearToOutputTexel",
        parameters.outputColorSpace,
      ),
      parameters.useDepthPacking
        ? "#define DEPTH_PACKING " + parameters.depthPacking
        : "",
      "\n",
    ]
      .filter(filterEmptyLine)
      .join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex =
      [
        customVertexExtensions,
        "precision mediump sampler2DArray;",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture",
      ].join("\n") +
      "\n" +
      prefixVertex;
    prefixFragment =
      [
        "precision mediump sampler2DArray;",
        "#define varying in",
        parameters.glslVersion === GLSL3
          ? ""
          : "layout(location = 0) out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3
          ? ""
          : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad",
      ].join("\n") +
      "\n" +
      prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  function onFirstUse(self2) {
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer.debug.onShaderError === "function") {
          renderer.debug.onShaderError(
            gl,
            program,
            glVertexShader,
            glFragmentShader,
          );
        } else {
          const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(
            gl,
            glFragmentShader,
            "fragment",
          );
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              gl.getError() +
              " - VALIDATE_STATUS " +
              gl.getProgramParameter(program, gl.VALIDATE_STATUS) +
              "\n\nMaterial Name: " +
              self2.name +
              "\nMaterial Type: " +
              self2.type +
              "\n\nProgram Info Log: " +
              programLog +
              "\n" +
              vertexErrors +
              "\n" +
              fragmentErrors,
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self2.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex,
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment,
          },
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl, program);
    cachedAttributes = fetchAttributeLocations(gl, program);
  }
  let cachedUniforms;
  this.getUniforms = function () {
    if (cachedUniforms === void 0) {
      onFirstUse(this);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function () {
    if (cachedAttributes === void 0) {
      onFirstUse(this);
    }
    return cachedAttributes;
  };
  let programReady =
    parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function () {
    if (programReady === false) {
      programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };
  this.destroy = function () {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
let _id$1 = 0;
class WebGLShaderCache {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0)
        this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    let set = cache.get(material);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      cache.set(material, set);
    }
    return set;
  }
  _getShaderStage(code) {
    const cache = this.shaderCache;
    let stage = cache.get(code);
    if (stage === void 0) {
      stage = new WebGLShaderStage(code);
      cache.set(code, stage);
    }
    return stage;
  }
}
class WebGLShaderStage {
  constructor(code) {
    this.id = _id$1++;
    this.code = code;
    this.usedTimes = 0;
  }
}
function WebGLPrograms(
  renderer,
  cubemaps,
  cubeuvmaps,
  extensions,
  capabilities,
  bindingStates,
  clipping,
) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const _activeChannels = /* @__PURE__ */ new Set();
  const programs = [];
  const IS_WEBGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function getChannel(value) {
    _activeChannels.add(value);
    if (value === 0) return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial
      ? scene.environment
      : null;
    const envMap = (
      material.isMeshStandardMaterial ? cubeuvmaps : cubemaps
    ).get(material.envMap || environment);
    const envMapCubeUVHeight =
      !!envMap && envMap.mapping === CubeUVReflectionMapping
        ? envMap.image.height
        : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          material.precision,
          "not supported, using",
          precision,
          "instead.",
        );
      }
    }
    const morphAttribute =
      geometry.morphAttributes.position ||
      geometry.morphAttributes.normal ||
      geometry.morphAttributes.color;
    const morphTargetsCount =
      morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const IS_BATCHEDMESH = object.isBatchedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP =
      HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP =
      HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP =
      HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    let toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (
        currentRenderTarget === null ||
        currentRenderTarget.isXRRenderTarget === true
      ) {
        toneMapping = renderer.toneMapping;
      }
    }
    const parameters = {
      isWebGL2: IS_WEBGL2,
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      batching: IS_BATCHEDMESH,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace:
        currentRenderTarget === null
          ? renderer.outputColorSpace
          : currentRenderTarget.isXRRenderTarget === true
            ? currentRenderTarget.texture.colorSpace
            : LinearSRGBColorSpace,
      alphaToCoverage: !!material.alphaToCoverage,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace:
        HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace:
        HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque:
        material.transparent === false &&
        material.blending === NormalBlending &&
        material.alphaToCoverage === false,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv:
        HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv:
        HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv:
        HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv:
        HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv:
        HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv:
        HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv:
        HAS_CLEARCOAT_NORMALMAP &&
        getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv:
        HAS_CLEARCOAT_ROUGHNESSMAP &&
        getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv:
        HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv:
        HAS_IRIDESCENCE_THICKNESSMAP &&
        getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv:
        HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv:
        HAS_SHEEN_ROUGHNESSMAP &&
        getChannel(material.sheenRoughnessMap.channel),
      specularMapUv:
        HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv:
        HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv:
        HAS_SPECULAR_INTENSITYMAP &&
        getChannel(material.specularIntensityMap.channel),
      transmissionMapUv:
        HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv:
        HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents:
        !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas:
        material.vertexColors === true &&
        !!geometry.attributes.color &&
        geometry.attributes.color.itemSize === 4,
      pointsUvs:
        object.isPoints === true &&
        !!geometry.attributes.uv &&
        (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: !!fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping,
      useLegacyLights: renderer._useLegacyLights,
      decodeVideoTexture:
        HAS_MAP &&
        material.map.isVideoTexture === true &&
        ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives:
        HAS_EXTENSIONS && material.extensions.derivatives === true,
      extensionFragDepth:
        HAS_EXTENSIONS && material.extensions.fragDepth === true,
      extensionDrawBuffers:
        HAS_EXTENSIONS && material.extensions.drawBuffers === true,
      extensionShaderTextureLOD:
        HAS_EXTENSIONS && material.extensions.shaderTextureLOD === true,
      extensionClipCullDistance:
        HAS_EXTENSIONS &&
        material.extensions.clipCullDistance === true &&
        extensions.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        HAS_EXTENSIONS &&
        material.extensions.multiDraw === true &&
        extensions.has("WEBGL_multi_draw"),
      rendererExtensionFragDepth: IS_WEBGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers:
        IS_WEBGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod:
        IS_WEBGL2 || extensions.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: extensions.has(
        "KHR_parallel_shader_compile",
      ),
      customProgramCacheKey: material.customProgramCacheKey(),
    };
    parameters.vertexUv1s = _activeChannels.has(1);
    parameters.vertexUv2s = _activeChannels.has(2);
    parameters.vertexUv3s = _activeChannels.has(3);
    _activeChannels.clear();
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.isWebGL2) _programLayers.enable(0);
    if (parameters.supportsVertexTextures) _programLayers.enable(1);
    if (parameters.instancing) _programLayers.enable(2);
    if (parameters.instancingColor) _programLayers.enable(3);
    if (parameters.instancingMorph) _programLayers.enable(4);
    if (parameters.matcap) _programLayers.enable(5);
    if (parameters.envMap) _programLayers.enable(6);
    if (parameters.normalMapObjectSpace) _programLayers.enable(7);
    if (parameters.normalMapTangentSpace) _programLayers.enable(8);
    if (parameters.clearcoat) _programLayers.enable(9);
    if (parameters.iridescence) _programLayers.enable(10);
    if (parameters.alphaTest) _programLayers.enable(11);
    if (parameters.vertexColors) _programLayers.enable(12);
    if (parameters.vertexAlphas) _programLayers.enable(13);
    if (parameters.vertexUv1s) _programLayers.enable(14);
    if (parameters.vertexUv2s) _programLayers.enable(15);
    if (parameters.vertexUv3s) _programLayers.enable(16);
    if (parameters.vertexTangents) _programLayers.enable(17);
    if (parameters.anisotropy) _programLayers.enable(18);
    if (parameters.alphaHash) _programLayers.enable(19);
    if (parameters.batching) _programLayers.enable(20);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog) _programLayers.enable(0);
    if (parameters.useFog) _programLayers.enable(1);
    if (parameters.flatShading) _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer) _programLayers.enable(3);
    if (parameters.skinning) _programLayers.enable(4);
    if (parameters.morphTargets) _programLayers.enable(5);
    if (parameters.morphNormals) _programLayers.enable(6);
    if (parameters.morphColors) _programLayers.enable(7);
    if (parameters.premultipliedAlpha) _programLayers.enable(8);
    if (parameters.shadowMapEnabled) _programLayers.enable(9);
    if (parameters.useLegacyLights) _programLayers.enable(10);
    if (parameters.doubleSided) _programLayers.enable(11);
    if (parameters.flipSided) _programLayers.enable(12);
    if (parameters.useDepthPacking) _programLayers.enable(13);
    if (parameters.dithering) _programLayers.enable(14);
    if (parameters.transmission) _programLayers.enable(15);
    if (parameters.sheen) _programLayers.enable(16);
    if (parameters.opaque) _programLayers.enable(17);
    if (parameters.pointsUvs) _programLayers.enable(18);
    if (parameters.decodeVideoTexture) _programLayers.enable(19);
    if (parameters.alphaToCoverage) _programLayers.enable(20);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose,
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update2(object, key2, value) {
    properties.get(object)[key2] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    remove,
    update: update2,
    dispose,
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group,
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(
      object,
      geometry,
      material,
      groupOrder,
      z,
      group,
    );
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(
      object,
      geometry,
      material,
      groupOrder,
      z,
      group,
    );
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort,
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === void 0) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose,
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3$1(),
            color: new Color(),
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3$1(),
            direction: new Vector3$1(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3$1(),
            color: new Color(),
            distance: 0,
            decay: 0,
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3$1(),
            skyColor: new Color(),
            groundColor: new Color(),
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3$1(),
            halfWidth: new Vector3$1(),
            halfHeight: new Vector3$1(),
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    },
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function (light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    },
  };
}
let nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (
    (lightB.castShadow ? 2 : 0) -
    (lightA.castShadow ? 2 : 0) +
    (lightB.map ? 1 : 0) -
    (lightA.map ? 1 : 0)
  );
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1,
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0,
  };
  for (let i = 0; i < 9; i++) state.probe.push(new Vector3$1());
  const vector3 = new Vector3$1();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, useLegacyLights) {
    let r = 0,
      g = 0,
      b = 0;
    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    let numLightProbes = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    const scaleFactor = useLegacyLights === true ? Math.PI : 1;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap =
        light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity * scaleFactor;
        g += color.g * intensity * scaleFactor;
        b += color.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color
          .copy(light.color)
          .multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] =
            light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow) numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color
          .copy(light.color)
          .multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor
          .copy(light.color)
          .multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor
          .copy(light.groundColor)
          .multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        }
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.",
          );
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;
    if (
      hash.directionalLength !== directionalLength ||
      hash.pointLength !== pointLength ||
      hash.spotLength !== spotLength ||
      hash.rectAreaLength !== rectAreaLength ||
      hash.hemiLength !== hemiLength ||
      hash.numDirectionalShadows !== numDirectionalShadows ||
      hash.numPointShadows !== numPointShadows ||
      hash.numSpotShadows !== numSpotShadows ||
      hash.numSpotMaps !== numSpotMaps ||
      hash.numLightProbes !== numLightProbes
    ) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length =
        numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      hash.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state,
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(useLegacyLights) {
    lights.setup(lightsArray, useLegacyLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights,
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow,
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose,
  };
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
}
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.type = "MeshDistanceMaterial";
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
}
const vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
const fragment =
  "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum2 = new Frustum();
  const _shadowMapSize = new Vector2(),
    _viewportSize = new Vector2(),
    _viewport = new Vector4(),
    _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
    _distanceMaterial = new MeshDistanceMaterial(),
    _materialCache = {},
    _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = {
    [FrontSide]: BackSide,
    [BackSide]: FrontSide,
    [DoubleSide]: DoubleSide,
  };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8,
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 },
    },
    vertexShader: vertex,
    fragmentShader: fragment,
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3,
    ),
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM =
      _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (
        _shadowMapSize.x > _maxTextureSize ||
        _shadowMapSize.y > _maxTextureSize
      ) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars =
          this.type !== VSMShadowMap
            ? { minFilter: NearestFilter, magFilter: NearestFilter }
            : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(
          _shadowMapSize.x,
          _shadowMapSize.y,
          pars,
        );
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w,
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum2 = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    _renderer.setRenderTarget(
      currentRenderTarget,
      activeCubeFace,
      activeMipmapLevel,
    );
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(
        _shadowMapSize.x,
        _shadowMapSize.y,
      );
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(
      camera,
      null,
      geometry,
      shadowMaterialVertical,
      fullScreenMesh,
      null,
    );
    shadowMaterialHorizontal.uniforms.shadow_pass.value =
      shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(
      camera,
      null,
      geometry,
      shadowMaterialHorizontal,
      fullScreenMesh,
      null,
    );
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial =
      light.isPointLight === true
        ? object.customDistanceMaterial
        : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (
        (_renderer.localClippingEnabled &&
          material.clipShadows === true &&
          Array.isArray(material.clippingPlanes) &&
          material.clippingPlanes.length !== 0) ||
        (material.displacementMap && material.displacementScale !== 0) ||
        (material.alphaMap && material.alphaTest > 0) ||
        (material.map && material.alphaTest > 0)
      ) {
        const keyA = result.uuid,
          keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
          material.addEventListener("dispose", onMaterialDispose);
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side =
        material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side =
        material.shadowSide !== null
          ? material.shadowSide
          : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = _renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if (
        (object.castShadow ||
          (object.receiveShadow && type === VSMShadowMap)) &&
        (!object.frustumCulled || _frustum2.intersectsObject(object))
      ) {
        object.modelViewMatrix.multiplyMatrices(
          shadowCamera.matrixWorldInverse,
          object.matrixWorld,
        );
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(
                object,
                groupMaterial,
                light,
                type,
              );
              object.onBeforeShadow(
                _renderer,
                object,
                camera,
                shadowCamera,
                geometry,
                depthMaterial,
                group,
              );
              _renderer.renderBufferDirect(
                shadowCamera,
                null,
                geometry,
                depthMaterial,
                object,
                group,
              );
              object.onAfterShadow(
                _renderer,
                object,
                camera,
                shadowCamera,
                geometry,
                depthMaterial,
                group,
              );
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          object.onBeforeShadow(
            _renderer,
            object,
            camera,
            shadowCamera,
            geometry,
            depthMaterial,
            null,
          );
          _renderer.renderBufferDirect(
            shadowCamera,
            null,
            geometry,
            depthMaterial,
            object,
            null,
          );
          object.onAfterShadow(
            _renderer,
            object,
            camera,
            shadowCamera,
            geometry,
            depthMaterial,
            null,
          );
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    for (const id in _materialCache) {
      const cache = _materialCache[id];
      const uuid = event.target.uuid;
      if (uuid in cache) {
        const shadowMaterial = cache[uuid];
        shadowMaterial.dispose();
        delete cache[uuid];
      }
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function (colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function () {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      },
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function (depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function (depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function (depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function () {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      },
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function (stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function (stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function (stencilFunc, stencilRef, stencilMask) {
        if (
          currentStencilFunc !== stencilFunc ||
          currentStencilRef !== stencilRef ||
          currentStencilFuncMask !== stencilMask
        ) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function (stencilFail, stencilZFail, stencilZPass) {
        if (
          currentStencilFail !== stencilFail ||
          currentStencilZFail !== stencilZFail ||
          currentStencilZPass !== stencilZPass
        ) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function (lock) {
        locked = lock;
      },
      setClear: function (stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function () {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      },
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentBlendColor = new Color(0, 0, 0);
  let currentBlendAlpha = 0;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  const viewportParam = gl.getParameter(gl.VIEWPORT);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count, dimensions) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i = 0; i < count; i++) {
      if (
        isWebGL2 &&
        (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY)
      ) {
        gl.texImage3D(
          target,
          0,
          gl.RGBA,
          1,
          1,
          dimensions,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          data,
        );
      } else {
        gl.texImage2D(
          target + i,
          0,
          gl.RGBA,
          1,
          1,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          data,
        );
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(
    gl.TEXTURE_CUBE_MAP,
    gl.TEXTURE_CUBE_MAP_POSITIVE_X,
    6,
  );
  if (isWebGL2) {
    emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(
      gl.TEXTURE_2D_ARRAY,
      gl.TEXTURE_2D_ARRAY,
      1,
      1,
    );
    emptyTextures[gl.TEXTURE_3D] = createTexture(
      gl.TEXTURE_3D,
      gl.TEXTURE_3D,
      1,
      1,
    );
  }
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === gl.DRAW_FRAMEBUFFER) {
          currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
        }
        if (target === gl.FRAMEBUFFER) {
          currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      const textures = renderTarget.textures;
      if (
        drawBuffers2.length !== textures.length ||
        drawBuffers2[0] !== gl.COLOR_ATTACHMENT0
      ) {
        for (let i = 0, il = textures.length; i < il; i++) {
          drawBuffers2[i] = gl.COLOR_ATTACHMENT0 + i;
        }
        drawBuffers2.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers2[0] !== gl.BACK) {
        drawBuffers2[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl.drawBuffers(drawBuffers2);
      } else if (extensions.has("WEBGL_draw_buffers") === true) {
        extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
      } else {
        throw new Error(
          "THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension",
        );
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT,
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = gl.MIN;
    equationToGL[MaxEquation] = gl.MAX;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: gl.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA,
  };
  function setBlending(
    blending,
    blendEquation,
    blendSrc,
    blendDst,
    blendEquationAlpha,
    blendSrcAlpha,
    blendDstAlpha,
    blendColor,
    blendAlpha,
    premultipliedAlpha,
  ) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (
        blending !== currentBlending ||
        premultipliedAlpha !== currentPremultipledAlpha
      ) {
        if (
          currentBlendEquation !== AddEquation ||
          currentBlendEquationAlpha !== AddEquation
        ) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(
                gl.ONE,
                gl.ONE_MINUS_SRC_ALPHA,
                gl.ONE,
                gl.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(
                gl.ZERO,
                gl.ONE_MINUS_SRC_COLOR,
                gl.ZERO,
                gl.ONE,
              );
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(
                gl.ZERO,
                gl.SRC_COLOR,
                gl.ZERO,
                gl.SRC_ALPHA,
              );
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(
                gl.SRC_ALPHA,
                gl.ONE_MINUS_SRC_ALPHA,
                gl.ONE,
                gl.ONE_MINUS_SRC_ALPHA,
              );
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(
                gl.ZERO,
                gl.ONE_MINUS_SRC_COLOR,
                gl.ZERO,
                gl.ONE,
              );
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (
      blendEquation !== currentBlendEquation ||
      blendEquationAlpha !== currentBlendEquationAlpha
    ) {
      gl.blendEquationSeparate(
        equationToGL[blendEquation],
        equationToGL[blendEquationAlpha],
      );
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (
      blendSrc !== currentBlendSrc ||
      blendDst !== currentBlendDst ||
      blendSrcAlpha !== currentBlendSrcAlpha ||
      blendDstAlpha !== currentBlendDstAlpha
    ) {
      gl.blendFuncSeparate(
        factorToGL[blendSrc],
        factorToGL[blendDst],
        factorToGL[blendSrcAlpha],
        factorToGL[blendDstAlpha],
      );
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (
      blendColor.equals(currentBlendColor) === false ||
      blendAlpha !== currentBlendAlpha
    ) {
      gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false
      ? setBlending(NoBlending)
      : setBlending(
          material.blending,
          material.blendEquation,
          material.blendSrc,
          material.blendDst,
          material.blendEquationAlpha,
          material.blendSrcAlpha,
          material.blendDstAlpha,
          material.blendColor,
          material.blendAlpha,
          material.premultipliedAlpha,
        );
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(
        material.stencilFunc,
        material.stencilRef,
        material.stencilFuncMask,
      );
      stencilBuffer.setOp(
        material.stencilFail,
        material.stencilZFail,
        material.stencilZPass,
      );
    }
    setPolygonOffset(
      material.polygonOffset,
      material.polygonOffsetFactor,
      material.polygonOffsetUnits,
    );
    material.alphaToCoverage === true
      ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE)
      : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (
        currentPolygonOffsetFactor !== factor ||
        currentPolygonOffsetUnits !== units
      ) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (
      boundTexture.type !== webglType ||
      boundTexture.texture !== webglTexture
    ) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl.uniformBlockBinding(
        program,
        blockIndex,
        uniformsGroup.__bindingPointIndex,
      );
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendColor(0, 0, 0, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer,
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset,
  };
}
function WebGLTextures(
  _gl,
  extensions,
  state,
  properties,
  capabilities,
  utils,
  info,
) {
  const isWebGL2 = capabilities.isWebGL2;
  const multisampledRTTExt = extensions.has(
    "WEBGL_multisampled_render_to_texture",
  )
    ? extensions.get("WEBGL_multisampled_render_to_texture")
    : null;
  const supportsInvalidateFramebuffer =
    typeof navigator === "undefined"
      ? false
      : /OculusBrowser/g.test(navigator.userAgent);
  const _imageDimensions = new Vector2();
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas =
      typeof OffscreenCanvas !== "undefined" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {}
  function createCanvas(width, height) {
    return useOffscreenCanvas
      ? // eslint-disable-next-line compat/compat
        new OffscreenCanvas(width, height)
      : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    const dimensions = getDimensions(image);
    if (dimensions.width > maxSize || dimensions.height > maxSize) {
      scale = maxSize / Math.max(dimensions.width, dimensions.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (
        (typeof HTMLImageElement !== "undefined" &&
          image instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement !== "undefined" &&
          image instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) ||
        (typeof VideoFrame !== "undefined" && image instanceof VideoFrame)
      ) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * dimensions.width);
        const height = floor(scale * dimensions.height);
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn(
          "THREE.WebGLRenderer: Texture has been resized from (" +
            dimensions.width +
            "x" +
            dimensions.height +
            ") to (" +
            width +
            "x" +
            height +
            ").",
        );
        return canvas;
      } else {
        if ("data" in image) {
          console.warn(
            "THREE.WebGLRenderer: Image in DataTexture is too big (" +
              dimensions.width +
              "x" +
              dimensions.height +
              ").",
          );
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    const dimensions = getDimensions(image);
    return isPowerOfTwo(dimensions.width) && isPowerOfTwo(dimensions.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2) return false;
    return (
      texture.wrapS !== ClampToEdgeWrapping ||
      texture.wrapT !== ClampToEdgeWrapping ||
      (texture.minFilter !== NearestFilter &&
        texture.minFilter !== LinearFilter)
    );
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return (
      texture.generateMipmaps &&
      supportsMips &&
      texture.minFilter !== NearestFilter &&
      texture.minFilter !== LinearFilter
    );
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(
    internalFormatName,
    glFormat,
    glType,
    colorSpace,
    forceLinearTransfer = false,
  ) {
    if (isWebGL2 === false) return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          internalFormatName +
          "'",
      );
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.R8I;
      if (glType === _gl.SHORT) internalFormat = _gl.R16I;
      if (glType === _gl.INT) internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RG_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
      if (glType === _gl.INT) internalFormat = _gl.RG32I;
    }
    if (glFormat === _gl.RGBA) {
      const transfer = forceLinearTransfer
        ? LinearTransfer
        : ColorManagement.getTransfer(colorSpace);
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat =
          transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
    }
    if (
      internalFormat === _gl.R16F ||
      internalFormat === _gl.R32F ||
      internalFormat === _gl.RG16F ||
      internalFormat === _gl.RG32F ||
      internalFormat === _gl.RGBA16F ||
      internalFormat === _gl.RGBA32F
    ) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture, image, supportsMips) {
    if (
      textureNeedsGenerateMipmaps(texture, supportsMips) === true ||
      (texture.isFramebufferTexture &&
        texture.minFilter !== NearestFilter &&
        texture.minFilter !== LinearFilter)
    ) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f) {
    if (
      f === NearestFilter ||
      f === NearestMipmapNearestFilter ||
      f === NearestMipmapLinearFilter
    ) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0) return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
          for (
            let level = 0;
            level < renderTargetProperties.__webglFramebuffer[i].length;
            level++
          )
            _gl.deleteFramebuffer(
              renderTargetProperties.__webglFramebuffer[i][level],
            );
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        }
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (
          let level = 0;
          level < renderTargetProperties.__webglFramebuffer.length;
          level++
        )
          _gl.deleteFramebuffer(
            renderTargetProperties.__webglFramebuffer[level],
          );
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(
          renderTargetProperties.__webglMultisampledFramebuffer,
        );
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (
          let i = 0;
          i < renderTargetProperties.__webglColorRenderbuffer.length;
          i++
        ) {
          if (renderTargetProperties.__webglColorRenderbuffer[i])
            _gl.deleteRenderbuffer(
              renderTargetProperties.__webglColorRenderbuffer[i],
            );
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    const textures = renderTarget.textures;
    for (let i = 0, il = textures.length; i < il; i++) {
      const attachmentProperties = properties.get(textures[i]);
      if (attachmentProperties.__webglTexture) {
        _gl.deleteTexture(attachmentProperties.__webglTexture);
        info.memory.textures--;
      }
      properties.remove(textures[i]);
    }
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      console.warn(
        "THREE.WebGLTextures: Trying to use " +
          textureUnit +
          " texture units while this GPU supports only " +
          capabilities.maxTextures,
      );
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (
      texture.isRenderTargetTexture === false &&
      texture.version > 0 &&
      textureProperties.__version !== texture.version
    ) {
      const image = texture.image;
      if (image === null) {
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found.",
        );
      } else if (image.complete === false) {
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
        );
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(
      _gl.TEXTURE_2D,
      textureProperties.__webglTexture,
      _gl.TEXTURE0 + slot,
    );
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (
      texture.version > 0 &&
      textureProperties.__version !== texture.version
    ) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(
      _gl.TEXTURE_2D_ARRAY,
      textureProperties.__webglTexture,
      _gl.TEXTURE0 + slot,
    );
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (
      texture.version > 0 &&
      textureProperties.__version !== texture.version
    ) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(
      _gl.TEXTURE_3D,
      textureProperties.__webglTexture,
      _gl.TEXTURE0 + slot,
    );
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (
      texture.version > 0 &&
      textureProperties.__version !== texture.version
    ) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(
      _gl.TEXTURE_CUBE_MAP,
      textureProperties.__webglTexture,
      _gl.TEXTURE0 + slot,
    );
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT,
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR,
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL,
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (
      texture.type === FloatType &&
      extensions.has("OES_texture_float_linear") === false &&
      (texture.magFilter === LinearFilter ||
        texture.magFilter === LinearMipmapNearestFilter ||
        texture.magFilter === NearestMipmapLinearFilter ||
        texture.magFilter === LinearMipmapLinearFilter ||
        texture.minFilter === LinearFilter ||
        texture.minFilter === LinearMipmapNearestFilter ||
        texture.minFilter === NearestMipmapLinearFilter ||
        texture.minFilter === LinearMipmapLinearFilter)
    ) {
      console.warn(
        "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.",
      );
    }
    if (supportsMips) {
      _gl.texParameteri(
        textureType,
        _gl.TEXTURE_WRAP_S,
        wrappingToGL[texture.wrapS],
      );
      _gl.texParameteri(
        textureType,
        _gl.TEXTURE_WRAP_T,
        wrappingToGL[texture.wrapT],
      );
      if (
        textureType === _gl.TEXTURE_3D ||
        textureType === _gl.TEXTURE_2D_ARRAY
      ) {
        _gl.texParameteri(
          textureType,
          _gl.TEXTURE_WRAP_R,
          wrappingToGL[texture.wrapR],
        );
      }
      _gl.texParameteri(
        textureType,
        _gl.TEXTURE_MAG_FILTER,
        filterToGL[texture.magFilter],
      );
      _gl.texParameteri(
        textureType,
        _gl.TEXTURE_MIN_FILTER,
        filterToGL[texture.minFilter],
      );
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      if (
        textureType === _gl.TEXTURE_3D ||
        textureType === _gl.TEXTURE_2D_ARRAY
      ) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
      }
      if (
        texture.wrapS !== ClampToEdgeWrapping ||
        texture.wrapT !== ClampToEdgeWrapping
      ) {
        console.warn(
          "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
        );
      }
      _gl.texParameteri(
        textureType,
        _gl.TEXTURE_MAG_FILTER,
        filterFallback(texture.magFilter),
      );
      _gl.texParameteri(
        textureType,
        _gl.TEXTURE_MIN_FILTER,
        filterFallback(texture.minFilter),
      );
      if (
        texture.minFilter !== NearestFilter &&
        texture.minFilter !== LinearFilter
      ) {
        console.warn(
          "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",
        );
      }
    }
    if (texture.compareFunction) {
      _gl.texParameteri(
        textureType,
        _gl.TEXTURE_COMPARE_MODE,
        _gl.COMPARE_REF_TO_TEXTURE,
      );
      _gl.texParameteri(
        textureType,
        _gl.TEXTURE_COMPARE_FUNC,
        compareToGL[texture.compareFunction],
      );
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture.magFilter === NearestFilter) return;
      if (
        texture.minFilter !== NearestMipmapLinearFilter &&
        texture.minFilter !== LinearMipmapLinearFilter
      )
        return;
      if (
        texture.type === FloatType &&
        extensions.has("OES_texture_float_linear") === false
      )
        return;
      if (
        isWebGL2 === false &&
        texture.type === HalfFloatType &&
        extensions.has("OES_texture_half_float_linear") === false
      )
        return;
      if (
        texture.anisotropy > 1 ||
        properties.get(texture).__currentAnisotropy
      ) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        _gl.texParameterf(
          textureType,
          extension.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()),
        );
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0,
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture)
      textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(
      textureType,
      textureProperties.__webglTexture,
      _gl.TEXTURE0 + slot,
    );
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(
        ColorManagement.workingColorSpace,
      );
      const texturePrimaries =
        texture.colorSpace === NoColorSpace
          ? null
          : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion =
        texture.colorSpace === NoColorSpace ||
        workingPrimaries === texturePrimaries
          ? _gl.NONE
          : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(
        _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        texture.premultiplyAlpha,
      );
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const needsPowerOfTwo =
        textureNeedsPowerOfTwo(texture) &&
        isPowerOfTwo$1(texture.image) === false;
      let image = resizeImage(
        texture.image,
        needsPowerOfTwo,
        false,
        capabilities.maxTextureSize,
      );
      image = verifyColorSpace(texture, image);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
        glFormat = utils.convert(texture.format, texture.colorSpace);
      let glType = utils.convert(texture.type),
        glInternalFormat = getInternalFormat(
          texture.internalFormat,
          glFormat,
          glType,
          texture.colorSpace,
          texture.isVideoTexture,
        );
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage =
        isWebGL2 &&
        texture.isVideoTexture !== true &&
        glInternalFormat !== RGB_ETC1_Format;
      const allocateMemory =
        sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      const levels = getMipLevels(texture, image, supportsMips);
      if (texture.isDepthTexture) {
        glInternalFormat = _gl.DEPTH_COMPONENT;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = _gl.DEPTH24_STENCIL8;
          } else {
            glInternalFormat = _gl.DEPTH_COMPONENT16;
          }
        } else {
          if (texture.type === FloatType) {
            console.error(
              "WebGLRenderer: Floating point depth texture requires WebGL2.",
            );
          }
        }
        if (
          texture.format === DepthFormat &&
          glInternalFormat === _gl.DEPTH_COMPONENT
        ) {
          if (
            texture.type !== UnsignedShortType &&
            texture.type !== UnsignedIntType
          ) {
            console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.",
            );
            texture.type = UnsignedIntType;
            glType = utils.convert(texture.type);
          }
        }
        if (
          texture.format === DepthStencilFormat &&
          glInternalFormat === _gl.DEPTH_COMPONENT
        ) {
          glInternalFormat = _gl.DEPTH_STENCIL;
          if (texture.type !== UnsignedInt248Type) {
            console.warn(
              "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
            );
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(
              _gl.TEXTURE_2D,
              1,
              glInternalFormat,
              image.width,
              image.height,
            );
          } else {
            state.texImage2D(
              _gl.TEXTURE_2D,
              0,
              glInternalFormat,
              image.width,
              image.height,
              0,
              glFormat,
              glType,
              null,
            );
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(
              _gl.TEXTURE_2D,
              levels,
              glInternalFormat,
              mipmaps[0].width,
              mipmaps[0].height,
            );
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(
                  _gl.TEXTURE_2D,
                  i,
                  0,
                  0,
                  mipmap.width,
                  mipmap.height,
                  glFormat,
                  glType,
                  mipmap.data,
                );
              }
            } else {
              state.texImage2D(
                _gl.TEXTURE_2D,
                i,
                glInternalFormat,
                mipmap.width,
                mipmap.height,
                0,
                glFormat,
                glType,
                mipmap.data,
              );
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(
                _gl.TEXTURE_2D,
                levels,
                glInternalFormat,
                image.width,
                image.height,
              );
            }
            if (dataReady) {
              state.texSubImage2D(
                _gl.TEXTURE_2D,
                0,
                0,
                0,
                image.width,
                image.height,
                glFormat,
                glType,
                image.data,
              );
            }
          } else {
            state.texImage2D(
              _gl.TEXTURE_2D,
              0,
              glInternalFormat,
              image.width,
              image.height,
              0,
              glFormat,
              glType,
              image.data,
            );
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(
              _gl.TEXTURE_2D_ARRAY,
              levels,
              glInternalFormat,
              mipmaps[0].width,
              mipmaps[0].height,
              image.depth,
            );
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage3D(
                      _gl.TEXTURE_2D_ARRAY,
                      i,
                      0,
                      0,
                      0,
                      mipmap.width,
                      mipmap.height,
                      image.depth,
                      glFormat,
                      mipmap.data,
                      0,
                      0,
                    );
                  }
                } else {
                  state.compressedTexImage3D(
                    _gl.TEXTURE_2D_ARRAY,
                    i,
                    glInternalFormat,
                    mipmap.width,
                    mipmap.height,
                    image.depth,
                    0,
                    mipmap.data,
                    0,
                    0,
                  );
                }
              } else {
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                );
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage3D(
                    _gl.TEXTURE_2D_ARRAY,
                    i,
                    0,
                    0,
                    0,
                    mipmap.width,
                    mipmap.height,
                    image.depth,
                    glFormat,
                    glType,
                    mipmap.data,
                  );
                }
              } else {
                state.texImage3D(
                  _gl.TEXTURE_2D_ARRAY,
                  i,
                  glInternalFormat,
                  mipmap.width,
                  mipmap.height,
                  image.depth,
                  0,
                  glFormat,
                  glType,
                  mipmap.data,
                );
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(
              _gl.TEXTURE_2D,
              levels,
              glInternalFormat,
              mipmaps[0].width,
              mipmaps[0].height,
            );
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(
                      _gl.TEXTURE_2D,
                      i,
                      0,
                      0,
                      mipmap.width,
                      mipmap.height,
                      glFormat,
                      mipmap.data,
                    );
                  }
                } else {
                  state.compressedTexImage2D(
                    _gl.TEXTURE_2D,
                    i,
                    glInternalFormat,
                    mipmap.width,
                    mipmap.height,
                    0,
                    mipmap.data,
                  );
                }
              } else {
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                );
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(
                    _gl.TEXTURE_2D,
                    i,
                    0,
                    0,
                    mipmap.width,
                    mipmap.height,
                    glFormat,
                    glType,
                    mipmap.data,
                  );
                }
              } else {
                state.texImage2D(
                  _gl.TEXTURE_2D,
                  i,
                  glInternalFormat,
                  mipmap.width,
                  mipmap.height,
                  0,
                  glFormat,
                  glType,
                  mipmap.data,
                );
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(
              _gl.TEXTURE_2D_ARRAY,
              levels,
              glInternalFormat,
              image.width,
              image.height,
              image.depth,
            );
          }
          if (dataReady) {
            state.texSubImage3D(
              _gl.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              image.width,
              image.height,
              image.depth,
              glFormat,
              glType,
              image.data,
            );
          }
        } else {
          state.texImage3D(
            _gl.TEXTURE_2D_ARRAY,
            0,
            glInternalFormat,
            image.width,
            image.height,
            image.depth,
            0,
            glFormat,
            glType,
            image.data,
          );
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(
              _gl.TEXTURE_3D,
              levels,
              glInternalFormat,
              image.width,
              image.height,
              image.depth,
            );
          }
          if (dataReady) {
            state.texSubImage3D(
              _gl.TEXTURE_3D,
              0,
              0,
              0,
              0,
              image.width,
              image.height,
              image.depth,
              glFormat,
              glType,
              image.data,
            );
          }
        } else {
          state.texImage3D(
            _gl.TEXTURE_3D,
            0,
            glInternalFormat,
            image.width,
            image.height,
            image.depth,
            0,
            glFormat,
            glType,
            image.data,
          );
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(
              _gl.TEXTURE_2D,
              levels,
              glInternalFormat,
              image.width,
              image.height,
            );
          } else {
            let width = image.width,
              height = image.height;
            for (let i = 0; i < levels; i++) {
              state.texImage2D(
                _gl.TEXTURE_2D,
                i,
                glInternalFormat,
                width,
                height,
                0,
                glFormat,
                glType,
                null,
              );
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            const dimensions = getDimensions(mipmaps[0]);
            state.texStorage2D(
              _gl.TEXTURE_2D,
              levels,
              glInternalFormat,
              dimensions.width,
              dimensions.height,
            );
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(
                  _gl.TEXTURE_2D,
                  i,
                  0,
                  0,
                  glFormat,
                  glType,
                  mipmap,
                );
              }
            } else {
              state.texImage2D(
                _gl.TEXTURE_2D,
                i,
                glInternalFormat,
                glFormat,
                glType,
                mipmap,
              );
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              const dimensions = getDimensions(image);
              state.texStorage2D(
                _gl.TEXTURE_2D,
                levels,
                glInternalFormat,
                dimensions.width,
                dimensions.height,
              );
            }
            if (dataReady) {
              state.texSubImage2D(
                _gl.TEXTURE_2D,
                0,
                0,
                0,
                glFormat,
                glType,
                image,
              );
            }
          } else {
            state.texImage2D(
              _gl.TEXTURE_2D,
              0,
              glInternalFormat,
              glFormat,
              glType,
              image,
            );
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(
      _gl.TEXTURE_CUBE_MAP,
      textureProperties.__webglTexture,
      _gl.TEXTURE0 + slot,
    );
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(
        ColorManagement.workingColorSpace,
      );
      const texturePrimaries =
        texture.colorSpace === NoColorSpace
          ? null
          : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion =
        texture.colorSpace === NoColorSpace ||
        workingPrimaries === texturePrimaries
          ? _gl.NONE
          : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(
        _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        texture.premultiplyAlpha,
      );
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const isCompressed =
        texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(
            texture.image[i],
            false,
            true,
            capabilities.maxCubemapSize,
          );
        } else {
          cubeImage[i] = isDataTexture
            ? texture.image[i].image
            : texture.image[i];
        }
        cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
      }
      const image = cubeImage[0],
        supportsMips = isPowerOfTwo$1(image) || isWebGL2,
        glFormat = utils.convert(texture.format, texture.colorSpace),
        glType = utils.convert(texture.type),
        glInternalFormat = getInternalFormat(
          texture.internalFormat,
          glFormat,
          glType,
          texture.colorSpace,
        );
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory =
        sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      let levels = getMipLevels(texture, image, supportsMips);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(
            _gl.TEXTURE_CUBE_MAP,
            levels,
            glInternalFormat,
            image.width,
            image.height,
          );
        }
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(
                      _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                      j,
                      0,
                      0,
                      mipmap.width,
                      mipmap.height,
                      glFormat,
                      mipmap.data,
                    );
                  }
                } else {
                  state.compressedTexImage2D(
                    _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                    j,
                    glInternalFormat,
                    mipmap.width,
                    mipmap.height,
                    0,
                    mipmap.data,
                  );
                }
              } else {
                console.warn(
                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                );
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(
                    _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                    j,
                    0,
                    0,
                    mipmap.width,
                    mipmap.height,
                    glFormat,
                    glType,
                    mipmap.data,
                  );
                }
              } else {
                state.texImage2D(
                  _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                  j,
                  glInternalFormat,
                  mipmap.width,
                  mipmap.height,
                  0,
                  glFormat,
                  glType,
                  mipmap.data,
                );
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0) levels++;
          const dimensions = getDimensions(cubeImage[0]);
          state.texStorage2D(
            _gl.TEXTURE_CUBE_MAP,
            levels,
            glInternalFormat,
            dimensions.width,
            dimensions.height,
          );
        }
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(
                  _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                  0,
                  0,
                  0,
                  cubeImage[i].width,
                  cubeImage[i].height,
                  glFormat,
                  glType,
                  cubeImage[i].data,
                );
              }
            } else {
              state.texImage2D(
                _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                0,
                glInternalFormat,
                cubeImage[i].width,
                cubeImage[i].height,
                0,
                glFormat,
                glType,
                cubeImage[i].data,
              );
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(
                    _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                    j + 1,
                    0,
                    0,
                    mipmapImage.width,
                    mipmapImage.height,
                    glFormat,
                    glType,
                    mipmapImage.data,
                  );
                }
              } else {
                state.texImage2D(
                  _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                  j + 1,
                  glInternalFormat,
                  mipmapImage.width,
                  mipmapImage.height,
                  0,
                  glFormat,
                  glType,
                  mipmapImage.data,
                );
              }
            }
          } else {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(
                  _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                  0,
                  0,
                  0,
                  glFormat,
                  glType,
                  cubeImage[i],
                );
              }
            } else {
              state.texImage2D(
                _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                0,
                glInternalFormat,
                glFormat,
                glType,
                cubeImage[i],
              );
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(
                    _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                    j + 1,
                    0,
                    0,
                    glFormat,
                    glType,
                    mipmap.image[i],
                  );
                }
              } else {
                state.texImage2D(
                  _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                  j + 1,
                  glInternalFormat,
                  glFormat,
                  glType,
                  mipmap.image[i],
                );
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(
    framebuffer,
    renderTarget,
    texture,
    attachment,
    textureTarget,
    level,
  ) {
    const glFormat = utils.convert(texture.format, texture.colorSpace);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(
      texture.internalFormat,
      glFormat,
      glType,
      texture.colorSpace,
    );
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (
        textureTarget === _gl.TEXTURE_3D ||
        textureTarget === _gl.TEXTURE_2D_ARRAY
      ) {
        state.texImage3D(
          textureTarget,
          level,
          glInternalFormat,
          width,
          height,
          renderTarget.depth,
          0,
          glFormat,
          glType,
          null,
        );
      } else {
        state.texImage2D(
          textureTarget,
          level,
          glInternalFormat,
          width,
          height,
          0,
          glFormat,
          glType,
          null,
        );
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(
        _gl.FRAMEBUFFER,
        attachment,
        textureTarget,
        properties.get(texture).__webglTexture,
        0,
        getRenderTargetSamples(renderTarget),
      );
    } else if (
      textureTarget === _gl.TEXTURE_2D ||
      (textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X &&
        textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z)
    ) {
      _gl.framebufferTexture2D(
        _gl.FRAMEBUFFER,
        attachment,
        textureTarget,
        properties.get(texture).__webglTexture,
        level,
      );
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat =
        isWebGL2 === true ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT16;
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(
            _gl.RENDERBUFFER,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          );
        } else {
          _gl.renderbufferStorageMultisample(
            _gl.RENDERBUFFER,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          );
        }
      } else {
        _gl.renderbufferStorage(
          _gl.RENDERBUFFER,
          glInternalFormat,
          renderTarget.width,
          renderTarget.height,
        );
      }
      _gl.framebufferRenderbuffer(
        _gl.FRAMEBUFFER,
        _gl.DEPTH_ATTACHMENT,
        _gl.RENDERBUFFER,
        renderbuffer,
      );
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(
          _gl.RENDERBUFFER,
          samples,
          _gl.DEPTH24_STENCIL8,
          renderTarget.width,
          renderTarget.height,
        );
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(
          _gl.RENDERBUFFER,
          samples,
          _gl.DEPTH24_STENCIL8,
          renderTarget.width,
          renderTarget.height,
        );
      } else {
        _gl.renderbufferStorage(
          _gl.RENDERBUFFER,
          _gl.DEPTH_STENCIL,
          renderTarget.width,
          renderTarget.height,
        );
      }
      _gl.framebufferRenderbuffer(
        _gl.FRAMEBUFFER,
        _gl.DEPTH_STENCIL_ATTACHMENT,
        _gl.RENDERBUFFER,
        renderbuffer,
      );
    } else {
      const textures = renderTarget.textures;
      for (let i = 0; i < textures.length; i++) {
        const texture = textures[i];
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(
          texture.internalFormat,
          glFormat,
          glType,
          texture.colorSpace,
        );
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(
            _gl.RENDERBUFFER,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          );
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(
            _gl.RENDERBUFFER,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          );
        } else {
          _gl.renderbufferStorage(
            _gl.RENDERBUFFER,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          );
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error(
        "Depth Texture with cube render targets is not supported",
      );
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (
      !(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)
    ) {
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture",
      );
    }
    if (
      !properties.get(renderTarget.depthTexture).__webglTexture ||
      renderTarget.depthTexture.image.width !== renderTarget.width ||
      renderTarget.depthTexture.image.height !== renderTarget.height
    ) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(
      renderTarget.depthTexture,
    ).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(
          _gl.FRAMEBUFFER,
          _gl.DEPTH_ATTACHMENT,
          _gl.TEXTURE_2D,
          webglDepthTexture,
          0,
          samples,
        );
      } else {
        _gl.framebufferTexture2D(
          _gl.FRAMEBUFFER,
          _gl.DEPTH_ATTACHMENT,
          _gl.TEXTURE_2D,
          webglDepthTexture,
          0,
        );
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(
          _gl.FRAMEBUFFER,
          _gl.DEPTH_STENCIL_ATTACHMENT,
          _gl.TEXTURE_2D,
          webglDepthTexture,
          0,
          samples,
        );
      } else {
        _gl.framebufferTexture2D(
          _gl.FRAMEBUFFER,
          _gl.DEPTH_STENCIL_ATTACHMENT,
          _gl.TEXTURE_2D,
          webglDepthTexture,
          0,
        );
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (
      renderTarget.depthTexture &&
      !renderTargetProperties.__autoAllocateDepthBuffer
    ) {
      if (isCube)
        throw new Error(
          "target.depthTexture not supported in Cube render targets",
        );
      setupDepthTexture(
        renderTargetProperties.__webglFramebuffer,
        renderTarget,
      );
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(
            _gl.FRAMEBUFFER,
            renderTargetProperties.__webglFramebuffer[i],
          );
          renderTargetProperties.__webglDepthbuffer[i] =
            _gl.createRenderbuffer();
          setupRenderBufferStorage(
            renderTargetProperties.__webglDepthbuffer[i],
            renderTarget,
            false,
          );
        }
      } else {
        state.bindFramebuffer(
          _gl.FRAMEBUFFER,
          renderTargetProperties.__webglFramebuffer,
        );
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(
          renderTargetProperties.__webglDepthbuffer,
          renderTarget,
          false,
        );
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(
        renderTargetProperties.__webglFramebuffer,
        renderTarget,
        renderTarget.texture,
        _gl.COLOR_ATTACHMENT0,
        _gl.TEXTURE_2D,
        0,
      );
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    const textures = renderTarget.textures;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = textures.length > 1;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (!isMultipleRenderTargets) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i] = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i][level] =
              _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i] =
            _gl.createFramebuffer();
        }
      }
    } else {
      if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0; level < texture.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] =
            _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          for (let i = 0, il = textures.length; i < il; i++) {
            const attachmentProperties = properties.get(textures[i]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.",
          );
        }
      }
      if (
        isWebGL2 &&
        renderTarget.samples > 0 &&
        useMultisampledRTT(renderTarget) === false
      ) {
        renderTargetProperties.__webglMultisampledFramebuffer =
          _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(
          _gl.FRAMEBUFFER,
          renderTargetProperties.__webglMultisampledFramebuffer,
        );
        for (let i = 0; i < textures.length; i++) {
          const texture2 = textures[i];
          renderTargetProperties.__webglColorRenderbuffer[i] =
            _gl.createRenderbuffer();
          _gl.bindRenderbuffer(
            _gl.RENDERBUFFER,
            renderTargetProperties.__webglColorRenderbuffer[i],
          );
          const glFormat = utils.convert(texture2.format, texture2.colorSpace);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(
            texture2.internalFormat,
            glFormat,
            glType,
            texture2.colorSpace,
            renderTarget.isXRRenderTarget === true,
          );
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(
            _gl.RENDERBUFFER,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          );
          _gl.framebufferRenderbuffer(
            _gl.FRAMEBUFFER,
            _gl.COLOR_ATTACHMENT0 + i,
            _gl.RENDERBUFFER,
            renderTargetProperties.__webglColorRenderbuffer[i],
          );
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer =
            _gl.createRenderbuffer();
          setupRenderBufferStorage(
            renderTargetProperties.__webglDepthRenderbuffer,
            renderTarget,
            true,
          );
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
      for (let i = 0; i < 6; i++) {
        if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(
              renderTargetProperties.__webglFramebuffer[i][level],
              renderTarget,
              texture,
              _gl.COLOR_ATTACHMENT0,
              _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
              level,
            );
          }
        } else {
          setupFrameBufferTexture(
            renderTargetProperties.__webglFramebuffer[i],
            renderTarget,
            texture,
            _gl.COLOR_ATTACHMENT0,
            _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
            0,
          );
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      for (let i = 0, il = textures.length; i < il; i++) {
        const attachment = textures[i];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
        setupFrameBufferTexture(
          renderTargetProperties.__webglFramebuffer,
          renderTarget,
          attachment,
          _gl.COLOR_ATTACHMENT0 + i,
          _gl.TEXTURE_2D,
          0,
        );
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (
        renderTarget.isWebGL3DRenderTarget ||
        renderTarget.isWebGLArrayRenderTarget
      ) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget
            ? _gl.TEXTURE_3D
            : _gl.TEXTURE_2D_ARRAY;
        } else {
          console.error(
            "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.",
          );
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
        for (let level = 0; level < texture.mipmaps.length; level++) {
          setupFrameBufferTexture(
            renderTargetProperties.__webglFramebuffer[level],
            renderTarget,
            texture,
            _gl.COLOR_ATTACHMENT0,
            glTextureType,
            level,
          );
        }
      } else {
        setupFrameBufferTexture(
          renderTargetProperties.__webglFramebuffer,
          renderTarget,
          texture,
          _gl.COLOR_ATTACHMENT0,
          glTextureType,
          0,
        );
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.textures;
    for (let i = 0, il = textures.length; i < il; i++) {
      const texture = textures[i];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget
          ? _gl.TEXTURE_CUBE_MAP
          : _gl.TEXTURE_2D;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (
      isWebGL2 &&
      renderTarget.samples > 0 &&
      useMultisampledRTT(renderTarget) === false
    ) {
      const textures = renderTarget.textures;
      const width = renderTarget.width;
      const height = renderTarget.height;
      let mask = _gl.COLOR_BUFFER_BIT;
      const invalidationArray = [];
      const depthStyle = renderTarget.stencilBuffer
        ? _gl.DEPTH_STENCIL_ATTACHMENT
        : _gl.DEPTH_ATTACHMENT;
      const renderTargetProperties = properties.get(renderTarget);
      const isMultipleRenderTargets = textures.length > 1;
      if (isMultipleRenderTargets) {
        for (let i = 0; i < textures.length; i++) {
          state.bindFramebuffer(
            _gl.FRAMEBUFFER,
            renderTargetProperties.__webglMultisampledFramebuffer,
          );
          _gl.framebufferRenderbuffer(
            _gl.FRAMEBUFFER,
            _gl.COLOR_ATTACHMENT0 + i,
            _gl.RENDERBUFFER,
            null,
          );
          state.bindFramebuffer(
            _gl.FRAMEBUFFER,
            renderTargetProperties.__webglFramebuffer,
          );
          _gl.framebufferTexture2D(
            _gl.DRAW_FRAMEBUFFER,
            _gl.COLOR_ATTACHMENT0 + i,
            _gl.TEXTURE_2D,
            null,
            0,
          );
        }
      }
      state.bindFramebuffer(
        _gl.READ_FRAMEBUFFER,
        renderTargetProperties.__webglMultisampledFramebuffer,
      );
      state.bindFramebuffer(
        _gl.DRAW_FRAMEBUFFER,
        renderTargetProperties.__webglFramebuffer,
      );
      for (let i = 0; i < textures.length; i++) {
        invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i);
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle);
        }
        const ignoreDepthValues =
          renderTargetProperties.__ignoreDepthValues !== void 0
            ? renderTargetProperties.__ignoreDepthValues
            : false;
        if (ignoreDepthValues === false) {
          if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
          if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
        }
        if (isMultipleRenderTargets) {
          _gl.framebufferRenderbuffer(
            _gl.READ_FRAMEBUFFER,
            _gl.COLOR_ATTACHMENT0,
            _gl.RENDERBUFFER,
            renderTargetProperties.__webglColorRenderbuffer[i],
          );
        }
        if (ignoreDepthValues === true) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
        if (isMultipleRenderTargets) {
          const webglTexture = properties.get(textures[i]).__webglTexture;
          _gl.framebufferTexture2D(
            _gl.DRAW_FRAMEBUFFER,
            _gl.COLOR_ATTACHMENT0,
            _gl.TEXTURE_2D,
            webglTexture,
            0,
          );
        }
        _gl.blitFramebuffer(
          0,
          0,
          width,
          height,
          0,
          0,
          width,
          height,
          mask,
          _gl.NEAREST,
        );
        if (supportsInvalidateFramebuffer) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
        }
      }
      state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      if (isMultipleRenderTargets) {
        for (let i = 0; i < textures.length; i++) {
          state.bindFramebuffer(
            _gl.FRAMEBUFFER,
            renderTargetProperties.__webglMultisampledFramebuffer,
          );
          _gl.framebufferRenderbuffer(
            _gl.FRAMEBUFFER,
            _gl.COLOR_ATTACHMENT0 + i,
            _gl.RENDERBUFFER,
            renderTargetProperties.__webglColorRenderbuffer[i],
          );
          const webglTexture = properties.get(textures[i]).__webglTexture;
          state.bindFramebuffer(
            _gl.FRAMEBUFFER,
            renderTargetProperties.__webglFramebuffer,
          );
          _gl.framebufferTexture2D(
            _gl.DRAW_FRAMEBUFFER,
            _gl.COLOR_ATTACHMENT0 + i,
            _gl.TEXTURE_2D,
            webglTexture,
            0,
          );
        }
      }
      state.bindFramebuffer(
        _gl.DRAW_FRAMEBUFFER,
        renderTargetProperties.__webglMultisampledFramebuffer,
      );
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(capabilities.maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return (
      isWebGL2 &&
      renderTarget.samples > 0 &&
      extensions.has("WEBGL_multisampled_render_to_texture") === true &&
      renderTargetProperties.__useRenderToTexture !== false
    );
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (
      texture.isCompressedTexture === true ||
      texture.isVideoTexture === true ||
      texture.format === _SRGBAFormat
    )
      return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
        if (isWebGL2 === false) {
          if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
            texture.format = _SRGBAFormat;
            texture.minFilter = LinearFilter;
            texture.generateMipmaps = false;
          } else {
            image = ImageUtils.sRGBToLinear(image);
          }
        } else {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn(
              "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.",
            );
          }
        }
      } else {
        console.error(
          "THREE.WebGLTextures: Unsupported texture color space:",
          colorSpace,
        );
      }
    }
    return image;
  }
  function getDimensions(image) {
    if (
      typeof HTMLImageElement !== "undefined" &&
      image instanceof HTMLImageElement
    ) {
      _imageDimensions.width = image.naturalWidth || image.width;
      _imageDimensions.height = image.naturalHeight || image.height;
    } else if (
      typeof VideoFrame !== "undefined" &&
      image instanceof VideoFrame
    ) {
      _imageDimensions.width = image.displayWidth;
      _imageDimensions.height = image.displayHeight;
    } else {
      _imageDimensions.width = image.width;
      _imageDimensions.height = image.height;
    }
    return _imageDimensions;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p, colorSpace = NoColorSpace) {
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === ByteType) return gl.BYTE;
    if (p === ShortType) return gl.SHORT;
    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p === IntType) return gl.INT;
    if (p === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p === FloatType) return gl.FLOAT;
    if (p === HalfFloatType) {
      if (isWebGL2) return gl.HALF_FLOAT;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat) return gl.ALPHA;
    if (p === RGBAFormat) return gl.RGBA;
    if (p === LuminanceFormat) return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p === _SRGBAFormat) {
      extension = extensions.get("EXT_sRGB");
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    }
    if (p === RedFormat) return gl.RED;
    if (p === RedIntegerFormat) return gl.RED_INTEGER;
    if (p === RGFormat) return gl.RG;
    if (p === RGIntegerFormat) return gl.RG_INTEGER;
    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (
      p === RGB_S3TC_DXT1_Format ||
      p === RGBA_S3TC_DXT1_Format ||
      p === RGBA_S3TC_DXT3_Format ||
      p === RGBA_S3TC_DXT5_Format
    ) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (
      p === RGB_PVRTC_4BPPV1_Format ||
      p === RGB_PVRTC_2BPPV1_Format ||
      p === RGBA_PVRTC_4BPPV1_Format ||
      p === RGBA_PVRTC_2BPPV1_Format
    ) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ETC2
            : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (
      p === RGBA_ASTC_4x4_Format ||
      p === RGBA_ASTC_5x4_Format ||
      p === RGBA_ASTC_5x5_Format ||
      p === RGBA_ASTC_6x5_Format ||
      p === RGBA_ASTC_6x6_Format ||
      p === RGBA_ASTC_8x5_Format ||
      p === RGBA_ASTC_8x6_Format ||
      p === RGBA_ASTC_8x8_Format ||
      p === RGBA_ASTC_10x5_Format ||
      p === RGBA_ASTC_10x6_Format ||
      p === RGBA_ASTC_10x8_Format ||
      p === RGBA_ASTC_10x10_Format ||
      p === RGBA_ASTC_12x10_Format ||
      p === RGBA_ASTC_12x12_Format
    ) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (
      p === RGBA_BPTC_Format ||
      p === RGB_BPTC_SIGNED_Format ||
      p === RGB_BPTC_UNSIGNED_Format
    ) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format)
          return transfer === SRGBTransfer
            ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p === RGB_BPTC_SIGNED_Format)
          return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p === RGB_BPTC_UNSIGNED_Format)
          return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (
      p === RED_RGTC1_Format ||
      p === SIGNED_RED_RGTC1_Format ||
      p === RED_GREEN_RGTC2_Format ||
      p === SIGNED_RED_GREEN_RGTC2_Format
    ) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p === SIGNED_RED_RGTC1_Format)
          return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p === RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p === SIGNED_RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2) return gl.UNSIGNED_INT_24_8;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
    return gl[p] !== void 0 ? gl[p] : null;
  }
  return { convert };
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
}
class Group extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
}
const _moveEvent = { type: "move" };
class WebXRController {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3$1();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3$1();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3$1();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3$1();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (
          hand.inputState.pinching &&
          distance > distanceToPinch + threshold
        ) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this,
          });
        } else if (
          !hand.inputState.pinching &&
          distance <= distanceToPinch - threshold
        ) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this,
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(
            targetRay.position,
            targetRay.rotation,
            targetRay.scale,
          );
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  // private method
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
}
const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class WebXRDepthSensing {
  constructor() {
    this.texture = null;
    this.mesh = null;
    this.depthNear = 0;
    this.depthFar = 0;
  }
  init(renderer, depthData, renderState) {
    if (this.texture === null) {
      const texture = new Texture();
      const texProps = renderer.properties.get(texture);
      texProps.__webglTexture = depthData.texture;
      if (
        depthData.depthNear != renderState.depthNear ||
        depthData.depthFar != renderState.depthFar
      ) {
        this.depthNear = depthData.depthNear;
        this.depthFar = depthData.depthFar;
      }
      this.texture = texture;
    }
  }
  render(renderer, cameraXR) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const viewport = cameraXR.cameras[0].viewport;
        const material = new ShaderMaterial({
          extensions: { fragDepth: true },
          vertexShader: _occlusion_vertex,
          fragmentShader: _occlusion_fragment,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: viewport.z },
            depthHeight: { value: viewport.w },
          },
        });
        this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
      }
      renderer.render(this.mesh, cameraXR);
    }
  }
  reset() {
    this.texture = null;
    this.mesh = null;
  }
}
class WebXRManager extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const depthSensing = new WebXRDepthSensing();
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const currentSize = new Vector2();
    let currentPixelRatio = null;
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera();
    cameraXR.layers.enable(1);
    cameraXR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function (index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function (index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function (index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.update(
          event.inputSource,
          event.frame,
          customReferenceSpace || referenceSpace,
        );
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        if (inputSource === null) continue;
        controllerInputSources[i] = null;
        controllers[i].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      depthSensing.reset();
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      renderer.setPixelRatio(currentPixelRatio);
      renderer.setSize(currentSize.width, currentSize.height, false);
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function (value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn(
          "THREE.WebXRManager: Cannot change framebuffer scale while presenting.",
        );
      }
    };
    this.setReferenceSpaceType = function (value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn(
          "THREE.WebXRManager: Cannot change reference space type while presenting.",
        );
      }
    };
    this.getReferenceSpace = function () {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function (space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function () {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function () {
      return glBinding;
    };
    this.getFrame = function () {
      return xrFrame;
    };
    this.getSession = function () {
      return session;
    };
    this.setSession = async function (value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        currentPixelRatio = renderer.getPixelRatio();
        renderer.getSize(currentSize);
        if (
          session.renderState.layers === void 0 ||
          renderer.capabilities.isWebGL2 === false
        ) {
          const layerInit = {
            antialias:
              session.renderState.layers === void 0
                ? attributes.antialias
                : true,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor,
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          renderer.setPixelRatio(1);
          renderer.setSize(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            false,
          );
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              colorSpace: renderer.outputColorSpace,
              stencilBuffer: attributes.stencil,
            },
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil
              ? gl.DEPTH24_STENCIL8
              : gl.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil
              ? UnsignedInt248Type
              : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor,
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          renderer.setPixelRatio(1);
          renderer.setSize(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            false,
          );
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(
                glProjLayer.textureWidth,
                glProjLayer.textureHeight,
                depthType,
                void 0,
                void 0,
                void 0,
                void 0,
                void 0,
                void 0,
                depthFormat,
              ),
              stencilBuffer: attributes.stencil,
              colorSpace: renderer.outputColorSpace,
              samples: attributes.antialias ? 4 : 0,
            },
          );
          const renderTargetProperties =
            renderer.properties.get(newRenderTarget);
          renderTargetProperties.__ignoreDepthValues =
            glProjLayer.ignoreDepthValues;
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace =
          await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function () {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    function onInputSourcesChange(event) {
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].disconnect(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i2 = 0; i2 < controllers.length; i2++) {
            if (i2 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i2;
              break;
            } else if (controllerInputSources[i2] === null) {
              controllerInputSources[i2] = inputSource;
              controllerIndex = i2;
              break;
            }
          }
          if (controllerIndex === -1) break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector3$1();
    const cameraRPos = new Vector3$1();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(
        camera.position,
        camera.quaternion,
        camera.scale,
      );
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(
        camera.position,
        camera.quaternion,
        camera.scale,
      );
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = ((topFov * far) / far2) * near2;
      const bottom2 = ((bottomFov * far) / far2) * near2;
      camera.projectionMatrix.makePerspective(
        left2,
        right2,
        top2,
        bottom2,
        near2,
        far2,
      );
      camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function (camera) {
      if (session === null) return;
      if (depthSensing.texture !== null) {
        camera.near = depthSensing.depthNear;
        camera.far = depthSensing.depthFar;
      }
      cameraXR.near = cameraR.near = cameraL.near = camera.near;
      cameraXR.far = cameraR.far = cameraL.far = camera.far;
      if (
        _currentDepthNear !== cameraXR.near ||
        _currentDepthFar !== cameraXR.far
      ) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far,
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
        cameraL.near = _currentDepthNear;
        cameraL.far = _currentDepthFar;
        cameraR.near = _currentDepthNear;
        cameraR.far = _currentDepthFar;
        cameraL.updateProjectionMatrix();
        cameraR.updateProjectionMatrix();
        camera.updateProjectionMatrix();
      }
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR2, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov =
          RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getCamera = function () {
      return cameraXR;
    };
    this.getFoveation = function () {
      if (glProjLayer === null && glBaseLayer === null) {
        return void 0;
      }
      return foveation;
    };
    this.setFoveation = function (value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    this.hasDepthSensing = function () {
      return depthSensing.texture !== null;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(
            newRenderTarget,
            glBaseLayer.framebuffer,
          );
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues
                  ? void 0
                  : glSubImage.depthStencilTexture,
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i);
            camera.viewport = new Vector4();
            cameras[i] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(
            camera.position,
            camera.quaternion,
            camera.scale,
          );
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(
            viewport.x,
            viewport.y,
            viewport.width,
            viewport.height,
          );
          if (i === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(
              cameraXR.position,
              cameraXR.quaternion,
              cameraXR.scale,
            );
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
        const enabledFeatures = session.enabledFeatures;
        if (enabledFeatures && enabledFeatures.includes("depth-sensing")) {
          const depthData = glBinding.getDepthInformation(views[0]);
          if (depthData && depthData.isValid && depthData.texture) {
            depthSensing.init(renderer, depthData, session.renderState);
          }
        }
      }
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        const controller = controllers[i];
        if (inputSource !== null && controller !== void 0) {
          controller.update(
            inputSource,
            frame,
            customReferenceSpace || referenceSpace,
          );
        }
      }
      depthSensing.render(renderer, cameraXR);
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function () {};
  }
}
const _e1 = /* @__PURE__ */ new Euler$1();
const _m1 = /* @__PURE__ */ new Matrix4();
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map, uniform) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(
      uniforms.fogColor.value,
      getUnlitUniformColorSpace(renderer),
    );
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(
    uniforms,
    material,
    pixelRatio,
    height,
    transmissionRenderTarget,
  ) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value
        .copy(material.emissive)
        .multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(
        material.displacementMap,
        uniforms.displacementMapTransform,
      );
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(
        material.emissiveMap,
        uniforms.emissiveMapTransform,
      );
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(
        material.specularMap,
        uniforms.specularMapTransform,
      );
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const materialProperties = properties.get(material);
    const envMap = materialProperties.envMap;
    const envMapRotation = materialProperties.envMapRotation;
    if (envMap) {
      uniforms.envMap.value = envMap;
      _e1.copy(envMapRotation);
      _e1.x *= -1;
      _e1.y *= -1;
      _e1.z *= -1;
      if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
        _e1.y *= -1;
        _e1.z *= -1;
      }
      uniforms.envMapRotation.value.setFromMatrix4(
        _m1.makeRotationFromEuler(_e1),
      );
      uniforms.flipEnvMap.value =
        envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      const scaleFactor = renderer._useLegacyLights === true ? Math.PI : 1;
      uniforms.lightMapIntensity.value =
        material.lightMapIntensity * scaleFactor;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(
        material.metalnessMap,
        uniforms.metalnessMapTransform,
      );
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(
        material.roughnessMap,
        uniforms.roughnessMapTransform,
      );
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(
    uniforms,
    material,
    transmissionRenderTarget,
  ) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value
        .copy(material.sheenColor)
        .multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(
          material.sheenColorMap,
          uniforms.sheenColorMapTransform,
        );
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(
          material.sheenRoughnessMap,
          uniforms.sheenRoughnessMapTransform,
        );
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(
          material.clearcoatMap,
          uniforms.clearcoatMapTransform,
        );
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(
          material.clearcoatRoughnessMap,
          uniforms.clearcoatRoughnessMapTransform,
        );
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(
          material.clearcoatNormalMap,
          uniforms.clearcoatNormalMapTransform,
        );
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value =
        material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value =
        material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(
          material.iridescenceMap,
          uniforms.iridescenceMapTransform,
        );
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value =
          material.iridescenceThicknessMap;
        refreshTransformUniform(
          material.iridescenceThicknessMap,
          uniforms.iridescenceThicknessMapTransform,
        );
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(
        transmissionRenderTarget.width,
        transmissionRenderTarget.height,
      );
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(
          material.transmissionMap,
          uniforms.transmissionMapTransform,
        );
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(
          material.thicknessMap,
          uniforms.thicknessMapTransform,
        );
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(
        material.anisotropy * Math.cos(material.anisotropyRotation),
        material.anisotropy * Math.sin(material.anisotropyRotation),
      );
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(
          material.anisotropyMap,
          uniforms.anisotropyMapTransform,
        );
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(
        material.specularColorMap,
        uniforms.specularColorMapTransform,
      );
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(
        material.specularIntensityMap,
        uniforms.specularIntensityMapTransform,
      );
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms,
  };
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = capabilities.isWebGL2
    ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS)
    : 0;
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update2(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i = 0; i < maxBindingPoints; i++) {
      if (allocatedBindingPoints.indexOf(i) === -1) {
        allocatedBindingPoints.push(i);
        return i;
      }
    }
    console.error(
      "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.",
    );
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (let i = 0, il = uniforms.length; i < il; i++) {
      const uniformArray = Array.isArray(uniforms[i])
        ? uniforms[i]
        : [uniforms[i]];
      for (let j = 0, jl = uniformArray.length; j < jl; j++) {
        const uniform = uniformArray[j];
        if (hasUniformChanged(uniform, i, j, cache) === true) {
          const offset = uniform.__offset;
          const values = Array.isArray(uniform.value)
            ? uniform.value
            : [uniform.value];
          let arrayOffset = 0;
          for (let k = 0; k < values.length; k++) {
            const value = values[k];
            const info2 = getUniformSize(value);
            if (typeof value === "number" || typeof value === "boolean") {
              uniform.__data[0] = value;
              gl.bufferSubData(
                gl.UNIFORM_BUFFER,
                offset + arrayOffset,
                uniform.__data,
              );
            } else if (value.isMatrix3) {
              uniform.__data[0] = value.elements[0];
              uniform.__data[1] = value.elements[1];
              uniform.__data[2] = value.elements[2];
              uniform.__data[3] = 0;
              uniform.__data[4] = value.elements[3];
              uniform.__data[5] = value.elements[4];
              uniform.__data[6] = value.elements[5];
              uniform.__data[7] = 0;
              uniform.__data[8] = value.elements[6];
              uniform.__data[9] = value.elements[7];
              uniform.__data[10] = value.elements[8];
              uniform.__data[11] = 0;
            } else {
              value.toArray(uniform.__data, arrayOffset);
              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
        }
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index, indexArray, cache) {
    const value = uniform.value;
    const indexString = index + "_" + indexArray;
    if (cache[indexString] === void 0) {
      if (typeof value === "number" || typeof value === "boolean") {
        cache[indexString] = value;
      } else {
        cache[indexString] = value.clone();
      }
      return true;
    } else {
      const cachedObject = cache[indexString];
      if (typeof value === "number" || typeof value === "boolean") {
        if (cachedObject !== value) {
          cache[indexString] = value;
          return true;
        }
      } else {
        if (cachedObject.equals(value) === false) {
          cachedObject.copy(value);
          return true;
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    for (let i = 0, l = uniforms.length; i < l; i++) {
      const uniformArray = Array.isArray(uniforms[i])
        ? uniforms[i]
        : [uniforms[i]];
      for (let j = 0, jl = uniformArray.length; j < jl; j++) {
        const uniform = uniformArray[j];
        const values = Array.isArray(uniform.value)
          ? uniform.value
          : [uniform.value];
        for (let k = 0, kl = values.length; k < kl; k++) {
          const value = values[k];
          const info2 = getUniformSize(value);
          const chunkOffsetUniform = offset % chunkSize;
          if (
            chunkOffsetUniform !== 0 &&
            chunkSize - chunkOffsetUniform < info2.boundary
          ) {
            offset += chunkSize - chunkOffsetUniform;
          }
          uniform.__data = new Float32Array(
            info2.storage / Float32Array.BYTES_PER_ELEMENT,
          );
          uniform.__offset = offset;
          offset += info2.storage;
        }
      }
    }
    const chunkOffset = offset % chunkSize;
    if (chunkOffset > 0) offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0,
      // bytes
    };
    if (typeof value === "number" || typeof value === "boolean") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn(
        "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.",
      );
    } else {
      console.warn(
        "THREE.WebGLRenderer: Unsupported uniform value type.",
        value,
      );
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(
      uniformsGroup.__bindingPointIndex,
    );
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update: update2,
    dispose,
  };
}
class WebGLRenderer {
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context = null,
      depth = true,
      stencil = true,
      alpha = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false,
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context !== null) {
      _alpha = context.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = canvas;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null,
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this._outputColorSpace = SRGBColorSpace;
    this._useLegacyLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    const _currentClearColor = new Color(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum2 = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix2 = new Matrix4();
    const _vector22 = new Vector2();
    const _vector32 = new Vector3$1();
    const _emptyScene = {
      background: null,
      fog: null,
      environment: null,
      overrideMaterial: null,
      isScene: true,
    };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context;
    function getContext2(contextNames, contextAttributes) {
      for (let i = 0; i < contextNames.length; i++) {
        const contextName2 = contextNames[i];
        const context2 = canvas.getContext(contextName2, contextAttributes);
        if (context2 !== null) return context2;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat,
      };
      if ("setAttribute" in canvas)
        canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener(
        "webglcontextcreationerror",
        onContextCreationError,
        false,
      );
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext2(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext2(contextNames)) {
            throw new Error(
              "Error creating WebGL context with your selected attributes.",
            );
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (
        typeof WebGLRenderingContext !== "undefined" &&
        _gl instanceof WebGLRenderingContext
      ) {
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.",
        );
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info;
    let properties,
      textures,
      cubemaps,
      cubeuvmaps,
      attributes,
      geometries,
      objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities);
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state = new WebGLState(_gl, extensions, capabilities);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(
        _gl,
        extensions,
        state,
        properties,
        capabilities,
        utils,
        info,
      );
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(
        _gl,
        extensions,
        attributes,
        capabilities,
      );
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(
        _this,
        cubemaps,
        cubeuvmaps,
        extensions,
        capabilities,
        bindingStates,
        clipping,
      );
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(
        _this,
        cubemaps,
        cubeuvmaps,
        state,
        objects,
        _alpha,
        premultipliedAlpha,
      );
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(
        _gl,
        extensions,
        info,
        capabilities,
      );
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(
        _gl,
        extensions,
        info,
        capabilities,
      );
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function () {
      return _gl;
    };
    this.getContextAttributes = function () {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function () {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.loseContext();
    };
    this.forceContextRestore = function () {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function () {
      return _pixelRatio;
    };
    this.setPixelRatio = function (value) {
      if (value === void 0) return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function (target) {
      return target.set(_width, _height);
    };
    this.setSize = function (width, height, updateStyle = true) {
      if (xr.isPresenting) {
        console.warn(
          "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
        );
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function (target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function (width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function (target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function (target) {
      return target.copy(_viewport);
    };
    this.setViewport = function (x, y2, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y2, width, height);
      }
      state.viewport(
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round(),
      );
    };
    this.getScissor = function (target) {
      return target.copy(_scissor);
    };
    this.setScissor = function (x, y2, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y2, width, height);
      }
      state.scissor(
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round(),
      );
    };
    this.getScissorTest = function () {
      return _scissorTest;
    };
    this.setScissorTest = function (boolean) {
      state.setScissorTest((_scissorTest = boolean));
    };
    this.setOpaqueSort = function (method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function (method) {
      _transparentSort = method;
    };
    this.getClearColor = function (target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function () {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function () {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function () {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function (color = true, depth2 = true, stencil2 = true) {
      let bits = 0;
      if (color) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat =
            targetFormat === RGBAIntegerFormat ||
            targetFormat === RGIntegerFormat ||
            targetFormat === RedIntegerFormat;
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType =
            targetType === UnsignedByteType ||
            targetType === UnsignedIntType ||
            targetType === UnsignedShortType ||
            targetType === UnsignedInt248Type ||
            targetType === UnsignedShort4444Type ||
            targetType === UnsignedShort5551Type;
          const clearColor = background.getClearColor();
          const a = background.getClearAlpha();
          const r = clearColor.r;
          const g = clearColor.g;
          const b = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r;
            uintClearColor[1] = g;
            uintClearColor[2] = b;
            uintClearColor[3] = a;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r;
            intClearColor[1] = g;
            intClearColor[2] = b;
            intClearColor[3] = a;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2) bits |= _gl.DEPTH_BUFFER_BIT;
      if (stencil2) {
        bits |= _gl.STENCIL_BUFFER_BIT;
        this.state.buffers.stencil.setMask(4294967295);
      }
      _gl.clear(bits);
    };
    this.clearColor = function () {
      this.clear(true, false, false);
    };
    this.clearDepth = function () {
      this.clear(false, true, false);
    };
    this.clearStencil = function () {
      this.clear(false, false, true);
    };
    this.dispose = function () {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener(
        "webglcontextrestored",
        onContextRestore,
        false,
      );
      canvas.removeEventListener(
        "webglcontextcreationerror",
        onContextCreationError,
        false,
      );
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        event.statusMessage,
      );
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function (program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function (
      camera,
      scene,
      geometry,
      material,
      object,
      group,
    ) {
      if (scene === null) scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        if (index === void 0) return;
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== void 0 && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity) return;
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(
            material.wireframeLinewidth * getTargetPixelRatio(),
          );
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0) lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isBatchedMesh) {
        renderer.renderMultiDraw(
          object._multiDrawStarts,
          object._multiDrawCounts,
          object._multiDrawCount,
        );
      } else if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount =
          geometry._maxInstanceCount !== void 0
            ? geometry._maxInstanceCount
            : Infinity;
        const instanceCount = Math.min(
          geometry.instanceCount,
          maxInstanceCount,
        );
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    function prepareMaterial(material, scene, object) {
      if (
        material.transparent === true &&
        material.side === DoubleSide &&
        material.forceSinglePass === false
      ) {
        material.side = BackSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = FrontSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = DoubleSide;
      } else {
        getProgram(material, scene, object);
      }
    }
    this.compile = function (scene, camera, targetScene = null) {
      if (targetScene === null) targetScene = scene;
      currentRenderState = renderStates.get(targetScene);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      targetScene.traverseVisible(function (object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      if (scene !== targetScene) {
        scene.traverseVisible(function (object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
      }
      currentRenderState.setupLights(_this._useLegacyLights);
      const materials2 = /* @__PURE__ */ new Set();
      scene.traverse(function (object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              prepareMaterial(material2, targetScene, object);
              materials2.add(material2);
            }
          } else {
            prepareMaterial(material, targetScene, object);
            materials2.add(material);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
      return materials2;
    };
    this.compileAsync = function (scene, camera, targetScene = null) {
      const materials2 = this.compile(scene, camera, targetScene);
      return new Promise((resolve) => {
        function checkMaterialsReady() {
          materials2.forEach(function (material) {
            const materialProperties = properties.get(material);
            const program = materialProperties.currentProgram;
            if (program.isReady()) {
              materials2.delete(material);
            }
          });
          if (materials2.size === 0) {
            resolve(scene);
            return;
          }
          setTimeout(checkMaterialsReady, 10);
        }
        if (extensions.get("KHR_parallel_shader_compile") !== null) {
          checkMaterialsReady();
        } else {
          setTimeout(checkMaterialsReady, 10);
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined") animation.setContext(self);
    this.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function (scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error(
          "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.",
        );
        return;
      }
      if (_isContextLost === true) return;
      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
        camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true)
        scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(
        camera.projectionMatrix,
        camera.matrixWorldInverse,
      );
      _frustum2.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(
        this.clippingPlanes,
        _localClippingEnabled,
      );
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      this.info.render.frame++;
      if (_clippingEnabled === true) clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true) clipping.endShadows();
      if (this.info.autoReset === true) this.info.reset();
      if (
        xr.enabled === false ||
        xr.isPresenting === false ||
        xr.hasDepthSensing() === false
      ) {
        background.render(currentRenderList, scene);
      }
      currentRenderState.setupLights(_this._useLegacyLights);
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let i = 0, l = cameras.length; i < l; i++) {
          const camera2 = cameras[i];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false) return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true) object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum2.intersectsSprite(object)) {
            if (sortObjects) {
              _vector32
                .setFromMatrixPosition(object.matrixWorld)
                .applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(
                object,
                geometry,
                material,
                groupOrder,
                _vector32.z,
                null,
              );
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum2.intersectsObject(object)) {
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== void 0) {
                if (object.boundingSphere === null)
                  object.computeBoundingSphere();
                _vector32.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null)
                  geometry.computeBoundingSphere();
                _vector32.copy(geometry.boundingSphere.center);
              }
              _vector32
                .applyMatrix4(object.matrixWorld)
                .applyMatrix4(_projScreenMatrix2);
            }
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(
                    object,
                    geometry,
                    groupMaterial,
                    groupOrder,
                    _vector32.z,
                    group,
                  );
                }
              }
            } else if (material.visible) {
              currentRenderList.push(
                object,
                geometry,
                material,
                groupOrder,
                _vector32.z,
                null,
              );
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true)
        clipping.setGlobalState(_this.clippingPlanes, camera);
      if (transmissiveObjects.length > 0)
        renderTransmissionPass(
          opaqueObjects,
          transmissiveObjects,
          scene,
          camera,
        );
      if (viewport) state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0)
        renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(
      opaqueObjects,
      transmissiveObjects,
      scene,
      camera,
    ) {
      const overrideMaterial =
        scene.isScene === true ? scene.overrideMaterial : null;
      if (overrideMaterial !== null) {
        return;
      }
      const isWebGL2 = capabilities.isWebGL2;
      if (_transmissionRenderTarget === null) {
        _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float")
            ? HalfFloatType
            : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: isWebGL2 ? 4 : 0,
        });
      }
      _this.getDrawingBufferSize(_vector22);
      if (isWebGL2) {
        _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
      } else {
        _transmissionRenderTarget.setSize(
          floorPowerOfTwo(_vector22.x),
          floorPowerOfTwo(_vector22.y),
        );
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      let renderTargetNeedsUpdate = false;
      for (let i = 0, l = transmissiveObjects.length; i < l; i++) {
        const renderItem = transmissiveObjects[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = renderItem.material;
        const group = renderItem.group;
        if (material.side === DoubleSide && object.layers.test(camera.layers)) {
          const currentSide = material.side;
          material.side = BackSide;
          material.needsUpdate = true;
          renderObject(object, scene, camera, geometry, material, group);
          material.side = currentSide;
          material.needsUpdate = true;
          renderTargetNeedsUpdate = true;
        }
      }
      if (renderTargetNeedsUpdate === true) {
        textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
        textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial =
        scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l = renderList.length; i < l; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material =
          overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(
        camera.matrixWorldInverse,
        object.matrixWorld,
      );
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (
        material.transparent === true &&
        material.side === DoubleSide &&
        material.forceSinglePass === false
      ) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(
          camera,
          scene,
          geometry,
          material,
          object,
          group,
        );
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(
          camera,
          scene,
          geometry,
          material,
          object,
          group,
        );
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(
          camera,
          scene,
          geometry,
          material,
          object,
          group,
        );
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(
        material,
        lights.state,
        shadowsArray,
        scene,
        object,
      );
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial
        ? scene.environment
        : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (
        material.isMeshStandardMaterial ? cubeuvmaps : cubemaps
      ).get(material.envMap || materialProperties.environment);
      materialProperties.envMapRotation =
        materialProperties.environment !== null && material.envMap === null
          ? scene.environmentRotation
          : material.envMapRotation;
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (
          materialProperties.currentProgram === program &&
          materialProperties.lightsStateVersion === lightsStateVersion
        ) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(object, parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (
        (!material.isShaderMaterial && !material.isRawShaderMaterial) ||
        material.clipping === true
      ) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value =
          lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = null;
      return program;
    }
    function getUniformList(materialProperties) {
      if (materialProperties.uniformsList === null) {
        const progUniforms = materialProperties.currentProgram.getUniforms();
        materialProperties.uniformsList = WebGLUniforms.seqWithValue(
          progUniforms.seq,
          materialProperties.uniforms,
        );
      }
      return materialProperties.uniformsList;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.batching = parameters2.batching;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.instancingColor = parameters2.instancingColor;
      materialProperties.instancingMorph = parameters2.instancingMorph;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial
        ? scene.environment
        : null;
      const colorSpace =
        _currentRenderTarget === null
          ? _this.outputColorSpace
          : _currentRenderTarget.isXRRenderTarget === true
            ? _currentRenderTarget.texture.colorSpace
            : LinearSRGBColorSpace;
      const envMap = (
        material.isMeshStandardMaterial ? cubeuvmaps : cubemaps
      ).get(material.envMap || environment);
      const vertexAlphas =
        material.vertexColors === true &&
        !!geometry.attributes.color &&
        geometry.attributes.color.itemSize === 4;
      const vertexTangents =
        !!geometry.attributes.tangent &&
        (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (
          _currentRenderTarget === null ||
          _currentRenderTarget.isXRRenderTarget === true
        ) {
          toneMapping = _this.toneMapping;
        }
      }
      const morphAttribute =
        geometry.morphAttributes.position ||
        geometry.morphAttributes.normal ||
        geometry.morphAttributes.color;
      const morphTargetsCount =
        morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache =
            camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (
          materialProperties.needsLights &&
          materialProperties.lightsStateVersion !== lights.state.version
        ) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (
          object.isBatchedMesh &&
          materialProperties.batching === false
        ) {
          needsProgramChange = true;
        } else if (
          !object.isBatchedMesh &&
          materialProperties.batching === true
        ) {
          needsProgramChange = true;
        } else if (
          object.isInstancedMesh &&
          materialProperties.instancing === false
        ) {
          needsProgramChange = true;
        } else if (
          !object.isInstancedMesh &&
          materialProperties.instancing === true
        ) {
          needsProgramChange = true;
        } else if (
          object.isSkinnedMesh &&
          materialProperties.skinning === false
        ) {
          needsProgramChange = true;
        } else if (
          !object.isSkinnedMesh &&
          materialProperties.skinning === true
        ) {
          needsProgramChange = true;
        } else if (
          object.isInstancedMesh &&
          materialProperties.instancingColor === true &&
          object.instanceColor === null
        ) {
          needsProgramChange = true;
        } else if (
          object.isInstancedMesh &&
          materialProperties.instancingColor === false &&
          object.instanceColor !== null
        ) {
          needsProgramChange = true;
        } else if (
          object.isInstancedMesh &&
          materialProperties.instancingMorph === true &&
          object.morphTexture === null
        ) {
          needsProgramChange = true;
        } else if (
          object.isInstancedMesh &&
          materialProperties.instancingMorph === false &&
          object.morphTexture !== null
        ) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (
          materialProperties.numClippingPlanes !== void 0 &&
          (materialProperties.numClippingPlanes !== clipping.numPlanes ||
            materialProperties.numIntersection !== clipping.numIntersection)
        ) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (
          capabilities.isWebGL2 === true &&
          materialProperties.morphTargetsCount !== morphTargetsCount
        ) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(),
        m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(
            _gl,
            _vector32.setFromMatrixPosition(camera.matrixWorld),
          );
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2),
          );
        }
        if (
          material.isMeshPhongMaterial ||
          material.isMeshToonMaterial ||
          material.isMeshLambertMaterial ||
          material.isMeshBasicMaterial ||
          material.isMeshStandardMaterial ||
          material.isShaderMaterial
        ) {
          p_uniforms.setValue(
            _gl,
            "isOrthographic",
            camera.isOrthographicCamera === true,
          );
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
            p_uniforms.setValue(
              _gl,
              "boneTexture",
              skeleton.boneTexture,
              textures,
            );
          } else {
            console.warn(
              "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.",
            );
          }
        }
      }
      if (object.isBatchedMesh) {
        p_uniforms.setOptional(_gl, object, "batchingTexture");
        p_uniforms.setValue(
          _gl,
          "batchingTexture",
          object._matricesTexture,
          textures,
        );
      }
      const morphAttributes = geometry.morphAttributes;
      if (
        morphAttributes.position !== void 0 ||
        morphAttributes.normal !== void 0 ||
        (morphAttributes.color !== void 0 && capabilities.isWebGL2 === true)
      ) {
        morphtargets.update(object, geometry, program);
      }
      if (
        refreshMaterial ||
        materialProperties.receiveShadow !== object.receiveShadow
      ) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value =
          envMap.isCubeTexture && envMap.isRenderTargetTexture === false
            ? -1
            : 1;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(
          _gl,
          "toneMappingExposure",
          _this.toneMappingExposure,
        );
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(
          m_uniforms,
          material,
          _pixelRatio,
          _height,
          _transmissionRenderTarget,
        );
        WebGLUniforms.upload(
          _gl,
          getUniformList(materialProperties),
          m_uniforms,
          textures,
        );
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(
          _gl,
          getUniformList(materialProperties),
          m_uniforms,
          textures,
        );
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i = 0, l = groups.length; i < l; i++) {
          if (capabilities.isWebGL2) {
            const group = groups[i];
            uniformsGroups.update(group, program);
            uniformsGroups.bind(group, program);
          } else {
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.",
            );
          }
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return (
        material.isMeshLambertMaterial ||
        material.isMeshToonMaterial ||
        material.isMeshPhongMaterial ||
        material.isMeshStandardMaterial ||
        material.isShadowMaterial ||
        (material.isShaderMaterial && material.lights === true)
      );
    }
    this.getActiveCubeFace = function () {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function () {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function () {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function (
      renderTarget,
      colorTexture,
      depthTexture,
    ) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      renderTargetProperties.__autoAllocateDepthBuffer =
        depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
          console.warn(
            "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided",
          );
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    };
    this.setRenderTargetFramebuffer = function (
      renderTarget,
      defaultFramebuffer,
    ) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer =
        defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function (
      renderTarget,
      activeCubeFace = 0,
      activeMipmapLevel = 0,
    ) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(
            renderTarget,
            properties.get(renderTarget.texture).__webglTexture,
            properties.get(renderTarget.depthTexture).__webglTexture,
          );
        }
        const texture = renderTarget.texture;
        if (
          texture.isData3DTexture ||
          texture.isDataArrayTexture ||
          texture.isCompressedArrayTexture
        ) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer =
          properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (
          capabilities.isWebGL2 &&
          renderTarget.samples > 0 &&
          textures.useMultisampledRTT(renderTarget) === false
        ) {
          framebuffer =
            properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(
        _gl.FRAMEBUFFER,
        framebuffer,
      );
      if (
        framebufferBound &&
        capabilities.drawBuffers &&
        useDefaultFramebuffer
      ) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(
          _gl.FRAMEBUFFER,
          _gl.COLOR_ATTACHMENT0,
          _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace,
          textureProperties.__webglTexture,
          activeMipmapLevel,
        );
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(
          _gl.FRAMEBUFFER,
          _gl.COLOR_ATTACHMENT0,
          textureProperties.__webglTexture,
          activeMipmapLevel || 0,
          layer,
        );
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function (
      renderTarget,
      x,
      y2,
      width,
      height,
      buffer,
      activeCubeFaceIndex,
    ) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error(
          "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
        );
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (
        renderTarget.isWebGLCubeRenderTarget &&
        activeCubeFaceIndex !== void 0
      ) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (
            textureFormat !== RGBAFormat &&
            utils.convert(textureFormat) !==
              _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.",
            );
            return;
          }
          const halfFloatSupportedByExt =
            textureType === HalfFloatType &&
            (extensions.has("EXT_color_buffer_half_float") ||
              (capabilities.isWebGL2 &&
                extensions.has("EXT_color_buffer_float")));
          if (
            textureType !== UnsignedByteType &&
            utils.convert(textureType) !==
              _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
            !(
              textureType === FloatType &&
              (capabilities.isWebGL2 ||
                extensions.has("OES_texture_float") ||
                extensions.has("WEBGL_color_buffer_float"))
            ) && // Chrome Mac >= 52 and Firefox
            !halfFloatSupportedByExt
          ) {
            console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.",
            );
            return;
          }
          if (
            x >= 0 &&
            x <= renderTarget.width - width &&
            y2 >= 0 &&
            y2 <= renderTarget.height - height
          ) {
            _gl.readPixels(
              x,
              y2,
              width,
              height,
              utils.convert(textureFormat),
              utils.convert(textureType),
              buffer,
            );
          }
        } finally {
          const framebuffer2 =
            _currentRenderTarget !== null
              ? properties.get(_currentRenderTarget).__webglFramebuffer
              : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function (position, texture, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(
        _gl.TEXTURE_2D,
        level,
        0,
        0,
        position.x,
        position.y,
        width,
        height,
      );
      state.unbindTexture();
    };
    this.copyTextureToTexture = function (
      position,
      srcTexture,
      dstTexture,
      level = 0,
    ) {
      const width = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(
        _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        dstTexture.premultiplyAlpha,
      );
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(
          _gl.TEXTURE_2D,
          level,
          position.x,
          position.y,
          width,
          height,
          glFormat,
          glType,
          srcTexture.image.data,
        );
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(
            _gl.TEXTURE_2D,
            level,
            position.x,
            position.y,
            srcTexture.mipmaps[0].width,
            srcTexture.mipmaps[0].height,
            glFormat,
            srcTexture.mipmaps[0].data,
          );
        } else {
          _gl.texSubImage2D(
            _gl.TEXTURE_2D,
            level,
            position.x,
            position.y,
            glFormat,
            glType,
            srcTexture.image,
          );
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(_gl.TEXTURE_2D);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function (
      sourceBox,
      position,
      srcTexture,
      dstTexture,
      level = 0,
    ) {
      if (_this.isWebGL1Renderer) {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.",
        );
        return;
      }
      const width = Math.round(sourceBox.max.x - sourceBox.min.x);
      const height = Math.round(sourceBox.max.y - sourceBox.min.y);
      const depth2 = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (
        dstTexture.isDataArrayTexture ||
        dstTexture.isCompressedArrayTexture
      ) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        console.warn(
          "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.",
        );
        return;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(
        _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
        dstTexture.premultiplyAlpha,
      );
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      const image = srcTexture.isCompressedTexture
        ? srcTexture.mipmaps[level]
        : srcTexture.image;
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(
          glTarget,
          level,
          position.x,
          position.y,
          position.z,
          width,
          height,
          depth2,
          glFormat,
          glType,
          image.data,
        );
      } else {
        if (dstTexture.isCompressedArrayTexture) {
          _gl.compressedTexSubImage3D(
            glTarget,
            level,
            position.x,
            position.y,
            position.z,
            width,
            height,
            depth2,
            glFormat,
            image.data,
          );
        } else {
          _gl.texSubImage3D(
            glTarget,
            level,
            position.x,
            position.y,
            position.z,
            width,
            height,
            depth2,
            glFormat,
            glType,
            image,
          );
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initTexture = function (texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (
        texture.isDataArrayTexture ||
        texture.isCompressedArrayTexture
      ) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function () {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this }),
      );
    }
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(colorSpace) {
    this._outputColorSpace = colorSpace;
    const gl = this.getContext();
    gl.drawingBufferColorSpace =
      colorSpace === DisplayP3ColorSpace ? "display-p3" : "srgb";
    gl.unpackColorSpace =
      ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace
        ? "display-p3"
        : "srgb";
  }
  get useLegacyLights() {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.",
    );
    return this._useLegacyLights;
  }
  set useLegacyLights(value) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.",
    );
    this._useLegacyLights = value;
  }
}
class WebGL1Renderer extends WebGLRenderer {}
WebGL1Renderer.prototype.isWebGL1Renderer = true;
class FogExp2 {
  constructor(color, density = 25e-5) {
    this.isFogExp2 = true;
    this.name = "";
    this.color = new Color(color);
    this.density = density;
  }
  clone() {
    return new FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      name: this.name,
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class Fog {
  constructor(color, near = 1, far = 1e3) {
    this.isFog = true;
    this.name = "";
    this.color = new Color(color);
    this.near = near;
    this.far = far;
  }
  clone() {
    return new Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      name: this.name,
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class Scene extends Object3D {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.backgroundRotation = new Euler$1();
    this.environmentRotation = new Euler$1();
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("observe", { detail: this }),
      );
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    this.backgroundRotation.copy(source.backgroundRotation);
    this.environmentRotation.copy(source.environmentRotation);
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0)
      data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1)
      data.object.backgroundIntensity = this.backgroundIntensity;
    data.object.backgroundRotation = this.backgroundRotation.toArray();
    data.object.environmentRotation = this.environmentRotation.toArray();
    return data;
  }
}
class InterleavedBuffer {
  constructor(array, stride) {
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this._updateRange = { offset: 0, count: -1 };
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {}
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  get updateRange() {
    warnOnce(
      "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.",
    );
    return this._updateRange;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(
      data.arrayBuffers[this.array.buffer._uuid],
    );
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(
        new Uint32Array(this.array.buffer),
      );
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride,
    };
  }
}
const _vector$6 = /* @__PURE__ */ new Vector3$1();
class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.applyMatrix4(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.applyNormalMatrix(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$6.fromBufferAttribute(this, i);
      _vector$6.transformDirection(m);
      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
    }
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.data.stride + this.offset + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized) value = normalize(value, this.array);
    this.data.array[index * this.data.stride + this.offset + component] = value;
    return this;
  }
  setX(index, x) {
    if (this.normalized) x = normalize(x, this.array);
    this.data.array[index * this.data.stride + this.offset] = x;
    return this;
  }
  setY(index, y2) {
    if (this.normalized) y2 = normalize(y2, this.array);
    this.data.array[index * this.data.stride + this.offset + 1] = y2;
    return this;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize(z, this.array);
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }
  setW(index, w) {
    if (this.normalized) w = normalize(w, this.array);
    this.data.array[index * this.data.stride + this.offset + 3] = w;
    return this;
  }
  getX(index) {
    let x = this.data.array[index * this.data.stride + this.offset];
    if (this.normalized) x = denormalize(x, this.array);
    return x;
  }
  getY(index) {
    let y2 = this.data.array[index * this.data.stride + this.offset + 1];
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  getZ(index) {
    let z = this.data.array[index * this.data.stride + this.offset + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  getW(index) {
    let w = this.data.array[index * this.data.stride + this.offset + 3];
    if (this.normalized) w = denormalize(w, this.array);
    return w;
  }
  setXY(index, x, y2) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize(x, this.array);
      y2 = normalize(y2, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x, y2, z) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize(x, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y2, z, w) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x = normalize(x, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
      w = normalize(w, this.array);
    }
    this.data.array[index + 0] = x;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.",
      );
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute(
        new this.array.constructor(array),
        this.itemSize,
        this.normalized,
      );
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new InterleavedBufferAttribute(
        data.interleavedBuffers[this.data.uuid],
        this.itemSize,
        this.offset,
        this.normalized,
      );
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.",
      );
      const array = [];
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized,
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized,
      };
    }
  }
}
class SpriteMaterial extends Material {
  constructor(parameters) {
    super();
    this.isSpriteMaterial = true;
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
let _geometry;
const _intersectPoint = /* @__PURE__ */ new Vector3$1();
const _worldScale = /* @__PURE__ */ new Vector3$1();
const _mvPosition = /* @__PURE__ */ new Vector3$1();
const _alignedPosition = /* @__PURE__ */ new Vector2();
const _rotatedPosition = /* @__PURE__ */ new Vector2();
const _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
const _vA = /* @__PURE__ */ new Vector3$1();
const _vB = /* @__PURE__ */ new Vector3$1();
const _vC = /* @__PURE__ */ new Vector3$1();
const _uvA = /* @__PURE__ */ new Vector2();
const _uvB = /* @__PURE__ */ new Vector2();
const _uvC = /* @__PURE__ */ new Vector2();
class Sprite extends Object3D {
  constructor(material = new SpriteMaterial()) {
    super();
    this.isSprite = true;
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
        0, 0, 1,
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute(
        "position",
        new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false),
      );
      _geometry.setAttribute(
        "uv",
        new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false),
      );
    }
    this.geometry = _geometry;
    this.material = material;
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      );
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(
      raycaster.camera.matrixWorldInverse,
      this.matrixWorld,
    );
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (
      raycaster.camera.isPerspectiveCamera &&
      this.material.sizeAttenuation === false
    ) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(
      _vA.set(-0.5, -0.5, 0),
      _mvPosition,
      center,
      _worldScale,
      sin,
      cos,
    );
    transformVertex(
      _vB.set(0.5, -0.5, 0),
      _mvPosition,
      center,
      _worldScale,
      sin,
      cos,
    );
    transformVertex(
      _vC.set(0.5, 0.5, 0),
      _mvPosition,
      center,
      _worldScale,
      sin,
      cos,
    );
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect2 = raycaster.ray.intersectTriangle(
      _vA,
      _vB,
      _vC,
      false,
      _intersectPoint,
    );
    if (intersect2 === null) {
      transformVertex(
        _vB.set(-0.5, 0.5, 0),
        _mvPosition,
        center,
        _worldScale,
        sin,
        cos,
      );
      _uvB.set(0, 1);
      intersect2 = raycaster.ray.intersectTriangle(
        _vA,
        _vC,
        _vB,
        false,
        _intersectPoint,
      );
      if (intersect2 === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getInterpolation(
        _intersectPoint,
        _vA,
        _vB,
        _vC,
        _uvA,
        _uvB,
        _uvC,
        new Vector2(),
      ),
      face: null,
      object: this,
    });
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.center !== void 0) this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
}
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition
    .subVectors(vertexPosition, center)
    .addScalar(0.5)
    .multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
const _v1$2 = /* @__PURE__ */ new Vector3$1();
const _v2$1 = /* @__PURE__ */ new Vector3$1();
class LOD extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: [],
      },
      isLOD: {
        value: true,
      },
    });
    this.autoUpdate = true;
  }
  copy(source) {
    super.copy(source, false);
    const levels = source.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      this.addLevel(level.object.clone(), level.distance, level.hysteresis);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  }
  addLevel(object, distance = 0, hysteresis = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l;
    for (l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break;
      }
    }
    levels.splice(l, 0, { distance, hysteresis, object });
    this.add(object);
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        let levelDistance = levels[i].distance;
        if (levels[i].object.visible) {
          levelDistance -= levelDistance * levels[i].hysteresis;
        }
        if (distance < levelDistance) {
          break;
        }
      }
      return levels[i - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(distance).raycast(raycaster, intersects2);
    }
  }
  update(camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$2.setFromMatrixPosition(camera.matrixWorld);
      _v2$1.setFromMatrixPosition(this.matrixWorld);
      const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
      levels[0].object.visible = true;
      let i, l;
      for (i = 1, l = levels.length; i < l; i++) {
        let levelDistance = levels[i].distance;
        if (levels[i].object.visible) {
          levelDistance -= levelDistance * levels[i].hysteresis;
        }
        if (distance >= levelDistance) {
          levels[i - 1].object.visible = false;
          levels[i].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i - 1;
      for (; i < l; i++) {
        levels[i].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.autoUpdate === false) data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance,
        hysteresis: level.hysteresis,
      });
    }
    return data;
  }
}
const _basePosition = /* @__PURE__ */ new Vector3$1();
const _skinIndex = /* @__PURE__ */ new Vector4();
const _skinWeight = /* @__PURE__ */ new Vector4();
const _vector3 = /* @__PURE__ */ new Vector3$1();
const _matrix4 = /* @__PURE__ */ new Matrix4();
const _vertex = /* @__PURE__ */ new Vector3$1();
const _sphere$4 = /* @__PURE__ */ new Sphere();
const _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
const _ray$2 = /* @__PURE__ */ new Ray();
class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.isSkinnedMesh = true;
    this.type = "SkinnedMesh";
    this.bindMode = AttachedBindMode;
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
    this.boundingBox = null;
    this.boundingSphere = null;
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i = 0; i < positionAttribute.count; i++) {
      this.getVertexPosition(i, _vertex);
      this.boundingBox.expandByPoint(_vertex);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i = 0; i < positionAttribute.count; i++) {
      this.getVertexPosition(i, _vertex);
      this.boundingSphere.expandByPoint(_vertex);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    if (source.boundingBox !== null)
      this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null)
      this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  raycast(raycaster, intersects2) {
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$4.copy(this.boundingSphere);
    _sphere$4.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (this.boundingBox !== null) {
      if (_ray$2.intersectsBox(this.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$2);
  }
  getVertexPosition(index, target) {
    super.getVertexPosition(index, target);
    this.applyBoneTransform(index, target);
    return target;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.fromBufferAttribute(skinWeight, i);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === AttachedBindMode) {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === DetachedBindMode) {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn(
        "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode,
      );
    }
  }
  applyBoneTransform(index, vector) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
    vector.set(0, 0, 0);
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i);
        _matrix4.multiplyMatrices(
          skeleton.bones[boneIndex].matrixWorld,
          skeleton.boneInverses[boneIndex],
        );
        vector.addScaledVector(
          _vector3.copy(_basePosition).applyMatrix4(_matrix4),
          weight,
        );
      }
    }
    return vector.applyMatrix4(this.bindMatrixInverse);
  }
}
class Bone extends Object3D {
  constructor() {
    super();
    this.isBone = true;
    this.type = "Bone";
  }
}
class DataTexture extends Texture {
  constructor(
    data = null,
    width = 1,
    height = 1,
    format,
    type,
    mapping,
    wrapS,
    wrapT,
    magFilter = NearestFilter,
    minFilter = NearestFilter,
    anisotropy,
    colorSpace,
  ) {
    super(
      null,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
      colorSpace,
    );
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
}
const _offsetMatrix = /* @__PURE__ */ new Matrix4();
const _identityMatrix$1 = /* @__PURE__ */ new Matrix4();
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn(
          "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.",
        );
        this.boneInverses = [];
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4();
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert();
      }
    }
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i = 0, il = bones.length; i < il; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix$1;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
      _offsetMatrix.toArray(boneMatrices, i * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size = Math.sqrt(this.bones.length * 4);
    size = Math.ceil(size / 4) * 4;
    size = Math.max(size, 4);
    const boneMatrices = new Float32Array(size * size * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(
      boneMatrices,
      size,
      size,
      RGBAFormat,
      FloatType,
    );
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    return this;
  }
  getBoneByName(name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i = 0, l = json.bones.length; i < l; i++) {
      const uuid = json.bones[i];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    super(array, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
}
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
const _instanceIntersects = [];
const _box3 = /* @__PURE__ */ new Box3();
const _identity = /* @__PURE__ */ new Matrix4();
const _mesh$1 = /* @__PURE__ */ new Mesh();
const _sphere$3 = /* @__PURE__ */ new Sphere();
class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.isInstancedMesh = true;
    this.instanceMatrix = new InstancedBufferAttribute(
      new Float32Array(count * 16),
      16,
    );
    this.instanceColor = null;
    this.morphTexture = null;
    this.count = count;
    this.boundingBox = null;
    this.boundingSphere = null;
    for (let i = 0; i < count; i++) {
      this.setMatrixAt(i, _identity);
    }
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    this.boundingBox.makeEmpty();
    for (let i = 0; i < count; i++) {
      this.getMatrixAt(i, _instanceLocalMatrix);
      _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
      this.boundingBox.union(_box3);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    this.boundingSphere.makeEmpty();
    for (let i = 0; i < count; i++) {
      this.getMatrixAt(i, _instanceLocalMatrix);
      _sphere$3
        .copy(geometry.boundingSphere)
        .applyMatrix4(_instanceLocalMatrix);
      this.boundingSphere.union(_sphere$3);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    if (source.boundingBox !== null)
      this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null)
      this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  getMorphAt(index, object) {
    const objectInfluences = object.morphTargetInfluences;
    const array = this.morphTexture.source.data.data;
    const len = objectInfluences.length + 1;
    const dataIndex = index * len + 1;
    for (let i = 0; i < objectInfluences.length; i++) {
      objectInfluences[i] = array[dataIndex + i];
    }
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh$1.geometry = this.geometry;
    _mesh$1.material = this.material;
    if (_mesh$1.material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$3.copy(this.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh$1.matrixWorld = _instanceWorldMatrix;
      _mesh$1.raycast(raycaster, _instanceIntersects);
      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect2 = _instanceIntersects[i];
        intersect2.instanceId = instanceId;
        intersect2.object = this;
        intersects2.push(intersect2);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(
        new Float32Array(this.instanceMatrix.count * 3),
        3,
      );
    }
    color.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  setMorphAt(index, object) {
    const objectInfluences = object.morphTargetInfluences;
    const len = objectInfluences.length + 1;
    if (this.morphTexture === null) {
      this.morphTexture = new DataTexture(
        new Float32Array(len * this.count),
        len,
        this.count,
        RedFormat,
        FloatType,
      );
    }
    const array = this.morphTexture.source.data.data;
    let morphInfluencesSum = 0;
    for (let i = 0; i < objectInfluences.length; i++) {
      morphInfluencesSum += objectInfluences[i];
    }
    const morphBaseInfluence = this.geometry.morphTargetsRelative
      ? 1
      : 1 - morphInfluencesSum;
    const dataIndex = len * index;
    array[dataIndex] = morphBaseInfluence;
    array.set(objectInfluences, dataIndex + 1);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function sortOpaque(a, b) {
  return a.z - b.z;
}
function sortTransparent(a, b) {
  return b.z - a.z;
}
class MultiDrawRenderList {
  constructor() {
    this.index = 0;
    this.pool = [];
    this.list = [];
  }
  push(drawRange, z) {
    const pool = this.pool;
    const list = this.list;
    if (this.index >= pool.length) {
      pool.push({
        start: -1,
        count: -1,
        z: -1,
      });
    }
    const item = pool[this.index];
    list.push(item);
    this.index++;
    item.start = drawRange.start;
    item.count = drawRange.count;
    item.z = z;
  }
  reset() {
    this.list.length = 0;
    this.index = 0;
  }
}
const ID_ATTR_NAME = "batchId";
const _matrix$1 = /* @__PURE__ */ new Matrix4();
const _invMatrixWorld = /* @__PURE__ */ new Matrix4();
const _identityMatrix = /* @__PURE__ */ new Matrix4();
const _projScreenMatrix$2 = /* @__PURE__ */ new Matrix4();
const _frustum = /* @__PURE__ */ new Frustum();
const _box$1 = /* @__PURE__ */ new Box3();
const _sphere$2 = /* @__PURE__ */ new Sphere();
const _vector$5 = /* @__PURE__ */ new Vector3$1();
const _renderList = /* @__PURE__ */ new MultiDrawRenderList();
const _mesh = /* @__PURE__ */ new Mesh();
const _batchIntersects = [];
function copyAttributeData(src, target, targetOffset = 0) {
  const itemSize = target.itemSize;
  if (
    src.isInterleavedBufferAttribute ||
    src.array.constructor !== target.array.constructor
  ) {
    const vertexCount = src.count;
    for (let i = 0; i < vertexCount; i++) {
      for (let c = 0; c < itemSize; c++) {
        target.setComponent(i + targetOffset, c, src.getComponent(i, c));
      }
    }
  } else {
    target.array.set(src.array, targetOffset * itemSize);
  }
  target.needsUpdate = true;
}
class BatchedMesh extends Mesh {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(
    maxGeometryCount,
    maxVertexCount,
    maxIndexCount = maxVertexCount * 2,
    material,
  ) {
    super(new BufferGeometry(), material);
    this.isBatchedMesh = true;
    this.perObjectFrustumCulled = true;
    this.sortObjects = true;
    this.boundingBox = null;
    this.boundingSphere = null;
    this.customSort = null;
    this._drawRanges = [];
    this._reservedRanges = [];
    this._visibility = [];
    this._active = [];
    this._bounds = [];
    this._maxGeometryCount = maxGeometryCount;
    this._maxVertexCount = maxVertexCount;
    this._maxIndexCount = maxIndexCount;
    this._geometryInitialized = false;
    this._geometryCount = 0;
    this._multiDrawCounts = new Int32Array(maxGeometryCount);
    this._multiDrawStarts = new Int32Array(maxGeometryCount);
    this._multiDrawCount = 0;
    this._visibilityChanged = true;
    this._matricesTexture = null;
    this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let size = Math.sqrt(this._maxGeometryCount * 4);
    size = Math.ceil(size / 4) * 4;
    size = Math.max(size, 4);
    const matricesArray = new Float32Array(size * size * 4);
    const matricesTexture = new DataTexture(
      matricesArray,
      size,
      size,
      RGBAFormat,
      FloatType,
    );
    this._matricesTexture = matricesTexture;
  }
  _initializeGeometry(reference) {
    const geometry = this.geometry;
    const maxVertexCount = this._maxVertexCount;
    const maxGeometryCount = this._maxGeometryCount;
    const maxIndexCount = this._maxIndexCount;
    if (this._geometryInitialized === false) {
      for (const attributeName in reference.attributes) {
        const srcAttribute = reference.getAttribute(attributeName);
        const { array, itemSize, normalized } = srcAttribute;
        const dstArray = new array.constructor(maxVertexCount * itemSize);
        const dstAttribute = new srcAttribute.constructor(
          dstArray,
          itemSize,
          normalized,
        );
        dstAttribute.setUsage(srcAttribute.usage);
        geometry.setAttribute(attributeName, dstAttribute);
      }
      if (reference.getIndex() !== null) {
        const indexArray =
          maxVertexCount > 65536
            ? new Uint32Array(maxIndexCount)
            : new Uint16Array(maxIndexCount);
        geometry.setIndex(new BufferAttribute(indexArray, 1));
      }
      const idArray =
        maxGeometryCount > 65536
          ? new Uint32Array(maxVertexCount)
          : new Uint16Array(maxVertexCount);
      geometry.setAttribute(ID_ATTR_NAME, new BufferAttribute(idArray, 1));
      this._geometryInitialized = true;
    }
  }
  // Make sure the geometry is compatible with the existing combined geometry atributes
  _validateGeometry(geometry) {
    if (geometry.getAttribute(ID_ATTR_NAME)) {
      throw new Error(
        `BatchedMesh: Geometry cannot use attribute "${ID_ATTR_NAME}"`,
      );
    }
    const batchGeometry = this.geometry;
    if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
      throw new Error(
        'BatchedMesh: All geometries must consistently have "index".',
      );
    }
    for (const attributeName in batchGeometry.attributes) {
      if (attributeName === ID_ATTR_NAME) {
        continue;
      }
      if (!geometry.hasAttribute(attributeName)) {
        throw new Error(
          `BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`,
        );
      }
      const srcAttribute = geometry.getAttribute(attributeName);
      const dstAttribute = batchGeometry.getAttribute(attributeName);
      if (
        srcAttribute.itemSize !== dstAttribute.itemSize ||
        srcAttribute.normalized !== dstAttribute.normalized
      ) {
        throw new Error(
          "BatchedMesh: All attributes must have a consistent itemSize and normalized value.",
        );
      }
    }
  }
  setCustomSort(func) {
    this.customSort = func;
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const geometryCount = this._geometryCount;
    const boundingBox = this.boundingBox;
    const active = this._active;
    boundingBox.makeEmpty();
    for (let i = 0; i < geometryCount; i++) {
      if (active[i] === false) continue;
      this.getMatrixAt(i, _matrix$1);
      this.getBoundingBoxAt(i, _box$1).applyMatrix4(_matrix$1);
      boundingBox.union(_box$1);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const geometryCount = this._geometryCount;
    const boundingSphere = this.boundingSphere;
    const active = this._active;
    boundingSphere.makeEmpty();
    for (let i = 0; i < geometryCount; i++) {
      if (active[i] === false) continue;
      this.getMatrixAt(i, _matrix$1);
      this.getBoundingSphereAt(i, _sphere$2).applyMatrix4(_matrix$1);
      boundingSphere.union(_sphere$2);
    }
  }
  addGeometry(geometry, vertexCount = -1, indexCount = -1) {
    this._initializeGeometry(geometry);
    this._validateGeometry(geometry);
    if (this._geometryCount >= this._maxGeometryCount) {
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    }
    const reservedRange = {
      vertexStart: -1,
      vertexCount: -1,
      indexStart: -1,
      indexCount: -1,
    };
    let lastRange = null;
    const reservedRanges = this._reservedRanges;
    const drawRanges = this._drawRanges;
    const bounds = this._bounds;
    if (this._geometryCount !== 0) {
      lastRange = reservedRanges[reservedRanges.length - 1];
    }
    if (vertexCount === -1) {
      reservedRange.vertexCount = geometry.getAttribute("position").count;
    } else {
      reservedRange.vertexCount = vertexCount;
    }
    if (lastRange === null) {
      reservedRange.vertexStart = 0;
    } else {
      reservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount;
    }
    const index = geometry.getIndex();
    const hasIndex = index !== null;
    if (hasIndex) {
      if (indexCount === -1) {
        reservedRange.indexCount = index.count;
      } else {
        reservedRange.indexCount = indexCount;
      }
      if (lastRange === null) {
        reservedRange.indexStart = 0;
      } else {
        reservedRange.indexStart = lastRange.indexStart + lastRange.indexCount;
      }
    }
    if (
      (reservedRange.indexStart !== -1 &&
        reservedRange.indexStart + reservedRange.indexCount >
          this._maxIndexCount) ||
      reservedRange.vertexStart + reservedRange.vertexCount >
        this._maxVertexCount
    ) {
      throw new Error(
        "BatchedMesh: Reserved space request exceeds the maximum buffer size.",
      );
    }
    const visibility = this._visibility;
    const active = this._active;
    const matricesTexture = this._matricesTexture;
    const matricesArray = this._matricesTexture.image.data;
    visibility.push(true);
    active.push(true);
    const geometryId = this._geometryCount;
    this._geometryCount++;
    _identityMatrix.toArray(matricesArray, geometryId * 16);
    matricesTexture.needsUpdate = true;
    reservedRanges.push(reservedRange);
    drawRanges.push({
      start: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart,
      count: -1,
    });
    bounds.push({
      boxInitialized: false,
      box: new Box3(),
      sphereInitialized: false,
      sphere: new Sphere(),
    });
    const idAttribute = this.geometry.getAttribute(ID_ATTR_NAME);
    for (let i = 0; i < reservedRange.vertexCount; i++) {
      idAttribute.setX(reservedRange.vertexStart + i, geometryId);
    }
    idAttribute.needsUpdate = true;
    this.setGeometryAt(geometryId, geometry);
    return geometryId;
  }
  setGeometryAt(id, geometry) {
    if (id >= this._geometryCount) {
      throw new Error("BatchedMesh: Maximum geometry count reached.");
    }
    this._validateGeometry(geometry);
    const batchGeometry = this.geometry;
    const hasIndex = batchGeometry.getIndex() !== null;
    const dstIndex = batchGeometry.getIndex();
    const srcIndex = geometry.getIndex();
    const reservedRange = this._reservedRanges[id];
    if (
      (hasIndex && srcIndex.count > reservedRange.indexCount) ||
      geometry.attributes.position.count > reservedRange.vertexCount
    ) {
      throw new Error(
        "BatchedMesh: Reserved space not large enough for provided geometry.",
      );
    }
    const vertexStart = reservedRange.vertexStart;
    const vertexCount = reservedRange.vertexCount;
    for (const attributeName in batchGeometry.attributes) {
      if (attributeName === ID_ATTR_NAME) {
        continue;
      }
      const srcAttribute = geometry.getAttribute(attributeName);
      const dstAttribute = batchGeometry.getAttribute(attributeName);
      copyAttributeData(srcAttribute, dstAttribute, vertexStart);
      const itemSize = srcAttribute.itemSize;
      for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {
        const index = vertexStart + i;
        for (let c = 0; c < itemSize; c++) {
          dstAttribute.setComponent(index, c, 0);
        }
      }
      dstAttribute.needsUpdate = true;
    }
    if (hasIndex) {
      const indexStart = reservedRange.indexStart;
      for (let i = 0; i < srcIndex.count; i++) {
        dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i));
      }
      for (let i = srcIndex.count, l = reservedRange.indexCount; i < l; i++) {
        dstIndex.setX(indexStart + i, vertexStart);
      }
      dstIndex.needsUpdate = true;
    }
    const bound = this._bounds[id];
    if (geometry.boundingBox !== null) {
      bound.box.copy(geometry.boundingBox);
      bound.boxInitialized = true;
    } else {
      bound.boxInitialized = false;
    }
    if (geometry.boundingSphere !== null) {
      bound.sphere.copy(geometry.boundingSphere);
      bound.sphereInitialized = true;
    } else {
      bound.sphereInitialized = false;
    }
    const drawRange = this._drawRanges[id];
    const posAttr = geometry.getAttribute("position");
    drawRange.count = hasIndex ? srcIndex.count : posAttr.count;
    this._visibilityChanged = true;
    return id;
  }
  deleteGeometry(geometryId) {
    const active = this._active;
    if (geometryId >= active.length || active[geometryId] === false) {
      return this;
    }
    active[geometryId] = false;
    this._visibilityChanged = true;
    return this;
  }
  // get bounding box and compute it if it doesn't exist
  getBoundingBoxAt(id, target) {
    const active = this._active;
    if (active[id] === false) {
      return null;
    }
    const bound = this._bounds[id];
    const box = bound.box;
    const geometry = this.geometry;
    if (bound.boxInitialized === false) {
      box.makeEmpty();
      const index = geometry.index;
      const position = geometry.attributes.position;
      const drawRange = this._drawRanges[id];
      for (
        let i = drawRange.start, l = drawRange.start + drawRange.count;
        i < l;
        i++
      ) {
        let iv = i;
        if (index) {
          iv = index.getX(iv);
        }
        box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));
      }
      bound.boxInitialized = true;
    }
    target.copy(box);
    return target;
  }
  // get bounding sphere and compute it if it doesn't exist
  getBoundingSphereAt(id, target) {
    const active = this._active;
    if (active[id] === false) {
      return null;
    }
    const bound = this._bounds[id];
    const sphere = bound.sphere;
    const geometry = this.geometry;
    if (bound.sphereInitialized === false) {
      sphere.makeEmpty();
      this.getBoundingBoxAt(id, _box$1);
      _box$1.getCenter(sphere.center);
      const index = geometry.index;
      const position = geometry.attributes.position;
      const drawRange = this._drawRanges[id];
      let maxRadiusSq = 0;
      for (
        let i = drawRange.start, l = drawRange.start + drawRange.count;
        i < l;
        i++
      ) {
        let iv = i;
        if (index) {
          iv = index.getX(iv);
        }
        _vector$5.fromBufferAttribute(position, iv);
        maxRadiusSq = Math.max(
          maxRadiusSq,
          sphere.center.distanceToSquared(_vector$5),
        );
      }
      sphere.radius = Math.sqrt(maxRadiusSq);
      bound.sphereInitialized = true;
    }
    target.copy(sphere);
    return target;
  }
  setMatrixAt(geometryId, matrix) {
    const active = this._active;
    const matricesTexture = this._matricesTexture;
    const matricesArray = this._matricesTexture.image.data;
    const geometryCount = this._geometryCount;
    if (geometryId >= geometryCount || active[geometryId] === false) {
      return this;
    }
    matrix.toArray(matricesArray, geometryId * 16);
    matricesTexture.needsUpdate = true;
    return this;
  }
  getMatrixAt(geometryId, matrix) {
    const active = this._active;
    const matricesArray = this._matricesTexture.image.data;
    const geometryCount = this._geometryCount;
    if (geometryId >= geometryCount || active[geometryId] === false) {
      return null;
    }
    return matrix.fromArray(matricesArray, geometryId * 16);
  }
  setVisibleAt(geometryId, value) {
    const visibility = this._visibility;
    const active = this._active;
    const geometryCount = this._geometryCount;
    if (
      geometryId >= geometryCount ||
      active[geometryId] === false ||
      visibility[geometryId] === value
    ) {
      return this;
    }
    visibility[geometryId] = value;
    this._visibilityChanged = true;
    return this;
  }
  getVisibleAt(geometryId) {
    const visibility = this._visibility;
    const active = this._active;
    const geometryCount = this._geometryCount;
    if (geometryId >= geometryCount || active[geometryId] === false) {
      return false;
    }
    return visibility[geometryId];
  }
  raycast(raycaster, intersects2) {
    const visibility = this._visibility;
    const active = this._active;
    const drawRanges = this._drawRanges;
    const geometryCount = this._geometryCount;
    const matrixWorld = this.matrixWorld;
    const batchGeometry = this.geometry;
    _mesh.material = this.material;
    _mesh.geometry.index = batchGeometry.index;
    _mesh.geometry.attributes = batchGeometry.attributes;
    if (_mesh.geometry.boundingBox === null) {
      _mesh.geometry.boundingBox = new Box3();
    }
    if (_mesh.geometry.boundingSphere === null) {
      _mesh.geometry.boundingSphere = new Sphere();
    }
    for (let i = 0; i < geometryCount; i++) {
      if (!visibility[i] || !active[i]) {
        continue;
      }
      const drawRange = drawRanges[i];
      _mesh.geometry.setDrawRange(drawRange.start, drawRange.count);
      this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);
      this.getBoundingBoxAt(i, _mesh.geometry.boundingBox);
      this.getBoundingSphereAt(i, _mesh.geometry.boundingSphere);
      _mesh.raycast(raycaster, _batchIntersects);
      for (let j = 0, l = _batchIntersects.length; j < l; j++) {
        const intersect2 = _batchIntersects[j];
        intersect2.object = this;
        intersect2.batchId = i;
        intersects2.push(intersect2);
      }
      _batchIntersects.length = 0;
    }
    _mesh.material = null;
    _mesh.geometry.index = null;
    _mesh.geometry.attributes = {};
    _mesh.geometry.setDrawRange(0, Infinity);
  }
  copy(source) {
    super.copy(source);
    this.geometry = source.geometry.clone();
    this.perObjectFrustumCulled = source.perObjectFrustumCulled;
    this.sortObjects = source.sortObjects;
    this.boundingBox =
      source.boundingBox !== null ? source.boundingBox.clone() : null;
    this.boundingSphere =
      source.boundingSphere !== null ? source.boundingSphere.clone() : null;
    this._drawRanges = source._drawRanges.map((range) => ({ ...range }));
    this._reservedRanges = source._reservedRanges.map((range) => ({
      ...range,
    }));
    this._visibility = source._visibility.slice();
    this._active = source._active.slice();
    this._bounds = source._bounds.map((bound) => ({
      boxInitialized: bound.boxInitialized,
      box: bound.box.clone(),
      sphereInitialized: bound.sphereInitialized,
      sphere: bound.sphere.clone(),
    }));
    this._maxGeometryCount = source._maxGeometryCount;
    this._maxVertexCount = source._maxVertexCount;
    this._maxIndexCount = source._maxIndexCount;
    this._geometryInitialized = source._geometryInitialized;
    this._geometryCount = source._geometryCount;
    this._multiDrawCounts = source._multiDrawCounts.slice();
    this._multiDrawStarts = source._multiDrawStarts.slice();
    this._matricesTexture = source._matricesTexture.clone();
    this._matricesTexture.image.data = this._matricesTexture.image.slice();
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this._matricesTexture.dispose();
    this._matricesTexture = null;
    return this;
  }
  onBeforeRender(renderer, scene, camera, geometry, material) {
    if (
      !this._visibilityChanged &&
      !this.perObjectFrustumCulled &&
      !this.sortObjects
    ) {
      return;
    }
    const index = geometry.getIndex();
    const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;
    const active = this._active;
    const visibility = this._visibility;
    const multiDrawStarts = this._multiDrawStarts;
    const multiDrawCounts = this._multiDrawCounts;
    const drawRanges = this._drawRanges;
    const perObjectFrustumCulled = this.perObjectFrustumCulled;
    if (perObjectFrustumCulled) {
      _projScreenMatrix$2
        .multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse)
        .multiply(this.matrixWorld);
      _frustum.setFromProjectionMatrix(
        _projScreenMatrix$2,
        renderer.coordinateSystem,
      );
    }
    let count = 0;
    if (this.sortObjects) {
      _invMatrixWorld.copy(this.matrixWorld).invert();
      _vector$5
        .setFromMatrixPosition(camera.matrixWorld)
        .applyMatrix4(_invMatrixWorld);
      for (let i = 0, l = visibility.length; i < l; i++) {
        if (visibility[i] && active[i]) {
          this.getMatrixAt(i, _matrix$1);
          this.getBoundingSphereAt(i, _sphere$2).applyMatrix4(_matrix$1);
          let culled = false;
          if (perObjectFrustumCulled) {
            culled = !_frustum.intersectsSphere(_sphere$2);
          }
          if (!culled) {
            const z = _vector$5.distanceTo(_sphere$2.center);
            _renderList.push(drawRanges[i], z);
          }
        }
      }
      const list = _renderList.list;
      const customSort = this.customSort;
      if (customSort === null) {
        list.sort(material.transparent ? sortTransparent : sortOpaque);
      } else {
        customSort.call(this, list, camera);
      }
      for (let i = 0, l = list.length; i < l; i++) {
        const item = list[i];
        multiDrawStarts[count] = item.start * bytesPerElement;
        multiDrawCounts[count] = item.count;
        count++;
      }
      _renderList.reset();
    } else {
      for (let i = 0, l = visibility.length; i < l; i++) {
        if (visibility[i] && active[i]) {
          let culled = false;
          if (perObjectFrustumCulled) {
            this.getMatrixAt(i, _matrix$1);
            this.getBoundingSphereAt(i, _sphere$2).applyMatrix4(_matrix$1);
            culled = !_frustum.intersectsSphere(_sphere$2);
          }
          if (!culled) {
            const range = drawRanges[i];
            multiDrawStarts[count] = range.start * bytesPerElement;
            multiDrawCounts[count] = range.count;
            count++;
          }
        }
      }
    }
    this._multiDrawCount = count;
    this._visibilityChanged = false;
  }
  onBeforeShadow(
    renderer,
    object,
    camera,
    shadowCamera,
    geometry,
    depthMaterial,
  ) {
    this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);
  }
}
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
}
const _start$1 = /* @__PURE__ */ new Vector3$1();
const _end$1 = /* @__PURE__ */ new Vector3$1();
const _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
const _ray$1 = /* @__PURE__ */ new Ray();
const _sphere$1 = /* @__PURE__ */ new Sphere();
class Line extends Object3D {
  constructor(
    geometry = new BufferGeometry(),
    material = new LineBasicMaterial(),
  ) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material)
      ? source.material.slice()
      : source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i = 1, l = positionAttribute.count; i < l; i++) {
        _start$1.fromBufferAttribute(positionAttribute, i - 1);
        _end$1.fromBufferAttribute(positionAttribute, i);
        lineDistances[i] = lineDistances[i - 1];
        lineDistances[i] += _start$1.distanceTo(_end$1);
      }
      geometry.setAttribute(
        "lineDistance",
        new Float32BufferAttribute(lineDistances, 1),
      );
    } else {
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold =
      threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3$1();
    const vEnd = new Vector3$1();
    const interSegment = new Vector3$1();
    const interRay = new Vector3$1();
    const step = this.isLineSegments ? 2 : 1;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i = start, l = end - 1; i < l; i += step) {
        const a = index.getX(i);
        const b = index.getX(i + 1);
        vStart.fromBufferAttribute(positionAttribute, a);
        vEnd.fromBufferAttribute(positionAttribute, b);
        const distSq = _ray$1.distanceSqToSegment(
          vStart,
          vEnd,
          interRay,
          interSegment,
        );
        if (distSq > localThresholdSq) continue;
        interRay.applyMatrix4(this.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far) continue;
        intersects2.push({
          distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i,
          face: null,
          faceIndex: null,
          object: this,
        });
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(
        positionAttribute.count,
        drawRange.start + drawRange.count,
      );
      for (let i = start, l = end - 1; i < l; i += step) {
        vStart.fromBufferAttribute(positionAttribute, i);
        vEnd.fromBufferAttribute(positionAttribute, i + 1);
        const distSq = _ray$1.distanceSqToSegment(
          vStart,
          vEnd,
          interRay,
          interSegment,
        );
        if (distSq > localThresholdSq) continue;
        interRay.applyMatrix4(this.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far) continue;
        intersects2.push({
          distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i,
          face: null,
          faceIndex: null,
          object: this,
        });
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
const _start = /* @__PURE__ */ new Vector3$1();
const _end = /* @__PURE__ */ new Vector3$1();
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
        _start.fromBufferAttribute(positionAttribute, i);
        _end.fromBufferAttribute(positionAttribute, i + 1);
        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
        lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
      }
      geometry.setAttribute(
        "lineDistance",
        new Float32BufferAttribute(lineDistances, 1),
      );
    } else {
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
      );
    }
    return this;
  }
}
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineLoop = true;
    this.type = "LineLoop";
  }
}
class PointsMaterial extends Material {
  constructor(parameters) {
    super();
    this.isPointsMaterial = true;
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
}
const _inverseMatrix = /* @__PURE__ */ new Matrix4();
const _ray$4 = /* @__PURE__ */ new Ray();
const _sphere = /* @__PURE__ */ new Sphere();
const _position$2 = /* @__PURE__ */ new Vector3$1();
class Points extends Object3D {
  constructor(
    geometry = new BufferGeometry(),
    material = new PointsMaterial(),
  ) {
    super();
    this.isPoints = true;
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material)
      ? source.material.slice()
      : source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false) return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray$4.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold =
      threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i = start, il = end; i < il; i++) {
        const a = index.getX(i);
        _position$2.fromBufferAttribute(positionAttribute, a);
        testPoint(
          _position$2,
          a,
          localThresholdSq,
          matrixWorld,
          raycaster,
          intersects2,
          this,
        );
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(
        positionAttribute.count,
        drawRange.start + drawRange.count,
      );
      for (let i = start, l = end; i < l; i++) {
        _position$2.fromBufferAttribute(positionAttribute, i);
        testPoint(
          _position$2,
          i,
          localThresholdSq,
          matrixWorld,
          raycaster,
          intersects2,
          this,
        );
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
}
function testPoint(
  point,
  index,
  localThresholdSq,
  matrixWorld,
  raycaster,
  intersects2,
  object,
) {
  const rayPointDistanceSq = _ray$4.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3$1();
    _ray$4.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object,
    });
  }
}
class VideoTexture extends Texture {
  constructor(
    video,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    format,
    type,
    anisotropy,
  ) {
    super(
      video,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
    );
    this.isVideoTexture = true;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (
      hasVideoFrameCallback === false &&
      video.readyState >= video.HAVE_CURRENT_DATA
    ) {
      this.needsUpdate = true;
    }
  }
}
class FramebufferTexture extends Texture {
  constructor(width, height) {
    super({ width, height });
    this.isFramebufferTexture = true;
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.generateMipmaps = false;
    this.needsUpdate = true;
  }
}
class CompressedTexture extends Texture {
  constructor(
    mipmaps,
    width,
    height,
    format,
    type,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    anisotropy,
    colorSpace,
  ) {
    super(
      null,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
      colorSpace,
    );
    this.isCompressedTexture = true;
    this.image = { width, height };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
}
class CompressedArrayTexture extends CompressedTexture {
  constructor(mipmaps, width, height, depth, format, type) {
    super(mipmaps, width, height, format, type);
    this.isCompressedArrayTexture = true;
    this.image.depth = depth;
    this.wrapR = ClampToEdgeWrapping;
  }
}
class CompressedCubeTexture extends CompressedTexture {
  constructor(images, format, type) {
    super(
      void 0,
      images[0].width,
      images[0].height,
      format,
      type,
      CubeReflectionMapping,
    );
    this.isCompressedCubeTexture = true;
    this.isCubeTexture = true;
    this.image = images;
  }
}
class CanvasTexture extends Texture {
  constructor(
    canvas,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    format,
    type,
    anisotropy,
  ) {
    super(
      canvas,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
    );
    this.isCanvasTexture = true;
    this.needsUpdate = true;
  }
}
class Curve {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === divisions + 1 &&
      !this.needsUpdate
    ) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current,
      last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0,
      high = il - 1,
      comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0) t1 = 0;
    if (t2 > 1) t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent =
      optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3$1());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3$1();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3$1();
    const mat = new Matrix4();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector3$1());
    }
    normals[0] = new Vector3$1();
    binormals[0] = new Vector3$1();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(
          clamp$1(tangents[i - 1].dot(tangents[i]), -1, 1),
        );
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp$1(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (
        tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0
      ) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals,
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON",
      },
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
}
class EllipseCurve extends Curve {
  constructor(
    aX = 0,
    aY = 0,
    xRadius = 1,
    yRadius = 1,
    aStartAngle = 0,
    aEndAngle = Math.PI * 2,
    aClockwise = false,
    aRotation = 0,
  ) {
    super();
    this.isEllipseCurve = true;
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0) deltaAngle += twoPi;
    while (deltaAngle > twoPi) deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y2 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y2 - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y2 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y2);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
}
class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.isArcCurve = true;
    this.type = "ArcCurve";
  }
}
function CubicPoly() {
  let c0 = 0,
    c1 = 0,
    c2 = 0,
    c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function (t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    },
  };
}
const tmp = /* @__PURE__ */ new Vector3$1();
const px = /* @__PURE__ */ new CubicPoly();
const py = /* @__PURE__ */ new CubicPoly();
const pz = /* @__PURE__ */ new CubicPoly();
class CatmullRomCurve3 extends Curve {
  constructor(
    points = [],
    closed = false,
    curveType = "centripetal",
    tension = 0.5,
  ) {
    super();
    this.isCatmullRomCurve3 = true;
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector3$1()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint +=
        intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      if (dt1 < 1e-4) dt1 = 1;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector3$1().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
}
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (
    (2 * p1 - 2 * p2 + v0 + v1) * t3 +
    (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 +
    v0 * t +
    p1
  );
}
function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return (
    QuadraticBezierP0(t, p0) +
    QuadraticBezierP1(t, p1) +
    QuadraticBezierP2(t, p2)
  );
}
function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier$1(t, p0, p1, p2, p3) {
  return (
    CubicBezierP0(t, p0) +
    CubicBezierP1(t, p1) +
    CubicBezierP2(t, p2) +
    CubicBezierP3(t, p3)
  );
}
class CubicBezierCurve extends Curve {
  constructor(
    v0 = new Vector2(),
    v1 = new Vector2(),
    v2 = new Vector2(),
    v3 = new Vector2(),
  ) {
    super();
    this.isCubicBezierCurve = true;
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2,
      v3 = this.v3;
    point.set(
      CubicBezier$1(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier$1(t, v0.y, v1.y, v2.y, v3.y),
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
class CubicBezierCurve3 extends Curve {
  constructor(
    v0 = new Vector3$1(),
    v1 = new Vector3$1(),
    v2 = new Vector3$1(),
    v3 = new Vector3$1(),
  ) {
    super();
    this.isCubicBezierCurve3 = true;
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector3$1()) {
    const point = optionalTarget;
    const v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2,
      v3 = this.v3;
    point.set(
      CubicBezier$1(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier$1(t, v0.y, v1.y, v2.y, v3.y),
      CubicBezier$1(t, v0.z, v1.z, v2.z, v3.z),
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
}
class LineCurve extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.isLineCurve = true;
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector2()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class LineCurve3 extends Curve {
  constructor(v1 = new Vector3$1(), v2 = new Vector3$1()) {
    super();
    this.isLineCurve3 = true;
    this.type = "LineCurve3";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3$1()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector3$1()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.isQuadraticBezierCurve = true;
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y),
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class QuadraticBezierCurve3 extends Curve {
  constructor(
    v0 = new Vector3$1(),
    v1 = new Vector3$1(),
    v2 = new Vector3$1(),
  ) {
    super();
    this.isQuadraticBezierCurve3 = true;
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector3$1()) {
    const point = optionalTarget;
    const v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y),
      QuadraticBezier(t, v0.z, v1.z, v2.z),
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
}
class SplineCurve extends Curve {
  constructor(points = []) {
    super();
    this.isSplineCurve = true;
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 =
      points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 =
      points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(
      CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
      CatmullRom(weight, p0.y, p1.y, p2.y, p3.y),
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
}
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve,
});
class CurvePath extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      const lineType =
        startPoint.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new Curves[lineType](endPoint, startPoint));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t, optionalTarget) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u, optionalTarget);
      }
      i++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve.isEllipseCurve
        ? divisions * 2
        : curve.isLineCurve || curve.isLineCurve3
          ? 1
          : curve.isSplineCurve
            ? divisions * curve.points.length
            : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue;
        points.push(point);
        last = point;
      }
    }
    if (
      this.autoClose &&
      points.length > 1 &&
      !points[points.length - 1].equals(points[0])
    ) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
}
class Path extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  }
  moveTo(x, y2) {
    this.currentPoint.set(x, y2);
    return this;
  }
  lineTo(x, y2) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y2));
    this.curves.push(curve);
    this.currentPoint.set(x, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCPx, aCPy),
      new Vector2(aX, aY),
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCP1x, aCP1y),
      new Vector2(aCP2x, aCP2y),
      new Vector2(aX, aY),
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(
      aX,
      aY,
      aRadius,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise,
    );
    return this;
  }
  ellipse(
    aX,
    aY,
    xRadius,
    yRadius,
    aStartAngle,
    aEndAngle,
    aClockwise,
    aRotation,
  ) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(
      aX + x0,
      aY + y0,
      xRadius,
      yRadius,
      aStartAngle,
      aEndAngle,
      aClockwise,
      aRotation,
    );
    return this;
  }
  absellipse(
    aX,
    aY,
    xRadius,
    yRadius,
    aStartAngle,
    aEndAngle,
    aClockwise,
    aRotation,
  ) {
    const curve = new EllipseCurve(
      aX,
      aY,
      xRadius,
      yRadius,
      aStartAngle,
      aEndAngle,
      aClockwise,
      aRotation,
    );
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(
    points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)],
    segments = 12,
    phiStart = 0,
    phiLength = Math.PI * 2,
  ) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength,
    };
    segments = Math.floor(segments);
    phiLength = clamp$1(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = [];
    const inverseSegments = 1 / segments;
    const vertex2 = new Vector3$1();
    const uv = new Vector2();
    const normal = new Vector3$1();
    const curNormal = new Vector3$1();
    const prevNormal = new Vector3$1();
    let dx = 0;
    let dy = 0;
    for (let j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;
        case points.length - 1:
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;
        default:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    }
    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j = 0; j <= points.length - 1; j++) {
        vertex2.x = points[j].x * sin;
        vertex2.y = points[j].y;
        vertex2.z = points[j].x * cos;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
        const x = initNormals[3 * j + 0] * sin;
        const y2 = initNormals[3 * j + 1];
        const z = initNormals[3 * j + 0] * cos;
        normals.push(x, y2, z);
      }
    }
    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base2 = j + i * points.length;
        const a = base2;
        const b = base2 + points.length;
        const c = base2 + points.length + 1;
        const d = base2 + 1;
        indices.push(a, b, d);
        indices.push(c, d, b);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new LatheGeometry(
      data.points,
      data.segments,
      data.phiStart,
      data.phiLength,
    );
  }
}
class CapsuleGeometry extends LatheGeometry {
  constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
    const path = new Path();
    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
    super(path.getPoints(capSegments), radialSegments);
    this.type = "CapsuleGeometry";
    this.parameters = {
      radius,
      length,
      capSegments,
      radialSegments,
    };
  }
  static fromJSON(data) {
    return new CapsuleGeometry(
      data.radius,
      data.length,
      data.capSegments,
      data.radialSegments,
    );
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(
    radius = 1,
    segments = 32,
    thetaStart = 0,
    thetaLength = Math.PI * 2,
  ) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength,
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3$1();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + (s / segments) * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new CircleGeometry(
      data.radius,
      data.segments,
      data.thetaStart,
      data.thetaLength,
    );
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(
    radiusTop = 1,
    radiusBottom = 1,
    height = 1,
    radialSegments = 32,
    heightSegments = 1,
    openEnded = false,
    thetaStart = 0,
    thetaLength = Math.PI * 2,
  ) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength,
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3$1();
      const vertex2 = new Vector3$1();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y2 = 0; y2 <= heightSegments; y2++) {
        const indexRow = [];
        const v = y2 / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex2.x = radius * sinTheta;
          vertex2.y = -v * height + halfHeight;
          vertex2.z = radius * cosTheta;
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y2 = 0; y2 < heightSegments; y2++) {
          const a = indexArray[y2][x];
          const b = indexArray[y2 + 1][x];
          const c = indexArray[y2 + 1][x + 1];
          const d = indexArray[y2][x + 1];
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex2 = new Vector3$1();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = halfHeight * sign2;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new CylinderGeometry(
      data.radiusTop,
      data.radiusBottom,
      data.height,
      data.radialSegments,
      data.heightSegments,
      data.openEnded,
      data.thetaStart,
      data.thetaLength,
    );
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(
    radius = 1,
    height = 1,
    radialSegments = 32,
    heightSegments = 1,
    openEnded = false,
    thetaStart = 0,
    thetaLength = Math.PI * 2,
  ) {
    super(
      0,
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength,
    );
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength,
    };
  }
  static fromJSON(data) {
    return new ConeGeometry(
      data.radius,
      data.height,
      data.radialSegments,
      data.heightSegments,
      data.openEnded,
      data.thetaStart,
      data.thetaLength,
    );
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail,
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute(
      "normal",
      new Float32BufferAttribute(vertexBuffer.slice(), 3),
    );
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a = new Vector3$1();
      const b = new Vector3$1();
      const c = new Vector3$1();
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a, b, c, detail2);
      }
    }
    function subdivideFace(a, b, c, detail2) {
      const cols = detail2 + 1;
      const v = [];
      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector3$1();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        vertex2.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex2.x;
        vertexBuffer[i + 1] = vertex2.y;
        vertexBuffer[i + 2] = vertex2.z;
      }
    }
    function generateUVs() {
      const vertex2 = new Vector3$1();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
        const v = inclination(vertex2) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1;
          if (x1 < 0.2) uvBuffer[i + 2] += 1;
          if (x2 < 0.2) uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
    }
    function getVertexByIndex(index, vertex2) {
      const stride = index * 3;
      vertex2.x = vertices[stride + 0];
      vertex2.y = vertices[stride + 1];
      vertex2.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a = new Vector3$1();
      const b = new Vector3$1();
      const c = new Vector3$1();
      const centroid = new Vector3$1();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(
        -vector.y,
        Math.sqrt(vector.x * vector.x + vector.z * vector.z),
      );
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new PolyhedronGeometry(
      data.vertices,
      data.indices,
      data.radius,
      data.details,
    );
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      // (±1/φ, ±φ, 0)
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      0,
      // (±φ, 0, ±1/φ)
      -t,
      0,
      -r,
      t,
      0,
      -r,
      -t,
      0,
      r,
      t,
      0,
      r,
    ];
    const indices = [
      3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
      17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0,
      18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18,
      1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5,
      19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5,
      9,
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail,
    };
  }
  static fromJSON(data) {
    return new DodecahedronGeometry(data.radius, data.detail);
  }
}
const _v0 = /* @__PURE__ */ new Vector3$1();
const _v1$1 = /* @__PURE__ */ new Vector3$1();
const _normal = /* @__PURE__ */ new Vector3$1();
const _triangle = /* @__PURE__ */ new Triangle();
class EdgesGeometry extends BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      geometry,
      thresholdAngle,
    };
    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(DEG2RAD$1 * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }
        const { a, b, c } = _triangle;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
        if (
          hashes[0] === hashes[1] ||
          hashes[1] === hashes[2] ||
          hashes[2] === hashes[0]
        ) {
          continue;
        }
        for (let j = 0; j < 3; j++) {
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone(),
            };
          }
        }
      }
      for (const key2 in edgeData) {
        if (edgeData[key2]) {
          const { index0, index1 } = edgeData[key2];
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
}
class Shape extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions),
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
}
const Earcut = {
  triangulate: function (data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x, y2, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y2 = data[i + 1];
        if (x < minX) minX = x;
        if (y2 < minY) minY = y2;
        if (x > maxX) maxX = x;
        if (y2 > maxY) maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  },
};
function linkedList(data, start, end, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start,
    again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear,
    prev,
    next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push((prev.i / dim) | 0);
      triangles.push((ear.i / dim) | 0);
      triangles.push((next.i / dim) | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x,
    bx = b.x,
    cx = c.x,
    ay = a.y,
    by = b.y,
    cy = c.y;
  const x0 = ax < bx ? (ax < cx ? ax : cx) : bx < cx ? bx : cx,
    y0 = ay < by ? (ay < cy ? ay : cy) : by < cy ? by : cy,
    x1 = ax > bx ? (ax > cx ? ax : cx) : bx > cx ? bx : cx,
    y1 = ay > by ? (ay > cy ? ay : cy) : by > cy ? by : cy;
  let p = c.next;
  while (p !== a) {
    if (
      p.x >= x0 &&
      p.x <= x1 &&
      p.y >= y0 &&
      p.y <= y1 &&
      pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
      area(p.prev, p, p.next) >= 0
    )
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev,
    b = ear,
    c = ear.next;
  if (area(a, b, c) >= 0) return false;
  const ax = a.x,
    bx = b.x,
    cx = c.x,
    ay = a.y,
    by = b.y,
    cy = c.y;
  const x0 = ax < bx ? (ax < cx ? ax : cx) : bx < cx ? bx : cx,
    y0 = ay < by ? (ay < cy ? ay : cy) : by < cy ? by : cy,
    x1 = ax > bx ? (ax > cx ? ax : cx) : bx > cx ? bx : cx,
    y1 = ay > by ? (ay > cy ? ay : cy) : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize),
    maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p = ear.prevZ,
    n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (
      p.x >= x0 &&
      p.x <= x1 &&
      p.y >= y0 &&
      p.y <= y1 &&
      p !== a &&
      p !== c &&
      pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
      area(p.prev, p, p.next) >= 0
    )
      return false;
    p = p.prevZ;
    if (
      n.x >= x0 &&
      n.x <= x1 &&
      n.y >= y0 &&
      n.y <= y1 &&
      n !== a &&
      n !== c &&
      pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) &&
      area(n.prev, n, n.next) >= 0
    )
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (
      p.x >= x0 &&
      p.x <= x1 &&
      p.y >= y0 &&
      p.y <= y1 &&
      p !== a &&
      p !== c &&
      pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) &&
      area(p.prev, p, p.next) >= 0
    )
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (
      n.x >= x0 &&
      n.x <= x1 &&
      n.y >= y0 &&
      n.y <= y1 &&
      n !== a &&
      n !== c &&
      pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) &&
      area(n.prev, n, n.next) >= 0
    )
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a = p.prev,
      b = p.next.next;
    if (
      !equals(a, b) &&
      intersects(a, p, p.next, b) &&
      locallyInside(a, b) &&
      locallyInside(b, a)
    ) {
      triangles.push((a.i / dim) | 0);
      triangles.push((p.i / dim) | 0);
      triangles.push((b.i / dim) | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode,
    qx = -Infinity,
    m;
  const hx = hole.x,
    hy = hole.y;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + ((hy - p.y) * (p.next.x - p.x)) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  const stop = m,
    mx = m.x,
    my = m.y;
  let tanMin = Infinity,
    tan;
  p = m;
  do {
    if (
      hx >= p.x &&
      p.x >= mx &&
      hx !== p.x &&
      pointInTriangle(
        hy < my ? hx : qx,
        hy,
        mx,
        my,
        hy < my ? qx : hx,
        hy,
        p.x,
        p.y,
      )
    ) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (
        locallyInside(p, hole) &&
        (tan < tanMin ||
          (tan === tanMin &&
            (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))
      ) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i,
    p,
    q,
    e,
    tail,
    numMerges,
    pSize,
    qSize,
    inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || (qSize > 0 && q)) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;
        else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y2, minX, minY, invSize) {
  x = ((x - minX) * invSize) | 0;
  y2 = ((y2 - minY) * invSize) | 0;
  x = (x | (x << 8)) & 16711935;
  x = (x | (x << 4)) & 252645135;
  x = (x | (x << 2)) & 858993459;
  x = (x | (x << 1)) & 1431655765;
  y2 = (y2 | (y2 << 8)) & 16711935;
  y2 = (y2 | (y2 << 4)) & 252645135;
  y2 = (y2 | (y2 << 2)) & 858993459;
  y2 = (y2 | (y2 << 1)) & 1431655765;
  return x | (y2 << 1);
}
function getLeftmost(start) {
  let p = start,
    leftmost = start;
  do {
    if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y))
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (
    (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) &&
    (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) &&
    (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2)
  );
}
function isValidDiagonal(a, b) {
  return (
    a.next.i !== b.i &&
    a.prev.i !== b.i &&
    !intersectsPolygon(a, b) && // dones't intersect other edges
    ((locallyInside(a, b) &&
      locallyInside(b, a) &&
      middleInside(a, b) && // locally visible
      (area(a.prev, a, b.prev) || area(a, b.prev, b))) || // does not create opposite-facing sectors
      (equals(a, b) &&
        area(a.prev, a, a.next) > 0 &&
        area(b.prev, b, b.next) > 0))
  );
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p, q, r) {
  return (
    q.x <= Math.max(p.x, r.x) &&
    q.x >= Math.min(p.x, r.x) &&
    q.y <= Math.max(p.y, r.y) &&
    q.y >= Math.min(p.y, r.y)
  );
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (
      p.i !== a.i &&
      p.next.i !== a.i &&
      p.i !== b.i &&
      p.next.i !== b.i &&
      intersects(p, p.next, a, b)
    )
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0
    ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0
    : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a,
    inside = false;
  const px2 = (a.x + b.x) / 2,
    py2 = (a.y + b.y) / 2;
  do {
    if (
      p.y > py2 !== p.next.y > py2 &&
      p.next.y !== p.y &&
      px2 < ((p.next.x - p.x) * (py2 - p.y)) / (p.next.y - p.y) + p.x
    )
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y),
    b2 = new Node(b.i, b.x, b.y),
    an = a.next,
    bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y2, last) {
  const p = new Node(i, x, y2);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y2) {
  this.i = i;
  this.x = x;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
class ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a = 0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
}
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(
    shapes = new Shape([
      new Vector2(0.5, 0.5),
      new Vector2(-0.5, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    options = {},
  ) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options,
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments =
        options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      const depth = options.depth !== void 0 ? options.depth : 1;
      let bevelEnabled =
        options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness =
        options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
      let bevelSize =
        options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset =
        options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments =
        options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen =
        options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      let extrudePts,
        extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3$1();
        normal = new Vector3$1();
        position2 = new Vector3$1();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return pt.clone().addScaledVector(vec, size);
      }
      const vlen = vertices.length,
        flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x,
          v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x,
          v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(
            v_next_x * v_next_x + v_next_y * v_next_y,
          );
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf =
            ((ptNextShift_x - ptPrevShift_x) * v_next_y -
              (ptNextShift_y - ptPrevShift_y) * v_next_x) /
            (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (
        let i = 0, il = contour.length, j = il - 1, k = i + 1;
        i < il;
        i++, j++, k++
      ) {
        if (j === il) j = 0;
        if (k === il) k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements,
        verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (
          let i = 0, il = ahole.length, j = il - 1, k = i + 1;
          i < il;
          i++, j++, k++
        ) {
          if (j === il) j = 0;
          if (k === il) k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos((t * Math.PI) / 2);
        const bs2 = bevelSize * Math.sin((t * Math.PI) / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, -z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled
          ? scalePt2(vertices[i], verticesMovements[i], bs)
          : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled
            ? scalePt2(vertices[i], verticesMovements[i], bs)
            : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, (depth / steps) * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos((t * Math.PI) / 2);
        const bs2 = bevelSize * Math.sin((t * Math.PI) / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, depth + z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(
                vert.x,
                vert.y + extrudePts[steps - 1].y,
                extrudePts[steps - 1].x + z,
              );
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(
              face[0] + vlen * steps,
              face[1] + vlen * steps,
              face[2] + vlen * steps,
            );
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0) k = contour2.length - 1;
          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1,
              b = layeroffset + k + slen1,
              c = layeroffset + k + slen2,
              d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }
      function v(x, y2, z) {
        placeholder.push(x);
        placeholder.push(y2);
        placeholder.push(z);
      }
      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(
          scope,
          verticesArray,
          nextIndex - 3,
          nextIndex - 2,
          nextIndex - 1,
        );
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(
          scope,
          verticesArray,
          nextIndex - 6,
          nextIndex - 3,
          nextIndex - 2,
          nextIndex - 1,
        );
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(
        extrudePath,
      );
    }
    return new ExtrudeGeometry(geometryShapes, data.options);
  }
}
const WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y),
    ];
  },
  generateSideWallUV: function (
    geometry,
    vertices,
    indexA,
    indexB,
    indexC,
    indexD,
  ) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z),
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z),
      ];
    }
  },
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  data.options = Object.assign({}, options);
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1,
    ];
    const indices = [
      0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
      10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4,
      9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail,
    };
  }
  static fromJSON(data) {
    return new IcosahedronGeometry(data.radius, data.detail);
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
    const indices = [
      0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail,
    };
  }
  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail);
  }
}
class RingGeometry extends BufferGeometry {
  constructor(
    innerRadius = 0.5,
    outerRadius = 1,
    thetaSegments = 32,
    phiSegments = 1,
    thetaStart = 0,
    thetaLength = Math.PI * 2,
  ) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength,
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex2 = new Vector3$1();
    const uv = new Vector2();
    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        const segment = thetaStart + (i / thetaSegments) * thetaLength;
        vertex2.x = radius * Math.cos(segment);
        vertex2.y = radius * Math.sin(segment);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, 0, 1);
        uv.x = (vertex2.x / outerRadius + 1) / 2;
        uv.y = (vertex2.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);
      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new RingGeometry(
      data.innerRadius,
      data.outerRadius,
      data.thetaSegments,
      data.phiSegments,
      data.thetaStart,
      data.thetaLength,
    );
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(
    shapes = new Shape([
      new Vector2(0, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    curveSegments = 12,
  ) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments,
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex2 = shapeVertices[i];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments);
  }
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
class SphereGeometry extends BufferGeometry {
  constructor(
    radius = 1,
    widthSegments = 32,
    heightSegments = 16,
    phiStart = 0,
    phiLength = Math.PI * 2,
    thetaStart = 0,
    thetaLength = Math.PI,
  ) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength,
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3$1();
    const normal = new Vector3$1();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex2.x =
          -radius *
          Math.cos(phiStart + u * phiLength) *
          Math.sin(thetaStart + v * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex2.z =
          radius *
          Math.sin(phiStart + u * phiLength) *
          Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new SphereGeometry(
      data.radius,
      data.widthSegments,
      data.heightSegments,
      data.phiStart,
      data.phiLength,
      data.thetaStart,
      data.thetaLength,
    );
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
    const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail,
    };
  }
  static fromJSON(data) {
    return new TetrahedronGeometry(data.radius, data.detail);
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(
    radius = 1,
    tube = 0.4,
    radialSegments = 12,
    tubularSegments = 48,
    arc = Math.PI * 2,
  ) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc,
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3$1();
    const vertex2 = new Vector3$1();
    const normal = new Vector3$1();
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = (i / tubularSegments) * arc;
        const v = (j / radialSegments) * Math.PI * 2;
        vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex2.z = tube * Math.sin(v);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex2, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new TorusGeometry(
      data.radius,
      data.tube,
      data.radialSegments,
      data.tubularSegments,
      data.arc,
    );
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(
    radius = 1,
    tube = 0.4,
    tubularSegments = 64,
    radialSegments = 8,
    p = 2,
    q = 3,
  ) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p,
      q,
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3$1();
    const normal = new Vector3$1();
    const P1 = new Vector3$1();
    const P2 = new Vector3$1();
    const B = new Vector3$1();
    const T2 = new Vector3$1();
    const N = new Vector3$1();
    for (let i = 0; i <= tubularSegments; ++i) {
      const u = (i / tubularSegments) * p * Math.PI * 2;
      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
      T2.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T2, N);
      N.crossVectors(B, T2);
      B.normalize();
      N.normalize();
      for (let j = 0; j <= radialSegments; ++j) {
        const v = (j / radialSegments) * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v);
        vertex2.x = P1.x + (cx * N.x + cy * B.x);
        vertex2.y = P1.y + (cx * N.y + cy * B.y);
        vertex2.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.subVectors(vertex2, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u, p2, q2, radius2, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = (q2 / p2) * u;
      const cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new TorusKnotGeometry(
      data.radius,
      data.tube,
      data.tubularSegments,
      data.radialSegments,
      data.p,
      data.q,
    );
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(
    path = new QuadraticBezierCurve3(
      new Vector3$1(-1, -1, 0),
      new Vector3$1(-1, 1, 0),
      new Vector3$1(1, 1, 0),
    ),
    tubularSegments = 64,
    radius = 1,
    radialSegments = 8,
    closed = false,
  ) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed,
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex2 = new Vector3$1();
    const normal = new Vector3$1();
    const uv = new Vector2();
    let P = new Vector3$1();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i) {
      P = path.getPointAt(i / tubularSegments, P);
      const N = frames.normals[i];
      const B = frames.binormals[i];
      for (let j = 0; j <= radialSegments; j++) {
        const v = (j / radialSegments) * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v);
        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex2.x = P.x + radius * normal.x;
        vertex2.y = P.y + radius * normal.y;
        vertex2.z = P.z + radius * normal.z;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }
    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new TubeGeometry(
      new Curves[data.path.type]().fromJSON(data.path),
      data.tubularSegments,
      data.radius,
      data.radialSegments,
      data.closed,
    );
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(geometry = null) {
    super();
    this.type = "WireframeGeometry";
    this.parameters = {
      geometry,
    };
    if (geometry !== null) {
      const vertices = [];
      const edges = /* @__PURE__ */ new Set();
      const start = new Vector3$1();
      const end = new Vector3$1();
      if (geometry.index !== null) {
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o];
          const groupStart = group.start;
          const groupCount = group.count;
          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i + j);
              const index2 = indices.getX(i + ((j + 1) % 3));
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);
              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        const position = geometry.attributes.position;
        for (let i = 0, l = position.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            const index1 = 3 * i + j;
            const index2 = 3 * i + ((j + 1) % 3);
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);
            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
}
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry,
  WireframeGeometry,
});
class ShadowMaterial extends Material {
  constructor(parameters) {
    super();
    this.isShadowMaterial = true;
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.fog = source.fog;
    return this;
  }
}
class RawShaderMaterial extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.isRawShaderMaterial = true;
    this.type = "RawShaderMaterial";
  }
}
class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshStandardMaterial = true;
    this.defines = { STANDARD: "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler$1();
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { STANDARD: "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.envMapIntensity = source.envMapIntensity;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.isMeshPhysicalMaterial = true;
    this.defines = {
      STANDARD: "",
      PHYSICAL: "",
    };
    this.type = "MeshPhysicalMaterial";
    this.anisotropyRotation = 0;
    this.anisotropyMap = null;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function () {
        return clamp$1((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
      },
      set: function (reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      },
    });
    this.iridescenceMap = null;
    this.iridescenceIOR = 1.3;
    this.iridescenceThicknessRange = [100, 400];
    this.iridescenceThicknessMap = null;
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = Infinity;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._anisotropy = 0;
    this._clearcoat = 0;
    this._iridescence = 0;
    this._sheen = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(value) {
    if (this._anisotropy > 0 !== value > 0) {
      this.version++;
    }
    this._anisotropy = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(value) {
    if (this._iridescence > 0 !== value > 0) {
      this.version++;
    }
    this._iridescence = value;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      STANDARD: "",
      PHYSICAL: "",
    };
    this.anisotropy = source.anisotropy;
    this.anisotropyRotation = source.anisotropyRotation;
    this.anisotropyMap = source.anisotropyMap;
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.ior = source.ior;
    this.iridescence = source.iridescence;
    this.iridescenceMap = source.iridescenceMap;
    this.iridescenceIOR = source.iridescenceIOR;
    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
    this.iridescenceThicknessMap = source.iridescenceThicknessMap;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
}
class MeshPhongMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshPhongMaterial = true;
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler$1();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshToonMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshToonMaterial = true;
    this.defines = { TOON: "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
}
class MeshNormalMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshNormalMaterial = true;
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
}
class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshLambertMaterial = true;
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler$1();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class MeshMatcapMaterial extends Material {
  constructor(parameters) {
    super();
    this.isMeshMatcapMaterial = true;
    this.defines = { MATCAP: "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { MATCAP: "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
}
class LineDashedMaterial extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.isLineDashedMaterial = true;
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
}
function convertArray(array, type, forceClone) {
  if (
    !array || // let 'undefined' and 'null' pass
    (!forceClone && array.constructor === type)
  )
    return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
function getKeyframeOrder(times) {
  function compareTime(i, j) {
    return times[i] - times[j];
  }
  const n = times.length;
  const result = new Array(n);
  for (let i = 0; i !== n; ++i) result[i] = i;
  result.sort(compareTime);
  return result;
}
function sortedArray(values, stride, order) {
  const nValues = values.length;
  const result = new values.constructor(nValues);
  for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
    const srcOffset = order[i] * stride;
    for (let j = 0; j !== stride; ++j) {
      result[dstOffset++] = values[srcOffset + j];
    }
  }
  return result;
}
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
  let i = 1,
    key2 = jsonKeys[0];
  while (key2 !== void 0 && key2[valuePropertyName] === void 0) {
    key2 = jsonKeys[i++];
  }
  if (key2 === void 0) return;
  let value = key2[valuePropertyName];
  if (value === void 0) return;
  if (Array.isArray(value)) {
    do {
      value = key2[valuePropertyName];
      if (value !== void 0) {
        times.push(key2.time);
        values.push.apply(values, value);
      }
      key2 = jsonKeys[i++];
    } while (key2 !== void 0);
  } else if (value.toArray !== void 0) {
    do {
      value = key2[valuePropertyName];
      if (value !== void 0) {
        times.push(key2.time);
        value.toArray(values, values.length);
      }
      key2 = jsonKeys[i++];
    } while (key2 !== void 0);
  } else {
    do {
      value = key2[valuePropertyName];
      if (value !== void 0) {
        times.push(key2.time);
        values.push(value);
      }
      key2 = jsonKeys[i++];
    } while (key2 !== void 0);
  }
}
function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
  const clip = sourceClip.clone();
  clip.name = name;
  const tracks = [];
  for (let i = 0; i < clip.tracks.length; ++i) {
    const track = clip.tracks[i];
    const valueSize = track.getValueSize();
    const times = [];
    const values = [];
    for (let j = 0; j < track.times.length; ++j) {
      const frame = track.times[j] * fps;
      if (frame < startFrame || frame >= endFrame) continue;
      times.push(track.times[j]);
      for (let k = 0; k < valueSize; ++k) {
        values.push(track.values[j * valueSize + k]);
      }
    }
    if (times.length === 0) continue;
    track.times = convertArray(times, track.times.constructor);
    track.values = convertArray(values, track.values.constructor);
    tracks.push(track);
  }
  clip.tracks = tracks;
  let minStartTime = Infinity;
  for (let i = 0; i < clip.tracks.length; ++i) {
    if (minStartTime > clip.tracks[i].times[0]) {
      minStartTime = clip.tracks[i].times[0];
    }
  }
  for (let i = 0; i < clip.tracks.length; ++i) {
    clip.tracks[i].shift(-1 * minStartTime);
  }
  clip.resetDuration();
  return clip;
}
function makeClipAdditive(
  targetClip,
  referenceFrame = 0,
  referenceClip = targetClip,
  fps = 30,
) {
  if (fps <= 0) fps = 30;
  const numTracks = referenceClip.tracks.length;
  const referenceTime = referenceFrame / fps;
  for (let i = 0; i < numTracks; ++i) {
    const referenceTrack = referenceClip.tracks[i];
    const referenceTrackType = referenceTrack.ValueTypeName;
    if (referenceTrackType === "bool" || referenceTrackType === "string")
      continue;
    const targetTrack = targetClip.tracks.find(function (track) {
      return (
        track.name === referenceTrack.name &&
        track.ValueTypeName === referenceTrackType
      );
    });
    if (targetTrack === void 0) continue;
    let referenceOffset = 0;
    const referenceValueSize = referenceTrack.getValueSize();
    if (
      referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline
    ) {
      referenceOffset = referenceValueSize / 3;
    }
    let targetOffset = 0;
    const targetValueSize = targetTrack.getValueSize();
    if (
      targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline
    ) {
      targetOffset = targetValueSize / 3;
    }
    const lastIndex = referenceTrack.times.length - 1;
    let referenceValue;
    if (referenceTime <= referenceTrack.times[0]) {
      const startIndex = referenceOffset;
      const endIndex = referenceValueSize - referenceOffset;
      referenceValue = referenceTrack.values.slice(startIndex, endIndex);
    } else if (referenceTime >= referenceTrack.times[lastIndex]) {
      const startIndex = lastIndex * referenceValueSize + referenceOffset;
      const endIndex = startIndex + referenceValueSize - referenceOffset;
      referenceValue = referenceTrack.values.slice(startIndex, endIndex);
    } else {
      const interpolant = referenceTrack.createInterpolant();
      const startIndex = referenceOffset;
      const endIndex = referenceValueSize - referenceOffset;
      interpolant.evaluate(referenceTime);
      referenceValue = interpolant.resultBuffer.slice(startIndex, endIndex);
    }
    if (referenceTrackType === "quaternion") {
      const referenceQuat = new Quaternion$1()
        .fromArray(referenceValue)
        .normalize()
        .conjugate();
      referenceQuat.toArray(referenceValue);
    }
    const numTimes = targetTrack.times.length;
    for (let j = 0; j < numTimes; ++j) {
      const valueStart = j * targetValueSize + targetOffset;
      if (referenceTrackType === "quaternion") {
        Quaternion$1.multiplyQuaternionsFlat(
          targetTrack.values,
          valueStart,
          referenceValue,
          0,
          targetTrack.values,
          valueStart,
        );
      } else {
        const valueEnd = targetValueSize - targetOffset * 2;
        for (let k = 0; k < valueEnd; ++k) {
          targetTrack.values[valueStart + k] -= referenceValue[k];
        }
      }
    }
  }
  targetClip.blendMode = AdditiveAnimationBlendMode;
  return targetClip;
}
const AnimationUtils = {
  convertArray,
  isTypedArray,
  getKeyframeOrder,
  sortedArray,
  flattenJSON,
  subclip,
  makeClipAdditive,
};
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer =
      resultBuffer !== void 0
        ? resultBuffer
        : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex,
      t1 = pp[i1],
      t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan: if (!(t < t1)) {
            for (let giveUpAt = i1 + 2; ; ) {
              if (t1 === void 0) {
                if (t < t0) break forward_scan;
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.copySampleValue_(i1 - 1);
              }
              if (i1 === giveUpAt) break;
              t0 = t1;
              t1 = pp[++i1];
              if (t < t1) {
                break seek;
              }
            }
            right = pp.length;
            break linear_scan;
          }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt) break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = (i1 + right) >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      offset = index * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding,
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2,
      iNext = i1 + 1,
      tPrev = pp[iPrev],
      tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5,
      stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      o1 = i1 * stride,
      o0 = o1 - stride,
      oP = this._offsetPrev,
      oN = this._offsetNext,
      wP = this._weightPrev,
      wN = this._weightNext,
      p = (t - t0) / (t1 - t0),
      pp = p * p,
      ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] =
        sP * values[oP + i] +
        s0 * values[o0 + i] +
        s1 * values[o1 + i] +
        sN * values[oN + i];
    }
    return result;
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      offset1 = i1 * stride,
      offset0 = offset1 - stride,
      weight1 = (t - t0) / (t1 - t0),
      weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
}
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error(
        "THREE.KeyframeTrack: no keyframes in track named " + name,
      );
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        name: track.name,
        times: convertArray(track.times, Array),
        values: convertArray(track.values, Array),
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      result,
    );
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      result,
    );
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      result,
    );
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times = this.times,
      nKeys = times.length;
    let from = 0,
      to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = times.slice(from, to);
      this.values = this.values.slice(from * stride, to * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times,
      values = this.values,
      nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          i,
          currTime,
        );
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error(
          "THREE.KeyframeTrack: Out of order keys.",
          this,
          i,
          currTime,
          prevTime,
        );
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              i,
              value,
            );
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times = this.times.slice(),
      values = this.values.slice(),
      stride = this.getValueSize(),
      smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
      lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride,
            offsetP = offset - stride,
            offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (
              value !== values[offsetP + j] ||
              value !== values[offsetN + j]
            ) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride,
            writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (
        let readOffset = lastIndex * stride,
          writeOffset = writeIndex * stride,
          j = 0;
        j !== stride;
        ++j
      ) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = times.slice(0, writeIndex);
      this.values = values.slice(0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = this.times.slice();
    const values = this.values.slice();
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
class BooleanKeyframeTrack extends KeyframeTrack {}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class ColorKeyframeTrack extends KeyframeTrack {}
ColorKeyframeTrack.prototype.ValueTypeName = "color";
class NumberKeyframeTrack extends KeyframeTrack {}
NumberKeyframeTrack.prototype.ValueTypeName = "number";
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion$1.slerpFlat(
        result,
        0,
        values,
        offset - stride,
        values,
        offset,
        alpha,
      );
    }
    return result;
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      result,
    );
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class StringKeyframeTrack extends KeyframeTrack {}
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
class VectorKeyframeTrack extends KeyframeTrack {}
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
class AnimationClip {
  constructor(
    name,
    duration = -1,
    tracks,
    blendMode = NormalAnimationBlendMode,
  ) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [],
      jsonTracks = json.tracks,
      frameTime = 1 / (json.fps || 1);
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [],
      clipTracks = clip.tracks;
    const json = {
      name: clip.name,
      duration: clip.duration,
      tracks: tracks,
      uuid: clip.uuid,
      blendMode: clip.blendMode,
    };
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i = 0; i < numMorphTargets; i++) {
      let times = [];
      let values = [];
      times.push(
        (i + numMorphTargets - 1) % numMorphTargets,
        i,
        (i + 1) % numMorphTargets,
      );
      values.push(0, 1, 0);
      const order = getKeyframeOrder(times);
      times = sortedArray(times, 1, order);
      values = sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i].name + "]",
          times,
          values,
        ).scale(1 / fps),
      );
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray;
      clipArray = (o.geometry && o.geometry.animations) || o.animations;
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(
        this.CreateFromMorphTargetSequence(
          name,
          animationToMorphTargets[name],
          fps,
          noLoop,
        ),
      );
    }
    return clips;
  }
  // parse the animation.hierarchy format
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function (
      trackType,
      trackName,
      animationKeys,
      propertyName,
      destTracks,
    ) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h = 0; h < hierarchyTracks.length; h++) {
      const animationKeys = hierarchyTracks[h].keys;
      if (!animationKeys || animationKeys.length === 0) continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k;
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(
            new NumberKeyframeTrack(
              ".morphTargetInfluence[" + morphTargetName + "]",
              times,
              values,
            ),
          );
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks,
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks,
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks,
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track = this.tracks[i];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate();
    }
    return valid;
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone());
    }
    return new this.constructor(
      this.name,
      this.duration,
      tracks,
      this.blendMode,
    );
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [],
      values = [];
    flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(
      json.name,
      json.times,
      json.values,
      json.interpolation,
    );
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function (key2, file) {
    if (this.enabled === false) return;
    this.files[key2] = file;
  },
  get: function (key2) {
    if (this.enabled === false) return;
    return this.files[key2];
  },
  remove: function (key2) {
    delete this.files[key2];
  },
  clear: function () {
    this.files = {};
  },
};
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function (url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function (url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function (url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function (url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function (transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function (regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function (regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function (file) {
      for (let i = 0, l = handlers.length; i < l; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global) regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
}
const DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {}
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function (resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {}
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
}
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const loading = {};
class HttpError extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
}
class FileLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad) onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError,
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError,
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin",
      // An abort controller could be added within a future PR
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req)
      .then((response) => {
        if (response.status === 200 || response.status === 0) {
          if (response.status === 0) {
            console.warn("THREE.FileLoader: HTTP Status 0 received.");
          }
          if (
            typeof ReadableStream === "undefined" ||
            response.body === void 0 ||
            response.body.getReader === void 0
          ) {
            return response;
          }
          const callbacks = loading[url];
          const reader = response.body.getReader();
          const contentLength =
            response.headers.get("Content-Length") ||
            response.headers.get("X-File-Size");
          const total = contentLength ? parseInt(contentLength) : 0;
          const lengthComputable = total !== 0;
          let loaded = 0;
          const stream = new ReadableStream({
            start(controller) {
              readData();
              function readData() {
                reader.read().then(({ done, value }) => {
                  if (done) {
                    controller.close();
                  } else {
                    loaded += value.byteLength;
                    const event = new ProgressEvent("progress", {
                      lengthComputable,
                      loaded,
                      total,
                    });
                    for (let i = 0, il = callbacks.length; i < il; i++) {
                      const callback = callbacks[i];
                      if (callback.onProgress) callback.onProgress(event);
                    }
                    controller.enqueue(value);
                    readData();
                  }
                });
              }
            },
          });
          return new Response(stream);
        } else {
          throw new HttpError(
            `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`,
            response,
          );
        }
      })
      .then((response) => {
        switch (responseType) {
          case "arraybuffer":
            return response.arrayBuffer();
          case "blob":
            return response.blob();
          case "document":
            return response.text().then((text) => {
              const parser = new DOMParser();
              return parser.parseFromString(text, mimeType);
            });
          case "json":
            return response.json();
          default:
            if (mimeType === void 0) {
              return response.text();
            } else {
              const re = /charset="?([^;"\s]*)"?/i;
              const exec = re.exec(mimeType);
              const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
              const decoder = new TextDecoder(label);
              return response.arrayBuffer().then((ab) => decoder.decode(ab));
            }
        }
      })
      .then((data) => {
        Cache.add(url, data);
        const callbacks = loading[url];
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onLoad) callback.onLoad(data);
        }
      })
      .catch((err) => {
        const callbacks = loading[url];
        if (callbacks === void 0) {
          this.manager.itemError(url);
          throw err;
        }
        delete loading[url];
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i];
          if (callback.onError) callback.onError(err);
        }
        this.manager.itemError(url);
      })
      .finally(() => {
        this.manager.itemEnd(url);
      });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
}
class AnimationLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(
      url,
      function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      },
      onProgress,
      onError,
    );
  }
  parse(json) {
    const animations = [];
    for (let i = 0; i < json.length; i++) {
      const clip = AnimationClip.parse(json[i]);
      animations.push(clip);
    }
    return animations;
  }
}
class CompressedTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(
        url[i],
        function (buffer) {
          const texDatas = scope.parse(buffer, true);
          images[i] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps,
          };
          loaded += 1;
          if (loaded === 6) {
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
            texture.image = images;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }
        },
        onProgress,
        onError,
      );
    }
    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i);
      }
    } else {
      loader.load(
        url,
        function (buffer) {
          const texDatas = scope.parse(buffer, true);
          if (texDatas.isCubemap) {
            const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
            for (let f = 0; f < faces; f++) {
              images[f] = { mipmaps: [] };
              for (let i = 0; i < texDatas.mipmapCount; i++) {
                images[f].mipmaps.push(
                  texDatas.mipmaps[f * texDatas.mipmapCount + i],
                );
                images[f].format = texDatas.format;
                images[f].width = texDatas.width;
                images[f].height = texDatas.height;
              }
            }
            texture.image = images;
          } else {
            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;
          }
          if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        },
        onProgress,
        onError,
      );
    }
    return texture;
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
}
class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    texture.colorSpace = SRGBColorSpace;
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i) {
      loader.load(
        urls[i],
        function (image) {
          texture.images[i] = image;
          loaded++;
          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }
        },
        void 0,
        onError,
      );
    }
    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i);
    }
    return texture;
  }
}
class DataTextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(
      url,
      function (buffer) {
        let texData;
        try {
          texData = scope.parse(buffer);
        } catch (error) {
          if (onError !== void 0) {
            onError(error);
          } else {
            console.error(error);
            return;
          }
        }
        if (texData.image !== void 0) {
          texture.image = texData.image;
        } else if (texData.data !== void 0) {
          texture.image.width = texData.width;
          texture.image.height = texData.height;
          texture.image.data = texData.data;
        }
        texture.wrapS =
          texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
        texture.wrapT =
          texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
        texture.magFilter =
          texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
        texture.minFilter =
          texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
        texture.anisotropy =
          texData.anisotropy !== void 0 ? texData.anisotropy : 1;
        if (texData.colorSpace !== void 0) {
          texture.colorSpace = texData.colorSpace;
        }
        if (texData.flipY !== void 0) {
          texture.flipY = texData.flipY;
        }
        if (texData.format !== void 0) {
          texture.format = texData.format;
        }
        if (texData.type !== void 0) {
          texture.type = texData.type;
        }
        if (texData.mipmaps !== void 0) {
          texture.mipmaps = texData.mipmaps;
          texture.minFilter = LinearMipmapLinearFilter;
        }
        if (texData.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        if (texData.generateMipmaps !== void 0) {
          texture.generateMipmaps = texData.generateMipmaps;
        }
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture, texData);
      },
      onProgress,
      onError,
    );
    return texture;
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(
      url,
      function (image) {
        texture.image = image;
        texture.needsUpdate = true;
        if (onLoad !== void 0) {
          onLoad(texture);
        }
      },
      onProgress,
      onError,
    );
    return texture;
  }
}
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  dispose() {}
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    return data;
  }
}
class HemisphereLight extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.isHemisphereLight = true;
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.groundColor.copy(source.groundColor);
    return this;
  }
}
const _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld$1 = /* @__PURE__ */ new Vector3$1();
const _lookTarget$1 = /* @__PURE__ */ new Vector3$1();
class LightShadow {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [new Vector4(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(
      shadowCamera.projectionMatrix,
      shadowCamera.matrixWorldInverse,
    );
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1,
    );
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (
      fov2 !== camera.fov ||
      aspect2 !== camera.aspect ||
      far !== camera.far
    ) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
}
class SpotLight extends Light {
  constructor(
    color,
    intensity,
    distance = 0,
    angle = Math.PI / 3,
    penumbra = 0,
    decay = 2,
  ) {
    super(color, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
const _projScreenMatrix = /* @__PURE__ */ new Matrix4();
const _lightPositionWorld = /* @__PURE__ */ new Vector3$1();
const _lookTarget = /* @__PURE__ */ new Vector3$1();
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1),
    ];
    this._cubeDirections = [
      new Vector3$1(1, 0, 0),
      new Vector3$1(-1, 0, 0),
      new Vector3$1(0, 0, 1),
      new Vector3$1(0, 0, -1),
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, -1, 0),
    ];
    this._cubeUps = [
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, 1, 0),
      new Vector3$1(0, 0, 1),
      new Vector3$1(0, 0, -1),
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(
      -_lightPositionWorld.x,
      -_lightPositionWorld.y,
      -_lightPositionWorld.z,
    );
    _projScreenMatrix.multiplyMatrices(
      camera.projectionMatrix,
      camera.matrixWorldInverse,
    );
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
}
class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 2) {
    super(color, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
}
class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
}
class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
}
class RectAreaLight extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.isRectAreaLight = true;
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
}
class SphericalHarmonics3 {
  constructor() {
    this.isSphericalHarmonics3 = true;
    this.coefficients = [];
    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3$1());
    }
  }
  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i]);
    }
    return this;
  }
  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0);
    }
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(normal, target) {
    const x = normal.x,
      y2 = normal.y,
      z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y2);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x);
    target.addScaledVector(coeff[4], 1.092548 * (x * y2));
    target.addScaledVector(coeff[5], 1.092548 * (y2 * z));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x * z));
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y2 * y2));
    return target;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(normal, target) {
    const x = normal.x,
      y2 = normal.y,
      z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y2);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y2 * y2));
    return target;
  }
  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i]);
    }
    return this;
  }
  addScaledSH(sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s);
    }
    return this;
  }
  scale(s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3);
    }
    return array;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(normal, shBasis) {
    const x = normal.x,
      y2 = normal.y,
      z = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y2;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x;
    shBasis[4] = 1.092548 * x * y2;
    shBasis[5] = 1.092548 * y2 * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x * z;
    shBasis[8] = 0.546274 * (x * x - y2 * y2);
  }
}
class LightProbe extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.isLightProbe = true;
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
}
class MaterialLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(
      url,
      function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      },
      onProgress,
      onError,
    );
  }
  parse(json) {
    const textures = this.textures;
    function getTexture(name) {
      if (textures[name] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name);
      }
      return textures[name];
    }
    const material = MaterialLoader.createMaterialFromType(json.type);
    if (json.uuid !== void 0) material.uuid = json.uuid;
    if (json.name !== void 0) material.name = json.name;
    if (json.color !== void 0 && material.color !== void 0)
      material.color.setHex(json.color);
    if (json.roughness !== void 0) material.roughness = json.roughness;
    if (json.metalness !== void 0) material.metalness = json.metalness;
    if (json.sheen !== void 0) material.sheen = json.sheen;
    if (json.sheenColor !== void 0)
      material.sheenColor = new Color().setHex(json.sheenColor);
    if (json.sheenRoughness !== void 0)
      material.sheenRoughness = json.sheenRoughness;
    if (json.emissive !== void 0 && material.emissive !== void 0)
      material.emissive.setHex(json.emissive);
    if (json.specular !== void 0 && material.specular !== void 0)
      material.specular.setHex(json.specular);
    if (json.specularIntensity !== void 0)
      material.specularIntensity = json.specularIntensity;
    if (json.specularColor !== void 0 && material.specularColor !== void 0)
      material.specularColor.setHex(json.specularColor);
    if (json.shininess !== void 0) material.shininess = json.shininess;
    if (json.clearcoat !== void 0) material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== void 0)
      material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.iridescence !== void 0) material.iridescence = json.iridescence;
    if (json.iridescenceIOR !== void 0)
      material.iridescenceIOR = json.iridescenceIOR;
    if (json.iridescenceThicknessRange !== void 0)
      material.iridescenceThicknessRange = json.iridescenceThicknessRange;
    if (json.transmission !== void 0) material.transmission = json.transmission;
    if (json.thickness !== void 0) material.thickness = json.thickness;
    if (json.attenuationDistance !== void 0)
      material.attenuationDistance = json.attenuationDistance;
    if (
      json.attenuationColor !== void 0 &&
      material.attenuationColor !== void 0
    )
      material.attenuationColor.setHex(json.attenuationColor);
    if (json.anisotropy !== void 0) material.anisotropy = json.anisotropy;
    if (json.anisotropyRotation !== void 0)
      material.anisotropyRotation = json.anisotropyRotation;
    if (json.fog !== void 0) material.fog = json.fog;
    if (json.flatShading !== void 0) material.flatShading = json.flatShading;
    if (json.blending !== void 0) material.blending = json.blending;
    if (json.combine !== void 0) material.combine = json.combine;
    if (json.side !== void 0) material.side = json.side;
    if (json.shadowSide !== void 0) material.shadowSide = json.shadowSide;
    if (json.opacity !== void 0) material.opacity = json.opacity;
    if (json.transparent !== void 0) material.transparent = json.transparent;
    if (json.alphaTest !== void 0) material.alphaTest = json.alphaTest;
    if (json.alphaHash !== void 0) material.alphaHash = json.alphaHash;
    if (json.depthFunc !== void 0) material.depthFunc = json.depthFunc;
    if (json.depthTest !== void 0) material.depthTest = json.depthTest;
    if (json.depthWrite !== void 0) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== void 0) material.colorWrite = json.colorWrite;
    if (json.blendSrc !== void 0) material.blendSrc = json.blendSrc;
    if (json.blendDst !== void 0) material.blendDst = json.blendDst;
    if (json.blendEquation !== void 0)
      material.blendEquation = json.blendEquation;
    if (json.blendSrcAlpha !== void 0)
      material.blendSrcAlpha = json.blendSrcAlpha;
    if (json.blendDstAlpha !== void 0)
      material.blendDstAlpha = json.blendDstAlpha;
    if (json.blendEquationAlpha !== void 0)
      material.blendEquationAlpha = json.blendEquationAlpha;
    if (json.blendColor !== void 0 && material.blendColor !== void 0)
      material.blendColor.setHex(json.blendColor);
    if (json.blendAlpha !== void 0) material.blendAlpha = json.blendAlpha;
    if (json.stencilWriteMask !== void 0)
      material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== void 0) material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== void 0) material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== void 0)
      material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== void 0) material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== void 0) material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== void 0) material.stencilZPass = json.stencilZPass;
    if (json.stencilWrite !== void 0) material.stencilWrite = json.stencilWrite;
    if (json.wireframe !== void 0) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== void 0)
      material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== void 0)
      material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== void 0)
      material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== void 0) material.rotation = json.rotation;
    if (json.linewidth !== void 0) material.linewidth = json.linewidth;
    if (json.dashSize !== void 0) material.dashSize = json.dashSize;
    if (json.gapSize !== void 0) material.gapSize = json.gapSize;
    if (json.scale !== void 0) material.scale = json.scale;
    if (json.polygonOffset !== void 0)
      material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== void 0)
      material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== void 0)
      material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.dithering !== void 0) material.dithering = json.dithering;
    if (json.alphaToCoverage !== void 0)
      material.alphaToCoverage = json.alphaToCoverage;
    if (json.premultipliedAlpha !== void 0)
      material.premultipliedAlpha = json.premultipliedAlpha;
    if (json.forceSinglePass !== void 0)
      material.forceSinglePass = json.forceSinglePass;
    if (json.visible !== void 0) material.visible = json.visible;
    if (json.toneMapped !== void 0) material.toneMapped = json.toneMapped;
    if (json.userData !== void 0) material.userData = json.userData;
    if (json.vertexColors !== void 0) {
      if (typeof json.vertexColors === "number") {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    }
    if (json.uniforms !== void 0) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name];
        material.uniforms[name] = {};
        switch (uniform.type) {
          case "t":
            material.uniforms[name].value = getTexture(uniform.value);
            break;
          case "c":
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;
          case "v2":
            material.uniforms[name].value = new Vector2().fromArray(
              uniform.value,
            );
            break;
          case "v3":
            material.uniforms[name].value = new Vector3$1().fromArray(
              uniform.value,
            );
            break;
          case "v4":
            material.uniforms[name].value = new Vector4().fromArray(
              uniform.value,
            );
            break;
          case "m3":
            material.uniforms[name].value = new Matrix3().fromArray(
              uniform.value,
            );
            break;
          case "m4":
            material.uniforms[name].value = new Matrix4().fromArray(
              uniform.value,
            );
            break;
          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }
    if (json.defines !== void 0) material.defines = json.defines;
    if (json.vertexShader !== void 0) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== void 0)
      material.fragmentShader = json.fragmentShader;
    if (json.glslVersion !== void 0) material.glslVersion = json.glslVersion;
    if (json.extensions !== void 0) {
      for (const key2 in json.extensions) {
        material.extensions[key2] = json.extensions[key2];
      }
    }
    if (json.lights !== void 0) material.lights = json.lights;
    if (json.clipping !== void 0) material.clipping = json.clipping;
    if (json.size !== void 0) material.size = json.size;
    if (json.sizeAttenuation !== void 0)
      material.sizeAttenuation = json.sizeAttenuation;
    if (json.map !== void 0) material.map = getTexture(json.map);
    if (json.matcap !== void 0) material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== void 0) material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== void 0) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== void 0) material.bumpScale = json.bumpScale;
    if (json.normalMap !== void 0)
      material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== void 0)
      material.normalMapType = json.normalMapType;
    if (json.normalScale !== void 0) {
      let normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== void 0)
      material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== void 0)
      material.displacementScale = json.displacementScale;
    if (json.displacementBias !== void 0)
      material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== void 0)
      material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== void 0)
      material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== void 0)
      material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== void 0)
      material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== void 0)
      material.specularMap = getTexture(json.specularMap);
    if (json.specularIntensityMap !== void 0)
      material.specularIntensityMap = getTexture(json.specularIntensityMap);
    if (json.specularColorMap !== void 0)
      material.specularColorMap = getTexture(json.specularColorMap);
    if (json.envMap !== void 0) material.envMap = getTexture(json.envMap);
    if (json.envMapRotation !== void 0)
      material.envMapRotation.fromArray(json.envMapRotation);
    if (json.envMapIntensity !== void 0)
      material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== void 0) material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== void 0)
      material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== void 0) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== void 0)
      material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== void 0) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== void 0)
      material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== void 0)
      material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== void 0)
      material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== void 0)
      material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== void 0)
      material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== void 0)
      material.clearcoatNormalScale = new Vector2().fromArray(
        json.clearcoatNormalScale,
      );
    if (json.iridescenceMap !== void 0)
      material.iridescenceMap = getTexture(json.iridescenceMap);
    if (json.iridescenceThicknessMap !== void 0)
      material.iridescenceThicknessMap = getTexture(
        json.iridescenceThicknessMap,
      );
    if (json.transmissionMap !== void 0)
      material.transmissionMap = getTexture(json.transmissionMap);
    if (json.thicknessMap !== void 0)
      material.thicknessMap = getTexture(json.thicknessMap);
    if (json.anisotropyMap !== void 0)
      material.anisotropyMap = getTexture(json.anisotropyMap);
    if (json.sheenColorMap !== void 0)
      material.sheenColorMap = getTexture(json.sheenColorMap);
    if (json.sheenRoughnessMap !== void 0)
      material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
    return material;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
  static createMaterialFromType(type) {
    const materialLib = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material,
    };
    return new materialLib[type]();
  }
}
class LoaderUtils {
  static decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s = "";
    for (let i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i]);
    }
    try {
      return decodeURIComponent(escape(s));
    } catch (e) {
      return s;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1) return "./";
    return url.slice(0, index + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "") return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url)) return url;
    if (/^data:.*,.*$/i.test(url)) return url;
    if (/^blob:.*$/i.test(url)) return url;
    return path + url;
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super();
    this.isInstancedBufferGeometry = true;
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
}
class BufferGeometryLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(
      url,
      function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      },
      onProgress,
      onError,
    );
  }
  parse(json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};
    function getInterleavedBuffer(json2, uuid) {
      if (interleavedBufferMap[uuid] !== void 0)
        return interleavedBufferMap[uuid];
      const interleavedBuffers = json2.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }
    function getArrayBuffer(json2, uuid) {
      if (arrayBufferMap[uuid] !== void 0) return arrayBufferMap[uuid];
      const arrayBuffers = json2.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }
    const geometry = json.isInstancedBufferGeometry
      ? new InstancedBufferGeometry()
      : new BufferGeometry();
    const index = json.data.index;
    if (index !== void 0) {
      const typedArray = getTypedArray(index.type, index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }
    const attributes = json.data.attributes;
    for (const key2 in attributes) {
      const attribute = attributes[key2];
      let bufferAttribute;
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(
          json.data,
          attribute.data,
        );
        bufferAttribute = new InterleavedBufferAttribute(
          interleavedBuffer,
          attribute.itemSize,
          attribute.offset,
          attribute.normalized,
        );
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute
          ? InstancedBufferAttribute
          : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(
          typedArray,
          attribute.itemSize,
          attribute.normalized,
        );
      }
      if (attribute.name !== void 0) bufferAttribute.name = attribute.name;
      if (attribute.usage !== void 0) bufferAttribute.setUsage(attribute.usage);
      geometry.setAttribute(key2, bufferAttribute);
    }
    const morphAttributes = json.data.morphAttributes;
    if (morphAttributes) {
      for (const key2 in morphAttributes) {
        const attributeArray = morphAttributes[key2];
        const array = [];
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(
              json.data,
              attribute.data,
            );
            bufferAttribute = new InterleavedBufferAttribute(
              interleavedBuffer,
              attribute.itemSize,
              attribute.offset,
              attribute.normalized,
            );
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute = new BufferAttribute(
              typedArray,
              attribute.itemSize,
              attribute.normalized,
            );
          }
          if (attribute.name !== void 0) bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }
        geometry.morphAttributes[key2] = array;
      }
    }
    const morphTargetsRelative = json.data.morphTargetsRelative;
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }
    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups !== void 0) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    const boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== void 0) {
      const center = new Vector3$1();
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  }
}
class ObjectLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(
      url,
      function (text) {
        let json = null;
        try {
          json = JSON.parse(text);
        } catch (error) {
          if (onError !== void 0) onError(error);
          console.error(
            "THREE:ObjectLoader: Can't parse " + url + ".",
            error.message,
          );
          return;
        }
        const metadata2 = json.metadata;
        if (
          metadata2 === void 0 ||
          metadata2.type === void 0 ||
          metadata2.type.toLowerCase() === "geometry"
        ) {
          if (onError !== void 0)
            onError(new Error("THREE.ObjectLoader: Can't load " + url));
          console.error("THREE.ObjectLoader: Can't load " + url);
          return;
        }
        scope.parse(json, onLoad);
      },
      onProgress,
      onError,
    );
  }
  async loadAsync(url, onProgress) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    const text = await loader.loadAsync(url, onProgress);
    const json = JSON.parse(text);
    const metadata2 = json.metadata;
    if (
      metadata2 === void 0 ||
      metadata2.type === void 0 ||
      metadata2.type.toLowerCase() === "geometry"
    ) {
      throw new Error("THREE.ObjectLoader: Can't load " + url);
    }
    return await scope.parseAsync(json);
  }
  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function () {
      if (onLoad !== void 0) onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(
      json.object,
      geometries,
      materials,
      textures,
      animations,
    );
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    if (onLoad !== void 0) {
      let hasImages = false;
      for (const uuid in images) {
        if (images[uuid].data instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }
      if (hasImages === false) onLoad(object);
    }
    return object;
  }
  async parseAsync(json) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries = this.parseGeometries(json.geometries, shapes);
    const images = await this.parseImagesAsync(json.images);
    const textures = this.parseTextures(json.textures, images);
    const materials = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(
      json.object,
      geometries,
      materials,
      textures,
      animations,
    );
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    return object;
  }
  parseShapes(json) {
    const shapes = {};
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const shape = new Shape().fromJSON(json[i]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  }
  parseSkeletons(json, object) {
    const skeletons = {};
    const bones = {};
    object.traverse(function (child) {
      if (child.isBone) bones[child.uuid] = child;
    });
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const skeleton = new Skeleton().fromJSON(json[i], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }
    return skeletons;
  }
  parseGeometries(json, shapes) {
    const geometries = {};
    if (json !== void 0) {
      const bufferGeometryLoader = new BufferGeometryLoader();
      for (let i = 0, l = json.length; i < l; i++) {
        let geometry;
        const data = json[i];
        switch (data.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            geometry = bufferGeometryLoader.parse(data);
            break;
          default:
            if (data.type in Geometries) {
              geometry = Geometries[data.type].fromJSON(data, shapes);
            } else {
              console.warn(
                `THREE.ObjectLoader: Unsupported geometry type "${data.type}"`,
              );
            }
        }
        geometry.uuid = data.uuid;
        if (data.name !== void 0) geometry.name = data.name;
        if (data.userData !== void 0) geometry.userData = data.userData;
        geometries[data.uuid] = geometry;
      }
    }
    return geometries;
  }
  parseMaterials(json, textures) {
    const cache = {};
    const materials = {};
    if (json !== void 0) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (cache[data.uuid] === void 0) {
          cache[data.uuid] = loader.parse(data);
        }
        materials[data.uuid] = cache[data.uuid];
      }
    }
    return materials;
  }
  parseAnimations(json) {
    const animations = {};
    if (json !== void 0) {
      for (let i = 0; i < json.length; i++) {
        const data = json[i];
        const clip = AnimationClip.parse(data);
        animations[clip.uuid] = clip;
      }
    }
    return animations;
  }
  parseImages(json, onLoad) {
    const scope = this;
    const images = {};
    let loader;
    function loadImage2(url) {
      scope.manager.itemStart(url);
      return loader.load(
        url,
        function () {
          scope.manager.itemEnd(url);
        },
        void 0,
        function () {
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        },
      );
    }
    function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url)
          ? url
          : scope.resourcePath + url;
        return loadImage2(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height,
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(
                  new DataTexture(
                    deserializedImage.data,
                    deserializedImage.width,
                    deserializedImage.height,
                  ),
                );
              }
            }
          }
          images[image.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = deserializeImage(image.url);
          images[image.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  async parseImagesAsync(json) {
    const scope = this;
    const images = {};
    let loader;
    async function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url)
          ? url
          : scope.resourcePath + url;
        return await loader.loadAsync(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height,
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i];
        const url = image.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = await deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(
                  new DataTexture(
                    deserializedImage.data,
                    deserializedImage.width,
                    deserializedImage.height,
                  ),
                );
              }
            }
          }
          images[image.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = await deserializeImage(image.url);
          images[image.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === "number") return value;
      console.warn(
        "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
        value,
      );
      return type[value];
    }
    const textures = {};
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        if (data.image === void 0) {
          console.warn(
            'THREE.ObjectLoader: No "image" specified for',
            data.uuid,
          );
        }
        if (images[data.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data.image);
        }
        const source = images[data.image];
        const image = source.data;
        let texture;
        if (Array.isArray(image)) {
          texture = new CubeTexture();
          if (image.length === 6) texture.needsUpdate = true;
        } else {
          if (image && image.data) {
            texture = new DataTexture();
          } else {
            texture = new Texture();
          }
          if (image) texture.needsUpdate = true;
        }
        texture.source = source;
        texture.uuid = data.uuid;
        if (data.name !== void 0) texture.name = data.name;
        if (data.mapping !== void 0)
          texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.channel !== void 0) texture.channel = data.channel;
        if (data.offset !== void 0) texture.offset.fromArray(data.offset);
        if (data.repeat !== void 0) texture.repeat.fromArray(data.repeat);
        if (data.center !== void 0) texture.center.fromArray(data.center);
        if (data.rotation !== void 0) texture.rotation = data.rotation;
        if (data.wrap !== void 0) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.format !== void 0) texture.format = data.format;
        if (data.internalFormat !== void 0)
          texture.internalFormat = data.internalFormat;
        if (data.type !== void 0) texture.type = data.type;
        if (data.colorSpace !== void 0) texture.colorSpace = data.colorSpace;
        if (data.minFilter !== void 0)
          texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== void 0)
          texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== void 0) texture.anisotropy = data.anisotropy;
        if (data.flipY !== void 0) texture.flipY = data.flipY;
        if (data.generateMipmaps !== void 0)
          texture.generateMipmaps = data.generateMipmaps;
        if (data.premultiplyAlpha !== void 0)
          texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== void 0)
          texture.unpackAlignment = data.unpackAlignment;
        if (data.compareFunction !== void 0)
          texture.compareFunction = data.compareFunction;
        if (data.userData !== void 0) texture.userData = data.userData;
        textures[data.uuid] = texture;
      }
    }
    return textures;
  }
  parseObject(data, geometries, materials, textures, animations) {
    let object;
    function getGeometry(name) {
      if (geometries[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name);
      }
      return geometries[name];
    }
    function getMaterial(name) {
      if (name === void 0) return void 0;
      if (Array.isArray(name)) {
        const array = [];
        for (let i = 0, l = name.length; i < l; i++) {
          const uuid = name[i];
          if (materials[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid);
          }
          array.push(materials[uuid]);
        }
        return array;
      }
      if (materials[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name);
      }
      return materials[name];
    }
    function getTexture(uuid) {
      if (textures[uuid] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined texture", uuid);
      }
      return textures[uuid];
    }
    let geometry, material;
    switch (data.type) {
      case "Scene":
        object = new Scene();
        if (data.background !== void 0) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          } else {
            object.background = getTexture(data.background);
          }
        }
        if (data.environment !== void 0) {
          object.environment = getTexture(data.environment);
        }
        if (data.fog !== void 0) {
          if (data.fog.type === "Fog") {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === "FogExp2") {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
          if (data.fog.name !== "") {
            object.fog.name = data.fog.name;
          }
        }
        if (data.backgroundBlurriness !== void 0)
          object.backgroundBlurriness = data.backgroundBlurriness;
        if (data.backgroundIntensity !== void 0)
          object.backgroundIntensity = data.backgroundIntensity;
        if (data.backgroundRotation !== void 0)
          object.backgroundRotation.fromArray(data.backgroundRotation);
        if (data.environmentRotation !== void 0)
          object.environmentRotation.fromArray(data.environmentRotation);
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(
          data.fov,
          data.aspect,
          data.near,
          data.far,
        );
        if (data.focus !== void 0) object.focus = data.focus;
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.filmGauge !== void 0) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== void 0) object.filmOffset = data.filmOffset;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(
          data.left,
          data.right,
          data.top,
          data.bottom,
          data.near,
          data.far,
        );
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data.color, data.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data.color, data.intensity);
        break;
      case "PointLight":
        object = new PointLight(
          data.color,
          data.intensity,
          data.distance,
          data.decay,
        );
        break;
      case "RectAreaLight":
        object = new RectAreaLight(
          data.color,
          data.intensity,
          data.width,
          data.height,
        );
        break;
      case "SpotLight":
        object = new SpotLight(
          data.color,
          data.intensity,
          data.distance,
          data.angle,
          data.penumbra,
          data.decay,
        );
        break;
      case "HemisphereLight":
        object = new HemisphereLight(
          data.color,
          data.groundColor,
          data.intensity,
        );
        break;
      case "LightProbe":
        object = new LightProbe().fromJSON(data);
        break;
      case "SkinnedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new SkinnedMesh(geometry, material);
        if (data.bindMode !== void 0) object.bindMode = data.bindMode;
        if (data.bindMatrix !== void 0)
          object.bindMatrix.fromArray(data.bindMatrix);
        if (data.skeleton !== void 0) object.skeleton = data.skeleton;
        break;
      case "Mesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;
      case "InstancedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        const instanceColor = data.instanceColor;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new InstancedBufferAttribute(
          new Float32Array(instanceMatrix.array),
          16,
        );
        if (instanceColor !== void 0)
          object.instanceColor = new InstancedBufferAttribute(
            new Float32Array(instanceColor.array),
            instanceColor.itemSize,
          );
        break;
      case "BatchedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new BatchedMesh(
          data.maxGeometryCount,
          data.maxVertexCount,
          data.maxIndexCount,
          material,
        );
        object.geometry = geometry;
        object.perObjectFrustumCulled = data.perObjectFrustumCulled;
        object.sortObjects = data.sortObjects;
        object._drawRanges = data.drawRanges;
        object._reservedRanges = data.reservedRanges;
        object._visibility = data.visibility;
        object._active = data.active;
        object._bounds = data.bounds.map((bound) => {
          const box = new Box3();
          box.min.fromArray(bound.boxMin);
          box.max.fromArray(bound.boxMax);
          const sphere = new Sphere();
          sphere.radius = bound.sphereRadius;
          sphere.center.fromArray(bound.sphereCenter);
          return {
            boxInitialized: bound.boxInitialized,
            box,
            sphereInitialized: bound.sphereInitialized,
            sphere,
          };
        });
        object._maxGeometryCount = data.maxGeometryCount;
        object._maxVertexCount = data.maxVertexCount;
        object._maxIndexCount = data.maxIndexCount;
        object._geometryInitialized = data.geometryInitialized;
        object._geometryCount = data.geometryCount;
        object._matricesTexture = getTexture(data.matricesTexture.uuid);
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(
          getGeometry(data.geometry),
          getMaterial(data.material),
        );
        break;
      case "LineLoop":
        object = new LineLoop(
          getGeometry(data.geometry),
          getMaterial(data.material),
        );
        break;
      case "LineSegments":
        object = new LineSegments(
          getGeometry(data.geometry),
          getMaterial(data.material),
        );
        break;
      case "PointCloud":
      case "Points":
        object = new Points(
          getGeometry(data.geometry),
          getMaterial(data.material),
        );
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data.material));
        break;
      case "Group":
        object = new Group();
        break;
      case "Bone":
        object = new Bone();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== void 0) object.name = data.name;
    if (data.matrix !== void 0) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== void 0)
        object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate)
        object.matrix.decompose(
          object.position,
          object.quaternion,
          object.scale,
        );
    } else {
      if (data.position !== void 0) object.position.fromArray(data.position);
      if (data.rotation !== void 0) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== void 0)
        object.quaternion.fromArray(data.quaternion);
      if (data.scale !== void 0) object.scale.fromArray(data.scale);
    }
    if (data.up !== void 0) object.up.fromArray(data.up);
    if (data.castShadow !== void 0) object.castShadow = data.castShadow;
    if (data.receiveShadow !== void 0)
      object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
      if (data.shadow.bias !== void 0) object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== void 0)
        object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== void 0)
        object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== void 0)
        object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== void 0)
        object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== void 0) object.visible = data.visible;
    if (data.frustumCulled !== void 0)
      object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== void 0) object.renderOrder = data.renderOrder;
    if (data.userData !== void 0) object.userData = data.userData;
    if (data.layers !== void 0) object.layers.mask = data.layers;
    if (data.children !== void 0) {
      const children = data.children;
      for (let i = 0; i < children.length; i++) {
        object.add(
          this.parseObject(
            children[i],
            geometries,
            materials,
            textures,
            animations,
          ),
        );
      }
    }
    if (data.animations !== void 0) {
      const objectAnimations = data.animations;
      for (let i = 0; i < objectAnimations.length; i++) {
        const uuid = objectAnimations[i];
        object.animations.push(animations[uuid]);
      }
    }
    if (data.type === "LOD") {
      if (data.autoUpdate !== void 0) object.autoUpdate = data.autoUpdate;
      const levels = data.levels;
      for (let l = 0; l < levels.length; l++) {
        const level = levels[l];
        const child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance, level.hysteresis);
        }
      }
    }
    return object;
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0) return;
    object.traverse(function (child) {
      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
        const skeleton = skeletons[child.skeleton];
        if (skeleton === void 0) {
          console.warn(
            "THREE.ObjectLoader: No skeleton found with UUID:",
            child.skeleton,
          );
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }
}
const TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping,
};
const TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping,
};
const TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter,
};
class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.isImageBitmapLoader = true;
    if (typeof createImageBitmap === "undefined") {
      console.warn(
        "THREE.ImageBitmapLoader: createImageBitmap() not supported.",
      );
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options) {
    this.options = options;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      if (cached.then) {
        cached
          .then((imageBitmap) => {
            if (onLoad) onLoad(imageBitmap);
            scope.manager.itemEnd(url);
          })
          .catch((e) => {
            if (onError) onError(e);
          });
        return;
      }
      setTimeout(function () {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    const promise = fetch(url, fetchOptions)
      .then(function (res) {
        return res.blob();
      })
      .then(function (blob) {
        return createImageBitmap(
          blob,
          Object.assign(scope.options, { colorSpaceConversion: "none" }),
        );
      })
      .then(function (imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad) onLoad(imageBitmap);
        scope.manager.itemEnd(url);
        return imageBitmap;
      })
      .catch(function (e) {
        if (onError) onError(e);
        Cache.remove(url);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    Cache.add(url, promise);
    scope.manager.itemStart(url);
  }
}
let _context;
class AudioContext {
  static getContext() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  }
  static setContext(value) {
    _context = value;
  }
}
class AudioLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(
      url,
      function (buffer) {
        try {
          const bufferCopy = buffer.slice(0);
          const context = AudioContext.getContext();
          context
            .decodeAudioData(bufferCopy, function (audioBuffer) {
              onLoad(audioBuffer);
            })
            .catch(handleError);
        } catch (e) {
          handleError(e);
        }
      },
      onProgress,
      onError,
    );
    function handleError(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }
      scope.manager.itemError(url);
    }
  }
}
const _eyeRight = /* @__PURE__ */ new Matrix4();
const _eyeLeft = /* @__PURE__ */ new Matrix4();
const _projectionMatrix = /* @__PURE__ */ new Matrix4();
class StereoCamera {
  constructor() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null,
    };
  }
  update(camera) {
    const cache = this._cache;
    const needsUpdate =
      cache.focus !== camera.focus ||
      cache.fov !== camera.fov ||
      cache.aspect !== camera.aspect * this.aspect ||
      cache.near !== camera.near ||
      cache.far !== camera.far ||
      cache.zoom !== camera.zoom ||
      cache.eyeSep !== this.eyeSep;
    if (needsUpdate) {
      cache.focus = camera.focus;
      cache.fov = camera.fov;
      cache.aspect = camera.aspect * this.aspect;
      cache.near = camera.near;
      cache.far = camera.far;
      cache.zoom = camera.zoom;
      cache.eyeSep = this.eyeSep;
      _projectionMatrix.copy(camera.projectionMatrix);
      const eyeSepHalf = cache.eyeSep / 2;
      const eyeSepOnProjection = (eyeSepHalf * cache.near) / cache.focus;
      const ymax =
        (cache.near * Math.tan(DEG2RAD$1 * cache.fov * 0.5)) / cache.zoom;
      let xmin, xmax;
      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf;
      xmin = -ymax * cache.aspect + eyeSepOnProjection;
      xmax = ymax * cache.aspect + eyeSepOnProjection;
      _projectionMatrix.elements[0] = (2 * cache.near) / (xmax - xmin);
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(_projectionMatrix);
      xmin = -ymax * cache.aspect - eyeSepOnProjection;
      xmax = ymax * cache.aspect - eyeSepOnProjection;
      _projectionMatrix.elements[0] = (2 * cache.near) / (xmax - xmin);
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(_projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
}
class Clock {
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
}
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
const _position$1 = /* @__PURE__ */ new Vector3$1();
const _quaternion$1 = /* @__PURE__ */ new Quaternion$1();
const _scale$1 = /* @__PURE__ */ new Vector3$1();
const _orientation$1 = /* @__PURE__ */ new Vector3$1();
class AudioListener extends Object3D {
  constructor() {
    super();
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
    _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
      listener.setOrientation(
        _orientation$1.x,
        _orientation$1.y,
        _orientation$1.z,
        up.x,
        up.y,
        up.z,
      );
    }
  }
}
class Audio extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay) this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress +=
        Math.max(this.context.currentTime - this._startedAt, 0) *
        this.playbackRate;
      if (this.loop === true) {
        this._progress =
          this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    if (this.source !== null) {
      this.source.stop();
      this.source.onended = null;
    }
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this._connected === false) {
      return;
    }
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value) value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.isPlaying === true && this.source.detune !== void 0) {
      this.source.detune.setTargetAtTime(
        this.detune,
        this.context.currentTime,
        0.01,
      );
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(
        this.playbackRate,
        this.context.currentTime,
        0.01,
      );
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
}
const _position = /* @__PURE__ */ new Vector3$1();
const _quaternion = /* @__PURE__ */ new Quaternion$1();
const _scale = /* @__PURE__ */ new Vector3$1();
const _orientation = /* @__PURE__ */ new Vector3$1();
class PositionalAudio extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  connect() {
    super.connect();
    this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect();
    this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(_position, _quaternion, _scale);
    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const panner = this.panner;
    if (panner.positionX) {
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
    } else {
      panner.setPosition(_position.x, _position.y, _position.z);
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
    }
  }
}
class AudioAnalyser {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i = 0; i < data.length; i++) {
      value += data[i];
    }
    return value / data.length;
  }
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(accuIndex, weight) {
    const buffer = this.buffer,
      stride = this.valueSize,
      offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(weight) {
    const buffer = this.buffer,
      stride = this.valueSize,
      offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(accuIndex) {
    const stride = this.valueSize,
      buffer = this.buffer,
      offset = accuIndex * stride + stride,
      weight = this.cumulativeWeight,
      weightAdditive = this.cumulativeWeightAdditive,
      binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(
        buffer,
        offset,
        originalValueOffset,
        1 - weight,
        stride,
      );
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(
        buffer,
        offset,
        this._addIndex * stride,
        1,
        stride,
      );
    }
    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer,
      stride = this.valueSize,
      originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + (i % stride)];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i];
    }
  }
  // mix functions
  _select(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t) {
    Quaternion$1.slerpFlat(
      buffer,
      dstOffset,
      buffer,
      dstOffset,
      buffer,
      srcOffset,
      t,
    );
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion$1.multiplyQuaternionsFlat(
      buffer,
      workOffset,
      buffer,
      dstOffset,
      buffer,
      srcOffset,
    );
    Quaternion$1.slerpFlat(
      buffer,
      dstOffset,
      buffer,
      dstOffset,
      buffer,
      workOffset,
      t,
    );
  }
  _lerp(buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t;
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i;
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
const _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
const _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
const _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
const _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace(
  "WC",
  _wordChar,
);
const _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace(
  "WCOD",
  _wordCharOrDot,
);
const _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
  "WC",
  _wordChar,
);
const _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace(
  "WC",
  _wordChar,
);
const _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$",
);
const _supportedObjectNames = ["material", "materials", "bones", "map"];
class Composite {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath =
      optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_,
      binding = this._bindings[firstValidIndex];
    if (binding !== void 0) binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (
      let i = this._targetGroup.nCachedObjects_, n = bindings.length;
      i !== n;
      ++i
    ) {
      bindings[i].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (
      let i = this._targetGroup.nCachedObjects_, n = bindings.length;
      i !== n;
      ++i
    ) {
      bindings[i].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (
      let i = this._targetGroup.nCachedObjects_, n = bindings.length;
      i !== n;
      ++i
    ) {
      bindings[i].unbind();
    }
  }
}
class PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath);
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (matches === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6],
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " +
          trackName,
      );
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (
      nodeName === void 0 ||
      nodeName === "" ||
      nodeName === "." ||
      nodeName === -1 ||
      nodeName === root.name ||
      nodeName === root.uuid
    ) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function (children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  // Getters
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  // Direct
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = PropertyBinding.findNode(
        this.rootNode,
        parsedPath.nodeName,
      );
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          ".",
      );
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!targetObject.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this,
            );
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this,
            );
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        case "map":
          if ("map" in targetObject) {
            targetObject = targetObject.map;
            break;
          }
          if (!targetObject.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this,
            );
            return;
          }
          if (!targetObject.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this,
            );
            return;
          }
          targetObject = targetObject.material.map;
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this,
            );
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            targetObject,
          );
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          nodeName +
          "." +
          propertyName +
          " but it wasn't found.",
        targetObject,
      );
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this,
          );
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this,
          );
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (
      nodeProperty.fromArray !== void 0 &&
      nodeProperty.toArray !== void 0
    ) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue =
      this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
}
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray,
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class AnimationObjectGroup {
  constructor() {
    this.isAnimationObjectGroup = true;
    this.uuid = generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      },
    };
  }
  add() {
    const objects = this._objects,
      indicesByUUID = this._indicesByUUID,
      paths = this._paths,
      parsedPaths = this._parsedPaths,
      bindings = this._bindings,
      nBindings = bindings.length;
    let knownObject = void 0,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
        uuid = object.uuid;
      let index = indicesByUUID[uuid];
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object);
        for (let j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(
            new PropertyBinding(object, paths[j], parsedPaths[j]),
          );
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        const firstActiveIndex = --nCachedObjects,
          lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
            lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error(
          "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.",
        );
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects,
      indicesByUUID = this._indicesByUUID,
      bindings = this._bindings,
      nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
        uuid = object.uuid,
        index = indicesByUUID[uuid];
      if (index !== void 0 && index >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++,
          firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
            firstActive = bindingsForPath[lastCachedIndex],
            binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // remove & forget
  uncache() {
    const objects = this._objects,
      indicesByUUID = this._indicesByUUID,
      bindings = this._bindings,
      nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_,
      nObjects = objects.length;
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
        uuid = object.uuid,
        index = indicesByUUID[uuid];
      if (index !== void 0) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects,
            lastCachedObject = objects[firstActiveIndex],
            lastIndex = --nObjects,
            lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j],
              lastCached = bindingsForPath[firstActiveIndex],
              last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects,
            lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }
          objects[index] = lastObject;
          objects.pop();
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== void 0) return bindings[index];
    const paths = this._paths,
      parsedPaths = this._parsedPaths,
      objects = this._objects,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_,
      bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i];
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath,
      index = indicesByPath[path];
    if (index !== void 0) {
      const paths = this._paths,
        parsedPaths = this._parsedPaths,
        bindings = this._bindings,
        lastBindingsIndex = bindings.length - 1,
        lastBindings = bindings[lastBindingsIndex],
        lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
}
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks,
      nTracks = tracks.length,
      interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding,
    };
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  // State & Scheduling
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration,
        fadeOutDuration = fadeOutAction._clip.duration,
        startEndRatio = fadeOutDuration / fadeInDuration,
        endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer,
      now2 = mixer.time,
      timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions,
      values = interpolant.sampleValues;
    times[0] = now2;
    times[1] = now2 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        deltaTime = 0;
      } else {
        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop2 = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop2 === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop2 === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished) this.paused = true;
        else this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1,
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished) this.paused = true;
          else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1,
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta,
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings;
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding;
      settings.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart
          ? ZeroSlopeEnding
          : ZeroCurvatureEnding;
      } else {
        settings.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd
          ? ZeroSlopeEnding
          : ZeroCurvatureEnding;
      } else {
        settings.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer,
      now2 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions,
      values = interpolant.sampleValues;
    times[0] = now2;
    values[0] = weightNow;
    times[1] = now2 + duration;
    values[1] = weightThen;
    return this;
  }
}
const _controlInterpolantsResultBuffer = new Float32Array(1);
class AnimationMixer extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root,
      tracks = action._clip.tracks,
      nTracks = tracks.length,
      bindings = action._propertyBindings,
      interpolants = action._interpolants,
      rootUuid = root.uuid,
      bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track = tracks[i],
        trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        ++binding.referenceCount;
        bindings[i] = binding;
      } else {
        binding = bindings[i];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path =
          prototypeAction &&
          prototypeAction._propertyBindings[i].binding.parsedPath;
        binding = new PropertyMixer(
          PropertyBinding.create(root, trackName, path),
          track.ValueTypeName,
          track.getValueSize(),
        );
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i] = binding;
      }
      interpolants[i].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid,
          clipUuid = action._clip.uuid,
          actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(
          action,
          actionsForClip && actionsForClip.knownActions[0],
        );
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        },
      },
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions,
      actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {},
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions.length;
    actions.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions = this._actions,
      lastInactiveAction = actions[actions.length - 1],
      cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions[cacheIndex] = lastInactiveAction;
    actions.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid,
      actionsByClip = this._actionsByClip,
      actionsForClip = actionsByClip[clipUuid],
      knownActionsForClip = actionsForClip.knownActions,
      lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
      byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot,
      rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions,
      prevIndex = action._cacheIndex,
      lastActiveIndex = this._nActiveActions++,
      firstInactiveAction = actions[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions = this._actions,
      prevIndex = action._cacheIndex,
      firstInactiveIndex = --this._nActiveActions,
      lastActiveAction = actions[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions[prevIndex] = lastActiveAction;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName,
      bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings,
      propBinding = binding.binding,
      rootUuid = propBinding.rootNode.uuid,
      trackName = propBinding.path,
      bindingsByRoot = this._bindingsByRootAndName,
      bindingByName = bindingsByRoot[rootUuid],
      lastInactiveBinding = bindings[bindings.length - 1],
      cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings,
      prevIndex = binding._cacheIndex,
      lastActiveIndex = this._nActiveBindings++,
      firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings,
      prevIndex = binding._cacheIndex,
      firstInactiveIndex = --this._nActiveBindings,
      lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants,
      lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(
        new Float32Array(2),
        new Float32Array(2),
        1,
        _controlInterpolantsResultBuffer,
      );
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants,
      prevIndex = interpolant.__cacheIndex,
      firstInactiveIndex = --this._nActiveControlInterpolants,
      lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root,
      rootUuid = root.uuid;
    let clipObject =
      typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null) clipObject = prototypeAction._clip;
    }
    if (clipObject === null) return null;
    const newAction = new AnimationAction(
      this,
      clipObject,
      optionalRoot,
      blendMode,
    );
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  // get an existing action
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root,
      rootUuid = root.uuid,
      clipObject =
        typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip,
      clipUuid = clipObject ? clipObject.uuid : clip,
      actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const actions = this._actions,
      nActions = this._nActiveActions;
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop();
    }
    return this;
  }
  // advance the time and update apply the animation
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions = this._actions,
      nActions = this._nActiveActions,
      time = (this.time += deltaTime),
      timeDirection = Math.sign(deltaTime),
      accuIndex = (this._accuIndex ^= 1);
    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings,
      nBindings = this._nActiveBindings;
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex);
    }
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0;
    }
    return this.update(timeInSeconds);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(clip) {
    const actions = this._actions,
      clipUuid = clip.uuid,
      actionsByClip = this._actionsByClip,
      actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex,
          lastInactiveAction = actions[actions.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(root) {
    const rootUuid = root.uuid,
      actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot,
        action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName,
      bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  // remove a targeted clip from the cache
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
}
class Uniform {
  constructor(value) {
    this.value = value;
  }
  clone() {
    return new Uniform(
      this.value.clone === void 0 ? this.value : this.value.clone(),
    );
  }
}
let _id = 0;
class UniformsGroup extends EventDispatcher {
  constructor() {
    super();
    this.isUniformsGroup = true;
    Object.defineProperty(this, "id", { value: _id++ });
    this.name = "";
    this.usage = StaticDrawUsage;
    this.uniforms = [];
  }
  add(uniform) {
    this.uniforms.push(uniform);
    return this;
  }
  remove(uniform) {
    const index = this.uniforms.indexOf(uniform);
    if (index !== -1) this.uniforms.splice(index, 1);
    return this;
  }
  setName(name) {
    this.name = name;
    return this;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.usage = source.usage;
    const uniformsSource = source.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, l = uniformsSource.length; i < l; i++) {
      const uniforms = Array.isArray(uniformsSource[i])
        ? uniformsSource[i]
        : [uniformsSource[i]];
      for (let j = 0; j < uniforms.length; j++) {
        this.uniforms.push(uniforms[j].clone());
      }
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride);
    this.isInstancedInterleavedBuffer = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
}
class GLBufferAttribute {
  constructor(buffer, type, itemSize, elementSize, count) {
    this.isGLBufferAttribute = true;
    this.name = "";
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setBuffer(buffer) {
    this.buffer = buffer;
    return this;
  }
  setType(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  }
  setItemSize(itemSize) {
    this.itemSize = itemSize;
    return this;
  }
  setCount(count) {
    this.count = count;
    return this;
  }
}
const _matrix = /* @__PURE__ */ new Matrix4();
class Raycaster {
  constructor(origin, direction, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {},
    };
  }
  set(origin, direction) {
    this.ray.set(origin, direction);
  }
  setFromCamera(coords, camera) {
    if (camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction
        .set(coords.x, coords.y, 0.5)
        .unproject(camera)
        .sub(this.ray.origin)
        .normalize();
      this.camera = camera;
    } else if (camera.isOrthographicCamera) {
      this.ray.origin
        .set(
          coords.x,
          coords.y,
          (camera.near + camera.far) / (camera.near - camera.far),
        )
        .unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  }
  setFromXRController(controller) {
    _matrix.identity().extractRotation(controller.matrixWorld);
    this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
    return this;
  }
  intersectObject(object, recursive = true, intersects2 = []) {
    intersect(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  }
  intersectObjects(objects, recursive = true, intersects2 = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersect(objects[i], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
}
function ascSort(a, b) {
  return a.distance - b.distance;
}
function intersect(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      intersect(children[i], raycaster, intersects2, true);
    }
  }
}
class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y2, z) {
    this.radius = Math.sqrt(x * x + y2 * y2 + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x, z);
      this.phi = Math.acos(clamp$1(y2 / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Cylindrical {
  constructor(radius = 1, theta = 0, y2 = 0) {
    this.radius = radius;
    this.theta = theta;
    this.y = y2;
    return this;
  }
  set(radius, theta, y2) {
    this.radius = radius;
    this.theta = theta;
    this.y = y2;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z);
  }
  setFromCartesianCoords(x, y2, z) {
    this.radius = Math.sqrt(x * x + z * z);
    this.theta = Math.atan2(x, z);
    this.y = y2;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$4 = /* @__PURE__ */ new Vector2();
class Box2 {
  constructor(
    min = new Vector2(Infinity, Infinity),
    max = new Vector2(-Infinity, -Infinity),
  ) {
    this.isBox2 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    return this.isEmpty()
      ? target.set(0, 0)
      : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty()
      ? target.set(0, 0)
      : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x ||
      point.x > this.max.x ||
      point.y < this.min.y ||
      point.y > this.max.y
      ? false
      : true;
  }
  containsBox(box) {
    return (
      this.min.x <= box.min.x &&
      box.max.x <= this.max.x &&
      this.min.y <= box.min.y &&
      box.max.y <= this.max.y
    );
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x ||
      box.min.x > this.max.x ||
      box.max.y < this.min.y ||
      box.min.y > this.max.y
      ? false
      : true;
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$4).distanceTo(point);
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
}
const _startP = /* @__PURE__ */ new Vector3$1();
const _startEnd = /* @__PURE__ */ new Vector3$1();
class Line3 {
  constructor(start = new Vector3$1(), end = new Vector3$1()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target) {
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = clamp$1(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const _vector$3 = /* @__PURE__ */ new Vector3$1();
class SpotLightHelper extends Object3D {
  constructor(light, color) {
    super();
    this.light = light;
    this.matrixAutoUpdate = false;
    this.color = color;
    this.type = "SpotLightHelper";
    const geometry = new BufferGeometry();
    const positions = [
      0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
      0, 0, 0, 0, -1, 1,
    ];
    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p1 = (i / l) * Math.PI * 2;
      const p2 = (j / l) * Math.PI * 2;
      positions.push(
        Math.cos(p1),
        Math.sin(p1),
        1,
        Math.cos(p2),
        Math.sin(p2),
        1,
      );
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }
  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    this.light.target.updateWorldMatrix(true, false);
    if (this.parent) {
      this.parent.updateWorldMatrix(true);
      this.matrix
        .copy(this.parent.matrixWorld)
        .invert()
        .multiply(this.light.matrixWorld);
    } else {
      this.matrix.copy(this.light.matrixWorld);
    }
    this.matrixWorld.copy(this.light.matrixWorld);
    const coneLength = this.light.distance ? this.light.distance : 1e3;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$3);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }
}
const _vector$2 = /* @__PURE__ */ new Vector3$1();
const _boneMatrix = /* @__PURE__ */ new Matrix4();
const _matrixWorldInv = /* @__PURE__ */ new Matrix4();
class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors2 = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors2.push(color1.r, color1.g, color1.b);
        colors2.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      depthTest: false,
      depthWrite: false,
      toneMapped: false,
      transparent: true,
    });
    super(geometry, material);
    this.isSkeletonHelper = true;
    this.type = "SkeletonHelper";
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
function getBoneList(object) {
  const boneList = [];
  if (object.isBone === true) {
    boneList.push(object);
  }
  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]));
  }
  return boneList;
}
class PointLightHelper extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false,
    });
    super(geometry, material);
    this.light = light;
    this.color = color;
    this.type = "PointLightHelper";
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  }
}
const _vector$1 = /* @__PURE__ */ new Vector3$1();
const _color1 = /* @__PURE__ */ new Color();
const _color2 = /* @__PURE__ */ new Color();
class HemisphereLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    this.type = "HemisphereLightHelper";
    const geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false,
    });
    if (this.color === void 0) this.material.vertexColors = true;
    const position = geometry.getAttribute("position");
    const colors2 = new Float32Array(position.count * 3);
    geometry.setAttribute("color", new BufferAttribute(colors2, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }
  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
  update() {
    const mesh = this.children[0];
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      const colors2 = mesh.geometry.getAttribute("color");
      _color1.copy(this.light.color);
      _color2.copy(this.light.groundColor);
      for (let i = 0, l = colors2.count; i < l; i++) {
        const color = i < l / 2 ? _color1 : _color2;
        colors2.setXYZ(i, color.r, color.g, color.b);
      }
      colors2.needsUpdate = true;
    }
    this.light.updateWorldMatrix(true, false);
    mesh.lookAt(
      _vector$1.setFromMatrixPosition(this.light.matrixWorld).negate(),
    );
  }
}
class GridHelper extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [],
      colors2 = [];
    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      const color = i === center ? color1 : color2;
      color.toArray(colors2, j);
      j += 3;
      color.toArray(colors2, j);
      j += 3;
      color.toArray(colors2, j);
      j += 3;
      color.toArray(colors2, j);
      j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false,
    });
    super(geometry, material);
    this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class PolarGridHelper extends LineSegments {
  constructor(
    radius = 10,
    sectors = 16,
    rings = 8,
    divisions = 64,
    color1 = 4473924,
    color2 = 8947848,
  ) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const vertices = [];
    const colors2 = [];
    if (sectors > 1) {
      for (let i = 0; i < sectors; i++) {
        const v = (i / sectors) * (Math.PI * 2);
        const x = Math.sin(v) * radius;
        const z = Math.cos(v) * radius;
        vertices.push(0, 0, 0);
        vertices.push(x, 0, z);
        const color = i & 1 ? color1 : color2;
        colors2.push(color.r, color.g, color.b);
        colors2.push(color.r, color.g, color.b);
      }
    }
    for (let i = 0; i < rings; i++) {
      const color = i & 1 ? color1 : color2;
      const r = radius - (radius / rings) * i;
      for (let j = 0; j < divisions; j++) {
        let v = (j / divisions) * (Math.PI * 2);
        let x = Math.sin(v) * r;
        let z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors2.push(color.r, color.g, color.b);
        v = ((j + 1) / divisions) * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors2.push(color.r, color.g, color.b);
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false,
    });
    super(geometry, material);
    this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
const _v1 = /* @__PURE__ */ new Vector3$1();
const _v2 = /* @__PURE__ */ new Vector3$1();
const _v3 = /* @__PURE__ */ new Vector3$1();
class DirectionalLightHelper extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    this.type = "DirectionalLightHelper";
    if (size === void 0) size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute(
      "position",
      new Float32BufferAttribute(
        [
          -size,
          size,
          0,
          size,
          size,
          0,
          size,
          -size,
          0,
          -size,
          -size,
          0,
          -size,
          size,
          0,
        ],
        3,
      ),
    );
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute(
      "position",
      new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3),
    );
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    this.light.target.updateWorldMatrix(true, false);
    _v1.setFromMatrixPosition(this.light.matrixWorld);
    _v2.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3.subVectors(_v2, _v1);
    this.lightPlane.lookAt(_v2);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2);
    this.targetLine.scale.z = _v3.length();
  }
}
const _vector = /* @__PURE__ */ new Vector3$1();
const _camera = /* @__PURE__ */ new Camera();
class CameraHelper extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({
      color: 16777215,
      vertexColors: true,
      toneMapped: false,
    });
    const vertices = [];
    const colors2 = [];
    const pointMap = {};
    addLine("n1", "n2");
    addLine("n2", "n4");
    addLine("n4", "n3");
    addLine("n3", "n1");
    addLine("f1", "f2");
    addLine("f2", "f4");
    addLine("f4", "f3");
    addLine("f3", "f1");
    addLine("n1", "f1");
    addLine("n2", "f2");
    addLine("n3", "f3");
    addLine("n4", "f4");
    addLine("p", "n1");
    addLine("p", "n2");
    addLine("p", "n3");
    addLine("p", "n4");
    addLine("u1", "u2");
    addLine("u2", "u3");
    addLine("u3", "u1");
    addLine("c", "t");
    addLine("p", "c");
    addLine("cn1", "cn2");
    addLine("cn3", "cn4");
    addLine("cf1", "cf2");
    addLine("cf3", "cf4");
    function addLine(a, b) {
      addPoint(a);
      addPoint(b);
    }
    function addPoint(id) {
      vertices.push(0, 0, 0);
      colors2.push(0, 0, 0);
      if (pointMap[id] === void 0) {
        pointMap[id] = [];
      }
      pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    super(geometry, material);
    this.type = "CameraHelper";
    this.camera = camera;
    if (this.camera.updateProjectionMatrix)
      this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
    const colorFrustum = new Color(16755200);
    const colorCone = new Color(16711680);
    const colorUp = new Color(43775);
    const colorTarget = new Color(16777215);
    const colorCross = new Color(3355443);
    this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
  }
  setColors(frustum, cone, up, target, cross) {
    const geometry = this.geometry;
    const colorAttribute = geometry.getAttribute("color");
    colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(25, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(27, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(29, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(31, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(32, up.r, up.g, up.b);
    colorAttribute.setXYZ(33, up.r, up.g, up.b);
    colorAttribute.setXYZ(34, up.r, up.g, up.b);
    colorAttribute.setXYZ(35, up.r, up.g, up.b);
    colorAttribute.setXYZ(36, up.r, up.g, up.b);
    colorAttribute.setXYZ(37, up.r, up.g, up.b);
    colorAttribute.setXYZ(38, target.r, target.g, target.b);
    colorAttribute.setXYZ(39, target.r, target.g, target.b);
    colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(41, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(43, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(45, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(47, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(49, cross.r, cross.g, cross.b);
    colorAttribute.needsUpdate = true;
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w = 1,
      h = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
    setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
    setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
    setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
    setPoint("n4", pointMap, geometry, _camera, w, h, -1);
    setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
    setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
    setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
    setPoint("f4", pointMap, geometry, _camera, w, h, 1);
    setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
    setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
    setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
    setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
    setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
    setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
    setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
    setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
    setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
function setPoint(point, pointMap, geometry, camera, x, y2, z) {
  _vector.set(x, y2, z).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry.getAttribute("position");
    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
    }
  }
}
const _box = /* @__PURE__ */ new Box3();
class BoxHelper extends LineSegments {
  constructor(object, color = 16776960) {
    const indices = new Uint16Array([
      0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
    ]);
    const positions = new Float32Array(8 * 3);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.object = object;
    this.type = "BoxHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update(object) {
    if (object !== void 0) {
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    }
    if (this.object !== void 0) {
      _box.setFromObject(this.object);
    }
    if (_box.isEmpty()) return;
    const min = _box.min;
    const max = _box.max;
    const position = this.geometry.attributes.position;
    const array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }
  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.object = source.object;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class Box3Helper extends LineSegments {
  constructor(box, color = 16776960) {
    const indices = new Uint16Array([
      0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
    ]);
    const positions = [
      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
      1, -1, -1,
    ];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.box = box;
    this.type = "Box3Helper";
    this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class PlaneHelper extends Line {
  constructor(plane, size = 1, hex = 16776960) {
    const color = hex;
    const positions = [
      1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1,
      1, 0,
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.type = "PlaneHelper";
    this.plane = plane;
    this.size = size;
    const positions2 = [
      1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0,
    ];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute(
      "position",
      new Float32BufferAttribute(positions2, 3),
    );
    geometry2.computeBoundingSphere();
    this.add(
      new Mesh(
        geometry2,
        new MeshBasicMaterial({
          color,
          opacity: 0.2,
          transparent: true,
          depthWrite: false,
          toneMapped: false,
        }),
      ),
    );
  }
  updateMatrixWorld(force) {
    this.position.set(0, 0, 0);
    this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
    this.lookAt(this.plane.normal);
    this.translateZ(-this.plane.constant);
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
}
const _axis = /* @__PURE__ */ new Vector3$1();
let _lineGeometry, _coneGeometry;
class ArrowHelper extends Object3D {
  // dir is assumed to be normalized
  constructor(
    dir = new Vector3$1(0, 0, 1),
    origin = new Vector3$1(0, 0, 0),
    length = 1,
    color = 16776960,
    headLength = length * 0.2,
    headWidth = headLength * 0.2,
  ) {
    super();
    this.type = "ArrowHelper";
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute(
        "position",
        new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3),
      );
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(
      _lineGeometry,
      new LineBasicMaterial({ color, toneMapped: false }),
    );
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(
      _coneGeometry,
      new MeshBasicMaterial({ color, toneMapped: false }),
    );
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }
  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  }
  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
  dispose() {
    this.line.geometry.dispose();
    this.line.material.dispose();
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
}
class AxesHelper extends LineSegments {
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
    ];
    const colors2 = [
      1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1,
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors2, 3));
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false,
    });
    super(geometry, material);
    this.type = "AxesHelper";
  }
  setColors(xAxisColor, yAxisColor, zAxisColor) {
    const color = new Color();
    const array = this.geometry.attributes.color.array;
    color.set(xAxisColor);
    color.toArray(array, 0);
    color.toArray(array, 3);
    color.set(yAxisColor);
    color.toArray(array, 6);
    color.toArray(array, 9);
    color.set(zAxisColor);
    color.toArray(array, 12);
    color.toArray(array, 15);
    this.geometry.attributes.color.needsUpdate = true;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
}
class ShapePath {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(x, y2) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x, y2);
    return this;
  }
  lineTo(x, y2) {
    this.currentPath.lineTo(x, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }
  toShapes(isCCW) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = [];
      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath2 = inSubpaths[i];
        const tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;
      let inside = false;
      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
        let edgeLowPt = inPolygon[p];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true;
          } else {
            const perpEdge =
              edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true;
            if (perpEdge < 0) continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y) continue;
          if (
            (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x) ||
            (edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
          )
            return true;
        }
      }
      return inside;
    }
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
      }
    }
    if (!newShapes[0]) return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      let toChange = 0;
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange++;
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange > 0 && ambiguous === false) {
        newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i];
      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  }
}
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  // @deprecated, r162
  constructor(width = 1, height = 1, count = 1, options = {}) {
    console.warn(
      'THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.',
    );
    super(width, height, { ...options, count });
    this.isWebGLMultipleRenderTargets = true;
  }
  get texture() {
    return this.textures;
  }
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", {
      detail: {
        revision: REVISION,
      },
    }),
  );
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}
const THREE = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping,
      AddEquation,
      AddOperation,
      AdditiveAnimationBlendMode,
      AdditiveBlending,
      AgXToneMapping,
      AlphaFormat,
      AlwaysCompare,
      AlwaysDepth,
      AlwaysStencilFunc,
      AmbientLight,
      AnimationAction,
      AnimationClip,
      AnimationLoader,
      AnimationMixer,
      AnimationObjectGroup,
      AnimationUtils,
      ArcCurve,
      ArrayCamera,
      ArrowHelper,
      AttachedBindMode,
      Audio,
      AudioAnalyser,
      AudioContext,
      AudioListener,
      AudioLoader,
      AxesHelper,
      BackSide,
      BasicDepthPacking,
      BasicShadowMap,
      BatchedMesh,
      Bone,
      BooleanKeyframeTrack,
      Box2,
      Box3,
      Box3Helper,
      BoxGeometry,
      BoxHelper,
      BufferAttribute,
      BufferGeometry,
      BufferGeometryLoader,
      ByteType,
      Cache,
      Camera,
      CameraHelper,
      CanvasTexture,
      CapsuleGeometry,
      CatmullRomCurve3,
      CineonToneMapping,
      CircleGeometry,
      ClampToEdgeWrapping,
      Clock,
      Color,
      ColorKeyframeTrack,
      ColorManagement,
      CompressedArrayTexture,
      CompressedCubeTexture,
      CompressedTexture,
      CompressedTextureLoader,
      ConeGeometry,
      ConstantAlphaFactor,
      ConstantColorFactor,
      CubeCamera,
      CubeReflectionMapping,
      CubeRefractionMapping,
      CubeTexture,
      CubeTextureLoader,
      CubeUVReflectionMapping,
      CubicBezierCurve,
      CubicBezierCurve3,
      CubicInterpolant,
      CullFaceBack,
      CullFaceFront,
      CullFaceFrontBack,
      CullFaceNone,
      Curve,
      CurvePath,
      CustomBlending,
      CustomToneMapping,
      CylinderGeometry,
      Cylindrical,
      Data3DTexture,
      DataArrayTexture,
      DataTexture,
      DataTextureLoader,
      DataUtils,
      DecrementStencilOp,
      DecrementWrapStencilOp,
      DefaultLoadingManager,
      DepthFormat,
      DepthStencilFormat,
      DepthTexture,
      DetachedBindMode,
      DirectionalLight,
      DirectionalLightHelper,
      DiscreteInterpolant,
      DisplayP3ColorSpace,
      DodecahedronGeometry,
      DoubleSide,
      DstAlphaFactor,
      DstColorFactor,
      DynamicCopyUsage,
      DynamicDrawUsage,
      DynamicReadUsage,
      EdgesGeometry,
      EllipseCurve,
      EqualCompare,
      EqualDepth,
      EqualStencilFunc,
      EquirectangularReflectionMapping,
      EquirectangularRefractionMapping,
      Euler: Euler$1,
      EventDispatcher,
      ExtrudeGeometry,
      FileLoader,
      Float16BufferAttribute,
      Float32BufferAttribute,
      FloatType,
      Fog,
      FogExp2,
      FramebufferTexture,
      FrontSide,
      Frustum,
      GLBufferAttribute,
      GLSL1,
      GLSL3,
      GreaterCompare,
      GreaterDepth,
      GreaterEqualCompare,
      GreaterEqualDepth,
      GreaterEqualStencilFunc,
      GreaterStencilFunc,
      GridHelper,
      Group,
      HalfFloatType,
      HemisphereLight,
      HemisphereLightHelper,
      IcosahedronGeometry,
      ImageBitmapLoader,
      ImageLoader,
      ImageUtils,
      IncrementStencilOp,
      IncrementWrapStencilOp,
      InstancedBufferAttribute,
      InstancedBufferGeometry,
      InstancedInterleavedBuffer,
      InstancedMesh,
      Int16BufferAttribute,
      Int32BufferAttribute,
      Int8BufferAttribute,
      IntType,
      InterleavedBuffer,
      InterleavedBufferAttribute,
      Interpolant,
      InterpolateDiscrete,
      InterpolateLinear,
      InterpolateSmooth,
      InvertStencilOp,
      KeepStencilOp,
      KeyframeTrack,
      LOD,
      LatheGeometry,
      Layers,
      LessCompare,
      LessDepth,
      LessEqualCompare,
      LessEqualDepth,
      LessEqualStencilFunc,
      LessStencilFunc,
      Light,
      LightProbe,
      Line,
      Line3,
      LineBasicMaterial,
      LineCurve,
      LineCurve3,
      LineDashedMaterial,
      LineLoop,
      LineSegments,
      LinearDisplayP3ColorSpace,
      LinearFilter,
      LinearInterpolant,
      LinearMipMapLinearFilter,
      LinearMipMapNearestFilter,
      LinearMipmapLinearFilter,
      LinearMipmapNearestFilter,
      LinearSRGBColorSpace,
      LinearToneMapping,
      LinearTransfer,
      Loader,
      LoaderUtils,
      LoadingManager,
      LoopOnce,
      LoopPingPong,
      LoopRepeat,
      LuminanceAlphaFormat,
      LuminanceFormat,
      MOUSE,
      Material,
      MaterialLoader,
      MathUtils,
      Matrix3,
      Matrix4,
      MaxEquation,
      Mesh,
      MeshBasicMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshLambertMaterial,
      MeshMatcapMaterial,
      MeshNormalMaterial,
      MeshPhongMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshToonMaterial,
      MinEquation,
      MirroredRepeatWrapping,
      MixOperation,
      MultiplyBlending,
      MultiplyOperation,
      NearestFilter,
      NearestMipMapLinearFilter,
      NearestMipMapNearestFilter,
      NearestMipmapLinearFilter,
      NearestMipmapNearestFilter,
      NeutralToneMapping,
      NeverCompare,
      NeverDepth,
      NeverStencilFunc,
      NoBlending,
      NoColorSpace,
      NoToneMapping,
      NormalAnimationBlendMode,
      NormalBlending,
      NotEqualCompare,
      NotEqualDepth,
      NotEqualStencilFunc,
      NumberKeyframeTrack,
      Object3D,
      ObjectLoader,
      ObjectSpaceNormalMap,
      OctahedronGeometry,
      OneFactor,
      OneMinusConstantAlphaFactor,
      OneMinusConstantColorFactor,
      OneMinusDstAlphaFactor,
      OneMinusDstColorFactor,
      OneMinusSrcAlphaFactor,
      OneMinusSrcColorFactor,
      OrthographicCamera,
      P3Primaries,
      PCFShadowMap,
      PCFSoftShadowMap,
      PMREMGenerator,
      Path,
      PerspectiveCamera,
      Plane,
      PlaneGeometry,
      PlaneHelper,
      PointLight,
      PointLightHelper,
      Points,
      PointsMaterial,
      PolarGridHelper,
      PolyhedronGeometry,
      PositionalAudio,
      PropertyBinding,
      PropertyMixer,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      Quaternion: Quaternion$1,
      QuaternionKeyframeTrack,
      QuaternionLinearInterpolant,
      RED_GREEN_RGTC2_Format,
      RED_RGTC1_Format,
      REVISION,
      RGBADepthPacking,
      RGBAFormat,
      RGBAIntegerFormat,
      RGBA_ASTC_10x10_Format,
      RGBA_ASTC_10x5_Format,
      RGBA_ASTC_10x6_Format,
      RGBA_ASTC_10x8_Format,
      RGBA_ASTC_12x10_Format,
      RGBA_ASTC_12x12_Format,
      RGBA_ASTC_4x4_Format,
      RGBA_ASTC_5x4_Format,
      RGBA_ASTC_5x5_Format,
      RGBA_ASTC_6x5_Format,
      RGBA_ASTC_6x6_Format,
      RGBA_ASTC_8x5_Format,
      RGBA_ASTC_8x6_Format,
      RGBA_ASTC_8x8_Format,
      RGBA_BPTC_Format,
      RGBA_ETC2_EAC_Format,
      RGBA_PVRTC_2BPPV1_Format,
      RGBA_PVRTC_4BPPV1_Format,
      RGBA_S3TC_DXT1_Format,
      RGBA_S3TC_DXT3_Format,
      RGBA_S3TC_DXT5_Format,
      RGB_BPTC_SIGNED_Format,
      RGB_BPTC_UNSIGNED_Format,
      RGB_ETC1_Format,
      RGB_ETC2_Format,
      RGB_PVRTC_2BPPV1_Format,
      RGB_PVRTC_4BPPV1_Format,
      RGB_S3TC_DXT1_Format,
      RGFormat,
      RGIntegerFormat,
      RawShaderMaterial,
      Ray,
      Raycaster,
      Rec709Primaries,
      RectAreaLight,
      RedFormat,
      RedIntegerFormat,
      ReinhardToneMapping,
      RenderTarget,
      RepeatWrapping,
      ReplaceStencilOp,
      ReverseSubtractEquation,
      RingGeometry,
      SIGNED_RED_GREEN_RGTC2_Format,
      SIGNED_RED_RGTC1_Format,
      SRGBColorSpace,
      SRGBTransfer,
      Scene,
      ShaderChunk,
      ShaderLib,
      ShaderMaterial,
      ShadowMaterial,
      Shape,
      ShapeGeometry,
      ShapePath,
      ShapeUtils,
      ShortType,
      Skeleton,
      SkeletonHelper,
      SkinnedMesh,
      Source,
      Sphere,
      SphereGeometry,
      Spherical,
      SphericalHarmonics3,
      SplineCurve,
      SpotLight,
      SpotLightHelper,
      Sprite,
      SpriteMaterial,
      SrcAlphaFactor,
      SrcAlphaSaturateFactor,
      SrcColorFactor,
      StaticCopyUsage,
      StaticDrawUsage,
      StaticReadUsage,
      StereoCamera,
      StreamCopyUsage,
      StreamDrawUsage,
      StreamReadUsage,
      StringKeyframeTrack,
      SubtractEquation,
      SubtractiveBlending,
      TOUCH,
      TangentSpaceNormalMap,
      TetrahedronGeometry,
      Texture,
      TextureLoader,
      TorusGeometry,
      TorusKnotGeometry,
      Triangle,
      TriangleFanDrawMode,
      TriangleStripDrawMode,
      TrianglesDrawMode,
      TubeGeometry,
      UVMapping,
      Uint16BufferAttribute,
      Uint32BufferAttribute,
      Uint8BufferAttribute,
      Uint8ClampedBufferAttribute,
      Uniform,
      UniformsGroup,
      UniformsLib,
      UniformsUtils,
      UnsignedByteType,
      UnsignedInt248Type,
      UnsignedIntType,
      UnsignedShort4444Type,
      UnsignedShort5551Type,
      UnsignedShortType,
      VSMShadowMap,
      Vector2,
      Vector3: Vector3$1,
      Vector4,
      VectorKeyframeTrack,
      VideoTexture,
      WebGL1Renderer,
      WebGL3DRenderTarget,
      WebGLArrayRenderTarget,
      WebGLCoordinateSystem,
      WebGLCubeRenderTarget,
      WebGLMultipleRenderTargets,
      WebGLRenderTarget,
      WebGLRenderer,
      WebGLUtils,
      WebGPUCoordinateSystem,
      WireframeGeometry,
      WrapAroundEnding,
      ZeroCurvatureEnding,
      ZeroFactor,
      ZeroSlopeEnding,
      ZeroStencilOp,
      _SRGBAFormat,
      createCanvasElement,
    },
    Symbol.toStringTag,
    { value: "Module" },
  ),
);
class DAG {
  allVertices = {};
  /** Nodes that are fully unlinked */
  isolatedVertices = {};
  connectedVertices = {};
  sortedConnectedValues = [];
  needsSort = false;
  emitter = mitt();
  emit = this.emitter.emit.bind(this.emitter);
  on = this.emitter.on.bind(this.emitter);
  off = this.emitter.off.bind(this.emitter);
  get sortedVertices() {
    return this.mapNodes((value) => value);
  }
  moveToIsolated(key2) {
    const vertex2 = this.connectedVertices[key2];
    if (!vertex2) return;
    this.isolatedVertices[key2] = vertex2;
    delete this.connectedVertices[key2];
  }
  moveToConnected(key2) {
    const vertex2 = this.isolatedVertices[key2];
    if (!vertex2) return;
    this.connectedVertices[key2] = vertex2;
    delete this.isolatedVertices[key2];
  }
  getKey = (v) => {
    if (typeof v === "object") {
      return v.key;
    }
    return v;
  };
  add(key2, value, options) {
    if (this.allVertices[key2] && this.allVertices[key2].value !== void 0) {
      throw new Error(`A node with the key ${key2.toString()} already exists`);
    }
    let vertex2 = this.allVertices[key2];
    if (!vertex2) {
      vertex2 = {
        value,
        previous: /* @__PURE__ */ new Set(),
        next: /* @__PURE__ */ new Set(),
      };
      this.allVertices[key2] = vertex2;
    } else if (vertex2.value === void 0) {
      vertex2.value = value;
    }
    const hasEdges = vertex2.next.size > 0 || vertex2.previous.size > 0;
    if (!options?.after && !options?.before && !hasEdges) {
      this.isolatedVertices[key2] = vertex2;
      this.emit("node:added", {
        key: key2,
        type: "isolated",
        value,
      });
      return;
    } else {
      this.connectedVertices[key2] = vertex2;
    }
    if (options?.after) {
      const afterArr = Array.isArray(options.after)
        ? options.after
        : [options.after];
      afterArr.forEach((after) => {
        vertex2.previous.add(this.getKey(after));
      });
      afterArr.forEach((after) => {
        const afterKey = this.getKey(after);
        const linkedAfter = this.allVertices[afterKey];
        if (!linkedAfter) {
          this.allVertices[afterKey] = {
            value: void 0,
            previous: /* @__PURE__ */ new Set(),
            next: /* @__PURE__ */ new Set([key2]),
          };
          this.connectedVertices[afterKey] = this.allVertices[afterKey];
        } else {
          linkedAfter.next.add(key2);
          this.moveToConnected(afterKey);
        }
      });
    }
    if (options?.before) {
      const beforeArr = Array.isArray(options.before)
        ? options.before
        : [options.before];
      beforeArr.forEach((before) => {
        vertex2.next.add(this.getKey(before));
      });
      beforeArr.forEach((before) => {
        const beforeKey = this.getKey(before);
        const linkedBefore = this.allVertices[beforeKey];
        if (!linkedBefore) {
          this.allVertices[beforeKey] = {
            value: void 0,
            previous: /* @__PURE__ */ new Set([key2]),
            next: /* @__PURE__ */ new Set(),
          };
          this.connectedVertices[beforeKey] = this.allVertices[beforeKey];
        } else {
          linkedBefore.previous.add(key2);
          this.moveToConnected(beforeKey);
        }
      });
    }
    this.emit("node:added", {
      key: key2,
      type: "connected",
      value,
    });
    this.needsSort = true;
  }
  remove(key2) {
    const removeKey = this.getKey(key2);
    const unlinkedVertex = this.isolatedVertices[removeKey];
    if (unlinkedVertex) {
      delete this.isolatedVertices[removeKey];
      delete this.allVertices[removeKey];
      this.emit("node:removed", {
        key: removeKey,
        type: "isolated",
      });
      return;
    }
    const linkedVertex = this.connectedVertices[removeKey];
    if (!linkedVertex) {
      return;
    }
    linkedVertex.next.forEach((nextKey) => {
      const nextVertex = this.connectedVertices[nextKey];
      if (nextVertex) {
        nextVertex.previous.delete(removeKey);
        if (nextVertex.previous.size === 0 && nextVertex.next.size === 0) {
          this.moveToIsolated(nextKey);
        }
      }
    });
    linkedVertex.previous.forEach((prevKey) => {
      const prevVertex = this.connectedVertices[prevKey];
      if (prevVertex) {
        prevVertex.next.delete(removeKey);
        if (prevVertex.previous.size === 0 && prevVertex.next.size === 0) {
          this.moveToIsolated(prevKey);
        }
      }
    });
    delete this.connectedVertices[removeKey];
    delete this.allVertices[removeKey];
    this.emit("node:removed", {
      key: removeKey,
      type: "connected",
    });
    this.needsSort = true;
  }
  mapNodes(callback) {
    if (this.needsSort) {
      this.sort();
    }
    const result = [];
    this.forEachNode((value, index) => {
      result.push(callback(value, index));
    });
    return result;
  }
  forEachNode(callback) {
    if (this.needsSort) {
      this.sort();
    }
    let index = 0;
    for (; index < this.sortedConnectedValues.length; index++) {
      callback(this.sortedConnectedValues[index], index);
    }
    Reflect.ownKeys(this.isolatedVertices).forEach((key2) => {
      const vertex2 = this.isolatedVertices[key2];
      if (vertex2.value !== void 0) callback(vertex2.value, index++);
    });
  }
  getValueByKey(key2) {
    return this.allVertices[key2]?.value;
  }
  getKeyByValue(value) {
    return (
      Reflect.ownKeys(this.connectedVertices).find(
        (key2) => this.connectedVertices[key2].value === value,
      ) ??
      Reflect.ownKeys(this.isolatedVertices).find(
        (key2) => this.isolatedVertices[key2].value === value,
      )
    );
  }
  sort() {
    const inDegree = /* @__PURE__ */ new Map();
    const zeroInDegreeQueue = [];
    const result = [];
    const connectedVertexKeysWithValues = Reflect.ownKeys(
      this.connectedVertices,
    ).filter((key2) => {
      const vertex2 = this.connectedVertices[key2];
      return vertex2.value !== void 0;
    });
    connectedVertexKeysWithValues.forEach((vertex2) => {
      inDegree.set(vertex2, 0);
    });
    connectedVertexKeysWithValues.forEach((vertexKey) => {
      const vertex2 = this.connectedVertices[vertexKey];
      vertex2.next.forEach((next) => {
        const nextVertex = this.connectedVertices[next];
        if (!nextVertex) return;
        inDegree.set(next, (inDegree.get(next) || 0) + 1);
      });
    });
    inDegree.forEach((degree, value) => {
      if (degree === 0) {
        zeroInDegreeQueue.push(value);
      }
    });
    while (zeroInDegreeQueue.length > 0) {
      const vertexKey = zeroInDegreeQueue.shift();
      result.push(vertexKey);
      const v = connectedVertexKeysWithValues.find(
        (key2) => key2 === vertexKey,
      );
      if (v) {
        this.connectedVertices[v]?.next.forEach((adjVertex) => {
          const adjVertexInDegree = (inDegree.get(adjVertex) || 0) - 1;
          inDegree.set(adjVertex, adjVertexInDegree);
          if (adjVertexInDegree === 0) {
            zeroInDegreeQueue.push(adjVertex);
          }
        });
      }
    }
    if (result.length !== connectedVertexKeysWithValues.length) {
      throw new Error(
        "The graph contains a cycle, and thus can not be sorted topologically.",
      );
    }
    const filterUndefined = (value) => value !== void 0;
    this.sortedConnectedValues = result
      .map((key2) => this.connectedVertices[key2].value)
      .filter(filterUndefined);
    this.needsSort = false;
  }
  clear() {
    this.allVertices = {};
    this.isolatedVertices = {};
    this.connectedVertices = {};
    this.sortedConnectedValues = [];
    this.needsSort = false;
  }
  static isKey(value) {
    return typeof value === "string" || typeof value === "symbol";
  }
  static isValue(value) {
    return typeof value === "object" && "key" in value;
  }
}
class Task {
  key;
  stage;
  callback;
  runTask = true;
  stop() {
    this.runTask = false;
  }
  start() {
    this.runTask = true;
  }
  constructor(stage, key2, callback) {
    this.stage = stage;
    this.key = key2;
    this.callback = callback;
  }
  run(delta) {
    if (!this.runTask) return;
    this.callback(delta);
  }
}
class Stage extends DAG {
  key;
  scheduler;
  get tasks() {
    return this.sortedVertices;
  }
  callback = (_, r) => r();
  constructor(scheduler, key2, callback) {
    super();
    this.scheduler = scheduler;
    this.key = key2;
    if (callback) this.callback = callback.bind(this);
  }
  createTask(key2, callback, options) {
    const task = new Task(this, key2, callback);
    this.add(key2, task, options);
    return task;
  }
  getTask(key2) {
    return this.getValueByKey(key2);
  }
  removeTask = this.remove.bind(this);
  run(delta) {
    this.callback(delta, (deltaOverride) => {
      this.forEachNode((task) => {
        task.run(deltaOverride ?? delta);
      });
    });
  }
  runWithTiming(delta) {
    const taskTimings = {};
    this.callback(delta, (deltaOverride) => {
      this.forEachNode((task) => {
        const start = performance.now();
        task.run(deltaOverride ?? delta);
        const duration = performance.now() - start;
        taskTimings[task.key] = duration;
      });
    });
    return taskTimings;
  }
  getSchedule() {
    return this.mapNodes((l) => l.key.toString());
  }
}
class Scheduler extends DAG {
  lastTime = performance.now();
  clampDeltaTo = 0.1;
  get stages() {
    return this.sortedVertices;
  }
  constructor(options) {
    super();
    if (options?.clampDeltaTo) this.clampDeltaTo = options.clampDeltaTo;
    this.run = this.run.bind(this);
  }
  createStage(key2, options) {
    const stage = new Stage(this, key2, options?.callback);
    this.add(key2, stage, {
      after: options?.after,
      before: options?.before,
    });
    return stage;
  }
  getStage(key2) {
    return this.getValueByKey(key2);
  }
  removeStage = this.remove.bind(this);
  /**
   * Runs all the stages in the scheduler.
   *
   * @param time The time in milliseconds since the start of the program.
   */
  run(time) {
    const delta = time - this.lastTime;
    this.forEachNode((stage) => {
      stage.run(Math.min(delta / 1e3, this.clampDeltaTo));
    });
    this.lastTime = time;
  }
  runWithTiming(time) {
    const delta = time - this.lastTime;
    const stageTimings = {};
    const start = performance.now();
    this.forEachNode((stage) => {
      const start2 = performance.now();
      const taskTimings = stage.runWithTiming(
        Math.min(delta / 1e3, this.clampDeltaTo),
      );
      const duration = performance.now() - start2;
      stageTimings[stage.key.toString()] = {
        duration,
        tasks: taskTimings,
      };
    });
    return {
      total: performance.now() - start,
      stages: stageTimings,
    };
  }
  getSchedule(
    include = {
      tasks: true,
    },
  ) {
    return {
      stages: this.mapNodes((stage) => {
        if (stage === void 0) throw new Error("Stage not found");
        return {
          key: stage.key.toString(),
          ...{ tasks: include.tasks ? stage.getSchedule() : void 0 },
        };
      }),
    };
  }
  dispose() {
    this.clear();
  }
}
const useLegacyFrameCompatibilityContextKey = Symbol(
  "use-legacy-frame-compatibility-context",
);
const injectLegacyFrameCompatibilityContext = () => {
  const ctx = {
    useFrameOrders: [],
    useRenderOrders: [],
  };
  setContext(useLegacyFrameCompatibilityContextKey, ctx);
  return ctx;
};
const useLegacyFrameCompatibilityContext = () => {
  const ctx = getContext(useLegacyFrameCompatibilityContextKey);
  if (ctx === void 0) {
    throw new Error(
      "No legacy frame compatibility context found, are you using this hook inside of <Canvas>?",
    );
  }
  return ctx;
};
const watch = (stores, callback) => {
  const d = derived(stores, (values) => {
    return values;
  });
  let cleanupFn;
  const unsubscribe = d.subscribe(async (values) => {
    if (cleanupFn) cleanupFn();
    const fn = await callback(values);
    if (fn) cleanupFn = fn;
  });
  onDestroy(() => {
    unsubscribe();
    if (cleanupFn) cleanupFn();
  });
};
function memoize(stores, transform) {
  const obj = {
    current: void 0,
  };
  watch(stores, (v) => {
    obj.current = transform ? transform(v) : v;
  });
  return obj;
}
const currentWritable = (value) => {
  const store = writable(value);
  const extendedWritable = {
    set: (value2) => {
      extendedWritable.current = value2;
      store.set(value2);
    },
    subscribe: store.subscribe,
    update: (fn) => {
      const newValue = fn(extendedWritable.current);
      extendedWritable.current = newValue;
      store.set(newValue);
    },
    current: value,
  };
  return extendedWritable;
};
const browser = typeof window !== "undefined";
const useParentSize = () => {
  const parentSize = currentWritable({ width: 0, height: 0 });
  if (!browser) {
    return {
      parentSize,
      parentSizeAction: () => {},
    };
  }
  const mutationOptions = {
    childList: true,
    subtree: false,
    attributes: false,
  };
  let el;
  const observeParent = (parent) => {
    resizeObserver.disconnect();
    mutationObserver.disconnect();
    resizeObserver.observe(parent);
    mutationObserver.observe(parent, mutationOptions);
  };
  const resizeObserver = new ResizeObserver(([entry]) => {
    const { width, height } = entry.contentRect;
    if (
      width === parentSize.current.width &&
      height === parentSize.current.height
    )
      return;
    parentSize.set({ width, height });
  });
  const mutationObserver = new MutationObserver((mutationsList) => {
    for (const mutation of mutationsList) {
      for (const node of mutation.removedNodes) {
        if (el === node && el.parentElement) {
          observeParent(el.parentElement);
          return;
        }
      }
    }
  });
  const parentSizeAction = (node) => {
    el = node;
    const parent = el.parentElement;
    if (!parent) return;
    parentSize.set({
      width: parent.clientWidth,
      height: parent.clientHeight,
    });
    observeParent(parent);
  };
  onDestroy(() => {
    resizeObserver.disconnect();
    mutationObserver.disconnect();
  });
  return {
    parentSize,
    parentSizeAction,
  };
};
function createObjectStore(object, onChange) {
  const objectStore = writable(object);
  let unwrappedObject = object;
  const unsubscribeObjectStore = objectStore.subscribe(
    (o) => (unwrappedObject = o),
  );
  onDestroy(unsubscribeObjectStore);
  const set = (newObject) => {
    if (newObject?.uuid === unwrappedObject?.uuid) return;
    const oldObject = unwrappedObject;
    objectStore.set(newObject);
    onChange?.(newObject, oldObject);
  };
  const update2 = (callback) => {
    const newObject = callback(unwrappedObject);
    if (newObject?.uuid === unwrappedObject?.uuid) return;
    const oldObject = unwrappedObject;
    objectStore.set(newObject);
    onChange?.(newObject, oldObject);
  };
  return {
    ...objectStore,
    set,
    update: update2,
  };
}
const useThrelte = () => {
  const context = getContext("threlte");
  if (context === void 0) {
    throw new Error(
      "No Threlte context found, are you using this hook inside of <Canvas>?",
    );
  }
  return context;
};
const key = Symbol("threlte-hierarchical-parent-context");
const useParent = () => {
  return getContext(key);
};
const setParent = (context) => {
  return setContext(key, context);
};
const createParentContext = (ref) => {
  const context = createObjectStore(ref);
  setContext(key, context);
  return context;
};
const useHierarchicalObject = () => {
  return {
    onChildMount: getContext("threlte-hierarchical-object-on-mount"),
    onChildDestroy: getContext("threlte-hierarchical-object-on-destroy"),
  };
};
const HierarchicalObject = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $parentStore, $$unsubscribe_parentStore;
    let { object = void 0 } = $$props;
    let { onChildMount = void 0 } = $$props;
    const onChildMountProxy = (child) => {
      onChildMount?.(child);
    };
    let { onChildDestroy = void 0 } = $$props;
    const onChildDestroyProxy = (child) => {
      onChildDestroy?.(child);
    };
    const { invalidate } = useThrelte();
    const parentStore = useParent();
    $$unsubscribe_parentStore = subscribe(
      parentStore,
      (value) => ($parentStore = value),
    );
    let { parent = $parentStore } = $$props;
    const parentCallbacks = useHierarchicalObject();
    if (object) {
      parentCallbacks.onChildMount?.(object);
      invalidate();
    }
    const objectStore = createObjectStore(object, (newObject, oldObject) => {
      if (oldObject) {
        parentCallbacks.onChildDestroy?.(oldObject);
        invalidate();
      }
      if (newObject) {
        parentCallbacks.onChildMount?.(newObject);
        invalidate();
      }
    });
    onDestroy(() => {
      if (object) {
        parentCallbacks.onChildDestroy?.(object);
        invalidate();
      }
    });
    setContext("threlte-hierarchical-object-on-mount", onChildMountProxy);
    setContext("threlte-hierarchical-object-on-destroy", onChildDestroyProxy);
    setParent(objectStore);
    if ($$props.object === void 0 && $$bindings.object && object !== void 0)
      $$bindings.object(object);
    if (
      $$props.onChildMount === void 0 &&
      $$bindings.onChildMount &&
      onChildMount !== void 0
    )
      $$bindings.onChildMount(onChildMount);
    if (
      $$props.onChildDestroy === void 0 &&
      $$bindings.onChildDestroy &&
      onChildDestroy !== void 0
    )
      $$bindings.onChildDestroy(onChildDestroy);
    if ($$props.parent === void 0 && $$bindings.parent && parent !== void 0)
      $$bindings.parent(parent);
    parent = $parentStore;
    {
      objectStore.set(object);
    }
    $$unsubscribe_parentStore();
    return `   ${slots.default ? slots.default({}) : ``}`;
  },
);
const SceneGraphObject = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let { object } = $$props;
    if ($$props.object === void 0 && $$bindings.object && object !== void 0)
      $$bindings.object(object);
    return `${validate_component(
      HierarchicalObject,
      "HierarchicalObject",
    ).$$render(
      $$result,
      {
        object,
        onChildMount: (child) => object.add(child),
        onChildDestroy: (child) => object.remove(child),
      },
      {},
      {
        default: () => {
          return `${slots.default ? slots.default({}) : ``}`;
        },
      },
    )}`;
  },
);
const createCache = () => {
  setContext("threlte-cache", []);
};
const defaultCamera = new PerspectiveCamera(75, 0, 0.1, 1e3);
defaultCamera.position.z = 5;
defaultCamera.lookAt(0, 0, 0);
const getDefaultCamera = () => defaultCamera;
const setDefaultCameraAspectOnSizeChange = (ctx) => {
  watch(ctx.size, (size) => {
    if (ctx.camera.current === defaultCamera) {
      const cam = ctx.camera.current;
      cam.aspect = size.width / size.height;
      cam.updateProjectionMatrix();
      ctx.invalidate();
    }
  });
};
const createContexts = (options) => {
  const internalCtx = {
    frameInvalidated: true,
    advance: false,
    autoInvalidations: /* @__PURE__ */ new Set(),
    resetFrameInvalidation: () => {
      internalCtx.frameInvalidated = false;
      internalCtx.advance = false;
    },
    dispose: async (force = false) => {
      await tick();
      if (!internalCtx.shouldDispose && !force) return;
      internalCtx.disposableObjects.forEach((mounted, object) => {
        if (mounted === 0 || force) {
          object?.dispose?.();
          internalCtx.disposableObjects.delete(object);
        }
      });
      internalCtx.shouldDispose = false;
    },
    collectDisposableObjects: (object, objects) => {
      const disposables = objects ?? [];
      if (!object) return disposables;
      if (
        object?.dispose &&
        typeof object.dispose === "function" &&
        object.type !== "Scene"
      ) {
        disposables.push(object);
      }
      Object.entries(object).forEach(([propKey, propValue]) => {
        if (
          propKey === "parent" ||
          propKey === "children" ||
          typeof propValue !== "object"
        )
          return;
        const value = propValue;
        if (value?.dispose) {
          internalCtx.collectDisposableObjects(value, disposables);
        }
      });
      return disposables;
    },
    addDisposableObjects: (objects) => {
      objects.forEach((obj) => {
        const currentValue = internalCtx.disposableObjects.get(obj);
        if (currentValue) {
          internalCtx.disposableObjects.set(obj, currentValue + 1);
        } else {
          internalCtx.disposableObjects.set(obj, 1);
        }
      });
    },
    removeDisposableObjects: (objects) => {
      if (objects.length === 0) return;
      objects.forEach((obj) => {
        const currentValue = internalCtx.disposableObjects.get(obj);
        if (currentValue && currentValue > 0) {
          internalCtx.disposableObjects.set(obj, currentValue - 1);
        }
      });
      internalCtx.shouldDispose = true;
    },
    disposableObjects: /* @__PURE__ */ new Map(),
    shouldDispose: false,
  };
  const ctx = {
    size: derived([options.userSize, options.parentSize], ([uSize, pSize]) => {
      return uSize ? uSize : pSize;
    }),
    camera: currentWritable(getDefaultCamera()),
    scene: new Scene(),
    renderer: void 0,
    invalidate: () => {
      internalCtx.frameInvalidated = true;
    },
    advance: () => {
      internalCtx.advance = true;
    },
    colorSpace: currentWritable(options.colorSpace),
    toneMapping: currentWritable(options.toneMapping),
    dpr: currentWritable(options.dpr),
    useLegacyLights: currentWritable(options.useLegacyLights),
    shadows: currentWritable(options.shadows),
    colorManagementEnabled: currentWritable(options.colorManagementEnabled),
    renderMode: currentWritable(options.renderMode),
    autoRender: currentWritable(options.autoRender),
    scheduler: void 0,
    mainStage: void 0,
    renderStage: void 0,
    autoRenderTask: void 0,
    shouldRender: () => {
      const shouldRender =
        ctx.renderMode.current === "always" ||
        (ctx.renderMode.current === "on-demand" &&
          (internalCtx.frameInvalidated ||
            internalCtx.autoInvalidations.size > 0)) ||
        (ctx.renderMode.current === "manual" && internalCtx.advance);
      return shouldRender;
    },
  };
  const userCtx = currentWritable({});
  setContext("threlte", ctx);
  setContext("threlte-internal-context", internalCtx);
  setContext("threlte-user-context", userCtx);
  const getCtx = () => ctx;
  const getInternalCtx = () => internalCtx;
  return {
    ctx,
    internalCtx,
    getCtx,
    getInternalCtx,
  };
};
const normalizedRevision = REVISION.replace("dev", "");
const revision = Number.parseInt(normalizedRevision);
const useRenderer = (ctx) => {
  const renderer = writable(void 0);
  const createRenderer = (canvas, rendererParameters) => {
    ctx.renderer = new WebGLRenderer({
      powerPreference: "high-performance",
      canvas,
      antialias: true,
      alpha: true,
      ...rendererParameters,
    });
    renderer.set(ctx.renderer);
  };
  watch([ctx.colorManagementEnabled], ([colorManagementEnabled]) => {
    ColorManagement.enabled = colorManagementEnabled;
  });
  watch([renderer, ctx.colorSpace], ([renderer2, colorSpace]) => {
    if (!renderer2) return;
    renderer2.outputColorSpace = colorSpace;
  });
  watch([renderer, ctx.dpr], ([renderer2, dpr]) => {
    renderer2?.setPixelRatio(dpr);
  });
  watch([renderer, ctx.size], ([renderer2, size]) => {
    if (renderer2?.xr?.isPresenting) return;
    renderer2?.setSize(size.width, size.height);
  });
  watch([renderer, ctx.shadows], ([renderer2, shadows]) => {
    if (!renderer2) return;
    renderer2.shadowMap.enabled = !!shadows;
    if (shadows && shadows !== true) {
      renderer2.shadowMap.type = shadows;
    } else if (shadows === true) {
      renderer2.shadowMap.type = PCFSoftShadowMap;
    }
  });
  watch([renderer, ctx.toneMapping], ([renderer2, toneMapping]) => {
    if (!renderer2) return;
    renderer2.toneMapping = toneMapping;
  });
  watch([renderer, ctx.useLegacyLights], ([renderer2, useLegacyLights]) => {
    if (!renderer2) return;
    if (useLegacyLights) {
      renderer2.useLegacyLights = useLegacyLights;
    }
  });
  return {
    createRenderer,
  };
};
const css = {
  code: "canvas.svelte-o3oskp{display:block}",
  map: null,
};
const Canvas = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $initialized, $$unsubscribe_initialized;
  let { colorManagementEnabled = true } = $$props;
  let { colorSpace = "srgb" } = $$props;
  let { dpr = browser ? window.devicePixelRatio : 1 } = $$props;
  let { renderMode = "on-demand" } = $$props;
  let { rendererParameters = void 0 } = $$props;
  let { shadows = PCFSoftShadowMap } = $$props;
  let { size = void 0 } = $$props;
  let { toneMapping = ACESFilmicToneMapping } = $$props;
  let { useLegacyLights = revision >= 155 ? false : true } = $$props;
  let { autoRender = true } = $$props;
  let canvas;
  let initialized2 = writable(false);
  $$unsubscribe_initialized = subscribe(
    initialized2,
    (value) => ($initialized = value),
  );
  const userSize = writable(size);
  const { parentSize, parentSizeAction } = useParentSize();
  const { useRenderOrders } = injectLegacyFrameCompatibilityContext();
  const contexts = createContexts({
    colorManagementEnabled,
    colorSpace,
    dpr,
    renderMode,
    parentSize,
    autoRender,
    shadows,
    toneMapping,
    useLegacyLights,
    userSize,
  });
  const scheduler = new Scheduler();
  contexts.getCtx().mainStage = scheduler.createStage(
    Symbol("threlte-main-stage"),
  );
  contexts.getCtx().renderStage = scheduler.createStage(
    Symbol("threlte-render-stage"),
    {
      after: contexts.ctx.mainStage,
      callback(_, runTasks) {
        if (contexts.ctx.shouldRender()) runTasks();
      },
    },
  );
  contexts.getCtx().autoRenderTask = contexts.ctx.renderStage.createTask(
    Symbol("threlte-auto-render-task"),
    (_) => {
      if (useRenderOrders.length > 0) return;
      contexts.ctx.renderer.render(ctx.scene, ctx.camera.current);
    },
  );
  watch(
    [initialized2, contexts.ctx.autoRender],
    ([initialized3, autoRender2]) => {
      if (initialized3 && autoRender2) {
        contexts.getCtx().autoRenderTask.start();
      } else {
        contexts.getCtx().autoRenderTask.stop();
      }
      return () => {
        contexts.getCtx().autoRenderTask.stop();
      };
    },
  );
  contexts.getCtx().scheduler = scheduler;
  createCache();
  const ctx = contexts.ctx;
  setDefaultCameraAspectOnSizeChange(ctx);
  useRenderer(ctx);
  onDestroy(() => {
    contexts.internalCtx.dispose(true);
    contexts.ctx.scheduler.dispose();
    contexts.ctx.renderer?.dispose();
  });
  if (
    $$props.colorManagementEnabled === void 0 &&
    $$bindings.colorManagementEnabled &&
    colorManagementEnabled !== void 0
  )
    $$bindings.colorManagementEnabled(colorManagementEnabled);
  if (
    $$props.colorSpace === void 0 &&
    $$bindings.colorSpace &&
    colorSpace !== void 0
  )
    $$bindings.colorSpace(colorSpace);
  if ($$props.dpr === void 0 && $$bindings.dpr && dpr !== void 0)
    $$bindings.dpr(dpr);
  if (
    $$props.renderMode === void 0 &&
    $$bindings.renderMode &&
    renderMode !== void 0
  )
    $$bindings.renderMode(renderMode);
  if (
    $$props.rendererParameters === void 0 &&
    $$bindings.rendererParameters &&
    rendererParameters !== void 0
  )
    $$bindings.rendererParameters(rendererParameters);
  if ($$props.shadows === void 0 && $$bindings.shadows && shadows !== void 0)
    $$bindings.shadows(shadows);
  if ($$props.size === void 0 && $$bindings.size && size !== void 0)
    $$bindings.size(size);
  if (
    $$props.toneMapping === void 0 &&
    $$bindings.toneMapping &&
    toneMapping !== void 0
  )
    $$bindings.toneMapping(toneMapping);
  if (
    $$props.useLegacyLights === void 0 &&
    $$bindings.useLegacyLights &&
    useLegacyLights !== void 0
  )
    $$bindings.useLegacyLights(useLegacyLights);
  if (
    $$props.autoRender === void 0 &&
    $$bindings.autoRender &&
    autoRender !== void 0
  )
    $$bindings.autoRender(autoRender);
  if ($$props.ctx === void 0 && $$bindings.ctx && ctx !== void 0)
    $$bindings.ctx(ctx);
  $$result.css.add(css);
  {
    userSize.set(size);
  }
  {
    contexts.ctx.colorSpace.set(colorSpace);
  }
  {
    contexts.ctx.dpr.set(dpr);
  }
  {
    contexts.ctx.renderMode.set(renderMode);
  }
  {
    contexts.ctx.autoRender.set(autoRender);
  }
  {
    contexts.ctx.shadows.set(shadows);
  }
  {
    contexts.ctx.toneMapping.set(toneMapping);
  }
  $$unsubscribe_initialized();
  return `<canvas class="svelte-o3oskp"${add_attribute("this", canvas, 0)}>${
    $initialized
      ? `${validate_component(SceneGraphObject, "SceneGraphObject").$$render(
          $$result,
          { object: contexts.ctx.scene },
          {},
          {
            default: () => {
              return `${slots.default ? slots.default({}) : ``}`;
            },
          },
        )}`
      : ``
  } </canvas>`;
});
const useThrelteInternal = () => {
  return getContext("threlte-internal-context");
};
const contextName = "threlte-disposable-object-context";
const DisposableObject = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $mergedDispose, $$unsubscribe_mergedDispose;
    let $parentDispose, $$unsubscribe_parentDispose;
    const {
      collectDisposableObjects,
      addDisposableObjects,
      removeDisposableObjects,
    } = useThrelteInternal();
    let { object = void 0 } = $$props;
    let previousObject = object;
    let { dispose = void 0 } = $$props;
    const parentDispose = getContext(contextName);
    $$unsubscribe_parentDispose = subscribe(
      parentDispose,
      (value) => ($parentDispose = value),
    );
    const mergedDispose = writable(dispose ?? $parentDispose ?? true);
    $$unsubscribe_mergedDispose = subscribe(
      mergedDispose,
      (value) => ($mergedDispose = value),
    );
    setContext(contextName, mergedDispose);
    let disposables = $mergedDispose ? collectDisposableObjects(object) : [];
    addDisposableObjects(disposables);
    onDestroy(() => {
      removeDisposableObjects(disposables);
    });
    if ($$props.object === void 0 && $$bindings.object && object !== void 0)
      $$bindings.object(object);
    if ($$props.dispose === void 0 && $$bindings.dispose && dispose !== void 0)
      $$bindings.dispose(dispose);
    {
      mergedDispose.set(dispose ?? $parentDispose ?? true);
    }
    {
      {
        if (object !== previousObject) {
          removeDisposableObjects(disposables);
          disposables = $mergedDispose ? collectDisposableObjects(object) : [];
          addDisposableObjects(disposables);
          previousObject = object;
        }
      }
    }
    $$unsubscribe_mergedDispose();
    $$unsubscribe_parentDispose();
    return `${slots.default ? slots.default({}) : ``}`;
  },
);
const classRegex = /^\s*class\s+/;
const isClass = (input) => {
  if (typeof input !== "function") {
    return false;
  }
  return classRegex.test(input.toString());
};
const argsIsConstructorParameters = (args) => {
  return Array.isArray(args);
};
const determineRef = (is, args) => {
  if (isClass(is)) {
    if (argsIsConstructorParameters(args)) {
      return new is(...args);
    } else {
      return new is();
    }
  }
  return is;
};
const extendsObject3D = (object) => {
  return "isObject3D" in object;
};
const isDisposableObject = (object) => {
  return "dispose" in object;
};
const resolvePropertyPath = (target, propertyPath) => {
  if (propertyPath.includes(".")) {
    const path = propertyPath.split(".");
    const key2 = path.pop();
    for (let i = 0; i < path.length; i += 1) {
      target = target[path[i]];
    }
    return {
      target,
      key: key2,
    };
  } else {
    return {
      target,
      key: propertyPath,
    };
  }
};
const initialValueBeforeAttach = Symbol("initialValueBeforeAttach");
const useAttach = () => {
  const { invalidate } = useThrelte();
  let isAttached = false;
  let valueBeforeAttach = initialValueBeforeAttach;
  let detachFn;
  let attachedTo;
  let attachedKey;
  const update2 = (instance, parent, attach) => {
    detach();
    if (!attach) {
      const i = instance;
      const isMaterial = i?.isMaterial || false;
      if (isMaterial) {
        attach = "material";
      }
      const isGeometry = i?.isBufferGeometry || i?.isGeometry || false;
      if (isGeometry) {
        attach = "geometry";
      }
    }
    if (!attach) return;
    if (typeof attach === "function") {
      detachFn = attach(parent, instance);
    } else {
      const { target, key: key2 } = resolvePropertyPath(parent, attach);
      valueBeforeAttach = target[key2];
      target[key2] = instance;
      attachedTo = target;
      attachedKey = key2;
    }
    isAttached = true;
    invalidate();
  };
  const detach = () => {
    if (!isAttached) return;
    if (detachFn) {
      detachFn();
      detachFn = void 0;
    } else if (
      attachedTo &&
      attachedKey &&
      valueBeforeAttach !== initialValueBeforeAttach
    ) {
      attachedTo[attachedKey] = valueBeforeAttach;
      valueBeforeAttach = initialValueBeforeAttach;
      attachedTo = void 0;
      attachedKey = void 0;
    }
    isAttached = false;
    invalidate();
  };
  onDestroy(() => {
    detach();
  });
  return {
    update: update2,
  };
};
const isCamera = (value) => {
  return value && value.isCamera;
};
const isOrthographicCamera = (value) => {
  return value && value.isOrthographicCamera;
};
const isPerspectiveCamera = (value) => {
  return value && value.isPerspectiveCamera;
};
const isPerspectiveCameraOrOrthographicCamera = (value) => {
  return isPerspectiveCamera(value) || isOrthographicCamera(value);
};
const useCamera = () => {
  const { invalidate, size, camera } = useThrelte();
  let currentInstance;
  let unsubscribe = void 0;
  onDestroy(() => {
    unsubscribe?.();
  });
  const subscriber = (size2) => {
    if (!currentInstance) return;
    if (isOrthographicCamera(currentInstance)) {
      currentInstance.left = size2.width / -2;
      currentInstance.right = size2.width / 2;
      currentInstance.top = size2.height / 2;
      currentInstance.bottom = size2.height / -2;
      currentInstance.updateProjectionMatrix();
      currentInstance.updateMatrixWorld();
      invalidate();
    } else if (isPerspectiveCamera(currentInstance)) {
      currentInstance.aspect = size2.width / size2.height;
      currentInstance.updateProjectionMatrix();
      currentInstance.updateMatrixWorld();
      invalidate();
    }
  };
  const update2 = (instance, manual) => {
    unsubscribe?.();
    if (manual || !isPerspectiveCameraOrOrthographicCamera(instance)) {
      currentInstance = void 0;
      return;
    }
    currentInstance = instance;
    unsubscribe = size.subscribe(subscriber);
  };
  const makeDefaultCamera = (instance, makeDefault) => {
    if (!isCamera(instance) || !makeDefault) return;
    camera.set(instance);
    invalidate();
  };
  return {
    update: update2,
    makeDefaultCamera,
  };
};
const createRawEventDispatcher = () => {
  const component = get_current_component();
  const dispatchRawEvent = (type, value) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      callbacks.forEach((fn) => {
        fn(value);
      });
    }
  };
  const hasEventListener = (type) => {
    return Boolean(component.$$.callbacks[type]);
  };
  Object.defineProperty(dispatchRawEvent, "hasEventListener", {
    value: hasEventListener,
    enumerable: true,
  });
  return dispatchRawEvent;
};
const useCreateEvent = () => {
  createRawEventDispatcher();
  const cleanupFunctions = [];
  const updateRef = (newRef) => {
    return;
  };
  onDestroy(() => {
    cleanupFunctions.forEach((cleanup) => cleanup());
  });
  return {
    updateRef,
  };
};
const isEventDispatcher = (value) => {
  return !!value?.addEventListener;
};
const useEvents = () => {
  const dispatch = createRawEventDispatcher();
  get_current_component();
  const eventHandlerProxy = (event) => {
    if (event?.type) {
      dispatch(event.type, event);
    }
  };
  const cleanupEventListeners = (ref2, events) => {
    if (isEventDispatcher(ref2)) {
      events.forEach((eventName) => {
        ref2.removeEventListener(eventName, eventHandlerProxy);
      });
    }
  };
  const addEventListeners = (ref2, events) => {
    if (isEventDispatcher(ref2)) {
      events.forEach((eventName) => {
        ref2.addEventListener(eventName, eventHandlerProxy);
      });
    }
  };
  const ref = writable();
  const eventNames = writable([]);
  watch([ref, eventNames], ([$ref, $eventNames]) => {
    addEventListeners($ref, $eventNames);
    return () => cleanupEventListeners($ref, $eventNames);
  });
  const updateRef = (newRef) => {
    ref.set(newRef);
  };
  return {
    updateRef,
  };
};
const usePlugins = (params) => {
  const pluginContextName = "threlte-plugin-context";
  const plugins = getContext(pluginContextName);
  if (!plugins) return;
  const pluginsReturns = Object.values(plugins)
    .map((plugin) => plugin(params))
    .filter(Boolean);
  const pluginsProps = pluginsReturns.flatMap(
    (callback) => callback.pluginProps ?? [],
  );
  let refCleanupCallbacks = [];
  onDestroy(() => {
    refCleanupCallbacks.forEach((callback) => callback());
  });
  const updateRef = (ref) => {
    refCleanupCallbacks.forEach((callback) => callback());
    refCleanupCallbacks = [];
    pluginsReturns.forEach((callback) => {
      const cleanupCallback = callback.onRefChange?.(ref);
      if (cleanupCallback) {
        refCleanupCallbacks.push(cleanupCallback);
      }
    });
  };
  const updateProps = (props) => {
    pluginsReturns.forEach((callback) => {
      callback.onPropsChange?.(props);
    });
  };
  const updateRestProps = (restProps) => {
    pluginsReturns.forEach((callback) => {
      callback.onRestPropsChange?.(restProps);
    });
  };
  return {
    updateRef,
    updateProps,
    updateRestProps,
    pluginsProps,
  };
};
const ignoredProps = /* @__PURE__ */ new Set([
  "$$scope",
  "$$slots",
  "type",
  "args",
  "attach",
  "instance",
]);
const updateProjectionMatrixKeys = /* @__PURE__ */ new Set([
  "fov",
  "aspect",
  "near",
  "far",
  "left",
  "right",
  "top",
  "bottom",
  "zoom",
]);
const memoizeProp = (value) => {
  if (typeof value === "string") return true;
  if (typeof value === "number") return true;
  if (typeof value === "boolean") return true;
  if (typeof value === "undefined") return true;
  if (value === null) return true;
  return false;
};
const createSetter = (target, key2, value) => {
  if (
    !Array.isArray(value) &&
    typeof value === "number" &&
    typeof target[key2]?.setScalar === "function" && // colors do have a setScalar function, but we don't want to use it, because
    // the hex notation (i.e. 0xff0000) is very popular and matches the number
    // type. So we exclude colors here.
    !target[key2]?.isColor
  ) {
    return (target2, key3, value2) => {
      target2[key3].setScalar(value2);
    };
  } else {
    if (typeof target[key2]?.set === "function") {
      if (Array.isArray(value)) {
        return (target2, key3, value2) => {
          target2[key3].set(...value2);
        };
      } else {
        return (target2, key3, value2) => {
          target2[key3].set(value2);
        };
      }
    } else {
      return (target2, key3, value2) => {
        target2[key3] = value2;
      };
    }
  }
};
const useProps = () => {
  const { invalidate } = useThrelte();
  const memoizedProps = /* @__PURE__ */ new Map();
  const memoizedSetters = /* @__PURE__ */ new Map();
  const setProp = (instance, propertyPath, value, options) => {
    if (memoizeProp(value)) {
      const memoizedProp = memoizedProps.get(propertyPath);
      if (
        memoizedProp &&
        memoizedProp.instance === instance &&
        memoizedProp.value === value
      ) {
        return;
      }
      memoizedProps.set(propertyPath, {
        instance,
        value,
      });
    }
    const { key: key2, target } = resolvePropertyPath(instance, propertyPath);
    if (value !== void 0 && value !== null) {
      const memoizedSetter = memoizedSetters.get(propertyPath);
      if (memoizedSetter) {
        memoizedSetter(target, key2, value);
      } else {
        const setter = createSetter(target, key2, value);
        memoizedSetters.set(propertyPath, setter);
        setter(target, key2, value);
      }
    } else {
      createSetter(target, key2, value)(target, key2, value);
    }
    if (options.manualCamera) return;
    if (
      updateProjectionMatrixKeys.has(key2) &&
      (target.isPerspectiveCamera || target.isOrthographicCamera)
    ) {
      target.updateProjectionMatrix();
    }
  };
  const updateProps = (instance, props, options) => {
    for (const key2 in props) {
      if (!ignoredProps.has(key2) && !options.pluginsProps?.includes(key2)) {
        setProp(instance, key2, props[key2], options);
      }
      invalidate();
    }
  };
  return {
    updateProps,
  };
};
const T$1 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "is",
    "args",
    "attach",
    "manual",
    "makeDefault",
    "dispose",
    "ref",
  ]);
  let $parent, $$unsubscribe_parent;
  let { is } = $$props;
  let { args = void 0 } = $$props;
  let { attach = void 0 } = $$props;
  let { manual = void 0 } = $$props;
  let { makeDefault = void 0 } = $$props;
  let { dispose = void 0 } = $$props;
  const parent = useParent();
  $$unsubscribe_parent = subscribe(parent, (value) => ($parent = value));
  const createEvent = useCreateEvent();
  let ref = determineRef(is, args);
  createEvent.updateRef(ref);
  let initialized2 = false;
  const maybeSetRef = () => {
    if (!initialized2) {
      initialized2 = true;
      return;
    }
    ref = determineRef(is, args);
    createEvent.updateRef(ref);
  };
  let { ref: publicRef = ref } = $$props;
  const parentContext = createParentContext(ref);
  const plugins = usePlugins({ ref, props: $$props });
  const pluginsProps = plugins?.pluginsProps ?? [];
  const props = useProps();
  const camera = useCamera();
  const attachment = useAttach();
  const events = useEvents();
  if ($$props.is === void 0 && $$bindings.is && is !== void 0)
    $$bindings.is(is);
  if ($$props.args === void 0 && $$bindings.args && args !== void 0)
    $$bindings.args(args);
  if ($$props.attach === void 0 && $$bindings.attach && attach !== void 0)
    $$bindings.attach(attach);
  if ($$props.manual === void 0 && $$bindings.manual && manual !== void 0)
    $$bindings.manual(manual);
  if (
    $$props.makeDefault === void 0 &&
    $$bindings.makeDefault &&
    makeDefault !== void 0
  )
    $$bindings.makeDefault(makeDefault);
  if ($$props.dispose === void 0 && $$bindings.dispose && dispose !== void 0)
    $$bindings.dispose(dispose);
  if ($$props.ref === void 0 && $$bindings.ref && publicRef !== void 0)
    $$bindings.ref(publicRef);
  {
    maybeSetRef();
  }
  publicRef = ref;
  {
    parentContext.set(ref);
  }
  {
    props.updateProps(ref, $$restProps, { manualCamera: manual, pluginsProps });
  }
  {
    camera.update(ref, manual);
  }
  {
    camera.makeDefaultCamera(ref, makeDefault);
  }
  {
    attachment.update(ref, $parent, attach);
  }
  {
    events.updateRef(ref);
  }
  {
    plugins?.updateRef(ref);
  }
  {
    plugins?.updateProps($$props);
  }
  {
    plugins?.updateRestProps($$restProps);
  }
  $$unsubscribe_parent();
  return `${isDisposableObject(ref) ? `${validate_component(DisposableObject, "DisposableObject").$$render($$result, { object: ref, dispose }, {}, {})}` : ``} ${
    extendsObject3D(ref)
      ? `${validate_component(SceneGraphObject, "SceneGraphObject").$$render(
          $$result,
          { object: ref },
          {},
          {
            default: () => {
              return `${slots.default ? slots.default({ ref }) : ``}`;
            },
          },
        )}`
      : `${slots.default ? slots.default({ ref }) : ``}`
  }`;
});
const catalogue = {};
const augmentConstructorArgs = (args, is) => {
  const module = catalogue[is] || THREE[is];
  if (!module) {
    throw new Error(
      `No Three.js module found for ${is}. Did you forget to extend the catalogue?`,
    );
  }
  return {
    ...args,
    props: {
      ...args.props,
      is: module,
    },
  };
};
const proxyTConstructor = (is) => {
  return new Proxy(class {}, {
    construct(_, [args]) {
      const castedArgs = args;
      return new T$1(augmentConstructorArgs(castedArgs, is));
    },
  });
};
const T = new Proxy(class {}, {
  construct(_, [args]) {
    const castedArgs = args;
    return new T$1(castedArgs);
  },
  get(_, is) {
    return proxyTConstructor(is);
  },
});
function injectPlugin(nameOrNamedPlugin, maybePlugin) {
  const contextName2 = "threlte-plugin-context";
  if (Array.isArray(nameOrNamedPlugin)) {
    const [name, plugin] = nameOrNamedPlugin;
    setContext(contextName2, {
      ...getContext(contextName2),
      [name]: plugin,
    });
  } else {
    const name = nameOrNamedPlugin;
    const plugin = maybePlugin;
    if (!plugin) return;
    setContext(contextName2, {
      ...getContext(contextName2),
      [name]: plugin,
    });
  }
}
function useTask(keyOrFn, fnOrOptions, options) {
  if (!browser) {
    return {
      task: void 0,
      start: () => void 0,
      stop: () => void 0,
      started: readable(false),
    };
  }
  let key2;
  let fn;
  let opts;
  if (DAG.isKey(keyOrFn)) {
    key2 = keyOrFn;
    fn = fnOrOptions;
    opts = options;
  } else {
    key2 = Symbol("useTask");
    fn = keyOrFn;
    opts = fnOrOptions;
  }
  const ctx = useThrelte();
  let stage = ctx.mainStage;
  if (opts) {
    if (opts.stage) {
      if (DAG.isValue(opts.stage)) {
        stage = opts.stage;
      } else {
        const maybeStage = ctx.scheduler.getStage(opts.stage);
        if (!maybeStage) {
          throw new Error(`No stage found with key ${opts.stage.toString()}`);
        }
        stage = maybeStage;
      }
    } else if (opts.after) {
      if (Array.isArray(opts.after)) {
        for (let index = 0; index < opts.after.length; index++) {
          const element = opts.after[index];
          if (DAG.isValue(element)) {
            stage = element.stage;
            break;
          }
        }
      } else if (DAG.isValue(opts.after)) {
        stage = opts.after.stage;
      }
    } else if (opts.before) {
      if (Array.isArray(opts.before)) {
        for (let index = 0; index < opts.before.length; index++) {
          const element = opts.before[index];
          if (DAG.isValue(element)) {
            stage = element.stage;
            break;
          }
        }
      } else if (DAG.isValue(opts.before)) {
        stage = opts.before.stage;
      }
    }
  }
  const { autoInvalidations } = getContext("threlte-internal-context");
  const started = writable(false);
  const task = stage.createTask(key2, fn, opts);
  const start = () => {
    started.set(true);
    if (opts?.autoInvalidate ?? true) {
      autoInvalidations.add(fn);
    }
    task.start();
  };
  const stop = () => {
    started.set(true);
    if (opts?.autoInvalidate ?? true) {
      autoInvalidations.delete(fn);
    }
    task.stop();
  };
  if (opts?.autoStart ?? true) {
    start();
  } else {
    stop();
  }
  onDestroy(() => {
    if (!stage) return;
    stage.removeTask(key2);
  });
  return {
    task,
    start,
    stop,
    started: {
      subscribe: started.subscribe,
    },
  };
}
function useThrelteUserContext(namespace, value, options) {
  const userCtxStore = getContext("threlte-user-context");
  if (!userCtxStore) {
    throw new Error(
      "No user context store found, did you invoke this function outside of your main <Canvas> component?",
    );
  }
  if (!namespace) {
    return {
      subscribe: userCtxStore.subscribe,
    };
  }
  if (namespace && !value) {
    return derived(userCtxStore, (ctx) => ctx[namespace]);
  }
  userCtxStore.update((ctx) => {
    if (namespace in ctx) {
      if (!options || options.existing === "skip") return ctx;
      if (options.existing === "merge") {
        Object.assign(ctx[namespace], value);
        return ctx;
      }
    }
    ctx[namespace] = value;
    return ctx;
  });
  return userCtxStore.current[namespace];
}
const orderToKey = (order) => `useFrame-order-${order.toString()}`;
const useFrame = (fn, options) => {
  if (!browser) {
    return {
      start: () => void 0,
      stop: () => void 0,
      started: readable(false),
    };
  }
  const started = writable(false);
  const ctx = useThrelte();
  const { useFrameOrders } = useLegacyFrameCompatibilityContext();
  const { autoInvalidations } = getContext("threlte-internal-context");
  let order = options?.order ?? 0;
  while (useFrameOrders.includes(order)) {
    order += 0.01;
  }
  useFrameOrders.push(order);
  const key2 = orderToKey(order);
  const proxy = (delta) => {
    fn(ctx, delta);
  };
  const task = ctx.mainStage.createTask(key2, proxy, {
    after: useFrameOrders.filter((o) => o < order).map((o) => orderToKey(o)),
    before: useFrameOrders.filter((o) => o > order).map((o) => orderToKey(o)),
  });
  const start = () => {
    started.set(true);
    if (options?.invalidate ?? true) {
      autoInvalidations.add(fn);
    }
    task.start();
  };
  const stop = () => {
    started.set(true);
    if (options?.invalidate ?? true) {
      autoInvalidations.delete(fn);
    }
    task.stop();
  };
  if (options?.autostart ?? true) {
    start();
  } else {
    stop();
  }
  onDestroy(() => {
    ctx.mainStage.removeTask(key2);
    useFrameOrders.splice(useFrameOrders.indexOf(order), 1);
  });
  return {
    start,
    stop,
    started: {
      subscribe: started.subscribe,
    },
  };
};
const forwardEventHandlers = () => {
  const component = get_current_component();
  const dispatchingComponent = writable(void 0);
  watch(dispatchingComponent, (dispatchingComponent2) => {
    if (!dispatchingComponent2) return;
    Object.entries(component.$$.callbacks).forEach((callback) => {
      const [key2, value] = callback;
      if (
        key2 in dispatchingComponent2.$$.callbacks &&
        Array.isArray(dispatchingComponent2.$$.callbacks[key2])
      ) {
        dispatchingComponent2.$$.callbacks[key2].push(...value);
      } else {
        dispatchingComponent2.$$.callbacks[key2] = value;
      }
    });
  });
  return dispatchingComponent;
};
function quadOut(t) {
  return -t * (t - 2);
}
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`,
  };
}
const TransitionFrame = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "transition",
      "params",
      "open",
      "dismissable",
    ]);
    let { transition = fade } = $$props;
    let { params = {} } = $$props;
    let { open = true } = $$props;
    let { dismissable = false } = $$props;
    const dispatch = createEventDispatcher();
    function close(ev) {
      if (ev?.stopPropagation) ev.stopPropagation();
      open = false;
    }
    if (
      $$props.transition === void 0 &&
      $$bindings.transition &&
      transition !== void 0
    )
      $$bindings.transition(transition);
    if ($$props.params === void 0 && $$bindings.params && params !== void 0)
      $$bindings.params(params);
    if ($$props.open === void 0 && $$bindings.open && open !== void 0)
      $$bindings.open(open);
    if (
      $$props.dismissable === void 0 &&
      $$bindings.dismissable &&
      dismissable !== void 0
    )
      $$bindings.dismissable(dismissable);
    {
      dispatch(open ? "open" : "close");
    }
    return `${
      dismissable
        ? `${
            open
              ? `<div>${validate_component(Frame, "Frame").$$render(
                  $$result,
                  Object.assign({}, $$restProps),
                  {},
                  {
                    default: () => {
                      return `${slots.default ? slots.default({ close }) : ``}`;
                    },
                  },
                )}</div>`
              : ``
          }`
        : `${validate_component(Frame, "Frame").$$render(
            $$result,
            Object.assign({}, $$restProps),
            {},
            {
              default: () => {
                return `${slots.default ? slots.default({ close }) : ``}`;
              },
            },
          )}`
    } `;
  },
);
const ToolbarButton = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "color",
      "name",
      "ariaLabel",
      "size",
      "href",
    ]);
    const background = getContext("background");
    let { color = "default" } = $$props;
    let { name = void 0 } = $$props;
    let { ariaLabel = void 0 } = $$props;
    let { size = "md" } = $$props;
    let { href = void 0 } = $$props;
    const colors2 = {
      dark: "text-gray-500 hover:text-gray-900 hover:bg-gray-200 dark:text-gray-400 dark:hover:text-white dark:hover:bg-gray-600",
      gray: "text-gray-500 focus:ring-gray-400 hover:bg-gray-200 dark:hover:bg-gray-800 dark:hover:text-gray-300",
      red: "text-red-500 focus:ring-red-400 hover:bg-red-200 dark:hover:bg-red-800 dark:hover:text-red-300",
      yellow:
        "text-yellow-500 focus:ring-yellow-400 hover:bg-yellow-200 dark:hover:bg-yellow-800 dark:hover:text-yellow-300",
      green:
        "text-green-500 focus:ring-green-400 hover:bg-green-200 dark:hover:bg-green-800 dark:hover:text-green-300",
      indigo:
        "text-indigo-500 focus:ring-indigo-400 hover:bg-indigo-200 dark:hover:bg-indigo-800 dark:hover:text-indigo-300",
      purple:
        "text-purple-500 focus:ring-purple-400 hover:bg-purple-200 dark:hover:bg-purple-800 dark:hover:text-purple-300",
      pink: "text-pink-500 focus:ring-pink-400 hover:bg-pink-200 dark:hover:bg-pink-800 dark:hover:text-pink-300",
      blue: "text-blue-500 focus:ring-blue-400 hover:bg-blue-200 dark:hover:bg-blue-800 dark:hover:text-blue-300",
      primary:
        "text-primary-500 focus:ring-primary-400 hover:bg-primary-200 dark:hover:bg-primary-800 dark:hover:text-primary-300",
      default: "focus:ring-gray-400",
    };
    const sizing = {
      xs: "m-0.5 rounded-sm focus:ring-1 p-0.5",
      sm: "m-0.5 rounded focus:ring-1 p-0.5",
      md: "m-0.5 rounded-lg focus:ring-2 p-1.5",
      lg: "m-0.5 rounded-lg focus:ring-2 p-2.5",
    };
    let buttonClass;
    const svgSizes = {
      xs: "w-3 h-3",
      sm: "w-3.5 h-3.5",
      md: "w-5 h-5",
      lg: "w-5 h-5",
    };
    if ($$props.color === void 0 && $$bindings.color && color !== void 0)
      $$bindings.color(color);
    if ($$props.name === void 0 && $$bindings.name && name !== void 0)
      $$bindings.name(name);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.href === void 0 && $$bindings.href && href !== void 0)
      $$bindings.href(href);
    buttonClass = twMerge(
      "focus:outline-none whitespace-normal",
      sizing[size],
      colors2[color],
      color === "default" &&
        (background
          ? "hover:bg-gray-100 dark:hover:bg-gray-600"
          : "hover:bg-gray-100 dark:hover:bg-gray-700"),
      $$props.class,
    );
    return `${
      href
        ? `<a${spread(
            [
              { href: escape_attribute_value(href) },
              escape_object($$restProps),
              {
                class: escape_attribute_value(buttonClass),
              },
              {
                "aria-label": escape_attribute_value(ariaLabel ?? name),
              },
            ],
            {},
          )}>${name ? `<span class="sr-only">${escape$1(name)}</span>` : ``} ${slots.default ? slots.default({ svgSize: svgSizes[size] }) : ``}</a>`
        : `<button${spread(
            [
              { type: "button" },
              escape_object($$restProps),
              {
                class: escape_attribute_value(buttonClass),
              },
              {
                "aria-label": escape_attribute_value(ariaLabel ?? name),
              },
            ],
            {},
          )}>${name ? `<span class="sr-only">${escape$1(name)}</span>` : ``} ${slots.default ? slots.default({ svgSize: svgSizes[size] }) : ``}</button>`
    } `;
  },
);
const CloseButton = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, ["name"]);
    let { name = "Close" } = $$props;
    if ($$props.name === void 0 && $$bindings.name && name !== void 0)
      $$bindings.name(name);
    return `${validate_component(ToolbarButton, "ToolbarButton").$$render(
      $$result,
      Object.assign({}, { name }, $$restProps, {
        class: twMerge("ms-auto", $$props.class),
      }),
      {},
      {
        default: ({ svgSize }) => {
          return `<svg${add_attribute("class", svgSize, 0)} fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg>`;
        },
      },
    )} `;
  },
);
const DarkMode = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "btnClass",
      "size",
      "ariaLabel",
    ]);
    let {
      btnClass = "text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-700 rounded-lg text-sm p-2.5",
    } = $$props;
    let { size = "md" } = $$props;
    let { ariaLabel = "Dark mode" } = $$props;
    const sizes = {
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
    };
    if (
      $$props.btnClass === void 0 &&
      $$bindings.btnClass &&
      btnClass !== void 0
    )
      $$bindings.btnClass(btnClass);
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `${
      (($$result.head += `<!-- HEAD_svelte-1pa505f_START --><script data-svelte-h="svelte-mp99qu">if ('color-theme' in localStorage) {
      // explicit preference - overrides author's choice
      localStorage.getItem('color-theme') === 'dark' ? window.document.documentElement.classList.add('dark') : window.document.documentElement.classList.remove('dark');
    } else {
      // browser preference - does not overrides
      if (window.matchMedia('(prefers-color-scheme: dark)').matches) window.document.documentElement.classList.add('dark');
    }<\/script><!-- HEAD_svelte-1pa505f_END -->`),
      "")
    } <button${spread(
      [
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { type: "button" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(twMerge(btnClass, $$props.class)),
        },
      ],
      {},
    )}><span class="hidden dark:block">${
      slots.lightIcon
        ? slots.lightIcon({})
        : ` <svg${add_attribute("class", sizes[size], 0)} fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707a1 1 0 00-1.414 1.414l.707.707zm1.414 8.486l-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1
  0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"></path></svg> `
    }</span> <span class="block dark:hidden">${slots.darkIcon ? slots.darkIcon({}) : ` <svg${add_attribute("class", sizes[size], 0)} fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg> `}</span></button> `;
  },
);
const Footer = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["footerType"]);
  let { footerType = void 0 } = $$props;
  let footerClass = twMerge(
    footerType === "sitemap" && "bg-gray-800",
    footerType === "socialmedia" && "p-4 bg-white sm:p-6 dark:bg-gray-800",
    footerType === "logo" &&
      "p-4 bg-white rounded-lg shadow md:px-6 md:py-8 dark:bg-gray-800",
    footerType === "default" &&
      "p-4 bg-white rounded-lg shadow md:flex md:items-center md:justify-between md:p-6 dark:bg-gray-800",
    $$props.class,
  );
  if (
    $$props.footerType === void 0 &&
    $$bindings.footerType &&
    footerType !== void 0
  )
    $$bindings.footerType(footerType);
  return `<footer${spread(
    [
      escape_object($$restProps),
      {
        class: escape_attribute_value(footerClass),
      },
    ],
    {},
  )}>${slots.default ? slots.default({}) : ``}</footer> `;
});
const FooterLink = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "liClass",
      "aClass",
      "href",
      "target",
    ]);
    let { liClass = "me-4 last:me-0 md:me-6" } = $$props;
    let { aClass = "hover:underline" } = $$props;
    let { href = "" } = $$props;
    let { target = void 0 } = $$props;
    let liCls = twMerge(liClass, $$props.classLi);
    let aCls = twMerge(aClass, $$props.classA);
    if ($$props.liClass === void 0 && $$bindings.liClass && liClass !== void 0)
      $$bindings.liClass(liClass);
    if ($$props.aClass === void 0 && $$bindings.aClass && aClass !== void 0)
      $$bindings.aClass(aClass);
    if ($$props.href === void 0 && $$bindings.href && href !== void 0)
      $$bindings.href(href);
    if ($$props.target === void 0 && $$bindings.target && target !== void 0)
      $$bindings.target(target);
    return `<li${add_attribute("class", liCls, 0)}><a${spread(
      [
        escape_object($$restProps),
        { href: escape_attribute_value(href) },
        { class: escape_attribute_value(aCls) },
        { target: escape_attribute_value(target) },
      ],
      {},
    )}>${slots.default ? slots.default({}) : ``}</a></li> `;
  },
);
const FooterLinkGroup = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let { ulClass = "text-gray-600 dark:text-gray-400" } = $$props;
    if ($$props.ulClass === void 0 && $$bindings.ulClass && ulClass !== void 0)
      $$bindings.ulClass(ulClass);
    return `<ul${add_attribute("class", twMerge(ulClass, $$props.class), 0)}>${slots.default ? slots.default({}) : ``}</ul> `;
  },
);
const Marquee = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let { speed = 1 } = $$props;
  let { hoverSpeed = 1 } = $$props;
  let { shadow = false } = $$props;
  let offset = 0;
  let shadowClass = `after:content-[''] after:absolute after:block after:z-10 after:h-full before:content-[''] before:absolute 
    before:block before:z-10 before:h-full before:end-0 after:shadow-[10px_0_50px_65px_rgba(256,256,256,1)] 
    before:shadow-[-10px_0_50px_65px_rgba(256,256,256,1)] dark:after:shadow-[10px_0_50px_65px_rgba(16,24,39,1)]
    dark:before:shadow-[-10px_0_50px_65px_rgba(16,24,39,1)]`;
  let divCls = twMerge(
    "relative flex overflow-hidden w-full",
    shadow ? shadowClass : "",
    $$props.class,
  );
  if ($$props.speed === void 0 && $$bindings.speed && speed !== void 0)
    $$bindings.speed(speed);
  if (
    $$props.hoverSpeed === void 0 &&
    $$bindings.hoverSpeed &&
    hoverSpeed !== void 0
  )
    $$bindings.hoverSpeed(hoverSpeed);
  if ($$props.shadow === void 0 && $$bindings.shadow && shadow !== void 0)
    $$bindings.shadow(shadow);
  return ` <div${add_attribute("class", divCls, 0)} role="banner"><div class="flex justify-around items-center min-w-full" style="${"transform: " + escape$1(`translateX(${offset}px)`, true)}">${slots.default ? slots.default({}) : ``}</div> <div class="flex justify-around items-center min-w-full" style="${"transform: " + escape$1(`translateX(${offset}px)`, true)}">${slots.default ? slots.default({}) : ``}</div></div> `;
});
const NavContainer = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let { fluid = false } = $$props;
    if ($$props.fluid === void 0 && $$bindings.fluid && fluid !== void 0)
      $$bindings.fluid(fluid);
    return `<div${add_attribute("class", twMerge("mx-auto flex flex-wrap justify-between items-center ", fluid ? "w-full" : "container", $$props.class), 0)}>${slots.default ? slots.default({}) : ``}</div> `;
  },
);
const Navbar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, ["fluid"]);
  let $hidden, $$unsubscribe_hidden;
  let { fluid = false } = $$props;
  let hidden = writable(true);
  $$unsubscribe_hidden = subscribe(hidden, (value) => ($hidden = value));
  setContext("navHidden", hidden);
  let toggle = () => hidden.update((hidden2) => !hidden2);
  if ($$props.fluid === void 0 && $$bindings.fluid && fluid !== void 0)
    $$bindings.fluid(fluid);
  {
    {
      $$restProps.color = $$restProps.color ?? "navbar";
    }
  }
  $$unsubscribe_hidden();
  return `${validate_component(Frame, "Frame").$$render(
    $$result,
    Object.assign({}, { tag: "nav" }, $$restProps, {
      class: twMerge("px-2 sm:px-4 py-2.5 w-full", $$props.class),
    }),
    {},
    {
      default: () => {
        return `${validate_component(NavContainer, "NavContainer").$$render(
          $$result,
          { fluid },
          {},
          {
            default: () => {
              return `${slots.default ? slots.default({ hidden: $hidden, toggle, NavContainer }) : ``}`;
            },
          },
        )}`;
      },
    },
  )} `;
});
const NavBrand = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, ["href"]);
    let { href = "" } = $$props;
    if ($$props.href === void 0 && $$bindings.href && href !== void 0)
      $$bindings.href(href);
    return `<a${spread(
      [
        { href: escape_attribute_value(href) },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("flex items-center", $$props.class),
          ),
        },
      ],
      {},
    )}>${slots.default ? slots.default({}) : ``}</a> `;
  },
);
function is_date(obj) {
  return Object.prototype.toString.call(obj) === "[object Date]";
}
function get_interpolator(a, b) {
  if (a === b || a !== a) return () => a;
  const type = typeof a;
  if (type !== typeof b || Array.isArray(a) !== Array.isArray(b)) {
    throw new Error("Cannot interpolate values of different type");
  }
  if (Array.isArray(a)) {
    const arr = b.map((bi, i) => {
      return get_interpolator(a[i], bi);
    });
    return (t) => arr.map((fn) => fn(t));
  }
  if (type === "object") {
    if (!a || !b) throw new Error("Object cannot be null");
    if (is_date(a) && is_date(b)) {
      a = a.getTime();
      b = b.getTime();
      const delta = b - a;
      return (t) => new Date(a + t * delta);
    }
    const keys = Object.keys(b);
    const interpolators = {};
    keys.forEach((key2) => {
      interpolators[key2] = get_interpolator(a[key2], b[key2]);
    });
    return (t) => {
      const result = {};
      keys.forEach((key2) => {
        result[key2] = interpolators[key2](t);
      });
      return result;
    };
  }
  if (type === "number") {
    const delta = b - a;
    return (t) => a + t * delta;
  }
  throw new Error(`Cannot interpolate ${type} values`);
}
function tweened(value, defaults = {}) {
  const store = writable(value);
  let task;
  let target_value = value;
  function set(new_value, opts) {
    if (value == null) {
      store.set((value = new_value));
      return Promise.resolve();
    }
    target_value = new_value;
    let previous_task = task;
    let started = false;
    let {
      delay = 0,
      duration = 400,
      easing = identity,
      interpolate: interpolate2 = get_interpolator,
    } = assign(assign({}, defaults), opts);
    if (duration === 0) {
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      store.set((value = target_value));
      return Promise.resolve();
    }
    const start = now$1() + delay;
    let fn;
    task = loop((now2) => {
      if (now2 < start) return true;
      if (!started) {
        fn = interpolate2(value, new_value);
        if (typeof duration === "function")
          duration = duration(value, new_value);
        started = true;
      }
      if (previous_task) {
        previous_task.abort();
        previous_task = null;
      }
      const elapsed = now2 - start;
      if (elapsed > /** @type {number} */ duration) {
        store.set((value = new_value));
        return false;
      }
      store.set((value = fn(easing(elapsed / duration))));
      return true;
    });
    return task.promise;
  }
  return {
    set,
    update: (fn, opts) => set(fn(target_value, value), opts),
    subscribe: store.subscribe,
  };
}
const clsBtnExtraClass =
  "-mx-1.5 -my-1.5 text-gray-400 hover:text-gray-900 focus:!ring-gray-300 hover:bg-gray-100 dark:text-gray-500 dark:hover:text-white dark:hover:bg-gray-700";
const Toast = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$restProps = compute_rest_props($$props, [
    "dismissable",
    "color",
    "position",
    "divClass",
    "defaultIconClass",
    "contentClass",
    "align",
  ]);
  let $$slots = compute_slots(slots);
  let { dismissable = true } = $$props;
  let { color = "primary" } = $$props;
  let { position = "none" } = $$props;
  let {
    divClass = "w-full max-w-xs p-4 text-gray-500 bg-white shadow dark:text-gray-400 dark:bg-gray-800 gap-3",
  } = $$props;
  let { defaultIconClass = "w-8 h-8" } = $$props;
  let { contentClass = "w-full text-sm font-normal" } = $$props;
  let { align = true } = $$props;
  const positions = {
    "top-left": "absolute top-5 start-5",
    "top-right": "absolute top-5 end-5",
    "bottom-left": "absolute bottom-5 start-5",
    "bottom-right": "absolute bottom-5 end-5",
    none: "",
  };
  let finalDivClass;
  const colors2 = {
    primary:
      "text-primary-500 bg-primary-100 dark:bg-primary-800 dark:text-primary-200",
    gray: "text-gray-500 bg-gray-100 dark:bg-gray-700 dark:text-gray-200",
    red: "text-red-500 bg-red-100 dark:bg-red-800 dark:text-red-200",
    yellow:
      "text-yellow-500 bg-yellow-100 dark:bg-yellow-800 dark:text-yellow-200",
    green: "text-green-500 bg-green-100 dark:bg-green-800 dark:text-green-200",
    blue: "text-blue-500 bg-blue-100 dark:bg-blue-800 dark:text-blue-200",
    indigo:
      "text-indigo-500 bg-indigo-100 dark:bg-indigo-800 dark:text-indigo-200",
    purple:
      "text-purple-500 bg-purple-100 dark:bg-purple-800 dark:text-purple-200",
    orange:
      "text-orange-500 bg-orange-100 dark:bg-orange-700 dark:text-orange-200",
    none: "",
  };
  let iconClass;
  if (
    $$props.dismissable === void 0 &&
    $$bindings.dismissable &&
    dismissable !== void 0
  )
    $$bindings.dismissable(dismissable);
  if ($$props.color === void 0 && $$bindings.color && color !== void 0)
    $$bindings.color(color);
  if ($$props.position === void 0 && $$bindings.position && position !== void 0)
    $$bindings.position(position);
  if ($$props.divClass === void 0 && $$bindings.divClass && divClass !== void 0)
    $$bindings.divClass(divClass);
  if (
    $$props.defaultIconClass === void 0 &&
    $$bindings.defaultIconClass &&
    defaultIconClass !== void 0
  )
    $$bindings.defaultIconClass(defaultIconClass);
  if (
    $$props.contentClass === void 0 &&
    $$bindings.contentClass &&
    contentClass !== void 0
  )
    $$bindings.contentClass(contentClass);
  if ($$props.align === void 0 && $$bindings.align && align !== void 0)
    $$bindings.align(align);
  finalDivClass = twMerge(
    "flex",
    align ? "items-center" : "items-start",
    divClass,
    positions[position],
    $$props.class,
  );
  iconClass = twMerge(
    "inline-flex items-center justify-center shrink-0",
    colors2[color],
    defaultIconClass,
  );
  return `${validate_component(TransitionFrame, "TransitionFrame").$$render(
    $$result,
    Object.assign(
      {},
      { rounded: true },
      { dismissable },
      { color: "none" },
      { role: "alert" },
      $$restProps,
      { class: finalDivClass },
    ),
    {},
    {
      default: ({ close }) => {
        return `${
          $$slots.icon
            ? `${validate_component(Frame, "Frame").$$render(
                $$result,
                {
                  rounded: true,
                  color: "none",
                  class: iconClass,
                },
                {},
                {
                  default: () => {
                    return `${slots.icon ? slots.icon({}) : ``}`;
                  },
                },
              )}`
            : ``
        } <div${add_attribute("class", contentClass, 0)}>${slots.default ? slots.default({}) : ``}</div> ${dismissable ? `${slots["close-button"] ? slots["close-button"]({ close }) : ` ${validate_component(CloseButton, "CloseButton").$$render($$result, { class: clsBtnExtraClass }, {}, {})} `}` : ``}`;
      },
    },
  )} `;
});
const AtomOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "atom outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 22 21" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M7.24 7.194a24.16 24.16 0 0 1 3.72-3.062m0 0c3.443-2.277 6.732-2.969 8.24-1.46 2.054 2.053.03 7.407-4.522 11.959-4.552 4.551-9.906 6.576-11.96 4.522C1.223 17.658 1.89 14.412 4.121 11m6.838-6.868c-3.443-2.277-6.732-2.969-8.24-1.46-2.054 2.053-.03 7.407 4.522 11.959m3.718-10.499a24.16 24.16 0 0 1 3.719 3.062M17.798 11c2.23 3.412 2.898 6.658 1.402 8.153-1.502 1.503-4.771.822-8.2-1.433m1-6.808a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg> `;
  },
);
const CodeMergeOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "code merge outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 14 20" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M3 5v10M3 5a2 2 0 1 0 0-4 2 2 0 0 0 0 4Zm0 10a2 2 0 1 0 0 4 2 2 0 0 0 0-4Zm6-3.976-2-.01A4.015 4.015 0 0 1 3 7m10 4a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg> `;
  },
);
const CodeOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "code outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 20 16" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M5 4 1 8l4 4m10-8 4 4-4 4M11 1 9 15"></path></svg> `;
  },
);
const DatabaseOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "database outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 18 20" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M17 4c0 1.657-3.582 3-8 3S1 5.657 1 4m16 0c0-1.657-3.582-3-8-3S1 2.343 1 4m16 0v6M1 4v6m0 0c0 1.657 3.582 3 8 3s8-1.343 8-3M1 10v6c0 1.657 3.582 3 8 3s8-1.343 8-3v-6"></path></svg> `;
  },
);
const DesktopPcOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "desktop pc outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 20 20" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M10 14v4m-4 1h8M1 10h18M2 1h16a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1Z"></path></svg> `;
  },
);
const DnaOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "dna outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 12 20" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M9.041 11.862A5 5 0 0 1 11 15.831V19M1 1v3.169a5 5 0 0 0 1.891 3.916M11 1v3.169a5 5 0 0 1-2.428 4.288l-5.144 3.086A5 5 0 0 0 1 15.831V19M1 3h10M1.399 6h9.252M2 14h8.652M1 17h10"></path></svg> `;
  },
);
const ExclamationCircleOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "exclamation circle outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 20 20" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M10 11V6m0 8h.01M19 10a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"></path></svg> `;
  },
);
const FireOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "fire outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 18 20" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M15.147 15.085a7.159 7.159 0 0 1-6.189 3.307A6.713 6.713 0 0 1 3.1 15.444c-2.679-4.513.287-8.737.888-9.548A4.373 4.373 0 0 0 5 1.608c1.287.953 6.445 3.218 5.537 10.5 1.5-1.122 2.706-3.009 2.853-6.139 1.433 1.048 3.993 5.394 1.757 9.116Z"></path></svg> `;
  },
);
const HomeSolid = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { ariaLabel = "home solid" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "currentColor" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 20 20" },
      ],
      {},
    )}><path fill="currentColor" d="m19.707 9.293-2-2-7-7a1 1 0 0 0-1.414 0l-7 7-2 2a1 1 0 0 0 1.414 1.414L2 10.414V18a2 2 0 0 0 2 2h3a1 1 0 0 0 1-1v-4a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1v4a1 1 0 0 0 1 1h3a2 2 0 0 0 2-2v-7.586l.293.293a1 1 0 0 0 1.414-1.414Z"></path></svg> `;
  },
);
const KeyboardOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { ariaLabel = "keyboard outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 20 14" },
      ],
      {},
    )}><path fill="currentColor" d="M6.5 9.5v-1a1 1 0 0 0-1 1h1Zm7 0h1a1 1 0 0 0-1-1v1Zm0 1v1a1 1 0 0 0 1-1h-1Zm-7 0h-1a1 1 0 0 0 1 1v-1ZM4 4V3H3v1h1Zm0 .01H3v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V3h-1v1ZM4 7V6H3v1h1Zm0 .01H3v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V6h-1v1ZM4 10V9H3v1h1Zm0 .01H3v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V9h-1v1ZM7 4V3H6v1h1Zm0 .01H6v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V3h-1v1ZM7 7V6H6v1h1Zm0 .01H6v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V6h-1v1ZM10 4V3H9v1h1Zm0 .01H9v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V3h-1v1ZM10 7V6H9v1h1Zm0 .01H9v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V6h-1v1ZM13 4V3h-1v1h1Zm0 .01h-1v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V3h-1v1ZM13 7V6h-1v1h1Zm0 .01h-1v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V6h-1v1ZM16 7V6h-1v1h1Zm0 .01h-1v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V6h-1v1ZM16 10V9h-1v1h1Zm0 .01h-1v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V9h-1v1ZM16 4V3h-1v1h1Zm0 .01h-1v1h1v-1Zm.01 0v1h1v-1h-1Zm0-.01h1V3h-1v1ZM2 2h16V0H2v2Zm16 0h2a2 2 0 0 0-2-2v2Zm0 0v10h2V2h-2Zm0 10v2a2 2 0 0 0 2-2h-2Zm0 0H2v2h16v-2ZM2 12H0a2 2 0 0 0 2 2v-2Zm0 0V2H0v10h2ZM2 2V0a2 2 0 0 0-2 2h2Zm4.5 8.5h7v-2h-7v2Zm6-1v1h2v-1h-2Zm1 0h-7v2h7v-2Zm-6 1v-1h-2v1h2ZM3 4v.01h2V4H3Zm1 1.01h.01v-2H4v2Zm1.01-1V4h-2v.01h2ZM4.01 3H4v2h.01V3ZM3 7v.01h2V7H3Zm1 1.01h.01v-2H4v2Zm1.01-1V7h-2v.01h2ZM4.01 6H4v2h.01V6ZM3 10v.01h2V10H3Zm1 1.01h.01v-2H4v2Zm1.01-1V10h-2v.01h2ZM4.01 9H4v2h.01V9ZM6 4v.01h2V4H6Zm1 1.01h.01v-2H7v2Zm1.01-1V4h-2v.01h2ZM7.01 3H7v2h.01V3ZM6 7v.01h2V7H6Zm1 1.01h.01v-2H7v2Zm1.01-1V7h-2v.01h2ZM7.01 6H7v2h.01V6ZM9 4v.01h2V4H9Zm1 1.01h.01v-2H10v2Zm1.01-1V4h-2v.01h2Zm-1-1.01H10v2h.01V3ZM9 7v.01h2V7H9Zm1 1.01h.01v-2H10v2Zm1.01-1V7h-2v.01h2Zm-1-1.01H10v2h.01V6ZM12 4v.01h2V4h-2Zm1 1.01h.01v-2H13v2Zm1.01-1V4h-2v.01h2Zm-1-1.01H13v2h.01V3ZM12 7v.01h2V7h-2Zm1 1.01h.01v-2H13v2Zm1.01-1V7h-2v.01h2Zm-1-1.01H13v2h.01V6ZM15 7v.01h2V7h-2Zm1 1.01h.01v-2H16v2Zm1.01-1V7h-2v.01h2Zm-1-1.01H16v2h.01V6ZM15 10v.01h2V10h-2Zm1 1.01h.01v-2H16v2Zm1.01-1V10h-2v.01h2Zm-1-1.01H16v2h.01V9ZM15 4v.01h2V4h-2Zm1 1.01h.01v-2H16v2Zm1.01-1V4h-2v.01h2Zm-1-1.01H16v2h.01V3Z"></path></svg> `;
  },
);
const MobilePhoneOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "mobile phone outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 14 20" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M1 14h12M1 4h12M6.5 16.5h1M2 1h10a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1Z"></path></svg> `;
  },
);
const ProfileCardOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "profile card outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 20 16" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="M3.656 12.115a3 3 0 0 1 5.682-.015M13 5h3m-3 3h3m-3 3h3M2 1h16a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1Zm6.5 4.5a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"></path></svg> `;
  },
);
const StarOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "star outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 21 20" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="m11.479 1.712 2.367 4.8a.532.532 0 0 0 .4.292l5.294.769a.534.534 0 0 1 .3.911l-3.83 3.734a.534.534 0 0 0-.154.473l.9 5.272a.535.535 0 0 1-.775.563l-4.734-2.489a.536.536 0 0 0-.5 0l-4.73 2.486a.535.535 0 0 1-.775-.563l.9-5.272a.534.534 0 0 0-.154-.473l-3.83-3.734a.534.534 0 0 1 .3-.911l5.294-.77a.532.532 0 0 0 .4-.292l2.367-4.8a.534.534 0 0 1 .96.004Z"></path></svg> `;
  },
);
const TerminalOutline = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, [
      "size",
      "role",
      "strokeLinecap",
      "strokeLinejoin",
      "strokeWidth",
      "ariaLabel",
    ]);
    const ctx = getContext("iconCtx") ?? {};
    const sizes = {
      xs: "w-3 h-3",
      sm: "w-4 h-4",
      md: "w-5 h-5",
      lg: "w-6 h-6",
      xl: "w-8 h-8",
    };
    let { size = ctx.size || "md" } = $$props;
    let { role = ctx.role || "img" } = $$props;
    let { strokeLinecap = ctx.strokeLinecap || "round" } = $$props;
    let { strokeLinejoin = ctx.strokeLinejoin || "round" } = $$props;
    let { strokeWidth = ctx.strokeWidth || "2" } = $$props;
    let { ariaLabel = "terminal outline" } = $$props;
    if ($$props.size === void 0 && $$bindings.size && size !== void 0)
      $$bindings.size(size);
    if ($$props.role === void 0 && $$bindings.role && role !== void 0)
      $$bindings.role(role);
    if (
      $$props.strokeLinecap === void 0 &&
      $$bindings.strokeLinecap &&
      strokeLinecap !== void 0
    )
      $$bindings.strokeLinecap(strokeLinecap);
    if (
      $$props.strokeLinejoin === void 0 &&
      $$bindings.strokeLinejoin &&
      strokeLinejoin !== void 0
    )
      $$bindings.strokeLinejoin(strokeLinejoin);
    if (
      $$props.strokeWidth === void 0 &&
      $$bindings.strokeWidth &&
      strokeWidth !== void 0
    )
      $$bindings.strokeWidth(strokeWidth);
    if (
      $$props.ariaLabel === void 0 &&
      $$bindings.ariaLabel &&
      ariaLabel !== void 0
    )
      $$bindings.ariaLabel(ariaLabel);
    return `<svg${spread(
      [
        { xmlns: "http://www.w3.org/2000/svg" },
        { fill: "none" },
        escape_object($$restProps),
        {
          class: escape_attribute_value(
            twMerge("shrink-0", sizes[size], $$props.class),
          ),
        },
        { role: escape_attribute_value(role) },
        {
          "aria-label": escape_attribute_value(ariaLabel),
        },
        { viewBox: "0 0 20 18" },
      ],
      {},
    )}><path stroke="currentColor"${add_attribute("stroke-linecap", strokeLinecap, 0)}${add_attribute("stroke-linejoin", strokeLinejoin, 0)}${add_attribute("stroke-width", strokeWidth, 0)} d="m5 5 4 4-4 4m5 0h5M2 1h16a1 1 0 0 1 1 1v14a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1Z"></path></svg> `;
  },
);
const site = {
  name: "Kooper's portfolio",
  description:
    "My own corner of the internet to play around with tech that's too fun for a production environment",
};
const Navbar_1 = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $currentUser, $$unsubscribe_currentUser;
    $$unsubscribe_currentUser = subscribe(
      currentUser,
      (value) => ($currentUser = value),
    );
    $currentUser?.model?.username;
    $$unsubscribe_currentUser();
    return `${validate_component(Navbar, "Navbar").$$render(
      $$result,
      { class: "flex flex-row" },
      {},
      {
        default: () => {
          return `${validate_component(NavBrand, "NavBrand").$$render(
            $$result,
            { href: "/", class: "w-20" },
            {},
            {
              default: () => {
                return `<span class="self-center whitespace-nowrap text-xl font-semibold dark:text-white">${validate_component(
                  HomeSolid,
                  "HomeSolid",
                ).$$render(
                  $$result,
                  {
                    class:
                      "text-primary-500 dark:text-primary-400 hover:bg-primary-100 dark:hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:focus:ring-gray-700 rounded-lg text-sm p-2.5 w-10 h-10",
                    fill: "primary-600",
                  },
                  {},
                  {},
                )}</span>`;
              },
            },
          )} ${validate_component(Marquee, "Marquee").$$render(
            $$result,
            { class: "w-0 grow" },
            {},
            {
              default: () => {
                return `${validate_component(AtomOutline, "AtomOutline").$$render($$result, {}, {}, {})} ${validate_component(MobilePhoneOutline, "MobilePhoneOutline").$$render($$result, { class: "hidden md:block" }, {}, {})} ${validate_component(ProfileCardOutline, "ProfileCardOutline").$$render($$result, { class: "hidden md:block" }, {}, {})} ${validate_component(CodeMergeOutline, "CodeMergeOutline").$$render($$result, { class: "hidden md:block" }, {}, {})} ${validate_component(CodeOutline, "CodeOutline").$$render($$result, {}, {}, {})} ${validate_component(DatabaseOutline, "DatabaseOutline").$$render($$result, {}, {}, {})} ${validate_component(DesktopPcOutline, "DesktopPcOutline").$$render($$result, { class: "hidden md:block" }, {}, {})} ${validate_component(DnaOutline, "DnaOutline").$$render($$result, { class: "hidden md:block" }, {}, {})} ${validate_component(KeyboardOutline, "KeyboardOutline").$$render($$result, {}, {}, {})} ${validate_component(StarOutline, "StarOutline").$$render($$result, { class: "hidden md:block" }, {}, {})} ${validate_component(TerminalOutline, "TerminalOutline").$$render($$result, {}, {}, {})}`;
              },
            },
          )} <div class="w-20 flex justify-end">${validate_component(DarkMode, "DarkMode").$$render($$result, { class: "w-10 h-10" }, {}, {})}</div>`;
        },
      },
    )}`;
  },
);
const metadata = writable({});
const toast = writable({});
new Vector3$1();
new Vector3$1();
new Vector3$1();
const useControlsContext = () => {
  return useThrelteUserContext("threlte-controls", {
    orbitControls: writable(void 0),
    trackballControls: writable(void 0),
  });
};
const _changeEvent = { type: "change" };
const _startEvent = { type: "start" };
const _endEvent = { type: "end" };
const _ray = new Ray();
const _plane = new Plane();
const TILT_LIMIT = Math.cos(70 * MathUtils.DEG2RAD);
let OrbitControls$1 = class OrbitControls extends EventDispatcher {
  constructor(object, domElement) {
    super();
    this.object = object;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    this.enabled = true;
    this.target = new Vector3$1();
    this.cursor = new Vector3$1();
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.minTargetRadius = 0;
    this.maxTargetRadius = Infinity;
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.enableDamping = false;
    this.dampingFactor = 0.05;
    this.enableZoom = true;
    this.zoomSpeed = 1;
    this.enableRotate = true;
    this.rotateSpeed = 1;
    this.enablePan = true;
    this.panSpeed = 1;
    this.screenSpacePanning = true;
    this.keyPanSpeed = 7;
    this.zoomToCursor = false;
    this.autoRotate = false;
    this.autoRotateSpeed = 2;
    this.keys = {
      LEFT: "ArrowLeft",
      UP: "ArrowUp",
      RIGHT: "ArrowRight",
      BOTTOM: "ArrowDown",
    };
    this.mouseButtons = {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN,
    };
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
    this.target0 = this.target.clone();
    this.position0 = this.object.position.clone();
    this.zoom0 = this.object.zoom;
    this._domElementKeyEvents = null;
    this.getPolarAngle = function () {
      return spherical.phi;
    };
    this.getAzimuthalAngle = function () {
      return spherical.theta;
    };
    this.getDistance = function () {
      return this.object.position.distanceTo(this.target);
    };
    this.listenToKeyEvents = function (domElement2) {
      domElement2.addEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = domElement2;
    };
    this.stopListenToKeyEvents = function () {
      this._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
      this._domElementKeyEvents = null;
    };
    this.saveState = function () {
      scope.target0.copy(scope.target);
      scope.position0.copy(scope.object.position);
      scope.zoom0 = scope.object.zoom;
    };
    this.reset = function () {
      scope.target.copy(scope.target0);
      scope.object.position.copy(scope.position0);
      scope.object.zoom = scope.zoom0;
      scope.object.updateProjectionMatrix();
      scope.dispatchEvent(_changeEvent);
      scope.update();
      state = STATE.NONE;
    };
    this.update = (function () {
      const offset = new Vector3$1();
      const quat = new Quaternion$1().setFromUnitVectors(
        object.up,
        new Vector3$1(0, 1, 0),
      );
      const quatInverse = quat.clone().invert();
      const lastPosition = new Vector3$1();
      const lastQuaternion = new Quaternion$1();
      const lastTargetPosition = new Vector3$1();
      const twoPI = 2 * Math.PI;
      return function update2(deltaTime = null) {
        const position = scope.object.position;
        offset.copy(position).sub(scope.target);
        offset.applyQuaternion(quat);
        spherical.setFromVector3(offset);
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle(deltaTime));
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor;
          spherical.phi += sphericalDelta.phi * scope.dampingFactor;
        } else {
          spherical.theta += sphericalDelta.theta;
          spherical.phi += sphericalDelta.phi;
        }
        let min = scope.minAzimuthAngle;
        let max = scope.maxAzimuthAngle;
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI) min += twoPI;
          else if (min > Math.PI) min -= twoPI;
          if (max < -Math.PI) max += twoPI;
          else if (max > Math.PI) max -= twoPI;
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta));
          } else {
            spherical.theta =
              spherical.theta > (min + max) / 2
                ? Math.max(min, spherical.theta)
                : Math.min(max, spherical.theta);
          }
        }
        spherical.phi = Math.max(
          scope.minPolarAngle,
          Math.min(scope.maxPolarAngle, spherical.phi),
        );
        spherical.makeSafe();
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor);
        } else {
          scope.target.add(panOffset);
        }
        scope.target.sub(scope.cursor);
        scope.target.clampLength(scope.minTargetRadius, scope.maxTargetRadius);
        scope.target.add(scope.cursor);
        let zoomChanged = false;
        if (
          (scope.zoomToCursor && performCursorZoom) ||
          scope.object.isOrthographicCamera
        ) {
          spherical.radius = clampDistance(spherical.radius);
        } else {
          const prevRadius = spherical.radius;
          spherical.radius = clampDistance(spherical.radius * scale);
          zoomChanged = prevRadius != spherical.radius;
        }
        offset.setFromSpherical(spherical);
        offset.applyQuaternion(quatInverse);
        position.copy(scope.target).add(offset);
        scope.object.lookAt(scope.target);
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor;
          sphericalDelta.phi *= 1 - scope.dampingFactor;
          panOffset.multiplyScalar(1 - scope.dampingFactor);
        } else {
          sphericalDelta.set(0, 0, 0);
          panOffset.set(0, 0, 0);
        }
        if (scope.zoomToCursor && performCursorZoom) {
          let newRadius = null;
          if (scope.object.isPerspectiveCamera) {
            const prevRadius = offset.length();
            newRadius = clampDistance(prevRadius * scale);
            const radiusDelta = prevRadius - newRadius;
            scope.object.position.addScaledVector(dollyDirection, radiusDelta);
            scope.object.updateMatrixWorld();
            zoomChanged = !!radiusDelta;
          } else if (scope.object.isOrthographicCamera) {
            const mouseBefore = new Vector3$1(mouse.x, mouse.y, 0);
            mouseBefore.unproject(scope.object);
            const prevZoom = scope.object.zoom;
            scope.object.zoom = Math.max(
              scope.minZoom,
              Math.min(scope.maxZoom, scope.object.zoom / scale),
            );
            scope.object.updateProjectionMatrix();
            zoomChanged = prevZoom !== scope.object.zoom;
            const mouseAfter = new Vector3$1(mouse.x, mouse.y, 0);
            mouseAfter.unproject(scope.object);
            scope.object.position.sub(mouseAfter).add(mouseBefore);
            scope.object.updateMatrixWorld();
            newRadius = offset.length();
          } else {
            console.warn(
              "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.",
            );
            scope.zoomToCursor = false;
          }
          if (newRadius !== null) {
            if (this.screenSpacePanning) {
              scope.target
                .set(0, 0, -1)
                .transformDirection(scope.object.matrix)
                .multiplyScalar(newRadius)
                .add(scope.object.position);
            } else {
              _ray.origin.copy(scope.object.position);
              _ray.direction
                .set(0, 0, -1)
                .transformDirection(scope.object.matrix);
              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {
                object.lookAt(scope.target);
              } else {
                _plane.setFromNormalAndCoplanarPoint(
                  scope.object.up,
                  scope.target,
                );
                _ray.intersectPlane(_plane, scope.target);
              }
            }
          }
        } else if (scope.object.isOrthographicCamera) {
          const prevZoom = scope.object.zoom;
          scope.object.zoom = Math.max(
            scope.minZoom,
            Math.min(scope.maxZoom, scope.object.zoom / scale),
          );
          if (prevZoom !== scope.object.zoom) {
            scope.object.updateProjectionMatrix();
            zoomChanged = true;
          }
        }
        scale = 1;
        performCursorZoom = false;
        if (
          zoomChanged ||
          lastPosition.distanceToSquared(scope.object.position) > EPS ||
          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS ||
          lastTargetPosition.distanceToSquared(scope.target) > EPS
        ) {
          scope.dispatchEvent(_changeEvent);
          lastPosition.copy(scope.object.position);
          lastQuaternion.copy(scope.object.quaternion);
          lastTargetPosition.copy(scope.target);
          return true;
        }
        return false;
      };
    })();
    this.dispose = function () {
      scope.domElement.removeEventListener("contextmenu", onContextMenu);
      scope.domElement.removeEventListener("pointerdown", onPointerDown);
      scope.domElement.removeEventListener("pointercancel", onPointerUp);
      scope.domElement.removeEventListener("wheel", onMouseWheel);
      scope.domElement.removeEventListener("pointermove", onPointerMove);
      scope.domElement.removeEventListener("pointerup", onPointerUp);
      const document3 = scope.domElement.getRootNode();
      document3.removeEventListener("keydown", interceptControlDown, {
        capture: true,
      });
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        scope._domElementKeyEvents = null;
      }
    };
    const scope = this;
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6,
    };
    let state = STATE.NONE;
    const EPS = 1e-6;
    const spherical = new Spherical();
    const sphericalDelta = new Spherical();
    let scale = 1;
    const panOffset = new Vector3$1();
    const rotateStart = new Vector2();
    const rotateEnd = new Vector2();
    const rotateDelta = new Vector2();
    const panStart = new Vector2();
    const panEnd = new Vector2();
    const panDelta = new Vector2();
    const dollyStart = new Vector2();
    const dollyEnd = new Vector2();
    const dollyDelta = new Vector2();
    const dollyDirection = new Vector3$1();
    const mouse = new Vector2();
    let performCursorZoom = false;
    const pointers = [];
    const pointerPositions = {};
    let controlActive = false;
    function getAutoRotationAngle(deltaTime) {
      if (deltaTime !== null) {
        return ((2 * Math.PI) / 60) * scope.autoRotateSpeed * deltaTime;
      } else {
        return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed;
      }
    }
    function getZoomScale(delta) {
      const normalizedDelta = Math.abs(delta * 0.01);
      return Math.pow(0.95, scope.zoomSpeed * normalizedDelta);
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle;
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle;
    }
    const panLeft = (function () {
      const v = new Vector3$1();
      return function panLeft2(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.multiplyScalar(-distance);
        panOffset.add(v);
      };
    })();
    const panUp = (function () {
      const v = new Vector3$1();
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(scope.object.up, v);
        }
        v.multiplyScalar(distance);
        panOffset.add(v);
      };
    })();
    const pan = (function () {
      const offset = new Vector3$1();
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement;
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          let targetDistance = offset.length();
          targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180);
          panLeft(
            (2 * deltaX * targetDistance) / element.clientHeight,
            scope.object.matrix,
          );
          panUp(
            (2 * deltaY * targetDistance) / element.clientHeight,
            scope.object.matrix,
          );
        } else if (scope.object.isOrthographicCamera) {
          panLeft(
            (deltaX * (scope.object.right - scope.object.left)) /
              scope.object.zoom /
              element.clientWidth,
            scope.object.matrix,
          );
          panUp(
            (deltaY * (scope.object.top - scope.object.bottom)) /
              scope.object.zoom /
              element.clientHeight,
            scope.object.matrix,
          );
        } else {
          console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.",
          );
          scope.enablePan = false;
        }
      };
    })();
    function dollyOut(dollyScale) {
      if (
        scope.object.isPerspectiveCamera ||
        scope.object.isOrthographicCamera
      ) {
        scale /= dollyScale;
      } else {
        console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.",
        );
        scope.enableZoom = false;
      }
    }
    function dollyIn(dollyScale) {
      if (
        scope.object.isPerspectiveCamera ||
        scope.object.isOrthographicCamera
      ) {
        scale *= dollyScale;
      } else {
        console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.",
        );
        scope.enableZoom = false;
      }
    }
    function updateZoomParameters(x, y2) {
      if (!scope.zoomToCursor) {
        return;
      }
      performCursorZoom = true;
      const rect = scope.domElement.getBoundingClientRect();
      const dx = x - rect.left;
      const dy = y2 - rect.top;
      const w = rect.width;
      const h = rect.height;
      mouse.x = (dx / w) * 2 - 1;
      mouse.y = -(dy / h) * 2 + 1;
      dollyDirection
        .set(mouse.x, mouse.y, 1)
        .unproject(scope.object)
        .sub(scope.object.position)
        .normalize();
    }
    function clampDistance(dist) {
      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownDolly(event) {
      updateZoomParameters(event.clientX, event.clientX);
      dollyStart.set(event.clientX, event.clientY);
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY);
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY);
      rotateDelta
        .subVectors(rotateEnd, rotateStart)
        .multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight);
      rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);
      rotateStart.copy(rotateEnd);
      scope.update();
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY);
      dollyDelta.subVectors(dollyEnd, dollyStart);
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale(dollyDelta.y));
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale(dollyDelta.y));
      }
      dollyStart.copy(dollyEnd);
      scope.update();
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
      scope.update();
    }
    function handleMouseWheel(event) {
      updateZoomParameters(event.clientX, event.clientY);
      if (event.deltaY < 0) {
        dollyIn(getZoomScale(event.deltaY));
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale(event.deltaY));
      }
      scope.update();
    }
    function handleKeyDown(event) {
      let needsUpdate = false;
      switch (event.code) {
        case scope.keys.UP:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(
              (2 * Math.PI * scope.rotateSpeed) / scope.domElement.clientHeight,
            );
          } else {
            pan(0, scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.BOTTOM:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateUp(
              (-2 * Math.PI * scope.rotateSpeed) /
                scope.domElement.clientHeight,
            );
          } else {
            pan(0, -scope.keyPanSpeed);
          }
          needsUpdate = true;
          break;
        case scope.keys.LEFT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(
              (2 * Math.PI * scope.rotateSpeed) / scope.domElement.clientHeight,
            );
          } else {
            pan(scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
        case scope.keys.RIGHT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            rotateLeft(
              (-2 * Math.PI * scope.rotateSpeed) /
                scope.domElement.clientHeight,
            );
          } else {
            pan(-scope.keyPanSpeed, 0);
          }
          needsUpdate = true;
          break;
      }
      if (needsUpdate) {
        event.preventDefault();
        scope.update();
      }
    }
    function handleTouchStartRotate(event) {
      if (pointers.length === 1) {
        rotateStart.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y2 = 0.5 * (event.pageY + position.y);
        rotateStart.set(x, y2);
      }
    }
    function handleTouchStartPan(event) {
      if (pointers.length === 1) {
        panStart.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y2 = 0.5 * (event.pageY + position.y);
        panStart.set(x, y2);
      }
    }
    function handleTouchStartDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
    function handleTouchStartDollyPan(event) {
      if (scope.enableZoom) handleTouchStartDolly(event);
      if (scope.enablePan) handleTouchStartPan(event);
    }
    function handleTouchStartDollyRotate(event) {
      if (scope.enableZoom) handleTouchStartDolly(event);
      if (scope.enableRotate) handleTouchStartRotate(event);
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y2 = 0.5 * (event.pageY + position.y);
        rotateEnd.set(x, y2);
      }
      rotateDelta
        .subVectors(rotateEnd, rotateStart)
        .multiplyScalar(scope.rotateSpeed);
      const element = scope.domElement;
      rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight);
      rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight);
      rotateStart.copy(rotateEnd);
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY);
      } else {
        const position = getSecondPointerPosition(event);
        const x = 0.5 * (event.pageX + position.x);
        const y2 = 0.5 * (event.pageY + position.y);
        panEnd.set(x, y2);
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event);
      const dx = event.pageX - position.x;
      const dy = event.pageY - position.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyOut(dollyDelta.y);
      dollyStart.copy(dollyEnd);
      const centerX = (event.pageX + position.x) * 0.5;
      const centerY = (event.pageY + position.y) * 0.5;
      updateZoomParameters(centerX, centerY);
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event);
      if (scope.enablePan) handleTouchMovePan(event);
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event);
      if (scope.enableRotate) handleTouchMoveRotate(event);
    }
    function onPointerDown(event) {
      if (scope.enabled === false) return;
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId);
        scope.domElement.addEventListener("pointermove", onPointerMove);
        scope.domElement.addEventListener("pointerup", onPointerUp);
      }
      if (isTrackingPointer(event)) return;
      addPointer(event);
      if (event.pointerType === "touch") {
        onTouchStart(event);
      } else {
        onMouseDown(event);
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false) return;
      if (event.pointerType === "touch") {
        onTouchMove(event);
      } else {
        onMouseMove(event);
      }
    }
    function onPointerUp(event) {
      removePointer(event);
      switch (pointers.length) {
        case 0:
          scope.domElement.releasePointerCapture(event.pointerId);
          scope.domElement.removeEventListener("pointermove", onPointerMove);
          scope.domElement.removeEventListener("pointerup", onPointerUp);
          scope.dispatchEvent(_endEvent);
          state = STATE.NONE;
          break;
        case 1:
          const pointerId = pointers[0];
          const position = pointerPositions[pointerId];
          onTouchStart({ pointerId, pageX: position.x, pageY: position.y });
          break;
      }
    }
    function onMouseDown(event) {
      let mouseAction;
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT;
          break;
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE;
          break;
        case 2:
          mouseAction = scope.mouseButtons.RIGHT;
          break;
        default:
          mouseAction = -1;
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false) return;
          handleMouseDownDolly(event);
          state = STATE.DOLLY;
          break;
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false) return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          } else {
            if (scope.enableRotate === false) return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          }
          break;
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false) return;
            handleMouseDownRotate(event);
            state = STATE.ROTATE;
          } else {
            if (scope.enablePan === false) return;
            handleMouseDownPan(event);
            state = STATE.PAN;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onMouseMove(event) {
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false) return;
          handleMouseMoveRotate(event);
          break;
        case STATE.DOLLY:
          if (scope.enableZoom === false) return;
          handleMouseMoveDolly(event);
          break;
        case STATE.PAN:
          if (scope.enablePan === false) return;
          handleMouseMovePan(event);
          break;
      }
    }
    function onMouseWheel(event) {
      if (
        scope.enabled === false ||
        scope.enableZoom === false ||
        state !== STATE.NONE
      )
        return;
      event.preventDefault();
      scope.dispatchEvent(_startEvent);
      handleMouseWheel(customWheelEvent(event));
      scope.dispatchEvent(_endEvent);
    }
    function customWheelEvent(event) {
      const mode = event.deltaMode;
      const newEvent = {
        clientX: event.clientX,
        clientY: event.clientY,
        deltaY: event.deltaY,
      };
      switch (mode) {
        case 1:
          newEvent.deltaY *= 16;
          break;
        case 2:
          newEvent.deltaY *= 100;
          break;
      }
      if (event.ctrlKey && !controlActive) {
        newEvent.deltaY *= 10;
      }
      return newEvent;
    }
    function interceptControlDown(event) {
      if (event.key === "Control") {
        controlActive = true;
        const document3 = scope.domElement.getRootNode();
        document3.addEventListener("keyup", interceptControlUp, {
          passive: true,
          capture: true,
        });
      }
    }
    function interceptControlUp(event) {
      if (event.key === "Control") {
        controlActive = false;
        const document3 = scope.domElement.getRootNode();
        document3.removeEventListener("keyup", interceptControlUp, {
          passive: true,
          capture: true,
        });
      }
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false) return;
      handleKeyDown(event);
    }
    function onTouchStart(event) {
      trackPointer(event);
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false) return;
              handleTouchStartRotate(event);
              state = STATE.TOUCH_ROTATE;
              break;
            case TOUCH.PAN:
              if (scope.enablePan === false) return;
              handleTouchStartPan(event);
              state = STATE.TOUCH_PAN;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return;
              handleTouchStartDollyPan(event);
              state = STATE.TOUCH_DOLLY_PAN;
              break;
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return;
              handleTouchStartDollyRotate(event);
              state = STATE.TOUCH_DOLLY_ROTATE;
              break;
            default:
              state = STATE.NONE;
          }
          break;
        default:
          state = STATE.NONE;
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent);
      }
    }
    function onTouchMove(event) {
      trackPointer(event);
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false) return;
          handleTouchMoveRotate(event);
          scope.update();
          break;
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false) return;
          handleTouchMovePan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false) return;
          handleTouchMoveDollyPan(event);
          scope.update();
          break;
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false)
            return;
          handleTouchMoveDollyRotate(event);
          scope.update();
          break;
        default:
          state = STATE.NONE;
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false) return;
      event.preventDefault();
    }
    function addPointer(event) {
      pointers.push(event.pointerId);
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId];
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i] == event.pointerId) {
          pointers.splice(i, 1);
          return;
        }
      }
    }
    function isTrackingPointer(event) {
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i] == event.pointerId) return true;
      }
      return false;
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId];
      if (position === void 0) {
        position = new Vector2();
        pointerPositions[event.pointerId] = position;
      }
      position.set(event.pageX, event.pageY);
    }
    function getSecondPointerPosition(event) {
      const pointerId =
        event.pointerId === pointers[0] ? pointers[1] : pointers[0];
      return pointerPositions[pointerId];
    }
    scope.domElement.addEventListener("contextmenu", onContextMenu);
    scope.domElement.addEventListener("pointerdown", onPointerDown);
    scope.domElement.addEventListener("pointercancel", onPointerUp);
    scope.domElement.addEventListener("wheel", onMouseWheel, {
      passive: false,
    });
    const document2 = scope.domElement.getRootNode();
    document2.addEventListener("keydown", interceptControlDown, {
      passive: true,
      capture: true,
    });
    this.update();
  }
};
const OrbitControls2 = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let $$restProps = compute_rest_props($$props, ["ref"]);
    let $parent, $$unsubscribe_parent;
    let $component, $$unsubscribe_component;
    const parent = useParent();
    $$unsubscribe_parent = subscribe(parent, (value) => ($parent = value));
    const isCamera2 = (p) => {
      return p.isCamera;
    };
    const { renderer, invalidate } = useThrelte();
    if (!isCamera2($parent)) {
      throw new Error(
        "Parent missing: <OrbitControls> need to be a child of a <Camera>",
      );
    }
    const ref = new OrbitControls$1($parent, renderer.domElement);
    const { start, stop } = useTask(ref.update, {
      autoStart: false,
      autoInvalidate: false,
    });
    const component = forwardEventHandlers();
    $$unsubscribe_component = subscribe(
      component,
      (value) => ($component = value),
    );
    const { orbitControls } = useControlsContext();
    orbitControls.set(ref);
    onDestroy(() => orbitControls.set(void 0));
    if ($$props.ref === void 0 && $$bindings.ref && ref !== void 0)
      $$bindings.ref(ref);
    let $$settled;
    let $$rendered;
    let previous_head = $$result.head;
    do {
      $$settled = true;
      $$result.head = previous_head;
      {
        {
          if ($$restProps.autoRotate || $$restProps.enableDamping) start();
          else stop();
        }
      }
      $$rendered = `${validate_component(T, "T").$$render(
        $$result,
        Object.assign({}, { is: ref }, $$restProps, { this: $component }),
        {
          this: ($$value) => {
            $component = $$value;
            $$settled = false;
          },
        },
        {
          default: ({ ref: ref2 }) => {
            return `${slots.default ? slots.default({ ref: ref2 }) : ``}`;
          },
        },
      )}`;
    } while (!$$settled);
    $$unsubscribe_parent();
    $$unsubscribe_component();
    return $$rendered;
  },
);
new Matrix4();
new Matrix4();
new Mesh();
`
    ${ShaderChunk.logdepthbuf_pars_vertex}
    ${ShaderChunk.fog_pars_vertex}

    attribute vec3 previous;
    attribute vec3 next;
    attribute float side;
    attribute float width;
    attribute float counters;

    uniform vec2 resolution;
    uniform float lineWidth;
    uniform vec3 color;
    uniform float opacity;
    uniform float sizeAttenuation;
    uniform float scaleDown;

    varying vec2 vUV;
    varying vec4 vColor;
    varying float vCounters;

    vec2 intoScreen(vec4 i) {
        return resolution * (0.5 * i.xy / i.w + 0.5);
    }

    void main() {
        float aspect = resolution.y / resolution.x;

        mat4 m = projectionMatrix * modelViewMatrix;

        vec4 currentClip = m * vec4( position, 1.0 );
        vec4 prevClip = m * vec4( previous, 1.0 );
        vec4 nextClip = m * vec4( next, 1.0 );

        vec4 currentNormed = currentClip / currentClip.w;
        vec4 prevNormed = prevClip / prevClip.w;
        vec4 nextNormed = nextClip / nextClip.w;

        vec2 currentScreen = intoScreen(currentNormed);
        vec2 prevScreen = intoScreen(prevNormed);
        vec2 nextScreen = intoScreen(nextNormed);

        float actualWidth = lineWidth * width;

        vec2 dir;
        if(nextScreen == currentScreen) {
            dir = normalize( currentScreen - prevScreen );
        } else if(prevScreen == currentScreen) {
            dir = normalize( nextScreen - currentScreen );
        } else {
            vec2 inDir = currentScreen - prevScreen;
            vec2 outDir = nextScreen - currentScreen;
            vec2 fullDir = nextScreen - prevScreen;

            if(length(fullDir) > 0.0) {
                dir = normalize(fullDir);
            } else if(length(inDir) > 0.0){
                dir = normalize(inDir);
            } else {
                dir = normalize(outDir);
            }
        }

        vec2 normal = vec2(-dir.y, dir.x);

        if(sizeAttenuation != 0.0) {
            normal /= currentClip.w;
            normal *= min(resolution.x, resolution.y);
        }

        if (scaleDown > 0.0) {
            float dist = length(nextNormed - prevNormed);
            normal *= smoothstep(0.0, scaleDown, dist);
        }

        vec2 offsetInScreen = actualWidth * normal * side * 0.5;

        vec2 withOffsetScreen = currentScreen + offsetInScreen;
        vec3 withOffsetNormed = vec3((2.0 * withOffsetScreen/resolution - 1.0), currentNormed.z);

        vCounters = counters;
        vColor = vec4( color, opacity );
        vUV = uv;

        gl_Position = currentClip.w * vec4(withOffsetNormed, 1.0);

        ${ShaderChunk.logdepthbuf_vertex}
        ${ShaderChunk.fog_vertex}
    }
`;
`
uniform vec3 glowColor;
uniform float falloffAmount;
uniform float glowSharpness;
uniform float glowInternalRadius;

varying vec3 vPosition;
varying vec3 vNormal;

void main()
{
	// Normal
	vec3 normal = normalize(vNormal);
	if(!gl_FrontFacing)
			normal *= - 1.0;
	vec3 viewDirection = normalize(cameraPosition - vPosition);
	float fresnel = dot(viewDirection, normal);
	fresnel = pow(fresnel, glowInternalRadius + 0.1);
	float falloff = smoothstep(0., falloffAmount, fresnel);
	float fakeGlow = fresnel;
	fakeGlow += fresnel * glowSharpness;
	fakeGlow *= falloff;
	gl_FragColor = vec4(clamp(glowColor * fresnel, 0., 1.0), clamp(fakeGlow, 0., 1.0));

	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;
`
uniform sampler2D pointTexture;
uniform float fade;
uniform float opacity;

varying vec3 vColor;
void main() {
	float pointOpacity = 1.0;
	if (fade == 1.0) {
		float d = distance(gl_PointCoord, vec2(0.5, 0.5));
		pointOpacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));
	}
	gl_FragColor = vec4(vColor, pointOpacity * opacity);

	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;
`#define ENVMAP_TYPE_CUBE_UV
precision highp isampler2D;
precision highp usampler2D;
varying vec3 vWorldPosition;
varying vec3 vNormal;
varying mat4 vModelMatrixInverse;

#ifdef USE_INSTANCING_COLOR
	varying vec3 vInstanceColor;
#endif

#ifdef ENVMAP_TYPE_CUBEM
	uniform samplerCube envMap;
#else
	uniform sampler2D envMap;
#endif

uniform float bounces;
${shaderStructs}
${shaderIntersectFunction}
uniform BVH bvh;
uniform float ior;
uniform bool correctMips;
uniform vec2 resolution;
uniform float fresnel;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrixInverse;
uniform mat4 viewMatrixInverse;
uniform float aberrationStrength;
uniform vec3 color;

float fresnelFunc(vec3 viewDirection, vec3 worldNormal) {
	return pow( 1.0 + dot( viewDirection, worldNormal), 10.0 );
}

vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 normal, float ior, mat4 modelMatrixInverse) {
	vec3 rayOrigin = ro;
	vec3 rayDirection = rd;
	rayDirection = refract(rayDirection, normal, 1.0 / ior);
	rayOrigin = vWorldPosition + rayDirection * 0.001;
	rayOrigin = (modelMatrixInverse * vec4(rayOrigin, 1.0)).xyz;
	rayDirection = normalize((modelMatrixInverse * vec4(rayDirection, 0.0)).xyz);
	for(float i = 0.0; i < bounces; i++) {
		uvec4 faceIndices = uvec4( 0u );
		vec3 faceNormal = vec3( 0.0, 0.0, 1.0 );
		vec3 barycoord = vec3( 0.0 );
		float side = 1.0;
		float dist = 0.0;
		bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );
		vec3 hitPos = rayOrigin + rayDirection * max(dist - 0.001, 0.0);
		vec3 tempDir = refract(rayDirection, faceNormal, ior);
		if (length(tempDir) != 0.0) {
			rayDirection = tempDir;
			break;
		}
		rayDirection = reflect(rayDirection, faceNormal);
		rayOrigin = hitPos + rayDirection * 0.01;
	}
	rayDirection = normalize((modelMatrix * vec4(rayDirection, 0.0)).xyz);
	return rayDirection;
}

#include <common>
#include <cube_uv_reflection_fragment>

#ifdef ENVMAP_TYPE_CUBEM
	vec4 textureGradient(samplerCube envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		return textureGrad(envMap, rayDirection, dFdx(correctMips ? directionCamPerfect: rayDirection), dFdy(correctMips ? directionCamPerfect: rayDirection));
	}
#else
	vec4 textureGradient(sampler2D envMap, vec3 rayDirection, vec3 directionCamPerfect) {
		vec2 uvv = equirectUv( rayDirection );
		vec2 smoothUv = equirectUv( directionCamPerfect );
		return textureGrad(envMap, uvv, dFdx(correctMips ? smoothUv : uvv), dFdy(correctMips ? smoothUv : uvv));
	}
#endif

void main() {
	vec2 uv = gl_FragCoord.xy / resolution;
	vec3 directionCamPerfect = (projectionMatrixInverse * vec4(uv * 2.0 - 1.0, 0.0, 1.0)).xyz;
	directionCamPerfect = (viewMatrixInverse * vec4(directionCamPerfect, 0.0)).xyz;
	directionCamPerfect = normalize(directionCamPerfect);
	vec3 normal = vNormal;
	vec3 rayOrigin = cameraPosition;
	vec3 rayDirection = normalize(vWorldPosition - cameraPosition);
	vec3 finalColor;
	#ifdef CHROMATIC_ABERRATIONS
		vec3 rayDirectionG = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		#ifdef FAST_CHROMA
			vec3 rayDirectionR = normalize(rayDirectionG + 1.0 * vec3(aberrationStrength / 2.0));
			vec3 rayDirectionB = normalize(rayDirectionG - 1.0 * vec3(aberrationStrength / 2.0));
		#else
			vec3 rayDirectionR = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 - aberrationStrength), 1.0), vModelMatrixInverse);
			vec3 rayDirectionB = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior * (1.0 + aberrationStrength), 1.0), vModelMatrixInverse);
		#endif
		float finalColorR = textureGradient(envMap, rayDirectionR, directionCamPerfect).r;
		float finalColorG = textureGradient(envMap, rayDirectionG, directionCamPerfect).g;
		float finalColorB = textureGradient(envMap, rayDirectionB, directionCamPerfect).b;
		finalColor = vec3(finalColorR, finalColorG, finalColorB);
	#else
		rayDirection = totalInternalReflection(rayOrigin, rayDirection, normal, max(ior, 1.0), vModelMatrixInverse);
		finalColor = textureGradient(envMap, rayDirection, directionCamPerfect).rgb;
	#endif

	finalColor *= color;
	#ifdef USE_INSTANCING_COLOR
		finalColor *= vInstanceColor;
	#endif

	vec3 viewDirection = normalize(vWorldPosition - cameraPosition);
	float nFresnel = fresnelFunc(viewDirection, normal) * fresnel;
	gl_FragColor = vec4(mix(finalColor, vec3(1.0), nFresnel), 1.0);
	${ShaderChunk.tonemapping_fragment}
	${ShaderChunk.colorspace_fragment}
}`;
const getDefaultComputeFunction = (target) => {
  const { camera } = useThrelte();
  let width = 0;
  let height = 0;
  const resizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      width = entry.contentRect.width;
      height = entry.contentRect.height;
    }
  });
  watch(target, (target2) => {
    if (target2) resizeObserver.observe(target2);
    return () => {
      if (target2) resizeObserver.unobserve(target2);
    };
  });
  return (event, state) => {
    state.pointer.update((pointer) => {
      pointer.set(
        (event.offsetX / width) * 2 - 1,
        -(event.offsetY / height) * 2 + 1,
      );
      return pointer;
    });
    state.raycaster.setFromCamera(state.pointer.current, camera.current);
  };
};
const contextKey = Symbol("interactivity-context");
const getInteractivityContext = () => {
  return getContext(contextKey);
};
const setInteractivityContext = (options) => {
  const target = currentWritable(
    options?.target ?? useThrelte().renderer.domElement,
  );
  const context = {
    enabled: currentWritable(options?.enabled ?? true),
    pointer: currentWritable(new Vector2()),
    pointerOverTarget: currentWritable(false),
    lastEvent: void 0,
    raycaster: new Raycaster(),
    initialClick: [0, 0],
    initialHits: [],
    hovered: /* @__PURE__ */ new Map(),
    interactiveObjects: [],
    target,
    compute: options?.compute ?? getDefaultComputeFunction(target),
    filter: options?.filter,
  };
  setContext(contextKey, context);
  return context;
};
const handlerContextKey = Symbol("interactivity-handler-context");
const getHandlerContext = () => {
  return getContext(handlerContextKey);
};
const setHandlerContext = () => {
  setContext(handlerContextKey, {
    dispatchers: /* @__PURE__ */ new WeakMap(),
  });
};
const useInteractivity = () => {
  const context = getInteractivityContext();
  const { dispatchers } = getHandlerContext();
  if (!context) {
    throw new Error(
      "No interactivity context found. Did you forget to implement interactivity()?",
    );
  }
  const eventDispatcher = createRawEventDispatcher();
  const addInteractiveObject = (object) => {
    if (context.interactiveObjects.indexOf(object) > -1) {
      return;
    }
    dispatchers.set(object, eventDispatcher);
    context.interactiveObjects.push(object);
  };
  const removeInteractiveObject = (object) => {
    const index = context.interactiveObjects.indexOf(object);
    context.interactiveObjects.splice(index, 1);
    dispatchers.delete(object);
  };
  return {
    ...context,
    addInteractiveObject,
    removeInteractiveObject,
  };
};
const useComponentHasEventHandlers = (eventNames) => {
  get_current_component();
  const hasEventHandlers = writable(false);
  return {
    hasEventHandlers,
  };
};
const injectInteractivityPlugin = () => {
  injectPlugin("interactivity", ({ ref }) => {
    if (!ref.isObject3D) return;
    const { addInteractiveObject, removeInteractiveObject } =
      useInteractivity();
    const refStore = writable(ref);
    const { hasEventHandlers } = useComponentHasEventHandlers();
    watch([hasEventHandlers, refStore], ([hasEventHandlers2, ref2]) => {
      if (!hasEventHandlers2) return;
      addInteractiveObject(ref2);
      return () => removeInteractiveObject(ref2);
    });
    return {
      onRefChange(ref2) {
        refStore.set(ref2);
      },
    };
  });
};
function getIntersectionId(event) {
  return `${(event.eventObject || event.object).uuid}/${event.index}${event.instanceId}`;
}
const DOM_EVENTS = [
  ["click", false],
  ["contextmenu", false],
  ["dblclick", false],
  ["wheel", false],
  ["pointerdown", true],
  ["pointerup", true],
  ["pointerleave", true],
  ["pointerenter", true],
  ["pointermove", true],
  ["pointercancel", true],
];
const setupInteractivity = (context) => {
  const { dispatchers } = getHandlerContext();
  const calculateDistance = (event) => {
    const dx = event.offsetX - context.initialClick[0];
    const dy = event.offsetY - context.initialClick[1];
    return Math.round(Math.hypot(dx, dy));
  };
  const cancelPointer = (intersections) => {
    for (const hoveredObj of context.hovered.values()) {
      if (
        intersections.length === 0 ||
        !intersections.some((hit) => {
          return (
            hit.object === hoveredObj.object &&
            hit.index === hoveredObj.index &&
            hit.instanceId === hoveredObj.instanceId
          );
        })
      ) {
        const { eventObject } = hoveredObj;
        context.hovered.delete(getIntersectionId(hoveredObj));
        const eventDispatcher = dispatchers.get(eventObject);
        if (eventDispatcher) {
          const data = { ...hoveredObj, intersections };
          eventDispatcher("pointerout", data);
          eventDispatcher("pointerleave", data);
        }
      }
    }
  };
  const enabled = memoize(context.enabled);
  const getHits = () => {
    if (!enabled.current) return [];
    const intersections = [];
    const hits = context.raycaster.intersectObjects(
      context.interactiveObjects,
      true,
    );
    const filtered =
      context.filter === void 0 ? hits : context.filter(hits, context);
    for (const hit of filtered) {
      let eventObject = hit.object;
      while (eventObject) {
        if (dispatchers.has(eventObject))
          intersections.push({ ...hit, eventObject });
        eventObject = eventObject.parent;
      }
    }
    return intersections;
  };
  const pointerMissed = (event, objects) => {
    for (const object of objects) {
      dispatchers.get(object)?.("pointermissed", event);
    }
  };
  const getEventHandler = (name) => {
    if (name === "pointerleave" || name === "pointercancel") {
      return () => {
        context.pointerOverTarget.set(false);
        cancelPointer([]);
      };
    }
    if (name === "pointerenter") {
      return () => {
        context.pointerOverTarget.set(true);
      };
    }
    return (event) => {
      const isPointerMove = name === "pointermove";
      const isClickEvent =
        name === "click" || name === "contextmenu" || name === "dblclick";
      context.compute(event, context);
      const hits = getHits();
      const delta = isClickEvent ? calculateDistance(event) : 0;
      if (name === "pointerdown") {
        context.initialClick = [event.offsetX, event.offsetY];
        context.initialHits = hits.map((hit) => hit.eventObject);
      }
      if (isClickEvent && hits.length === 0) {
        if (delta <= 2) {
          pointerMissed(event, context.interactiveObjects);
        }
      }
      if (isPointerMove) cancelPointer(hits);
      let stopped = false;
      dispatchEvents: for (const hit of hits) {
        const intersectionEvent = {
          stopped,
          ...hit,
          intersections: hits,
          stopPropagation() {
            stopped = true;
            intersectionEvent.stopped = true;
            if (
              context.hovered.size > 0 &&
              Array.from(context.hovered.values()).some(
                (i) => i.eventObject === hit.eventObject,
              )
            ) {
              const higher = hits.slice(0, hits.indexOf(hit));
              cancelPointer([...higher, hit]);
            }
          },
          camera: context.raycaster.camera,
          delta,
          nativeEvent: event,
          pointer: context.pointer.current,
          ray: context.raycaster.ray,
        };
        const eventDispatcher = dispatchers.get(hit.eventObject);
        if (!eventDispatcher) return;
        if (isPointerMove) {
          if (
            eventDispatcher.hasEventListener("pointerover") ||
            eventDispatcher.hasEventListener("pointerenter") ||
            eventDispatcher.hasEventListener("pointerout") ||
            eventDispatcher.hasEventListener("pointerleave")
          ) {
            const id = getIntersectionId(intersectionEvent);
            const hoveredItem = context.hovered.get(id);
            if (!hoveredItem) {
              context.hovered.set(id, intersectionEvent);
              eventDispatcher("pointerover", intersectionEvent);
              eventDispatcher("pointerenter", intersectionEvent);
            } else if (hoveredItem.stopped) {
              intersectionEvent.stopPropagation();
            }
          }
          eventDispatcher("pointermove", intersectionEvent);
        } else {
          const hasEventListener = eventDispatcher.hasEventListener(name);
          if (hasEventListener) {
            if (
              !isClickEvent ||
              context.initialHits.includes(hit.eventObject)
            ) {
              pointerMissed(
                event,
                context.interactiveObjects.filter(
                  (object) => !context.initialHits.includes(object),
                ),
              );
              eventDispatcher(name, intersectionEvent);
            }
          } else {
            if (isClickEvent && context.initialHits.includes(hit.eventObject)) {
              pointerMissed(
                event,
                context.interactiveObjects.filter(
                  (object) => !context.initialHits.includes(object),
                ),
              );
            }
          }
        }
        if (stopped) break dispatchEvents;
      }
    };
  };
  const disconnect = (target) => {
    DOM_EVENTS.forEach(([eventName]) => {
      target.removeEventListener(eventName, getEventHandler(eventName));
    });
  };
  const connect = (target) => {
    DOM_EVENTS.forEach(([eventName, passive]) => {
      target.addEventListener(eventName, getEventHandler(eventName), {
        passive,
      });
    });
  };
  watch(context.target, (target) => {
    if (target) connect(target);
    return () => {
      if (target) disconnect(target);
    };
  });
};
const interactivity = (options) => {
  setHandlerContext();
  const context = setInteractivityContext(options);
  injectInteractivityPlugin();
  setupInteractivity(context);
  return context;
};
const standard = {
  baseBackgroundColor: "hsl(230, 7%, 17%)",
  baseBorderRadius: "6px",
  baseFontFamily: "Roboto Mono, Source Code Pro, Menlo, Courier, monospace",
  baseShadowColor: "rgba(0, 0, 0, 0.2)",
  bladeBorderRadius: "2px",
  bladeHorizontalPadding: "4px",
  bladeValueWidth: "160px",
  buttonBackgroundColor: "hsl(230, 7%, 70%)",
  buttonBackgroundColorActive: "#d6d7db",
  buttonBackgroundColorFocus: "#c8cad0",
  buttonBackgroundColorHover: "#bbbcc4",
  buttonForegroundColor: "hsl(230, 7%, 17%)",
  containerBackgroundColor: "rgba(187, 188, 196, 0.1)",
  containerBackgroundColorActive: "rgba(187, 188, 196, 0.25)",
  containerBackgroundColorFocus: "rgba(187, 188, 196, 0.2)",
  containerBackgroundColorHover: "rgba(187, 188, 196, 0.15)",
  containerForegroundColor: "hsl(230, 7%, 75%)",
  containerHorizontalPadding: "4px",
  containerUnitSize: "20px",
  containerUnitSpacing: "4px",
  containerVerticalPadding: "4px",
  grooveForegroundColor: "rgba(187, 188, 196, 0.1)",
  inputBackgroundColor: "rgba(187, 188, 196, 0.1)",
  inputBackgroundColorActive: "rgba(187, 188, 196, 0.25)",
  inputBackgroundColorFocus: "rgba(187, 188, 196, 0.2)",
  inputBackgroundColorHover: "rgba(187, 188, 196, 0.15)",
  inputForegroundColor: "hsl(230, 7%, 75%)",
  labelForegroundColor: "rgba(187, 188, 196, 0.7)",
  monitorBackgroundColor: "rgba(0, 0, 0, 0.2)",
  monitorForegroundColor: "rgba(187, 188, 196, 0.7)",
  pluginImageDraggingColor: "hsla(230, 100%, 66%, 1)",
  // PluginThumbnailListHeight: '400px', pluginThumbnailListThumbSize: '20px',
  // pluginThumbnailListWidth: '200px'
};
Object.keys(standard).reduce((acc, key2) => {
  acc[key2] = key2;
  return acc;
}, {});
function forceCast$6(v) {
  return v;
}
function isEmpty$6(value) {
  return value === null || value === void 0;
}
function isObject$1$6(value) {
  return value !== null && typeof value === "object";
}
function isRecord$6(value) {
  return value !== null && typeof value === "object";
}
function deepEqualsArray$6(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (let i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
function deepMerge$6(r1, r2) {
  const keys = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(r1), ...Object.keys(r2)]),
  );
  return keys.reduce((result, key2) => {
    const v1 = r1[key2];
    const v2 = r2[key2];
    return isRecord$6(v1) && isRecord$6(v2)
      ? Object.assign(Object.assign({}, result), {
          [key2]: deepMerge$6(v1, v2),
        })
      : Object.assign(Object.assign({}, result), {
          [key2]: key2 in r2 ? v2 : v1,
        });
  }, {});
}
function isBinding$6(value) {
  if (!isObject$1$6(value)) {
    return false;
  }
  return "target" in value;
}
const CREATE_MESSAGE_MAP$6 = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (context) => `Invalid parameters for '${context.name}'`,
  nomatchingcontroller: (context) =>
    `No matching controller for '${context.key}'`,
  nomatchingview: (context) =>
    `No matching view for '${JSON.stringify(context.params)}'`,
  notbindable: () => `Value is not bindable`,
  notcompatible: (context) => `Not compatible with  plugin '${context.id}'`,
  propertynotfound: (context) => `Property '${context.name}' not found`,
  shouldneverhappen: () => "This error should never happen",
};
let TpError$6 = class TpError {
  static alreadyDisposed() {
    return new TpError({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new TpError({
      type: "notbindable",
    });
  }
  static notCompatible(bundleId, id) {
    return new TpError({
      type: "notcompatible",
      context: {
        id: `${bundleId}.${id}`,
      },
    });
  }
  static propertyNotFound(name) {
    return new TpError({
      type: "propertynotfound",
      context: {
        name,
      },
    });
  }
  static shouldNeverHappen() {
    return new TpError({ type: "shouldneverhappen" });
  }
  constructor(config) {
    var _a;
    this.message =
      (_a = CREATE_MESSAGE_MAP$6[config.type](forceCast$6(config.context))) !==
        null && _a !== void 0
        ? _a
        : "Unexpected error";
    this.name = this.constructor.name;
    this.stack = new Error(this.message).stack;
    this.type = config.type;
  }
  toString() {
    return this.message;
  }
};
let BindingTarget$6 = class BindingTarget {
  constructor(obj, key2) {
    this.obj_ = obj;
    this.key = key2;
  }
  static isBindable(obj) {
    if (obj === null) {
      return false;
    }
    if (typeof obj !== "object" && typeof obj !== "function") {
      return false;
    }
    return true;
  }
  read() {
    return this.obj_[this.key];
  }
  write(value) {
    this.obj_[this.key] = value;
  }
  writeProperty(name, value) {
    const valueObj = this.read();
    if (!BindingTarget.isBindable(valueObj)) {
      throw TpError$6.notBindable();
    }
    if (!(name in valueObj)) {
      throw TpError$6.propertyNotFound(name);
    }
    valueObj[name] = value;
  }
};
let Emitter$6 = class Emitter {
  constructor() {
    this.observers_ = {};
  }
  on(eventName, handler) {
    let observers = this.observers_[eventName];
    if (!observers) {
      observers = this.observers_[eventName] = [];
    }
    observers.push({
      handler,
    });
    return this;
  }
  off(eventName, handler) {
    const observers = this.observers_[eventName];
    if (observers) {
      this.observers_[eventName] = observers.filter((observer) => {
        return observer.handler !== handler;
      });
    }
    return this;
  }
  emit(eventName, event) {
    const observers = this.observers_[eventName];
    if (!observers) {
      return;
    }
    observers.forEach((observer) => {
      observer.handler(event);
    });
  }
};
let ComplexValue$6 = class ComplexValue {
  constructor(initialValue, config) {
    var _a;
    this.constraint_ =
      config === null || config === void 0 ? void 0 : config.constraint;
    this.equals_ =
      (_a = config === null || config === void 0 ? void 0 : config.equals) !==
        null && _a !== void 0
        ? _a
        : (v1, v2) => v1 === v2;
    this.emitter = new Emitter$6();
    this.rawValue_ = initialValue;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(rawValue) {
    this.setRawValue(rawValue, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(rawValue, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const constrainedValue = this.constraint_
      ? this.constraint_.constrain(rawValue)
      : rawValue;
    const prevValue = this.rawValue_;
    const changed = !this.equals_(prevValue, constrainedValue);
    if (!changed && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.rawValue_ = constrainedValue;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: constrainedValue,
      sender: this,
    });
  }
};
let PrimitiveValue$6 = class PrimitiveValue {
  constructor(initialValue) {
    this.emitter = new Emitter$6();
    this.value_ = initialValue;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(value) {
    this.setRawValue(value, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(value, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const prevValue = this.value_;
    if (prevValue === value && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.value_ = value;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: this.value_,
      sender: this,
    });
  }
};
let ReadonlyPrimitiveValue$6 = class ReadonlyPrimitiveValue {
  constructor(value) {
    this.emitter = new Emitter$6();
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value_ = value;
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit(
      "beforechange",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
  onValueChange_(ev) {
    this.emitter.emit(
      "change",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
};
function createValue$6(initialValue, config) {
  const constraint =
    config === null || config === void 0 ? void 0 : config.constraint;
  const equals2 = config === null || config === void 0 ? void 0 : config.equals;
  if (!constraint && !equals2) {
    return new PrimitiveValue$6(initialValue);
  }
  return new ComplexValue$6(initialValue, config);
}
function createReadonlyValue$6(value) {
  return [
    new ReadonlyPrimitiveValue$6(value),
    (rawValue, options) => {
      value.setRawValue(rawValue, options);
    },
  ];
}
let ValueMap$6 = class ValueMap {
  constructor(valueMap) {
    this.emitter = new Emitter$6();
    this.valMap_ = valueMap;
    for (const key2 in this.valMap_) {
      const v = this.valMap_[key2];
      v.emitter.on("change", () => {
        this.emitter.emit("change", {
          key: key2,
          sender: this,
        });
      });
    }
  }
  static createCore(initialValue) {
    const keys = Object.keys(initialValue);
    return keys.reduce((o, key2) => {
      return Object.assign(o, {
        [key2]: createValue$6(initialValue[key2]),
      });
    }, {});
  }
  static fromObject(initialValue) {
    const core = this.createCore(initialValue);
    return new ValueMap(core);
  }
  get(key2) {
    return this.valMap_[key2].rawValue;
  }
  set(key2, value) {
    this.valMap_[key2].rawValue = value;
  }
  value(key2) {
    return this.valMap_[key2];
  }
};
let DefiniteRangeConstraint$6 = class DefiniteRangeConstraint {
  constructor(config) {
    this.values = ValueMap$6.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    return Math.min(Math.max(value, min), max);
  }
};
let RangeConstraint$6 = class RangeConstraint {
  constructor(config) {
    this.values = ValueMap$6.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    let result = value;
    if (!isEmpty$6(min)) {
      result = Math.max(result, min);
    }
    if (!isEmpty$6(max)) {
      result = Math.min(result, max);
    }
    return result;
  }
};
let StepConstraint$6 = class StepConstraint {
  constructor(step, origin = 0) {
    this.step = step;
    this.origin = origin;
  }
  constrain(value) {
    const o = this.origin % this.step;
    const r = Math.round((value - o) / this.step);
    return o + r * this.step;
  }
};
let NumberLiteralNode$6 = class NumberLiteralNode {
  constructor(text) {
    this.text = text;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
};
const BINARY_OPERATION_MAP$6 = {
  "**": (v1, v2) => Math.pow(v1, v2),
  "*": (v1, v2) => v1 * v2,
  "/": (v1, v2) => v1 / v2,
  "%": (v1, v2) => v1 % v2,
  "+": (v1, v2) => v1 + v2,
  "-": (v1, v2) => v1 - v2,
  "<<": (v1, v2) => v1 << v2,
  ">>": (v1, v2) => v1 >> v2,
  ">>>": (v1, v2) => v1 >>> v2,
  "&": (v1, v2) => v1 & v2,
  "^": (v1, v2) => v1 ^ v2,
  "|": (v1, v2) => v1 | v2,
};
let BinaryOperationNode$6 = class BinaryOperationNode {
  constructor(operator, left, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  evaluate() {
    const op = BINARY_OPERATION_MAP$6[this.operator];
    if (!op) {
      throw new Error(`unexpected binary operator: '${this.operator}`);
    }
    return op(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")",
    ].join(" ");
  }
};
const UNARY_OPERATION_MAP$6 = {
  "+": (v) => v,
  "-": (v) => -v,
  "~": (v) => ~v,
};
let UnaryOperationNode$6 = class UnaryOperationNode {
  constructor(operator, expr) {
    this.operator = operator;
    this.expression = expr;
  }
  evaluate() {
    const op = UNARY_OPERATION_MAP$6[this.operator];
    if (!op) {
      throw new Error(`unexpected unary operator: '${this.operator}`);
    }
    return op(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
};
function combineReader$6(parsers) {
  return (text, cursor) => {
    for (let i = 0; i < parsers.length; i++) {
      const result = parsers[i](text, cursor);
      if (result !== "") {
        return result;
      }
    }
    return "";
  };
}
function readWhitespace$6(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^\s+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readNonZeroDigit$6(text, cursor) {
  const ch = text.substr(cursor, 1);
  return ch.match(/^[1-9]$/) ? ch : "";
}
function readDecimalDigits$6(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readSignedInteger$6(text, cursor) {
  const ds = readDecimalDigits$6(text, cursor);
  if (ds !== "") {
    return ds;
  }
  const sign2 = text.substr(cursor, 1);
  cursor += 1;
  if (sign2 !== "-" && sign2 !== "+") {
    return "";
  }
  const sds = readDecimalDigits$6(text, cursor);
  if (sds === "") {
    return "";
  }
  return sign2 + sds;
}
function readExponentPart$6(text, cursor) {
  const e = text.substr(cursor, 1);
  cursor += 1;
  if (e.toLowerCase() !== "e") {
    return "";
  }
  const si = readSignedInteger$6(text, cursor);
  if (si === "") {
    return "";
  }
  return e + si;
}
function readDecimalIntegerLiteral$6(text, cursor) {
  const ch = text.substr(cursor, 1);
  if (ch === "0") {
    return ch;
  }
  const nzd = readNonZeroDigit$6(text, cursor);
  cursor += nzd.length;
  if (nzd === "") {
    return "";
  }
  return nzd + readDecimalDigits$6(text, cursor);
}
function readDecimalLiteral1$6(text, cursor) {
  const dil = readDecimalIntegerLiteral$6(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$6(text, cursor);
  cursor += dds.length;
  return dil + dot2 + dds + readExponentPart$6(text, cursor);
}
function readDecimalLiteral2$6(text, cursor) {
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$6(text, cursor);
  cursor += dds.length;
  if (dds === "") {
    return "";
  }
  return dot2 + dds + readExponentPart$6(text, cursor);
}
function readDecimalLiteral3$6(text, cursor) {
  const dil = readDecimalIntegerLiteral$6(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  return dil + readExponentPart$6(text, cursor);
}
const readDecimalLiteral$6 = combineReader$6([
  readDecimalLiteral1$6,
  readDecimalLiteral2$6,
  readDecimalLiteral3$6,
]);
function parseBinaryDigits$6(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[01]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readBinaryIntegerLiteral$6(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0b") {
    return "";
  }
  const bds = parseBinaryDigits$6(text, cursor);
  if (bds === "") {
    return "";
  }
  return prefix + bds;
}
function readOctalDigits$6(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-7]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readOctalIntegerLiteral$6(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0o") {
    return "";
  }
  const ods = readOctalDigits$6(text, cursor);
  if (ods === "") {
    return "";
  }
  return prefix + ods;
}
function readHexDigits$6(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9a-f]+/i);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readHexIntegerLiteral$6(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0x") {
    return "";
  }
  const hds = readHexDigits$6(text, cursor);
  if (hds === "") {
    return "";
  }
  return prefix + hds;
}
const readNonDecimalIntegerLiteral$6 = combineReader$6([
  readBinaryIntegerLiteral$6,
  readOctalIntegerLiteral$6,
  readHexIntegerLiteral$6,
]);
const readNumericLiteral$6 = combineReader$6([
  readNonDecimalIntegerLiteral$6,
  readDecimalLiteral$6,
]);
function parseLiteral$6(text, cursor) {
  const num = readNumericLiteral$6(text, cursor);
  cursor += num.length;
  if (num === "") {
    return null;
  }
  return {
    evaluable: new NumberLiteralNode$6(num),
    cursor,
  };
}
function parseParenthesizedExpression$6(text, cursor) {
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "(") {
    return null;
  }
  const expr = parseExpression$6(text, cursor);
  if (!expr) {
    return null;
  }
  cursor = expr.cursor;
  cursor += readWhitespace$6(text, cursor).length;
  const cl = text.substr(cursor, 1);
  cursor += cl.length;
  if (cl !== ")") {
    return null;
  }
  return {
    evaluable: expr.evaluable,
    cursor,
  };
}
function parsePrimaryExpression$6(text, cursor) {
  var _a;
  return (_a = parseLiteral$6(text, cursor)) !== null && _a !== void 0
    ? _a
    : parseParenthesizedExpression$6(text, cursor);
}
function parseUnaryExpression$6(text, cursor) {
  const expr = parsePrimaryExpression$6(text, cursor);
  if (expr) {
    return expr;
  }
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "+" && op !== "-" && op !== "~") {
    return null;
  }
  const num = parseUnaryExpression$6(text, cursor);
  if (!num) {
    return null;
  }
  cursor = num.cursor;
  return {
    cursor,
    evaluable: new UnaryOperationNode$6(op, num.evaluable),
  };
}
function readBinaryOperator$6(ops, text, cursor) {
  cursor += readWhitespace$6(text, cursor).length;
  const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
  if (!op) {
    return null;
  }
  cursor += op.length;
  cursor += readWhitespace$6(text, cursor).length;
  return {
    cursor,
    operator: op,
  };
}
function createBinaryOperationExpressionParser$6(exprParser, ops) {
  return (text, cursor) => {
    const firstExpr = exprParser(text, cursor);
    if (!firstExpr) {
      return null;
    }
    cursor = firstExpr.cursor;
    let expr = firstExpr.evaluable;
    for (;;) {
      const op = readBinaryOperator$6(ops, text, cursor);
      if (!op) {
        break;
      }
      cursor = op.cursor;
      const nextExpr = exprParser(text, cursor);
      if (!nextExpr) {
        return null;
      }
      cursor = nextExpr.cursor;
      expr = new BinaryOperationNode$6(op.operator, expr, nextExpr.evaluable);
    }
    return expr
      ? {
          cursor,
          evaluable: expr,
        }
      : null;
  };
}
const parseBinaryOperationExpression$6 = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"],
].reduce((parser, ops) => {
  return createBinaryOperationExpressionParser$6(parser, ops);
}, parseUnaryExpression$6);
function parseExpression$6(text, cursor) {
  cursor += readWhitespace$6(text, cursor).length;
  return parseBinaryOperationExpression$6(text, cursor);
}
function parseEcmaNumberExpression$6(text) {
  const expr = parseExpression$6(text, 0);
  if (!expr) {
    return null;
  }
  const cursor = expr.cursor + readWhitespace$6(text, expr.cursor).length;
  if (cursor !== text.length) {
    return null;
  }
  return expr.evaluable;
}
function parseNumber$6(text) {
  var _a;
  const r = parseEcmaNumberExpression$6(text);
  return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null &&
    _a !== void 0
    ? _a
    : null;
}
function numberFromUnknown$6(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const pv = parseNumber$6(value);
    if (!isEmpty$6(pv)) {
      return pv;
    }
  }
  return 0;
}
function createNumberFormatter$6(digits) {
  return (value) => {
    return value.toFixed(Math.max(Math.min(digits, 20), 0));
  };
}
function mapRange$6(value, start1, end1, start2, end2) {
  const p = (value - start1) / (end1 - start1);
  return start2 + p * (end2 - start2);
}
function getDecimalDigits$6(value) {
  const text = String(value.toFixed(10));
  const frac = text.split(".")[1];
  return frac.replace(/0+$/, "").length;
}
function constrainRange$6(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function loopRange$6(value, max) {
  return ((value % max) + max) % max;
}
function getSuitableDecimalDigits$6(params, rawValue) {
  return !isEmpty$6(params.step)
    ? getDecimalDigits$6(params.step)
    : Math.max(getDecimalDigits$6(rawValue), 2);
}
function getSuitableKeyScale$6(params) {
  var _a;
  return (_a = params.step) !== null && _a !== void 0 ? _a : 1;
}
function getSuitablePointerScale$6(params, rawValue) {
  var _a;
  const base2 = Math.abs(
    (_a = params.step) !== null && _a !== void 0 ? _a : rawValue,
  );
  return base2 === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base2)) - 1);
}
function createStepConstraint$6(params, initialValue) {
  if (!isEmpty$6(params.step)) {
    return new StepConstraint$6(params.step, initialValue);
  }
  return null;
}
function createRangeConstraint$6(params) {
  if (!isEmpty$6(params.max) && !isEmpty$6(params.min)) {
    return new DefiniteRangeConstraint$6({
      max: params.max,
      min: params.min,
    });
  }
  if (!isEmpty$6(params.max) || !isEmpty$6(params.min)) {
    return new RangeConstraint$6({
      max: params.max,
      min: params.min,
    });
  }
  return null;
}
function createNumberTextPropsObject$6(params, initialValue) {
  var _a, _b, _c;
  return {
    formatter:
      (_a = params.format) !== null && _a !== void 0
        ? _a
        : createNumberFormatter$6(
            getSuitableDecimalDigits$6(params, initialValue),
          ),
    keyScale:
      (_b = params.keyScale) !== null && _b !== void 0
        ? _b
        : getSuitableKeyScale$6(params),
    pointerScale:
      (_c = params.pointerScale) !== null && _c !== void 0
        ? _c
        : getSuitablePointerScale$6(params, initialValue),
  };
}
function createNumberTextInputParamsParser$6(p) {
  return {
    format: p.optional.function,
    keyScale: p.optional.number,
    max: p.optional.number,
    min: p.optional.number,
    pointerScale: p.optional.number,
    step: p.optional.number,
  };
}
function createPointAxis$6(config) {
  return {
    constraint: config.constraint,
    textProps: ValueMap$6.fromObject(
      createNumberTextPropsObject$6(config.params, config.initialValue),
    ),
  };
}
let BladeApi$6 = class BladeApi {
  constructor(controller) {
    this.controller = controller;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller.viewProps.set("disabled", disabled);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(hidden) {
    this.controller.viewProps.set("hidden", hidden);
  }
  dispose() {
    this.controller.viewProps.set("disposed", true);
  }
  importState(state) {
    return this.controller.importState(state);
  }
  exportState() {
    return this.controller.exportState();
  }
};
let TpEvent$6 = class TpEvent {
  constructor(target) {
    this.target = target;
  }
};
let TpChangeEvent$6 = class TpChangeEvent extends TpEvent$6 {
  constructor(target, value, last) {
    super(target);
    this.value = value;
    this.last = last !== null && last !== void 0 ? last : true;
  }
};
let TpFoldEvent$6 = class TpFoldEvent extends TpEvent$6 {
  constructor(target, expanded) {
    super(target);
    this.expanded = expanded;
  }
};
let TpTabSelectEvent$6 = class TpTabSelectEvent extends TpEvent$6 {
  constructor(target, index) {
    super(target);
    this.index = index;
  }
};
let BindingApi$6 = class BindingApi extends BladeApi$6 {
  constructor(controller) {
    super(controller);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.emitter_ = new Emitter$6();
    this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(tag) {
    this.controller.tag = tag;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(ev) {
    const value = this.controller.value;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$6(
        this,
        forceCast$6(value.binding.target.read()),
        ev.options.last,
      ),
    );
  }
};
function parseObject$6(value, keyToParserMap) {
  const keys = Object.keys(keyToParserMap);
  const result = keys.reduce((tmp2, key2) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const parser = keyToParserMap[key2];
    const result2 = parser(value[key2]);
    return result2.succeeded
      ? Object.assign(Object.assign({}, tmp2), { [key2]: result2.value })
      : void 0;
  }, {});
  return forceCast$6(result);
}
function parseArray$6(value, parseItem) {
  return value.reduce((tmp2, item) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const result = parseItem(item);
    if (!result.succeeded || result.value === void 0) {
      return void 0;
    }
    return [...tmp2, result.value];
  }, []);
}
function isObject$7(value) {
  if (value === null) {
    return false;
  }
  return typeof value === "object";
}
function createMicroParserBuilder$6(parse) {
  return (optional) => (v) => {
    if (!optional && v === void 0) {
      return {
        succeeded: false,
        value: void 0,
      };
    }
    if (optional && v === void 0) {
      return {
        succeeded: true,
        value: void 0,
      };
    }
    const result = parse(v);
    return result !== void 0
      ? {
          succeeded: true,
          value: result,
        }
      : {
          succeeded: false,
          value: void 0,
        };
  };
}
function createMicroParserBuilders$6(optional) {
  return {
    custom: (parse) => createMicroParserBuilder$6(parse)(optional),
    boolean: createMicroParserBuilder$6((v) =>
      typeof v === "boolean" ? v : void 0,
    )(optional),
    number: createMicroParserBuilder$6((v) =>
      typeof v === "number" ? v : void 0,
    )(optional),
    string: createMicroParserBuilder$6((v) =>
      typeof v === "string" ? v : void 0,
    )(optional),
    function: createMicroParserBuilder$6((v) =>
      typeof v === "function" ? v : void 0,
    )(optional),
    constant: (value) =>
      createMicroParserBuilder$6((v) => (v === value ? value : void 0))(
        optional,
      ),
    raw: createMicroParserBuilder$6((v) => v)(optional),
    object: (keyToParserMap) =>
      createMicroParserBuilder$6((v) => {
        if (!isObject$7(v)) {
          return void 0;
        }
        return parseObject$6(v, keyToParserMap);
      })(optional),
    array: (itemParser) =>
      createMicroParserBuilder$6((v) => {
        if (!Array.isArray(v)) {
          return void 0;
        }
        return parseArray$6(v, itemParser);
      })(optional),
  };
}
const MicroParsers$6 = {
  optional: createMicroParserBuilders$6(true),
  required: createMicroParserBuilders$6(false),
};
function parseRecord$6(value, keyToParserMap) {
  const map = keyToParserMap(MicroParsers$6);
  const result = MicroParsers$6.required.object(map)(value);
  return result.succeeded ? result.value : void 0;
}
function importBladeState$6(state, superImport, parser, callback) {
  if (superImport && !superImport(state)) {
    return false;
  }
  const result = parseRecord$6(state, parser);
  return result ? callback(result) : false;
}
function exportBladeState$6(superExport, thisState) {
  var _a;
  return deepMerge$6(
    (_a =
      superExport === null || superExport === void 0
        ? void 0
        : superExport()) !== null && _a !== void 0
      ? _a
      : {},
    thisState,
  );
}
function isValueBladeController$6(bc) {
  return "value" in bc;
}
function isBindingValue$6(v) {
  if (!isObject$1$6(v) || !("binding" in v)) {
    return false;
  }
  const b = v.binding;
  return isBinding$6(b);
}
const SVG_NS$6 = "http://www.w3.org/2000/svg";
function forceReflow$6(element) {
  element.offsetHeight;
}
function disableTransitionTemporarily$6(element, callback) {
  const t = element.style.transition;
  element.style.transition = "none";
  callback();
  element.style.transition = t;
}
function supportsTouch$6(doc) {
  return doc.ontouchstart !== void 0;
}
function getCanvasContext$6(canvasElement) {
  const win = canvasElement.ownerDocument.defaultView;
  if (!win) {
    return null;
  }
  const isBrowser = "document" in win;
  return isBrowser
    ? canvasElement.getContext("2d", {
        willReadFrequently: true,
      })
    : null;
}
const ICON_ID_TO_INNER_HTML_MAP$6 = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad:
    '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function createSvgIconElement$6(document2, iconId) {
  const elem = document2.createElementNS(SVG_NS$6, "svg");
  elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP$6[iconId];
  return elem;
}
function insertElementAt$6(parentElement, element, index) {
  parentElement.insertBefore(element, parentElement.children[index]);
}
function removeElement$6(element) {
  if (element.parentElement) {
    element.parentElement.removeChild(element);
  }
}
function removeChildElements$6(element) {
  while (element.children.length > 0) {
    element.removeChild(element.children[0]);
  }
}
function removeChildNodes$6(element) {
  while (element.childNodes.length > 0) {
    element.removeChild(element.childNodes[0]);
  }
}
function findNextTarget$6(ev) {
  if (ev.relatedTarget) {
    return forceCast$6(ev.relatedTarget);
  }
  if ("explicitOriginalTarget" in ev) {
    return ev.explicitOriginalTarget;
  }
  return null;
}
function bindValue$6(value, applyValue) {
  value.emitter.on("change", (ev) => {
    applyValue(ev.rawValue);
  });
  applyValue(value.rawValue);
}
function bindValueMap$6(valueMap, key2, applyValue) {
  bindValue$6(valueMap.value(key2), applyValue);
}
const PREFIX$6 = "tp";
function ClassName$6(viewName) {
  const fn = (opt_elementName, opt_modifier) => {
    return [
      PREFIX$6,
      "-",
      viewName,
      "v",
      opt_elementName ? `_${opt_elementName}` : "",
      opt_modifier ? `-${opt_modifier}` : "",
    ].join("");
  };
  return fn;
}
const cn$q$6 = ClassName$6("lbl");
function createLabelNode$6(doc, label) {
  const frag = doc.createDocumentFragment();
  const lineNodes = label.split("\n").map((line) => {
    return doc.createTextNode(line);
  });
  lineNodes.forEach((lineNode, index) => {
    if (index > 0) {
      frag.appendChild(doc.createElement("br"));
    }
    frag.appendChild(lineNode);
  });
  return frag;
}
let LabelView$6 = class LabelView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$q$6());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("div");
    labelElem.classList.add(cn$q$6("l"));
    bindValueMap$6(config.props, "label", (value) => {
      if (isEmpty$6(value)) {
        this.element.classList.add(cn$q$6(void 0, "nol"));
      } else {
        this.element.classList.remove(cn$q$6(void 0, "nol"));
        removeChildNodes$6(labelElem);
        labelElem.appendChild(createLabelNode$6(doc, value));
      }
    });
    this.element.appendChild(labelElem);
    this.labelElement = labelElem;
    const valueElem = doc.createElement("div");
    valueElem.classList.add(cn$q$6("v"));
    this.element.appendChild(valueElem);
    this.valueElement = valueElem;
  }
};
let LabelController$6 = class LabelController {
  constructor(doc, config) {
    this.props = config.props;
    this.valueController = config.valueController;
    this.viewProps = config.valueController.viewProps;
    this.view = new LabelView$6(doc, {
      props: config.props,
      viewProps: this.viewProps,
    });
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(state) {
    return importBladeState$6(
      state,
      null,
      (p) => ({
        label: p.optional.string,
      }),
      (result) => {
        this.props.set("label", result.label);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$6(null, {
      label: this.props.get("label"),
    });
  }
};
function getAllBladePositions$6() {
  return ["veryfirst", "first", "last", "verylast"];
}
const cn$p$6 = ClassName$6("");
const POS_TO_CLASS_NAME_MAP$6 = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst",
};
let BladeController$6 = class BladeController {
  constructor(config) {
    this.parent_ = null;
    this.blade = config.blade;
    this.view = config.view;
    this.viewProps = config.viewProps;
    const elem = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      getAllBladePositions$6().forEach((pos) => {
        elem.classList.remove(cn$p$6(void 0, POS_TO_CLASS_NAME_MAP$6[pos]));
      });
      this.blade.get("positions").forEach((pos) => {
        elem.classList.add(cn$p$6(void 0, POS_TO_CLASS_NAME_MAP$6[pos]));
      });
    });
    this.viewProps.handleDispose(() => {
      removeElement$6(elem);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(parent) {
    this.parent_ = parent;
    this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(state) {
    return importBladeState$6(
      state,
      null,
      (p) => ({
        disabled: p.required.boolean,
        hidden: p.required.boolean,
      }),
      (result) => {
        this.viewProps.importState(result);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$6(
      null,
      Object.assign({}, this.viewProps.exportState()),
    );
  }
};
class LabeledValueBladeController extends BladeController$6 {
  constructor(doc, config) {
    if (config.value !== config.valueController.value) {
      throw TpError$6.shouldNeverHappen();
    }
    const viewProps = config.valueController.viewProps;
    const lc = new LabelController$6(doc, {
      blade: config.blade,
      props: config.props,
      valueController: config.valueController,
    });
    super(
      Object.assign(Object.assign({}, config), {
        view: new LabelView$6(doc, {
          props: config.props,
          viewProps,
        }),
        viewProps,
      }),
    );
    this.labelController = lc;
    this.value = config.value;
    this.valueController = config.valueController;
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importState(state) {
    return importBladeState$6(
      state,
      (s) => {
        var _a, _b, _c;
        return (
          super.importState(s) &&
          this.labelController.importProps(s) &&
          ((_c =
            (_b = (_a = this.valueController).importProps) === null ||
            _b === void 0
              ? void 0
              : _b.call(_a, state)) !== null && _c !== void 0
            ? _c
            : true)
        );
      },
      (p) => ({
        value: p.optional.raw,
      }),
      (result) => {
        if (result.value) {
          this.value.rawValue = result.value;
        }
        return true;
      },
    );
  }
  exportState() {
    var _a, _b, _c;
    return exportBladeState$6(
      () => super.exportState(),
      Object.assign(
        Object.assign(
          { value: this.value.rawValue },
          this.labelController.exportProps(),
        ),
        (_c =
          (_b = (_a = this.valueController).exportProps) === null ||
          _b === void 0
            ? void 0
            : _b.call(_a)) !== null && _c !== void 0
          ? _c
          : {},
      ),
    );
  }
}
function fillBuffer(buffer, bufferSize) {
  while (buffer.length < bufferSize) {
    buffer.push(void 0);
  }
}
function initializeBuffer(bufferSize) {
  const buffer = [];
  fillBuffer(buffer, bufferSize);
  return buffer;
}
function createTrimmedBuffer(buffer) {
  const index = buffer.indexOf(void 0);
  return forceCast$6(index < 0 ? buffer : buffer.slice(0, index));
}
function createPushedBuffer(buffer, newValue) {
  const newBuffer = [...createTrimmedBuffer(buffer), newValue];
  if (newBuffer.length > buffer.length) {
    newBuffer.splice(0, newBuffer.length - buffer.length);
  } else {
    fillBuffer(newBuffer, buffer.length);
  }
  return newBuffer;
}
let ButtonApi$6 = class ButtonApi extends BladeApi$6 {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get title() {
    var _a;
    return (_a = this.controller.buttonController.props.get("title")) !==
      null && _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.buttonController.props.set("title", title);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller.buttonController.emitter;
    emitter.on(eventName, () => {
      bh(new TpEvent$6(this));
    });
    return this;
  }
};
function applyClass$6(elem, className2, active) {
  if (active) {
    elem.classList.add(className2);
  } else {
    elem.classList.remove(className2);
  }
}
function valueToClassName$6(elem, className2) {
  return (value) => {
    applyClass$6(elem, className2, value);
  };
}
function bindValueToTextContent$6(value, elem) {
  bindValue$6(value, (text) => {
    elem.textContent = text !== null && text !== void 0 ? text : "";
  });
}
const cn$o$6 = ClassName$6("btn");
let ButtonView$6 = class ButtonView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$o$6());
    config.viewProps.bindClassModifiers(this.element);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$o$6("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$o$6("t"));
    bindValueToTextContent$6(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
  }
};
let ButtonController$6 = class ButtonController {
  constructor(doc, config) {
    this.emitter = new Emitter$6();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new ButtonView$6(doc, {
      props: this.props,
      viewProps: this.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(state) {
    return importBladeState$6(
      state,
      null,
      (p) => ({
        title: p.optional.string,
      }),
      (result) => {
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$6(null, {
      title: this.props.get("title"),
    });
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let ButtonBladeController$6 = class ButtonBladeController extends BladeController$6 {
  constructor(doc, config) {
    const bc = new ButtonController$6(doc, {
      props: config.buttonProps,
      viewProps: config.viewProps,
    });
    const lc = new LabelController$6(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: config.viewProps,
    });
    this.buttonController = bc;
    this.labelController = lc;
  }
  importState(state) {
    return importBladeState$6(
      state,
      (s) =>
        super.importState(s) &&
        this.buttonController.importProps(s) &&
        this.labelController.importProps(s),
      () => ({}),
      () => true,
    );
  }
  exportState() {
    return exportBladeState$6(
      () => super.exportState(),
      Object.assign(
        Object.assign({}, this.buttonController.exportProps()),
        this.labelController.exportProps(),
      ),
    );
  }
};
let Semver$6 = class Semver {
  constructor(text) {
    const [core, prerelease] = text.split("-");
    const coreComps = core.split(".");
    this.major = parseInt(coreComps[0], 10);
    this.minor = parseInt(coreComps[1], 10);
    this.patch = parseInt(coreComps[2], 10);
    this.prerelease =
      prerelease !== null && prerelease !== void 0 ? prerelease : null;
  }
  toString() {
    const core = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
  }
};
const VERSION$6 = new Semver$6("2.0.0-beta.2");
function createPlugin$6(plugin) {
  return Object.assign({ core: VERSION$6 }, plugin);
}
createPlugin$6({
  id: "button",
  type: "blade",
  accept(params) {
    const result = parseRecord$6(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("button"),
      label: p.optional.string,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new ButtonBladeController$6(args.document, {
      blade: args.blade,
      buttonProps: ValueMap$6.fromObject({
        title: args.params.title,
      }),
      labelProps: ValueMap$6.fromObject({
        label: args.params.label,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (args.controller instanceof ButtonBladeController$6) {
      return new ButtonApi$6(args.controller);
    }
    return null;
  },
});
function addButtonAsBlade$6(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "button" }),
  );
}
function addFolderAsBlade$6(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "folder" }),
  );
}
function addTabAsBlade$6(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "tab" }),
  );
}
function isRefreshable$6(value) {
  if (!isObject$1$6(value)) {
    return false;
  }
  return "refresh" in value && typeof value.refresh === "function";
}
function createBindingTarget$6(obj, key2) {
  if (!BindingTarget$6.isBindable(obj)) {
    throw TpError$6.notBindable();
  }
  return new BindingTarget$6(obj, key2);
}
let RackApi$6 = class RackApi {
  constructor(controller, pool) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.controller_ = controller;
    this.emitter_ = new Emitter$6();
    this.pool_ = pool;
    const rack = this.controller_.rack;
    rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((bc) => this.pool_.createApi(bc));
  }
  addBinding(object, key2, opt_params) {
    const params =
      opt_params !== null && opt_params !== void 0 ? opt_params : {};
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBinding(
      doc,
      createBindingTarget$6(object, key2),
      params,
    );
    const api = this.pool_.createBindingApi(bc);
    return this.add(api, params.index);
  }
  addFolder(params) {
    return addFolderAsBlade$6(this, params);
  }
  addButton(params) {
    return addButtonAsBlade$6(this, params);
  }
  addTab(params) {
    return addTabAsBlade$6(this, params);
  }
  add(api, opt_index) {
    const bc = api.controller;
    this.controller_.rack.add(bc, opt_index);
    return api;
  }
  remove(api) {
    this.controller_.rack.remove(api.controller);
  }
  addBlade(params) {
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBlade(doc, params);
    const api = this.pool_.createApi(bc);
    return this.add(api, params.index);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.children.forEach((c) => {
      if (isRefreshable$6(c)) {
        c.refresh();
      }
    });
  }
  onRackValueChange_(ev) {
    const bc = ev.bladeController;
    const api = this.pool_.createApi(bc);
    const binding = isBindingValue$6(bc.value) ? bc.value.binding : null;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$6(
        api,
        binding ? binding.target.read() : bc.value.rawValue,
        ev.options.last,
      ),
    );
  }
};
let ContainerBladeApi$6 = class ContainerBladeApi extends BladeApi$6 {
  constructor(controller, pool) {
    super(controller);
    this.rackApi_ = new RackApi$6(controller.rackController, pool);
  }
};
let ContainerBladeController$6 = class ContainerBladeController extends BladeController$6 {
  constructor(config) {
    super({
      blade: config.blade,
      view: config.view,
      viewProps: config.rackController.viewProps,
    });
    this.rackController = config.rackController;
  }
  importState(state) {
    return importBladeState$6(
      state,
      (s) => super.importState(s),
      (p) => ({
        children: p.required.array(p.required.raw),
      }),
      (result) => {
        return this.rackController.rack.children.every((c, index) => {
          return c.importState(result.children[index]);
        });
      },
    );
  }
  exportState() {
    return exportBladeState$6(() => super.exportState(), {
      children: this.rackController.rack.children.map((c) => c.exportState()),
    });
  }
};
function isContainerBladeController$6(bc) {
  return "rackController" in bc;
}
let NestedOrderedSet$6 = class NestedOrderedSet {
  constructor(extract) {
    this.emitter = new Emitter$6();
    this.items_ = [];
    this.cache_ = /* @__PURE__ */ new Set();
    this.onSubListAdd_ = this.onSubListAdd_.bind(this);
    this.onSubListRemove_ = this.onSubListRemove_.bind(this);
    this.extract_ = extract;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(callback) {
    for (const item of this.allItems()) {
      if (callback(item)) {
        return item;
      }
    }
    return null;
  }
  includes(item) {
    return this.cache_.has(item);
  }
  add(item, opt_index) {
    if (this.includes(item)) {
      throw TpError$6.shouldNeverHappen();
    }
    const index = opt_index !== void 0 ? opt_index : this.items_.length;
    this.items_.splice(index, 0, item);
    this.cache_.add(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.emitter.on("add", this.onSubListAdd_);
      subList.emitter.on("remove", this.onSubListRemove_);
      subList.allItems().forEach((i) => {
        this.cache_.add(i);
      });
    }
    this.emitter.emit("add", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    this.cache_.delete(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.allItems().forEach((i) => {
        this.cache_.delete(i);
      });
      subList.emitter.off("add", this.onSubListAdd_);
      subList.emitter.off("remove", this.onSubListRemove_);
    }
    this.emitter.emit("remove", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  onSubListAdd_(ev) {
    this.cache_.add(ev.item);
    this.emitter.emit("add", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
  onSubListRemove_(ev) {
    this.cache_.delete(ev.item);
    this.emitter.emit("remove", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
};
function findValueBladeController$6(bcs, v) {
  for (let i = 0; i < bcs.length; i++) {
    const bc = bcs[i];
    if (isValueBladeController$6(bc) && bc.value === v) {
      return bc;
    }
  }
  return null;
}
function findSubBladeControllerSet$6(bc) {
  return isContainerBladeController$6(bc)
    ? bc.rackController.rack["bcSet_"]
    : null;
}
let Rack$6 = class Rack {
  constructor(config) {
    var _a, _b;
    this.emitter = new Emitter$6();
    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
    this.onSetAdd_ = this.onSetAdd_.bind(this);
    this.onSetRemove_ = this.onSetRemove_.bind(this);
    this.onChildDispose_ = this.onChildDispose_.bind(this);
    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
    this.onChildValueChange_ = this.onChildValueChange_.bind(this);
    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
    this.onRackLayout_ = this.onRackLayout_.bind(this);
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
    (_b = this.blade_) === null || _b === void 0
      ? void 0
      : _b
          .value("positions")
          .emitter.on("change", this.onBladePositionsChange_);
    this.viewProps = config.viewProps;
    this.bcSet_ = new NestedOrderedSet$6(findSubBladeControllerSet$6);
    this.bcSet_.emitter.on("add", this.onSetAdd_);
    this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(bc, opt_index) {
    var _a;
    (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
    bc.parent = this;
    this.bcSet_.add(bc, opt_index);
  }
  remove(bc) {
    bc.parent = null;
    this.bcSet_.remove(bc);
  }
  find(finder) {
    return this.bcSet_.allItems().filter(finder);
  }
  onSetAdd_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("add", {
      bladeController: ev.item,
      index: ev.index,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
    bc.blade
      .value("positions")
      .emitter.on("change", this.onChildPositionsChange_);
    bc.viewProps.handleDispose(this.onChildDispose_);
    if (isValueBladeController$6(bc)) {
      bc.value.emitter.on("change", this.onChildValueChange_);
    } else if (isContainerBladeController$6(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.on("layout", this.onRackLayout_);
        emitter.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("remove", {
      bladeController: ev.item,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    if (isValueBladeController$6(bc)) {
      bc.value.emitter.off("change", this.onChildValueChange_);
    } else if (isContainerBladeController$6(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.off("layout", this.onRackLayout_);
        emitter.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const visibleItems = this.bcSet_.items.filter(
      (bc) => !bc.viewProps.get("hidden"),
    );
    const firstVisibleItem = visibleItems[0];
    const lastVisibleItem = visibleItems[visibleItems.length - 1];
    this.bcSet_.items.forEach((bc) => {
      const ps = [];
      if (bc === firstVisibleItem) {
        ps.push("first");
        if (
          !this.blade_ ||
          this.blade_.get("positions").includes("veryfirst")
        ) {
          ps.push("veryfirst");
        }
      }
      if (bc === lastVisibleItem) {
        ps.push("last");
        if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
          ps.push("verylast");
        }
      }
      bc.blade.set("positions", ps);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildViewPropsChange_(_ev) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildDispose_() {
    const disposedUcs = this.bcSet_.items.filter((bc) => {
      return bc.viewProps.get("disposed");
    });
    disposedUcs.forEach((bc) => {
      this.bcSet_.remove(bc);
    });
  }
  onChildValueChange_(ev) {
    const bc = findValueBladeController$6(
      this.find(isValueBladeController$6),
      ev.sender,
    );
    if (!bc) {
      throw TpError$6.alreadyDisposed();
    }
    this.emitter.emit("valuechange", {
      bladeController: bc,
      options: ev.options,
      sender: this,
    });
  }
  onRackLayout_(_) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onRackValueChange_(ev) {
    this.emitter.emit("valuechange", {
      bladeController: ev.bladeController,
      options: ev.options,
      sender: this,
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
};
let RackController$6 = class RackController {
  constructor(config) {
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    this.element = config.element;
    this.viewProps = config.viewProps;
    const rack = new Rack$6({
      blade: config.root ? void 0 : config.blade,
      viewProps: config.viewProps,
    });
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.rack = rack;
    this.viewProps.handleDispose(() => {
      for (let i = this.rack.children.length - 1; i >= 0; i--) {
        const bc = this.rack.children[i];
        bc.viewProps.set("disposed", true);
      }
    });
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    insertElementAt$6(this.element, ev.bladeController.view.element, ev.index);
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    removeElement$6(ev.bladeController.view.element);
  }
};
function createBlade$6() {
  return new ValueMap$6({
    positions: createValue$6([], {
      equals: deepEqualsArray$6,
    }),
  });
}
let Foldable$6 = class Foldable extends ValueMap$6 {
  constructor(valueMap) {
    super(valueMap);
  }
  static create(expanded) {
    const coreObj = {
      completed: true,
      expanded,
      expandedHeight: null,
      shouldFixHeight: false,
      temporaryExpanded: null,
    };
    const core = ValueMap$6.createCore(coreObj);
    return new Foldable(core);
  }
  get styleExpanded() {
    var _a;
    return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0
      ? _a
      : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded) {
      return "0";
    }
    const exHeight = this.get("expandedHeight");
    if (this.get("shouldFixHeight") && !isEmpty$6(exHeight)) {
      return `${exHeight}px`;
    }
    return "auto";
  }
  bindExpandedClass(elem, expandedClassName) {
    const onExpand = () => {
      const expanded = this.styleExpanded;
      if (expanded) {
        elem.classList.add(expandedClassName);
      } else {
        elem.classList.remove(expandedClassName);
      }
    };
    bindValueMap$6(this, "expanded", onExpand);
    bindValueMap$6(this, "temporaryExpanded", onExpand);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", false);
    this.set("expandedHeight", null);
    this.set("completed", true);
  }
};
function computeExpandedFolderHeight$6(folder, containerElement) {
  let height = 0;
  disableTransitionTemporarily$6(containerElement, () => {
    folder.set("expandedHeight", null);
    folder.set("temporaryExpanded", true);
    forceReflow$6(containerElement);
    height = containerElement.clientHeight;
    folder.set("temporaryExpanded", null);
    forceReflow$6(containerElement);
  });
  return height;
}
function applyHeight$6(foldable, elem) {
  elem.style.height = foldable.styleHeight;
}
function bindFoldable$6(foldable, elem) {
  foldable.value("expanded").emitter.on("beforechange", () => {
    foldable.set("completed", false);
    if (isEmpty$6(foldable.get("expandedHeight"))) {
      const h = computeExpandedFolderHeight$6(foldable, elem);
      if (h > 0) {
        foldable.set("expandedHeight", h);
      }
    }
    foldable.set("shouldFixHeight", true);
    forceReflow$6(elem);
  });
  foldable.emitter.on("change", () => {
    applyHeight$6(foldable, elem);
  });
  applyHeight$6(foldable, elem);
  elem.addEventListener("transitionend", (ev) => {
    if (ev.propertyName !== "height") {
      return;
    }
    foldable.cleanUpTransition();
  });
}
let FolderApi$6 = class FolderApi extends ContainerBladeApi$6 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$6();
    this.controller.foldable.value("expanded").emitter.on("change", (ev) => {
      this.emitter_.emit("fold", new TpFoldEvent$6(this, ev.sender.rawValue));
    });
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(expanded) {
    this.controller.foldable.set("expanded", expanded);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(title) {
    this.controller.props.set("title", title);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    return this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.rackApi_.refresh();
  }
};
const bladeContainerClassName$6 = ClassName$6("cnt");
let FolderView$6 = class FolderView {
  constructor(doc, config) {
    var _a;
    this.className_ = ClassName$6(
      (_a = config.viewName) !== null && _a !== void 0 ? _a : "fld",
    );
    this.element = doc.createElement("div");
    this.element.classList.add(this.className_(), bladeContainerClassName$6());
    config.viewProps.bindClassModifiers(this.element);
    this.foldable_ = config.foldable;
    this.foldable_.bindExpandedClass(
      this.element,
      this.className_(void 0, "expanded"),
    );
    bindValueMap$6(
      this.foldable_,
      "completed",
      valueToClassName$6(this.element, this.className_(void 0, "cpl")),
    );
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(this.className_("b"));
    bindValueMap$6(config.props, "title", (title) => {
      if (isEmpty$6(title)) {
        this.element.classList.add(this.className_(void 0, "not"));
      } else {
        this.element.classList.remove(this.className_(void 0, "not"));
      }
    });
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(this.className_("i"));
    this.element.appendChild(indentElem);
    const titleElem = doc.createElement("div");
    titleElem.classList.add(this.className_("t"));
    bindValueToTextContent$6(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(this.className_("m"));
    this.buttonElement.appendChild(markElem);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(this.className_("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
let FolderController$6 = class FolderController extends ContainerBladeController$6 {
  constructor(doc, config) {
    var _a;
    const foldable = Foldable$6.create(
      (_a = config.expanded) !== null && _a !== void 0 ? _a : true,
    );
    const view = new FolderView$6(doc, {
      foldable,
      props: config.props,
      viewName: config.root ? "rot" : void 0,
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$6({
          blade: config.blade,
          element: view.containerElement,
          root: config.root,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onTitleClick_ = this.onTitleClick_.bind(this);
    this.props = config.props;
    this.foldable = foldable;
    bindFoldable$6(this.foldable, this.view.containerElement);
    this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    });
    this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    });
    this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(state) {
    return importBladeState$6(
      state,
      (s) => super.importState(s),
      (p) => ({
        expanded: p.required.boolean,
        title: p.optional.string,
      }),
      (result) => {
        this.foldable.set("expanded", result.expanded);
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$6(() => super.exportState(), {
      expanded: this.foldable.get("expanded"),
      title: this.props.get("title"),
    });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
};
createPlugin$6({
  id: "folder",
  type: "blade",
  accept(params) {
    const result = parseRecord$6(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("folder"),
      expanded: p.optional.boolean,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new FolderController$6(args.document, {
      blade: args.blade,
      expanded: args.params.expanded,
      props: ValueMap$6.fromObject({
        title: args.params.title,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (!(args.controller instanceof FolderController$6)) {
      return null;
    }
    return new FolderApi$6(args.controller, args.pool);
  },
});
const cn$n$6 = ClassName$6("");
function valueToModifier$6(elem, modifier) {
  return valueToClassName$6(elem, cn$n$6(void 0, modifier));
}
let ViewProps$6 = class ViewProps extends ValueMap$6 {
  constructor(valueMap) {
    var _a;
    super(valueMap);
    this.onDisabledChange_ = this.onDisabledChange_.bind(this);
    this.onParentChange_ = this.onParentChange_.bind(this);
    this.onParentGlobalDisabledChange_ =
      this.onParentGlobalDisabledChange_.bind(this);
    [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue$6(
      createValue$6(this.getGlobalDisabled_()),
    );
    this.value("disabled").emitter.on("change", this.onDisabledChange_);
    this.value("parent").emitter.on("change", this.onParentChange_);
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
  }
  static create(opt_initialValue) {
    var _a, _b, _c;
    const initialValue =
      opt_initialValue !== null && opt_initialValue !== void 0
        ? opt_initialValue
        : {};
    return new ViewProps(
      ValueMap$6.createCore({
        disabled:
          (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
        disposed: false,
        hidden:
          (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
        parent:
          (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null,
      }),
    );
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(elem) {
    bindValue$6(this.globalDisabled_, valueToModifier$6(elem, "disabled"));
    bindValueMap$6(this, "hidden", valueToModifier$6(elem, "hidden"));
  }
  bindDisabled(target) {
    bindValue$6(this.globalDisabled_, (disabled) => {
      target.disabled = disabled;
    });
  }
  bindTabIndex(elem) {
    bindValue$6(this.globalDisabled_, (disabled) => {
      elem.tabIndex = disabled ? -1 : 0;
    });
  }
  handleDispose(callback) {
    this.value("disposed").emitter.on("change", (disposed) => {
      if (disposed) {
        callback();
      }
    });
  }
  importState(state) {
    this.set("disabled", state.disabled);
    this.set("hidden", state.hidden);
  }
  exportState() {
    return {
      disabled: this.get("disabled"),
      hidden: this.get("hidden"),
    };
  }
  getGlobalDisabled_() {
    const parent = this.get("parent");
    const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
    return parentDisabled || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(ev) {
    var _a;
    const prevParent = ev.previousRawValue;
    prevParent === null || prevParent === void 0
      ? void 0
      : prevParent.globalDisabled.emitter.off(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    this.updateGlobalDisabled_();
  }
};
const cn$m$6 = ClassName$6("tbp");
let TabPageView$6 = class TabPageView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$m$6());
    config.viewProps.bindClassModifiers(this.element);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(cn$m$6("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
const cn$l$6 = ClassName$6("tbi");
let TabItemView$6 = class TabItemView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$l$6());
    config.viewProps.bindClassModifiers(this.element);
    bindValueMap$6(config.props, "selected", (selected) => {
      if (selected) {
        this.element.classList.add(cn$l$6(void 0, "sel"));
      } else {
        this.element.classList.remove(cn$l$6(void 0, "sel"));
      }
    });
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$l$6("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$l$6("t"));
    bindValueToTextContent$6(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
  }
};
let TabItemController$6 = class TabItemController {
  constructor(doc, config) {
    this.emitter = new Emitter$6();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new TabItemView$6(doc, {
      props: config.props,
      viewProps: config.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let TabPageController$6 = class TabPageController extends ContainerBladeController$6 {
  constructor(doc, config) {
    const view = new TabPageView$6(doc, {
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$6({
          blade: config.blade,
          element: view.containerElement,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onItemClick_ = this.onItemClick_.bind(this);
    this.ic_ = new TabItemController$6(doc, {
      props: config.itemProps,
      viewProps: ViewProps$6.create(),
    });
    this.ic_.emitter.on("click", this.onItemClick_);
    this.props = config.props;
    bindValueMap$6(this.props, "selected", (selected) => {
      this.itemController.props.set("selected", selected);
      this.viewProps.set("hidden", !selected);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(state) {
    return importBladeState$6(
      state,
      (s) => super.importState(s),
      (p) => ({
        selected: p.required.boolean,
        title: p.required.string,
      }),
      (result) => {
        this.ic_.props.set("selected", result.selected);
        this.ic_.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$6(() => super.exportState(), {
      selected: this.ic_.props.get("selected"),
      title: this.ic_.props.get("title"),
    });
  }
  onItemClick_() {
    this.props.set("selected", true);
  }
};
let TabApi$6 = class TabApi extends ContainerBladeApi$6 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$6();
    this.onSelect_ = this.onSelect_.bind(this);
    this.pool_ = pool;
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
    this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(params) {
    const doc = this.controller.view.element.ownerDocument;
    const pc = new TabPageController$6(doc, {
      blade: createBlade$6(),
      itemProps: ValueMap$6.fromObject({
        selected: false,
        title: params.title,
      }),
      props: ValueMap$6.fromObject({
        selected: false,
      }),
      viewProps: ViewProps$6.create(),
    });
    const papi = this.pool_.createApi(pc);
    return this.rackApi_.add(papi, params.index);
  }
  removePage(index) {
    this.rackApi_.remove(this.rackApi_.children[index]);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  onSelect_(ev) {
    this.emitter_.emit("select", new TpTabSelectEvent$6(this, ev.rawValue));
  }
};
let TabPageApi$6 = class TabPageApi extends ContainerBladeApi$6 {
  get title() {
    var _a;
    return (_a = this.controller.itemController.props.get("title")) !== null &&
      _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.itemController.props.set("title", title);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(selected) {
    this.controller.props.set("selected", selected);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  refresh() {
    this.rackApi_.refresh();
  }
};
const INDEX_NOT_SELECTED$6 = -1;
let Tab$6 = class Tab {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
    this.empty = createValue$6(true);
    this.selectedIndex = createValue$6(INDEX_NOT_SELECTED$6);
    this.items_ = [];
  }
  add(item, opt_index) {
    const index =
      opt_index !== null && opt_index !== void 0
        ? opt_index
        : this.items_.length;
    this.items_.splice(index, 0, item);
    item.emitter.on("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    item.emitter.off("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = INDEX_NOT_SELECTED$6;
      this.empty.rawValue = true;
      return;
    }
    const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
    if (firstSelIndex < 0) {
      this.items_.forEach((s, i) => {
        s.rawValue = i === 0;
      });
      this.selectedIndex.rawValue = 0;
    } else {
      this.items_.forEach((s, i) => {
        s.rawValue = i === firstSelIndex;
      });
      this.selectedIndex.rawValue = firstSelIndex;
    }
    this.empty.rawValue = false;
  }
  onItemSelectedChange_(ev) {
    if (ev.rawValue) {
      const index = this.items_.findIndex((s) => s === ev.sender);
      this.items_.forEach((s, i) => {
        s.rawValue = i === index;
      });
      this.selectedIndex.rawValue = index;
    } else {
      this.keepSelection_();
    }
  }
};
const cn$k$6 = ClassName$6("tab");
let TabView$6 = class TabView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$k$6(), bladeContainerClassName$6());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$6(
      config.empty,
      valueToClassName$6(this.element, cn$k$6(void 0, "nop")),
    );
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$k$6("t"));
    this.element.appendChild(titleElem);
    this.itemsElement = titleElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(cn$k$6("i"));
    this.element.appendChild(indentElem);
    const contentsElem = doc.createElement("div");
    contentsElem.classList.add(cn$k$6("c"));
    this.element.appendChild(contentsElem);
    this.contentsElement = contentsElem;
  }
};
let TabController$6 = class TabController extends ContainerBladeController$6 {
  constructor(doc, config) {
    const tab = new Tab$6();
    const view = new TabView$6(doc, {
      empty: tab.empty,
      viewProps: config.viewProps,
    });
    super({
      blade: config.blade,
      rackController: new RackController$6({
        blade: config.blade,
        element: view.contentsElement,
        viewProps: config.viewProps,
      }),
      view,
    });
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    const rack = this.rackController.rack;
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.tab = tab;
  }
  add(pc, opt_index) {
    this.rackController.rack.add(pc, opt_index);
  }
  remove(index) {
    this.rackController.rack.remove(this.rackController.rack.children[index]);
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    insertElementAt$6(
      this.view.itemsElement,
      pc.itemController.view.element,
      ev.index,
    );
    pc.itemController.viewProps.set("parent", this.viewProps);
    this.tab.add(pc.props.value("selected"));
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    removeElement$6(pc.itemController.view.element);
    pc.itemController.viewProps.set("parent", null);
    this.tab.remove(pc.props.value("selected"));
  }
};
createPlugin$6({
  id: "tab",
  type: "blade",
  accept(params) {
    const result = parseRecord$6(params, (p) => ({
      pages: p.required.array(p.required.object({ title: p.required.string })),
      view: p.required.constant("tab"),
    }));
    if (!result || result.pages.length === 0) {
      return null;
    }
    return { params: result };
  },
  controller(args) {
    const c = new TabController$6(args.document, {
      blade: args.blade,
      viewProps: args.viewProps,
    });
    args.params.pages.forEach((p) => {
      const pc = new TabPageController$6(args.document, {
        blade: createBlade$6(),
        itemProps: ValueMap$6.fromObject({
          selected: false,
          title: p.title,
        }),
        props: ValueMap$6.fromObject({
          selected: false,
        }),
        viewProps: ViewProps$6.create(),
      });
      c.add(pc);
    });
    return c;
  },
  api(args) {
    if (args.controller instanceof TabController$6) {
      return new TabApi$6(args.controller, args.pool);
    }
    if (args.controller instanceof TabPageController$6) {
      return new TabPageApi$6(args.controller, args.pool);
    }
    return null;
  },
});
let ListInputBindingApi$6 = class ListInputBindingApi extends BindingApi$6 {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(options) {
    this.controller.valueController.props.set("options", options);
  }
};
let ManualTicker$1 = class ManualTicker {
  constructor() {
    this.disabled = false;
    this.emitter = new Emitter$6();
  }
  dispose() {}
  tick() {
    if (this.disabled) {
      return;
    }
    this.emitter.emit("tick", {
      sender: this,
    });
  }
};
let IntervalTicker$1 = class IntervalTicker {
  constructor(doc, interval) {
    this.disabled_ = false;
    this.timerId_ = null;
    this.onTick_ = this.onTick_.bind(this);
    this.doc_ = doc;
    this.emitter = new Emitter$6();
    this.interval_ = interval;
    this.setTimer_();
  }
  get disabled() {
    return this.disabled_;
  }
  set disabled(inactive) {
    this.disabled_ = inactive;
    if (this.disabled_) {
      this.clearTimer_();
    } else {
      this.setTimer_();
    }
  }
  dispose() {
    this.clearTimer_();
  }
  clearTimer_() {
    if (this.timerId_ === null) {
      return;
    }
    const win = this.doc_.defaultView;
    if (win) {
      win.clearInterval(this.timerId_);
    }
    this.timerId_ = null;
  }
  setTimer_() {
    this.clearTimer_();
    if (this.interval_ <= 0) {
      return;
    }
    const win = this.doc_.defaultView;
    if (win) {
      this.timerId_ = win.setInterval(this.onTick_, this.interval_);
    }
  }
  onTick_() {
    if (this.disabled_) {
      return;
    }
    this.emitter.emit("tick", {
      sender: this,
    });
  }
};
let CompositeConstraint$6 = class CompositeConstraint {
  constructor(constraints) {
    this.constraints = constraints;
  }
  constrain(value) {
    return this.constraints.reduce((result, c) => {
      return c.constrain(result);
    }, value);
  }
};
function findConstraint$6(c, constraintClass) {
  if (c instanceof constraintClass) {
    return c;
  }
  if (c instanceof CompositeConstraint$6) {
    const result = c.constraints.reduce((tmpResult, sc) => {
      if (tmpResult) {
        return tmpResult;
      }
      return sc instanceof constraintClass ? sc : null;
    }, null);
    if (result) {
      return result;
    }
  }
  return null;
}
let ListConstraint$6 = class ListConstraint {
  constructor(options) {
    this.values = ValueMap$6.fromObject({
      options,
    });
  }
  constrain(value) {
    const opts = this.values.get("options");
    if (opts.length === 0) {
      return value;
    }
    const matched =
      opts.filter((item) => {
        return item.value === value;
      }).length > 0;
    return matched ? value : opts[0].value;
  }
};
function parseListOptions$6(value) {
  var _a;
  const p = MicroParsers$6;
  if (Array.isArray(value)) {
    return (_a = parseRecord$6({ items: value }, (p2) => ({
      items: p2.required.array(
        p2.required.object({
          text: p2.required.string,
          value: p2.required.raw,
        }),
      ),
    }))) === null || _a === void 0
      ? void 0
      : _a.items;
  }
  if (typeof value === "object") {
    return p.required.raw(value).value;
  }
  return void 0;
}
function normalizeListOptions$6(options) {
  if (Array.isArray(options)) {
    return options;
  }
  const items = [];
  Object.keys(options).forEach((text) => {
    items.push({ text, value: options[text] });
  });
  return items;
}
function createListConstraint$6(options) {
  return !isEmpty$6(options)
    ? new ListConstraint$6(normalizeListOptions$6(forceCast$6(options)))
    : null;
}
const cn$j$6 = ClassName$6("lst");
let ListView$6 = class ListView {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$j$6());
    config.viewProps.bindClassModifiers(this.element);
    const selectElem = doc.createElement("select");
    selectElem.classList.add(cn$j$6("s"));
    config.viewProps.bindDisabled(selectElem);
    this.element.appendChild(selectElem);
    this.selectElement = selectElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(cn$j$6("m"));
    markElem.appendChild(createSvgIconElement$6(doc, "dropdown"));
    this.element.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value_ = config.value;
    bindValueMap$6(this.props_, "options", (opts) => {
      removeChildElements$6(this.selectElement);
      opts.forEach((item) => {
        const optionElem = doc.createElement("option");
        optionElem.textContent = item.text;
        this.selectElement.appendChild(optionElem);
      });
      this.update_();
    });
  }
  update_() {
    const values = this.props_.get("options").map((o) => o.value);
    this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
};
let ListController$6 = class ListController {
  constructor(doc, config) {
    this.onSelectChange_ = this.onSelectChange_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ListView$6(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const selectElem = forceCast$6(e.currentTarget);
    this.value.rawValue =
      this.props.get("options")[selectElem.selectedIndex].value;
  }
  importProps(state) {
    return importBladeState$6(
      state,
      null,
      (p) => ({
        options: p.required.custom(parseListOptions$6),
      }),
      (result) => {
        this.props.set("options", normalizeListOptions$6(result.options));
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$6(null, {
      options: this.props.get("options"),
    });
  }
};
const cn$i$6 = ClassName$6("pop");
let PopupView$6 = class PopupView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$i$6());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$6(
      config.shows,
      valueToClassName$6(this.element, cn$i$6(void 0, "v")),
    );
  }
};
let PopupController$6 = class PopupController {
  constructor(doc, config) {
    this.shows = createValue$6(false);
    this.viewProps = config.viewProps;
    this.view = new PopupView$6(doc, {
      shows: this.shows,
      viewProps: this.viewProps,
    });
  }
};
const cn$h$6 = ClassName$6("txt");
let TextView$6 = class TextView {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$h$6());
    config.viewProps.bindClassModifiers(this.element);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$h$6("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onChange_);
    this.value_ = config.value;
    this.refresh();
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let TextController$6 = class TextController {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new TextView$6(doc, {
      props: config.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$6(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$6(parsedValue)) {
      this.value.rawValue = parsedValue;
    }
    this.view.refresh();
  }
};
function boolToString$6(value) {
  return String(value);
}
function boolFromUnknown$6(value) {
  if (value === "false") {
    return false;
  }
  return !!value;
}
function BooleanFormatter$6(value) {
  return boolToString$6(value);
}
function composeParsers$6(parsers) {
  return (text) => {
    return parsers.reduce((result, parser) => {
      if (result !== null) {
        return result;
      }
      return parser(text);
    }, null);
  };
}
const innerFormatter$6 = createNumberFormatter$6(0);
function formatPercentage$6(value) {
  return innerFormatter$6(value) + "%";
}
function stringFromUnknown$6(value) {
  return String(value);
}
function formatString$6(value) {
  return value;
}
function connectValues$6({ primary, secondary, forward, backward }) {
  let changing = false;
  function preventFeedback(callback) {
    if (changing) {
      return;
    }
    changing = true;
    callback();
    changing = false;
  }
  primary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  secondary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      primary.setRawValue(
        backward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  preventFeedback(() => {
    secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), {
      forceEmit: false,
      last: true,
    });
  });
}
function getStepForKey$6(keyScale, keys) {
  const step = keyScale * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
  if (keys.upKey) {
    return +step;
  } else if (keys.downKey) {
    return -step;
  }
  return 0;
}
function getVerticalStepKeys$6(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowDown",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowUp",
  };
}
function getHorizontalStepKeys$6(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowLeft",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowRight",
  };
}
function isVerticalArrowKey$6(key2) {
  return key2 === "ArrowUp" || key2 === "ArrowDown";
}
function isArrowKey$6(key2) {
  return (
    isVerticalArrowKey$6(key2) || key2 === "ArrowLeft" || key2 === "ArrowRight"
  );
}
function computeOffset$1$6(ev, elem) {
  var _a, _b;
  const win = elem.ownerDocument.defaultView;
  const rect = elem.getBoundingClientRect();
  return {
    x:
      ev.pageX -
      (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) +
        rect.left),
    y:
      ev.pageY -
      (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) +
        rect.top),
  };
}
let PointerHandler$6 = class PointerHandler {
  constructor(element) {
    this.lastTouch_ = null;
    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onTouchEnd_ = this.onTouchEnd_.bind(this);
    this.onTouchMove_ = this.onTouchMove_.bind(this);
    this.onTouchStart_ = this.onTouchStart_.bind(this);
    this.elem_ = element;
    this.emitter = new Emitter$6();
    element.addEventListener("touchstart", this.onTouchStart_, {
      passive: false,
    });
    element.addEventListener("touchmove", this.onTouchMove_, {
      passive: true,
    });
    element.addEventListener("touchend", this.onTouchEnd_);
    element.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(offset) {
    const rect = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: rect.width,
        height: rect.height,
      },
      point: offset
        ? {
            x: offset.x,
            y: offset.y,
          }
        : null,
    };
  }
  onMouseDown_(ev) {
    var _a;
    ev.preventDefault();
    (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
    const doc = this.elem_.ownerDocument;
    doc.addEventListener("mousemove", this.onDocumentMouseMove_);
    doc.addEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$6(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseMove_(ev) {
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$6(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseUp_(ev) {
    const doc = this.elem_.ownerDocument;
    doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
    doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$6(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onTouchStart_(ev) {
    ev.preventDefault();
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchMove_(ev) {
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchEnd_(ev) {
    var _a;
    const touch =
      (_a = ev.targetTouches.item(0)) !== null && _a !== void 0
        ? _a
        : this.lastTouch_;
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
};
const cn$g$6 = ClassName$6("txt");
let NumberTextView$6 = class NumberTextView {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$g$6(), cn$g$6(void 0, "num"));
    if (config.arrayPosition) {
      this.element.classList.add(cn$g$6(void 0, config.arrayPosition));
    }
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$g$6("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    this.onDraggingChange_ = this.onDraggingChange_.bind(this);
    this.dragging_ = config.dragging;
    this.dragging_.emitter.on("change", this.onDraggingChange_);
    this.element.classList.add(cn$g$6());
    this.inputElement.classList.add(cn$g$6("i"));
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$g$6("k"));
    this.element.appendChild(knobElem);
    this.knobElement = knobElem;
    const guideElem = doc.createElementNS(SVG_NS$6, "svg");
    guideElem.classList.add(cn$g$6("g"));
    this.knobElement.appendChild(guideElem);
    const bodyElem = doc.createElementNS(SVG_NS$6, "path");
    bodyElem.classList.add(cn$g$6("gb"));
    guideElem.appendChild(bodyElem);
    this.guideBodyElem_ = bodyElem;
    const headElem = doc.createElementNS(SVG_NS$6, "path");
    headElem.classList.add(cn$g$6("gh"));
    guideElem.appendChild(headElem);
    this.guideHeadElem_ = headElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(ClassName$6("tt")());
    this.knobElement.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.refresh();
  }
  onDraggingChange_(ev) {
    if (ev.rawValue === null) {
      this.element.classList.remove(cn$g$6(void 0, "drg"));
      return;
    }
    this.element.classList.add(cn$g$6(void 0, "drg"));
    const x = ev.rawValue / this.props_.get("pointerScale");
    const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
    const adx = constrainRange$6(-aox, -4, 4);
    this.guideHeadElem_.setAttributeNS(
      null,
      "d",
      [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(
        " ",
      ),
    );
    this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
    const formatter = this.props_.get("formatter");
    this.tooltipElem_.textContent = formatter(this.value.rawValue);
    this.tooltipElem_.style.left = `${x}px`;
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let NumberTextController$6 = class NumberTextController {
  constructor(doc, config) {
    var _a;
    this.originRawValue_ = 0;
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.sliderProps_ =
      (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.dragging_ = createValue$6(null);
    this.view = new NumberTextView$6(doc, {
      arrayPosition: config.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
    this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
    this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const ph = new PointerHandler$6(this.view.knobElement);
    ph.emitter.on("down", this.onPointerDown_);
    ph.emitter.on("move", this.onPointerMove_);
    ph.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(value) {
    var _a, _b;
    const min =
      (_a = this.sliderProps_) === null || _a === void 0
        ? void 0
        : _a.get("min");
    const max =
      (_b = this.sliderProps_) === null || _b === void 0
        ? void 0
        : _b.get("max");
    let v = value;
    if (min !== void 0) {
      v = Math.max(v, min);
    }
    if (max !== void 0) {
      v = Math.min(v, max);
    }
    return v;
  }
  onInputChange_(e) {
    const inputElem = forceCast$6(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$6(parsedValue)) {
      this.value.rawValue = this.constrainValue_(parsedValue);
    }
    this.view.refresh();
  }
  onInputKeyDown_(ev) {
    const step = getStepForKey$6(
      this.props.get("keyScale"),
      getVerticalStepKeys$6(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
      forceEmit: false,
      last: false,
    });
  }
  onInputKeyUp_(ev) {
    const step = getStepForKey$6(
      this.props.get("keyScale"),
      getVerticalStepKeys$6(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue;
    this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(data) {
    if (!data.point) {
      return null;
    }
    const dx = data.point.x - data.bounds.width / 2;
    return this.constrainValue_(
      this.originRawValue_ + dx * this.props.get("pointerScale"),
    );
  }
  onPointerMove_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: false,
      last: false,
    });
    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
  }
  onPointerUp_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: true,
      last: true,
    });
    this.dragging_.rawValue = null;
  }
};
const cn$f$6 = ClassName$6("sld");
let SliderView$6 = class SliderView {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$f$6());
    config.viewProps.bindClassModifiers(this.element);
    const trackElem = doc.createElement("div");
    trackElem.classList.add(cn$f$6("t"));
    config.viewProps.bindTabIndex(trackElem);
    this.element.appendChild(trackElem);
    this.trackElement = trackElem;
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$f$6("k"));
    this.trackElement.appendChild(knobElem);
    this.knobElement = knobElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const p = constrainRange$6(
      mapRange$6(
        this.value.rawValue,
        this.props_.get("min"),
        this.props_.get("max"),
        0,
        100,
      ),
      0,
      100,
    );
    this.knobElement.style.width = `${p}%`;
  }
  onChange_() {
    this.update_();
  }
};
let SliderController$6 = class SliderController {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.props = config.props;
    this.view = new SliderView$6(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$6(this.view.trackElement);
    this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
    this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    this.value.setRawValue(
      mapRange$6(
        constrainRange$6(d.point.x, 0, d.bounds.width),
        0,
        d.bounds.width,
        this.props.get("min"),
        this.props.get("max"),
      ),
      opts,
    );
  }
  onPointerDownOrMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$6(
      this.props.get("keyScale"),
      getHorizontalStepKeys$6(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue + step, {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$6(
      this.props.get("keyScale"),
      getHorizontalStepKeys$6(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$e$6 = ClassName$6("sldtxt");
let SliderTextView$6 = class SliderTextView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$e$6());
    const sliderElem = doc.createElement("div");
    sliderElem.classList.add(cn$e$6("s"));
    this.sliderView_ = config.sliderView;
    sliderElem.appendChild(this.sliderView_.element);
    this.element.appendChild(sliderElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$e$6("t"));
    this.textView_ = config.textView;
    textElem.appendChild(this.textView_.element);
    this.element.appendChild(textElem);
  }
};
let SliderTextController$6 = class SliderTextController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.sliderC_ = new SliderController$6(doc, {
      props: config.sliderProps,
      value: config.value,
      viewProps: this.viewProps,
    });
    this.textC_ = new NumberTextController$6(doc, {
      parser: config.parser,
      props: config.textProps,
      sliderProps: config.sliderProps,
      value: config.value,
      viewProps: config.viewProps,
    });
    this.view = new SliderTextView$6(doc, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view,
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(state) {
    return importBladeState$6(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        const sliderProps = this.sliderC_.props;
        sliderProps.set("max", result.max);
        sliderProps.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    const sliderProps = this.sliderC_.props;
    return exportBladeState$6(null, {
      max: sliderProps.get("max"),
      min: sliderProps.get("min"),
    });
  }
};
function createSliderTextProps$6(config) {
  return {
    sliderProps: new ValueMap$6({
      keyScale: config.keyScale,
      max: config.max,
      min: config.min,
    }),
    textProps: new ValueMap$6({
      formatter: createValue$6(config.formatter),
      keyScale: config.keyScale,
      pointerScale: createValue$6(config.pointerScale),
    }),
  };
}
const CSS_VAR_MAP$6 = {
  containerUnitSize: "cnt-usz",
};
function getCssVar$6(key2) {
  return `--${CSS_VAR_MAP$6[key2]}`;
}
class PlainView {
  constructor(doc, config) {
    const cn2 = ClassName$6(config.viewName);
    this.element = doc.createElement("div");
    this.element.classList.add(cn2());
    config.viewProps.bindClassModifiers(this.element);
  }
}
function createPointDimensionParser$6(p) {
  return createNumberTextInputParamsParser$6(p);
}
function parsePointDimensionParams$6(value) {
  if (!isRecord$6(value)) {
    return void 0;
  }
  return parseRecord$6(value, createPointDimensionParser$6);
}
function createDimensionConstraint$6(params, initialValue) {
  if (!params) {
    return void 0;
  }
  const constraints = [];
  const cs = createStepConstraint$6(params, initialValue);
  if (cs) {
    constraints.push(cs);
  }
  const rs = createRangeConstraint$6(params);
  if (rs) {
    constraints.push(rs);
  }
  return new CompositeConstraint$6(constraints);
}
function parsePickerLayout$6(value) {
  if (value === "inline" || value === "popup") {
    return value;
  }
  return void 0;
}
function writePrimitive$6(target, value) {
  target.write(value);
}
const cn$d$6 = ClassName$6("ckb");
let CheckboxView$6 = class CheckboxView {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$d$6());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("label");
    labelElem.classList.add(cn$d$6("l"));
    this.element.appendChild(labelElem);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$d$6("i"));
    inputElem.type = "checkbox";
    labelElem.appendChild(inputElem);
    this.inputElement = inputElem;
    config.viewProps.bindDisabled(this.inputElement);
    const wrapperElem = doc.createElement("div");
    wrapperElem.classList.add(cn$d$6("w"));
    labelElem.appendChild(wrapperElem);
    const markElem = createSvgIconElement$6(doc, "check");
    wrapperElem.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
};
let CheckboxController$6 = class CheckboxController {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new CheckboxView$6(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$6(e.currentTarget);
    this.value.rawValue = inputElem.checked;
  }
};
function createConstraint$8$1(params) {
  const constraints = [];
  const lc = createListConstraint$6(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$6(constraints);
}
createPlugin$6({
  id: "input-bool",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$6(params, (p) => ({
      options: p.optional.custom(parseListOptions$6),
      readonly: p.optional.constant(false),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$6,
    constraint: (args) => createConstraint$8$1(args.params),
    writer: (_args) => writePrimitive$6,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$6(c, ListConstraint$6);
    if (lc) {
      return new ListController$6(doc, {
        props: new ValueMap$6({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new CheckboxController$6(doc, {
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "boolean") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$6) {
      return new ListInputBindingApi$6(args.controller);
    }
    return null;
  },
});
const cn$c$6 = ClassName$6("col");
let ColorView$6 = class ColorView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$c$6());
    config.foldable.bindExpandedClass(this.element, cn$c$6(void 0, "expanded"));
    bindValueMap$6(
      config.foldable,
      "completed",
      valueToClassName$6(this.element, cn$c$6(void 0, "cpl")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$c$6("h"));
    this.element.appendChild(headElem);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$c$6("s"));
    headElem.appendChild(swatchElem);
    this.swatchElement = swatchElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$c$6("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$c$6("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
function rgbToHslInt$6(r, g, b) {
  const rp = constrainRange$6(r / 255, 0, 1);
  const gp = constrainRange$6(g / 255, 0, 1);
  const bp = constrainRange$6(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const c = cmax - cmin;
  let h = 0;
  let s = 0;
  const l = (cmin + cmax) / 2;
  if (c !== 0) {
    s = c / (1 - Math.abs(cmax + cmin - 1));
    if (rp === cmax) {
      h = (gp - bp) / c;
    } else if (gp === cmax) {
      h = 2 + (bp - rp) / c;
    } else {
      h = 4 + (rp - gp) / c;
    }
    h = h / 6 + (h < 0 ? 1 : 0);
  }
  return [h * 360, s * 100, l * 100];
}
function hslToRgbInt$6(h, s, l) {
  const hp = ((h % 360) + 360) % 360;
  const sp = constrainRange$6(s / 100, 0, 1);
  const lp = constrainRange$6(l / 100, 0, 1);
  const c = (1 - Math.abs(2 * lp - 1)) * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = lp - c / 2;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function rgbToHsvInt$6(r, g, b) {
  const rp = constrainRange$6(r / 255, 0, 1);
  const gp = constrainRange$6(g / 255, 0, 1);
  const bp = constrainRange$6(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const d = cmax - cmin;
  let h;
  if (d === 0) {
    h = 0;
  } else if (cmax === rp) {
    h = 60 * (((((gp - bp) / d) % 6) + 6) % 6);
  } else if (cmax === gp) {
    h = 60 * ((bp - rp) / d + 2);
  } else {
    h = 60 * ((rp - gp) / d + 4);
  }
  const s = cmax === 0 ? 0 : d / cmax;
  const v = cmax;
  return [h, s * 100, v * 100];
}
function hsvToRgbInt$6(h, s, v) {
  const hp = loopRange$6(h, 360);
  const sp = constrainRange$6(s / 100, 0, 1);
  const vp = constrainRange$6(v / 100, 0, 1);
  const c = vp * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = vp - c;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function hslToHsvInt$6(h, s, l) {
  const sd = l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100);
  return [
    h,
    sd !== 0 ? (s * (100 - Math.abs(2 * l - 100))) / sd : 0,
    l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100),
  ];
}
function hsvToHslInt$6(h, s, v) {
  const sd = 100 - Math.abs((v * (200 - s)) / 100 - 100);
  return [h, sd !== 0 ? (s * v) / sd : 0, (v * (200 - s)) / (2 * 100)];
}
function removeAlphaComponent$6(comps) {
  return [comps[0], comps[1], comps[2]];
}
function appendAlphaComponent$6(comps, alpha) {
  return [comps[0], comps[1], comps[2], alpha];
}
const MODE_CONVERTER_MAP$6 = {
  hsl: {
    hsl: (h, s, l) => [h, s, l],
    hsv: hslToHsvInt$6,
    rgb: hslToRgbInt$6,
  },
  hsv: {
    hsl: hsvToHslInt$6,
    hsv: (h, s, v) => [h, s, v],
    rgb: hsvToRgbInt$6,
  },
  rgb: {
    hsl: rgbToHslInt$6,
    hsv: rgbToHsvInt$6,
    rgb: (r, g, b) => [r, g, b],
  },
};
function getColorMaxComponents$6(mode, type) {
  return [
    type === "float" ? 1 : mode === "rgb" ? 255 : 360,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
  ];
}
function loopHueRange$6(hue, max) {
  return hue === max ? max : loopRange$6(hue, max);
}
function constrainColorComponents$6(components, mode, type) {
  var _a;
  const ms = getColorMaxComponents$6(mode, type);
  return [
    mode === "rgb"
      ? constrainRange$6(components[0], 0, ms[0])
      : loopHueRange$6(components[0], ms[0]),
    constrainRange$6(components[1], 0, ms[1]),
    constrainRange$6(components[2], 0, ms[2]),
    constrainRange$6(
      (_a = components[3]) !== null && _a !== void 0 ? _a : 1,
      0,
      1,
    ),
  ];
}
function convertColorType$6(comps, mode, from, to) {
  const fms = getColorMaxComponents$6(mode, from);
  const tms = getColorMaxComponents$6(mode, to);
  return comps.map((c, index) => (c / fms[index]) * tms[index]);
}
function convertColor$6(components, from, to) {
  const intComps = convertColorType$6(components, from.mode, from.type, "int");
  const result = MODE_CONVERTER_MAP$6[from.mode][to.mode](...intComps);
  return convertColorType$6(result, to.mode, "int", to.type);
}
let IntColor$6 = class IntColor {
  static black() {
    return new IntColor([0, 0, 0], "rgb");
  }
  constructor(comps, mode) {
    this.type = "int";
    this.mode = mode;
    this.comps_ = constrainColorComponents$6(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$6(
      convertColor$6(
        removeAlphaComponent$6(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const cn$b$6 = ClassName$6("colp");
let ColorPickerView$6 = class ColorPickerView {
  constructor(doc, config) {
    this.alphaViews_ = null;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$b$6());
    config.viewProps.bindClassModifiers(this.element);
    const hsvElem = doc.createElement("div");
    hsvElem.classList.add(cn$b$6("hsv"));
    const svElem = doc.createElement("div");
    svElem.classList.add(cn$b$6("sv"));
    this.svPaletteView_ = config.svPaletteView;
    svElem.appendChild(this.svPaletteView_.element);
    hsvElem.appendChild(svElem);
    const hElem = doc.createElement("div");
    hElem.classList.add(cn$b$6("h"));
    this.hPaletteView_ = config.hPaletteView;
    hElem.appendChild(this.hPaletteView_.element);
    hsvElem.appendChild(hElem);
    this.element.appendChild(hsvElem);
    const rgbElem = doc.createElement("div");
    rgbElem.classList.add(cn$b$6("rgb"));
    this.textsView_ = config.textsView;
    rgbElem.appendChild(this.textsView_.element);
    this.element.appendChild(rgbElem);
    if (config.alphaViews) {
      this.alphaViews_ = {
        palette: config.alphaViews.palette,
        text: config.alphaViews.text,
      };
      const aElem = doc.createElement("div");
      aElem.classList.add(cn$b$6("a"));
      const apElem = doc.createElement("div");
      apElem.classList.add(cn$b$6("ap"));
      apElem.appendChild(this.alphaViews_.palette.element);
      aElem.appendChild(apElem);
      const atElem = doc.createElement("div");
      atElem.classList.add(cn$b$6("at"));
      atElem.appendChild(this.alphaViews_.text.element);
      aElem.appendChild(atElem);
      this.element.appendChild(aElem);
    }
  }
  get allFocusableElements() {
    const elems = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textsView_.modeSelectElement,
      ...this.textsView_.inputViews.map((v) => v.inputElement),
    ];
    if (this.alphaViews_) {
      elems.push(
        this.alphaViews_.palette.element,
        this.alphaViews_.text.inputElement,
      );
    }
    return elems;
  }
};
function parseColorType$6(value) {
  return value === "int" ? "int" : value === "float" ? "float" : void 0;
}
function parseColorInputParams$6(params) {
  return parseRecord$6(params, (p) => ({
    color: p.optional.object({
      alpha: p.optional.boolean,
      type: p.optional.custom(parseColorType$6),
    }),
    expanded: p.optional.boolean,
    picker: p.optional.custom(parsePickerLayout$6),
    readonly: p.optional.constant(false),
  }));
}
function getKeyScaleForColor$6(forAlpha) {
  return forAlpha ? 0.1 : 1;
}
function extractColorType$6(params) {
  var _a;
  return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
}
let FloatColor$6 = class FloatColor {
  constructor(comps, mode) {
    this.type = "float";
    this.mode = mode;
    this.comps_ = constrainColorComponents$6(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$6(
      convertColor$6(
        removeAlphaComponent$6(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const TYPE_TO_CONSTRUCTOR_MAP$6 = {
  int: (comps, mode) => new IntColor$6(comps, mode),
  float: (comps, mode) => new FloatColor$6(comps, mode),
};
function createColor$6(comps, mode, type) {
  return TYPE_TO_CONSTRUCTOR_MAP$6[type](comps, mode);
}
function isFloatColor$6(c) {
  return c.type === "float";
}
function isIntColor$6(c) {
  return c.type === "int";
}
function convertFloatToInt$6(cf) {
  const comps = cf.getComponents();
  const ms = getColorMaxComponents$6(cf.mode, "int");
  return new IntColor$6(
    [
      Math.round(mapRange$6(comps[0], 0, 1, 0, ms[0])),
      Math.round(mapRange$6(comps[1], 0, 1, 0, ms[1])),
      Math.round(mapRange$6(comps[2], 0, 1, 0, ms[2])),
      comps[3],
    ],
    cf.mode,
  );
}
function convertIntToFloat$6(ci) {
  const comps = ci.getComponents();
  const ms = getColorMaxComponents$6(ci.mode, "int");
  return new FloatColor$6(
    [
      mapRange$6(comps[0], 0, ms[0], 0, 1),
      mapRange$6(comps[1], 0, ms[1], 0, 1),
      mapRange$6(comps[2], 0, ms[2], 0, 1),
      comps[3],
    ],
    ci.mode,
  );
}
function mapColorType$6(c, type) {
  if (c.type === type) {
    return c;
  }
  if (isIntColor$6(c) && type === "float") {
    return convertIntToFloat$6(c);
  }
  if (isFloatColor$6(c) && type === "int") {
    return convertFloatToInt$6(c);
  }
  throw TpError$6.shouldNeverHappen();
}
function equalsStringColorFormat$6(f1, f2) {
  return (
    f1.alpha === f2.alpha &&
    f1.mode === f2.mode &&
    f1.notation === f2.notation &&
    f1.type === f2.type
  );
}
function parseCssNumberOrPercentage$6(text, max) {
  const m = text.match(/^(.+)%$/);
  if (!m) {
    return Math.min(parseFloat(text), max);
  }
  return Math.min(parseFloat(m[1]) * 0.01 * max, max);
}
const ANGLE_TO_DEG_MAP$6 = {
  deg: (angle) => angle,
  grad: (angle) => (angle * 360) / 400,
  rad: (angle) => (angle * 360) / (2 * Math.PI),
  turn: (angle) => angle * 360,
};
function parseCssNumberOrAngle$6(text) {
  const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!m) {
    return parseFloat(text);
  }
  const angle = parseFloat(m[1]);
  const unit = m[2];
  return ANGLE_TO_DEG_MAP$6[unit](angle);
}
function parseFunctionalRgbColorComponents$6(text) {
  const m = text.match(
    /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$6(m[1], 255),
    parseCssNumberOrPercentage$6(m[2], 255),
    parseCssNumberOrPercentage$6(m[3], 255),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbColor$6(text) {
  const comps = parseFunctionalRgbColorComponents$6(text);
  return comps ? new IntColor$6(comps, "rgb") : null;
}
function parseFunctionalRgbaColorComponents$6(text) {
  const m = text.match(
    /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$6(m[1], 255),
    parseCssNumberOrPercentage$6(m[2], 255),
    parseCssNumberOrPercentage$6(m[3], 255),
    parseCssNumberOrPercentage$6(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbaColor$6(text) {
  const comps = parseFunctionalRgbaColorComponents$6(text);
  return comps ? new IntColor$6(comps, "rgb") : null;
}
function parseFunctionalHslColorComponents$6(text) {
  const m = text.match(
    /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$6(m[1]),
    parseCssNumberOrPercentage$6(m[2], 100),
    parseCssNumberOrPercentage$6(m[3], 100),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalHslColor$6(text) {
  const comps = parseFunctionalHslColorComponents$6(text);
  return comps ? new IntColor$6(comps, "hsl") : null;
}
function parseHslaColorComponents$6(text) {
  const m = text.match(
    /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$6(m[1]),
    parseCssNumberOrPercentage$6(m[2], 100),
    parseCssNumberOrPercentage$6(m[3], 100),
    parseCssNumberOrPercentage$6(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalHslaColor$6(text) {
  const comps = parseHslaColorComponents$6(text);
  return comps ? new IntColor$6(comps, "hsl") : null;
}
function parseHexRgbColorComponents$6(text) {
  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
    ];
  }
  return null;
}
function parseHexRgbColor$6(text) {
  const comps = parseHexRgbColorComponents$6(text);
  return comps ? new IntColor$6(comps, "rgb") : null;
}
function parseHexRgbaColorComponents$6(text) {
  const mRgb = text.match(
    /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/,
  );
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
      mapRange$6(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
      mapRange$6(parseInt(mRrggbb[4], 16), 0, 255, 0, 1),
    ];
  }
  return null;
}
function parseHexRgbaColor$6(text) {
  const comps = parseHexRgbaColorComponents$6(text);
  return comps ? new IntColor$6(comps, "rgb") : null;
}
function parseObjectRgbColorComponents$6(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function createObjectRgbColorParser$6(type) {
  return (text) => {
    const comps = parseObjectRgbColorComponents$6(text);
    return comps ? createColor$6(comps, "rgb", type) : null;
  };
}
function parseObjectRgbaColorComponents$6(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseFloat(m[1]),
    parseFloat(m[2]),
    parseFloat(m[3]),
    parseFloat(m[4]),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function createObjectRgbaColorParser$6(type) {
  return (text) => {
    const comps = parseObjectRgbaColorComponents$6(text);
    return comps ? createColor$6(comps, "rgb", type) : null;
  };
}
const PARSER_AND_RESULT$6 = [
  {
    parser: parseHexRgbColorComponents$6,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseHexRgbaColorComponents$6,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseFunctionalRgbColorComponents$6,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalRgbaColorComponents$6,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalHslColorComponents$6,
    result: {
      alpha: false,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseHslaColorComponents$6,
    result: {
      alpha: true,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseObjectRgbColorComponents$6,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "object",
    },
  },
  {
    parser: parseObjectRgbaColorComponents$6,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "object",
    },
  },
];
function detectStringColor$6(text) {
  return PARSER_AND_RESULT$6.reduce((prev, { parser, result: detection }) => {
    if (prev) {
      return prev;
    }
    return parser(text) ? detection : null;
  }, null);
}
function detectStringColorFormat$6(text, type = "int") {
  const r = detectStringColor$6(text);
  if (!r) {
    return null;
  }
  if (r.notation === "hex" && type !== "float") {
    return Object.assign(Object.assign({}, r), { type: "int" });
  }
  if (r.notation === "func") {
    return Object.assign(Object.assign({}, r), { type });
  }
  return null;
}
function createColorStringParser$6(type) {
  const parsers = [
    parseHexRgbColor$6,
    parseHexRgbaColor$6,
    parseFunctionalRgbColor$6,
    parseFunctionalRgbaColor$6,
    parseFunctionalHslColor$6,
    parseFunctionalHslaColor$6,
  ];
  if (type === "int") {
    parsers.push(
      createObjectRgbColorParser$6("int"),
      createObjectRgbaColorParser$6("int"),
    );
  }
  if (type === "float") {
    parsers.push(
      createObjectRgbColorParser$6("float"),
      createObjectRgbaColorParser$6("float"),
    );
  }
  const parser = composeParsers$6(parsers);
  return (text) => {
    const result = parser(text);
    return result ? mapColorType$6(result, type) : null;
  };
}
function readIntColorString$6(value) {
  const parser = createColorStringParser$6("int");
  if (typeof value !== "string") {
    return IntColor$6.black();
  }
  const result = parser(value);
  return result !== null && result !== void 0 ? result : IntColor$6.black();
}
function zerofill$6(comp) {
  const hex = constrainRange$6(Math.floor(comp), 0, 255).toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function colorToHexRgbString$6(value, prefix = "#") {
  const hexes = removeAlphaComponent$6(value.getComponents("rgb"))
    .map(zerofill$6)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToHexRgbaString$6(value, prefix = "#") {
  const rgbaComps = value.getComponents("rgb");
  const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
    .map(zerofill$6)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToFunctionalRgbString$6(value) {
  const formatter = createNumberFormatter$6(0);
  const ci = mapColorType$6(value, "int");
  const comps = removeAlphaComponent$6(ci.getComponents("rgb")).map((comp) =>
    formatter(comp),
  );
  return `rgb(${comps.join(", ")})`;
}
function colorToFunctionalRgbaString$6(value) {
  const aFormatter = createNumberFormatter$6(2);
  const rgbFormatter = createNumberFormatter$6(0);
  const ci = mapColorType$6(value, "int");
  const comps = ci.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return formatter(comp);
  });
  return `rgba(${comps.join(", ")})`;
}
function colorToFunctionalHslString$6(value) {
  const formatters = [
    createNumberFormatter$6(0),
    formatPercentage$6,
    formatPercentage$6,
  ];
  const ci = mapColorType$6(value, "int");
  const comps = removeAlphaComponent$6(ci.getComponents("hsl")).map(
    (comp, index) => formatters[index](comp),
  );
  return `hsl(${comps.join(", ")})`;
}
function colorToFunctionalHslaString$6(value) {
  const formatters = [
    createNumberFormatter$6(0),
    formatPercentage$6,
    formatPercentage$6,
    createNumberFormatter$6(2),
  ];
  const ci = mapColorType$6(value, "int");
  const comps = ci
    .getComponents("hsl")
    .map((comp, index) => formatters[index](comp));
  return `hsla(${comps.join(", ")})`;
}
function colorToObjectRgbString$6(value, type) {
  const formatter = createNumberFormatter$6(type === "float" ? 2 : 0);
  const names = ["r", "g", "b"];
  const cc = mapColorType$6(value, type);
  const comps = removeAlphaComponent$6(cc.getComponents("rgb")).map(
    (comp, index) => `${names[index]}: ${formatter(comp)}`,
  );
  return `{${comps.join(", ")}}`;
}
function createObjectRgbColorFormatter$6(type) {
  return (value) => colorToObjectRgbString$6(value, type);
}
function colorToObjectRgbaString$6(value, type) {
  const aFormatter = createNumberFormatter$6(2);
  const rgbFormatter = createNumberFormatter$6(type === "float" ? 2 : 0);
  const names = ["r", "g", "b", "a"];
  const cc = mapColorType$6(value, type);
  const comps = cc.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return `${names[index]}: ${formatter(comp)}`;
  });
  return `{${comps.join(", ")}}`;
}
function createObjectRgbaColorFormatter$6(type) {
  return (value) => colorToObjectRgbaString$6(value, type);
}
const FORMAT_AND_STRINGIFIERS$6 = [
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbString$6,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbaString$6,
  },
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbString$6,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbaString$6,
  },
  {
    format: {
      alpha: false,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslString$6,
  },
  {
    format: {
      alpha: true,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslaString$6,
  },
  ...["int", "float"].reduce((prev, type) => {
    return [
      ...prev,
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbColorFormatter$6(type),
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbaColorFormatter$6(type),
      },
    ];
  }, []),
];
function findColorStringifier$6(format) {
  return FORMAT_AND_STRINGIFIERS$6.reduce((prev, fas) => {
    if (prev) {
      return prev;
    }
    return equalsStringColorFormat$6(fas.format, format)
      ? fas.stringifier
      : null;
  }, null);
}
const cn$a$6 = ClassName$6("apl");
let APaletteView$6 = class APaletteView {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$a$6());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const barElem = doc.createElement("div");
    barElem.classList.add(cn$a$6("b"));
    this.element.appendChild(barElem);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$a$6("c"));
    barElem.appendChild(colorElem);
    this.colorElem_ = colorElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$a$6("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    const previewElem = doc.createElement("div");
    previewElem.classList.add(cn$a$6("p"));
    this.markerElem_.appendChild(previewElem);
    this.previewElem_ = previewElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const rgbaComps = c.getComponents("rgb");
    const leftColor = new IntColor$6(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 0],
      "rgb",
    );
    const rightColor = new IntColor$6(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 255],
      "rgb",
    );
    const gradientComps = [
      "to right",
      colorToFunctionalRgbaString$6(leftColor),
      colorToFunctionalRgbaString$6(rightColor),
    ];
    this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
    this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString$6(c);
    const left = mapRange$6(rgbaComps[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let APaletteController$6 = class APaletteController {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new APaletteView$6(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$6(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const alpha = d.point.x / d.bounds.width;
    const c = this.value.rawValue;
    const [h, s, v] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$6([h, s, v, alpha], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$6(
      getKeyScaleForColor$6(true),
      getHorizontalStepKeys$6(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$6([h, s, v, a + step], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$6(
      getKeyScaleForColor$6(true),
      getHorizontalStepKeys$6(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$9$6 = ClassName$6("coltxt");
function createModeSelectElement$6(doc) {
  const selectElem = doc.createElement("select");
  const items = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" },
    { text: "HEX", value: "hex" },
  ];
  selectElem.appendChild(
    items.reduce((frag, item) => {
      const optElem = doc.createElement("option");
      optElem.textContent = item.text;
      optElem.value = item.value;
      frag.appendChild(optElem);
      return frag;
    }, doc.createDocumentFragment()),
  );
  return selectElem;
}
let ColorTextsView$6 = class ColorTextsView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$9$6());
    config.viewProps.bindClassModifiers(this.element);
    const modeElem = doc.createElement("div");
    modeElem.classList.add(cn$9$6("m"));
    this.modeElem_ = createModeSelectElement$6(doc);
    this.modeElem_.classList.add(cn$9$6("ms"));
    modeElem.appendChild(this.modeSelectElement);
    config.viewProps.bindDisabled(this.modeElem_);
    const modeMarkerElem = doc.createElement("div");
    modeMarkerElem.classList.add(cn$9$6("mm"));
    modeMarkerElem.appendChild(createSvgIconElement$6(doc, "dropdown"));
    modeElem.appendChild(modeMarkerElem);
    this.element.appendChild(modeElem);
    const inputsElem = doc.createElement("div");
    inputsElem.classList.add(cn$9$6("w"));
    this.element.appendChild(inputsElem);
    this.inputsElem_ = inputsElem;
    this.inputViews_ = config.inputViews;
    this.applyInputViews_();
    bindValue$6(config.mode, (mode) => {
      this.modeElem_.value = mode;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(inputViews) {
    this.inputViews_ = inputViews;
    this.applyInputViews_();
  }
  applyInputViews_() {
    removeChildElements$6(this.inputsElem_);
    const doc = this.element.ownerDocument;
    this.inputViews_.forEach((v) => {
      const compElem = doc.createElement("div");
      compElem.classList.add(cn$9$6("c"));
      compElem.appendChild(v.element);
      this.inputsElem_.appendChild(compElem);
    });
  }
};
function createFormatter$2$6(type) {
  return createNumberFormatter$6(type === "float" ? 2 : 0);
}
function createConstraint$7$2(mode, type, index) {
  const max = getColorMaxComponents$6(mode, type)[index];
  return new DefiniteRangeConstraint$6({
    min: 0,
    max,
  });
}
function createComponentController$6(doc, config, index) {
  return new NumberTextController$6(doc, {
    arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
    parser: config.parser,
    props: ValueMap$6.fromObject({
      formatter: createFormatter$2$6(config.colorType),
      keyScale: getKeyScaleForColor$6(false),
      pointerScale: config.colorType === "float" ? 0.01 : 1,
    }),
    value: createValue$6(0, {
      constraint: createConstraint$7$2(
        config.colorMode,
        config.colorType,
        index,
      ),
    }),
    viewProps: config.viewProps,
  });
}
function createComponentControllers$6(doc, config) {
  const cc = {
    colorMode: config.colorMode,
    colorType: config.colorType,
    parser: parseNumber$6,
    viewProps: config.viewProps,
  };
  return [0, 1, 2].map((i) => {
    const c = createComponentController$6(doc, cc, i);
    connectValues$6({
      primary: config.value,
      secondary: c.value,
      forward(p) {
        const mc = mapColorType$6(p, config.colorType);
        return mc.getComponents(config.colorMode)[i];
      },
      backward(p, s) {
        const pickedMode = config.colorMode;
        const mc = mapColorType$6(p, config.colorType);
        const comps = mc.getComponents(pickedMode);
        comps[i] = s;
        const c2 = createColor$6(
          appendAlphaComponent$6(removeAlphaComponent$6(comps), comps[3]),
          pickedMode,
          config.colorType,
        );
        return mapColorType$6(c2, "int");
      },
    });
    return c;
  });
}
function createHexController$6(doc, config) {
  const c = new TextController$6(doc, {
    parser: createColorStringParser$6("int"),
    props: ValueMap$6.fromObject({
      formatter: colorToHexRgbString$6,
    }),
    value: createValue$6(IntColor$6.black()),
    viewProps: config.viewProps,
  });
  connectValues$6({
    primary: config.value,
    secondary: c.value,
    forward: (p) =>
      new IntColor$6(removeAlphaComponent$6(p.getComponents()), p.mode),
    backward: (p, s) =>
      new IntColor$6(
        appendAlphaComponent$6(
          removeAlphaComponent$6(s.getComponents(p.mode)),
          p.getComponents()[3],
        ),
        p.mode,
      ),
  });
  return [c];
}
function isColorMode$6(mode) {
  return mode !== "hex";
}
let ColorTextsController$6 = class ColorTextsController {
  constructor(doc, config) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
    this.colorType_ = config.colorType;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.colorMode = createValue$6(this.value.rawValue.mode);
    this.ccs_ = this.createComponentControllers_(doc);
    this.view = new ColorTextsView$6(doc, {
      mode: this.colorMode,
      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
      viewProps: this.viewProps,
    });
    this.view.modeSelectElement.addEventListener(
      "change",
      this.onModeSelectChange_,
    );
  }
  createComponentControllers_(doc) {
    const mode = this.colorMode.rawValue;
    if (isColorMode$6(mode)) {
      return createComponentControllers$6(doc, {
        colorMode: mode,
        colorType: this.colorType_,
        value: this.value,
        viewProps: this.viewProps,
      });
    }
    return createHexController$6(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
  onModeSelectChange_(ev) {
    const selectElem = ev.currentTarget;
    this.colorMode.rawValue = selectElem.value;
    this.ccs_ = this.createComponentControllers_(
      this.view.element.ownerDocument,
    );
    this.view.inputViews = this.ccs_.map((cc) => cc.view);
  }
};
const cn$8$6 = ClassName$6("hpl");
let HPaletteView$6 = class HPaletteView {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$8$6());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$8$6("c"));
    this.element.appendChild(colorElem);
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$8$6("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const [h] = c.getComponents("hsv");
    this.markerElem_.style.backgroundColor = colorToFunctionalRgbString$6(
      new IntColor$6([h, 100, 100], "hsv"),
    );
    const left = mapRange$6(h, 0, 360, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let HPaletteController$6 = class HPaletteController {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new HPaletteView$6(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$6(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const hue = mapRange$6(
      constrainRange$6(d.point.x, 0, d.bounds.width),
      0,
      d.bounds.width,
      0,
      360,
    );
    const c = this.value.rawValue;
    const [, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$6([hue, s, v, a], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$6(
      getKeyScaleForColor$6(false),
      getHorizontalStepKeys$6(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$6([h + step, s, v, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$6(
      getKeyScaleForColor$6(false),
      getHorizontalStepKeys$6(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$7$6 = ClassName$6("svp");
const CANVAS_RESOL$6 = 64;
let SvPaletteView$6 = class SvPaletteView {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$7$6());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const canvasElem = doc.createElement("canvas");
    canvasElem.height = CANVAS_RESOL$6;
    canvasElem.width = CANVAS_RESOL$6;
    canvasElem.classList.add(cn$7$6("c"));
    this.element.appendChild(canvasElem);
    this.canvasElement = canvasElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$7$6("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const ctx = getCanvasContext$6(this.canvasElement);
    if (!ctx) {
      return;
    }
    const c = this.value.rawValue;
    const hsvComps = c.getComponents("hsv");
    const width = this.canvasElement.width;
    const height = this.canvasElement.height;
    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;
    for (let iy = 0; iy < height; iy++) {
      for (let ix = 0; ix < width; ix++) {
        const s = mapRange$6(ix, 0, width, 0, 100);
        const v = mapRange$6(iy, 0, height, 100, 0);
        const rgbComps = hsvToRgbInt$6(hsvComps[0], s, v);
        const i = (iy * width + ix) * 4;
        data[i] = rgbComps[0];
        data[i + 1] = rgbComps[1];
        data[i + 2] = rgbComps[2];
        data[i + 3] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    const left = mapRange$6(hsvComps[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${left}%`;
    const top = mapRange$6(hsvComps[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${top}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let SvPaletteController$6 = class SvPaletteController {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SvPaletteView$6(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$6(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const saturation = mapRange$6(d.point.x, 0, d.bounds.width, 0, 100);
    const value = mapRange$6(d.point.y, 0, d.bounds.height, 100, 0);
    const [h, , , a] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(
      new IntColor$6([h, saturation, value, a], "hsv"),
      opts,
    );
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    if (isArrowKey$6(ev.key)) {
      ev.preventDefault();
    }
    const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
    const keyScale = getKeyScaleForColor$6(false);
    const ds = getStepForKey$6(keyScale, getHorizontalStepKeys$6(ev));
    const dv = getStepForKey$6(keyScale, getVerticalStepKeys$6(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(new IntColor$6([h, s + ds, v + dv, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const keyScale = getKeyScaleForColor$6(false);
    const ds = getStepForKey$6(keyScale, getHorizontalStepKeys$6(ev));
    const dv = getStepForKey$6(keyScale, getVerticalStepKeys$6(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let ColorPickerController$6 = class ColorPickerController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.hPaletteC_ = new HPaletteController$6(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.svPaletteC_ = new SvPaletteController$6(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.alphaIcs_ = config.supportsAlpha
      ? {
          palette: new APaletteController$6(doc, {
            value: this.value,
            viewProps: this.viewProps,
          }),
          text: new NumberTextController$6(doc, {
            parser: parseNumber$6,
            props: ValueMap$6.fromObject({
              pointerScale: 0.01,
              keyScale: 0.1,
              formatter: createNumberFormatter$6(2),
            }),
            value: createValue$6(0, {
              constraint: new DefiniteRangeConstraint$6({ min: 0, max: 1 }),
            }),
            viewProps: this.viewProps,
          }),
        }
      : null;
    if (this.alphaIcs_) {
      connectValues$6({
        primary: this.value,
        secondary: this.alphaIcs_.text.value,
        forward: (p) => p.getComponents()[3],
        backward: (p, s) => {
          const comps = p.getComponents();
          comps[3] = s;
          return new IntColor$6(comps, p.mode);
        },
      });
    }
    this.textsC_ = new ColorTextsController$6(doc, {
      colorType: config.colorType,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorPickerView$6(doc, {
      alphaViews: this.alphaIcs_
        ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view,
          }
        : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: config.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textsView: this.textsC_.view,
      viewProps: this.viewProps,
    });
  }
  get textsController() {
    return this.textsC_;
  }
};
const cn$6$6 = ClassName$6("colsw");
let ColorSwatchView$6 = class ColorSwatchView {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$6$6());
    config.viewProps.bindClassModifiers(this.element);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$6$6("sw"));
    this.element.appendChild(swatchElem);
    this.swatchElem_ = swatchElem;
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$6$6("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    this.update_();
  }
  update_() {
    const value = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = colorToHexRgbaString$6(value);
  }
  onValueChange_() {
    this.update_();
  }
};
let ColorSwatchController$6 = class ColorSwatchController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ColorSwatchView$6(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
let ColorController$6 = class ColorController {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$6.create(config.expanded);
    this.swatchC_ = new ColorSwatchController$6(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    const buttonElem = this.swatchC_.view.buttonElement;
    buttonElem.addEventListener("blur", this.onButtonBlur_);
    buttonElem.addEventListener("click", this.onButtonClick_);
    this.textC_ = new TextController$6(doc, {
      parser: config.parser,
      props: ValueMap$6.fromObject({
        formatter: config.formatter,
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorView$6(doc, {
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout,
    });
    this.view.swatchElement.appendChild(this.swatchC_.view.element);
    this.view.textElement.appendChild(this.textC_.view.element);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$6(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const pickerC = new ColorPickerController$6(doc, {
      colorType: config.colorType,
      supportsAlpha: config.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps,
    });
    pickerC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = pickerC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(pickerC.view.element);
      connectValues$6({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$6(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$6(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$6(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.swatchC_.view.buttonElement &&
      !supportsTouch$6(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.swatchC_.view.buttonElement.focus();
      }
    }
  }
};
function colorToRgbNumber$6(value) {
  return removeAlphaComponent$6(value.getComponents("rgb")).reduce(
    (result, comp) => {
      return (result << 8) | (Math.floor(comp) & 255);
    },
    0,
  );
}
function colorToRgbaNumber$6(value) {
  return (
    value.getComponents("rgb").reduce((result, comp, index) => {
      const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
      return (result << 8) | hex;
    }, 0) >>> 0
  );
}
function numberToRgbColor$6(num) {
  return new IntColor$6(
    [(num >> 16) & 255, (num >> 8) & 255, num & 255],
    "rgb",
  );
}
function numberToRgbaColor$6(num) {
  return new IntColor$6(
    [
      (num >> 24) & 255,
      (num >> 16) & 255,
      (num >> 8) & 255,
      mapRange$6(num & 255, 0, 255, 0, 1),
    ],
    "rgb",
  );
}
function colorFromRgbNumber$6(value) {
  if (typeof value !== "number") {
    return IntColor$6.black();
  }
  return numberToRgbColor$6(value);
}
function colorFromRgbaNumber$6(value) {
  if (typeof value !== "number") {
    return IntColor$6.black();
  }
  return numberToRgbaColor$6(value);
}
function isRgbColorComponent$6(obj, key2) {
  if (typeof obj !== "object" || isEmpty$6(obj)) {
    return false;
  }
  return key2 in obj && typeof obj[key2] === "number";
}
function isRgbColorObject$6(obj) {
  return (
    isRgbColorComponent$6(obj, "r") &&
    isRgbColorComponent$6(obj, "g") &&
    isRgbColorComponent$6(obj, "b")
  );
}
function isRgbaColorObject$6(obj) {
  return isRgbColorObject$6(obj) && isRgbColorComponent$6(obj, "a");
}
function isColorObject$6(obj) {
  return isRgbColorObject$6(obj);
}
function equalsColor$6(v1, v2) {
  if (v1.mode !== v2.mode) {
    return false;
  }
  if (v1.type !== v2.type) {
    return false;
  }
  const comps1 = v1.getComponents();
  const comps2 = v2.getComponents();
  for (let i = 0; i < comps1.length; i++) {
    if (comps1[i] !== comps2[i]) {
      return false;
    }
  }
  return true;
}
function createColorComponentsFromRgbObject$6(obj) {
  return "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
}
function createColorStringWriter$6(format) {
  const stringify = findColorStringifier$6(format);
  return stringify
    ? (target, value) => {
        writePrimitive$6(target, stringify(value));
      }
    : null;
}
function createColorNumberWriter$6(supportsAlpha) {
  const colorToNumber = supportsAlpha
    ? colorToRgbaNumber$6
    : colorToRgbNumber$6;
  return (target, value) => {
    writePrimitive$6(target, colorToNumber(value));
  };
}
function writeRgbaColorObject$6(target, value, type) {
  const cc = mapColorType$6(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
  target.writeProperty("a", obj.a);
}
function writeRgbColorObject$6(target, value, type) {
  const cc = mapColorType$6(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
}
function createColorObjectWriter$6(supportsAlpha, type) {
  return (target, inValue) => {
    if (supportsAlpha) {
      writeRgbaColorObject$6(target, inValue, type);
    } else {
      writeRgbColorObject$6(target, inValue, type);
    }
  };
}
function shouldSupportAlpha$1$6(inputParams) {
  var _a;
  if (
    (_a =
      inputParams === null || inputParams === void 0
        ? void 0
        : inputParams.color) === null || _a === void 0
      ? void 0
      : _a.alpha
  ) {
    return true;
  }
  return false;
}
function createFormatter$1$6(supportsAlpha) {
  return supportsAlpha
    ? (v) => colorToHexRgbaString$6(v, "0x")
    : (v) => colorToHexRgbString$6(v, "0x");
}
function isForColor$6(params) {
  if ("color" in params) {
    return true;
  }
  if (params.view === "color") {
    return true;
  }
  return false;
}
createPlugin$6({
  id: "input-color-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    if (!isForColor$6(params)) {
      return null;
    }
    const result = parseColorInputParams$6(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            supportsAlpha: shouldSupportAlpha$1$6(params),
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => {
      return args.params.supportsAlpha
        ? colorFromRgbaNumber$6
        : colorFromRgbNumber$6;
    },
    equals: equalsColor$6,
    writer: (args) => {
      return createColorNumberWriter$6(args.params.supportsAlpha);
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$6(args.document, {
      colorType: "int",
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createFormatter$1$6(args.params.supportsAlpha),
      parser: createColorStringParser$6("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
function colorFromObject$6(value, type) {
  if (!isColorObject$6(value)) {
    return mapColorType$6(IntColor$6.black(), type);
  }
  if (type === "int") {
    const comps = createColorComponentsFromRgbObject$6(value);
    return new IntColor$6(comps, "rgb");
  }
  if (type === "float") {
    const comps = createColorComponentsFromRgbObject$6(value);
    return new FloatColor$6(comps, "rgb");
  }
  return mapColorType$6(IntColor$6.black(), "int");
}
function shouldSupportAlpha$7(initialValue) {
  return isRgbaColorObject$6(initialValue);
}
function createColorObjectBindingReader$6(type) {
  return (value) => {
    const c = colorFromObject$6(value, type);
    return mapColorType$6(c, "int");
  };
}
function createColorObjectFormatter$6(supportsAlpha, type) {
  return (value) => {
    if (supportsAlpha) {
      return colorToObjectRgbaString$6(value, type);
    }
    return colorToObjectRgbString$6(value, type);
  };
}
createPlugin$6({
  id: "input-color-object",
  type: "input",
  accept: (value, params) => {
    var _a;
    if (!isColorObject$6(value)) {
      return null;
    }
    const result = parseColorInputParams$6(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            colorType:
              (_a = extractColorType$6(params)) !== null && _a !== void 0
                ? _a
                : "int",
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => createColorObjectBindingReader$6(args.params.colorType),
    equals: equalsColor$6,
    writer: (args) =>
      createColorObjectWriter$6(
        shouldSupportAlpha$7(args.initialValue),
        args.params.colorType,
      ),
  },
  controller: (args) => {
    var _a, _b;
    const supportsAlpha = isRgbaColorObject$6(args.initialValue);
    return new ColorController$6(args.document, {
      colorType: args.params.colorType,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createColorObjectFormatter$6(
        supportsAlpha,
        args.params.colorType,
      ),
      parser: createColorStringParser$6("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
createPlugin$6({
  id: "input-color-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    if (params.view === "text") {
      return null;
    }
    const format = detectStringColorFormat$6(value, extractColorType$6(params));
    if (!format) {
      return null;
    }
    const stringifier = findColorStringifier$6(format);
    if (!stringifier) {
      return null;
    }
    const result = parseColorInputParams$6(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            format,
            stringifier,
          }),
        }
      : null;
  },
  binding: {
    reader: () => readIntColorString$6,
    equals: equalsColor$6,
    writer: (args) => {
      const writer = createColorStringWriter$6(args.params.format);
      if (!writer) {
        throw TpError$6.notBindable();
      }
      return writer;
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$6(args.document, {
      colorType: args.params.format.type,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: args.params.stringifier,
      parser: createColorStringParser$6("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.format.alpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let PointNdConstraint$6 = class PointNdConstraint {
  constructor(config) {
    this.components = config.components;
    this.asm_ = config.assembly;
  }
  constrain(value) {
    const comps = this.asm_.toComponents(value).map((comp, index) => {
      var _a, _b;
      return (_b =
        (_a = this.components[index]) === null || _a === void 0
          ? void 0
          : _a.constrain(comp)) !== null && _b !== void 0
        ? _b
        : comp;
    });
    return this.asm_.fromComponents(comps);
  }
};
const cn$5$6 = ClassName$6("pndtxt");
let PointNdTextView$6 = class PointNdTextView {
  constructor(doc, config) {
    this.textViews = config.textViews;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$5$6());
    this.textViews.forEach((v) => {
      const axisElem = doc.createElement("div");
      axisElem.classList.add(cn$5$6("a"));
      axisElem.appendChild(v.element);
      this.element.appendChild(axisElem);
    });
  }
};
function createAxisController$6(doc, config, index) {
  return new NumberTextController$6(doc, {
    arrayPosition:
      index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
    parser: config.parser,
    props: config.axes[index].textProps,
    value: createValue$6(0, {
      constraint: config.axes[index].constraint,
    }),
    viewProps: config.viewProps,
  });
}
let PointNdTextController$6 = class PointNdTextController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.acs_ = config.axes.map((_, index) =>
      createAxisController$6(doc, config, index),
    );
    this.acs_.forEach((c, index) => {
      connectValues$6({
        primary: this.value,
        secondary: c.value,
        forward: (p) => config.assembly.toComponents(p)[index],
        backward: (p, s) => {
          const comps = config.assembly.toComponents(p);
          comps[index] = s;
          return config.assembly.fromComponents(comps);
        },
      });
    });
    this.view = new PointNdTextView$6(doc, {
      textViews: this.acs_.map((ac) => ac.view),
    });
  }
  get textControllers() {
    return this.acs_;
  }
};
let SliderInputBindingApi$6 = class SliderInputBindingApi extends BindingApi$6 {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.sliderController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(max) {
    this.controller.valueController.sliderController.props.set("min", max);
  }
};
function createConstraint$6$6(params, initialValue) {
  const constraints = [];
  const sc = createStepConstraint$6(params, initialValue);
  if (sc) {
    constraints.push(sc);
  }
  const rc = createRangeConstraint$6(params);
  if (rc) {
    constraints.push(rc);
  }
  const lc = createListConstraint$6(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$6(constraints);
}
createPlugin$6({
  id: "input-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$6(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser$6(p)), {
        options: p.optional.custom(parseListOptions$6),
        readonly: p.optional.constant(false),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown$6,
    constraint: (args) => createConstraint$6$6(args.params, args.initialValue),
    writer: (_args) => writePrimitive$6,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$6(c, ListConstraint$6);
    if (lc) {
      return new ListController$6(args.document, {
        props: new ValueMap$6({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    const textPropsObj = createNumberTextPropsObject$6(
      args.params,
      value.rawValue,
    );
    const drc = c && findConstraint$6(c, DefiniteRangeConstraint$6);
    if (drc) {
      return new SliderTextController$6(
        args.document,
        Object.assign(
          Object.assign(
            {},
            createSliderTextProps$6(
              Object.assign(Object.assign({}, textPropsObj), {
                keyScale: createValue$6(textPropsObj.keyScale),
                max: drc.values.value("max"),
                min: drc.values.value("min"),
              }),
            ),
          ),
          { parser: parseNumber$6, value, viewProps: args.viewProps },
        ),
      );
    }
    return new NumberTextController$6(args.document, {
      parser: parseNumber$6,
      props: ValueMap$6.fromObject(textPropsObj),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "number") {
      return null;
    }
    if (args.controller.valueController instanceof SliderTextController$6) {
      return new SliderInputBindingApi$6(args.controller);
    }
    if (args.controller.valueController instanceof ListController$6) {
      return new ListInputBindingApi$6(args.controller);
    }
    return null;
  },
});
let Point2d$6 = class Point2d {
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(obj) {
    if (isEmpty$6(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    if (typeof x !== "number" || typeof y2 !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
    };
  }
};
const Point2dAssembly$6 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point2d$6(...comps),
};
const cn$4$6 = ClassName$6("p2d");
let Point2dView$6 = class Point2dView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$4$6());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$6(
      config.expanded,
      valueToClassName$6(this.element, cn$4$6(void 0, "expanded")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$4$6("h"));
    this.element.appendChild(headElem);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$4$6("b"));
    buttonElem.appendChild(createSvgIconElement$6(doc, "p2dpad"));
    config.viewProps.bindDisabled(buttonElem);
    headElem.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$4$6("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$4$6("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
const cn$3$6 = ClassName$6("p2dp");
let Point2dPickerView$6 = class Point2dPickerView {
  constructor(doc, config) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this);
    this.onPropsChange_ = this.onPropsChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onPropsChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$3$6());
    if (config.layout === "popup") {
      this.element.classList.add(cn$3$6(void 0, "p"));
    }
    config.viewProps.bindClassModifiers(this.element);
    const padElem = doc.createElement("div");
    padElem.classList.add(cn$3$6("p"));
    config.viewProps.bindTabIndex(padElem);
    this.element.appendChild(padElem);
    this.padElement = padElem;
    const svgElem = doc.createElementNS(SVG_NS$6, "svg");
    svgElem.classList.add(cn$3$6("g"));
    this.padElement.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const xAxisElem = doc.createElementNS(SVG_NS$6, "line");
    xAxisElem.classList.add(cn$3$6("ax"));
    xAxisElem.setAttributeNS(null, "x1", "0");
    xAxisElem.setAttributeNS(null, "y1", "50%");
    xAxisElem.setAttributeNS(null, "x2", "100%");
    xAxisElem.setAttributeNS(null, "y2", "50%");
    this.svgElem_.appendChild(xAxisElem);
    const yAxisElem = doc.createElementNS(SVG_NS$6, "line");
    yAxisElem.classList.add(cn$3$6("ax"));
    yAxisElem.setAttributeNS(null, "x1", "50%");
    yAxisElem.setAttributeNS(null, "y1", "0");
    yAxisElem.setAttributeNS(null, "x2", "50%");
    yAxisElem.setAttributeNS(null, "y2", "100%");
    this.svgElem_.appendChild(yAxisElem);
    const lineElem = doc.createElementNS(SVG_NS$6, "line");
    lineElem.classList.add(cn$3$6("l"));
    lineElem.setAttributeNS(null, "x1", "50%");
    lineElem.setAttributeNS(null, "y1", "50%");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$3$6("m"));
    this.padElement.appendChild(markerElem);
    this.markerElem_ = markerElem;
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [x, y2] = this.value.rawValue.getComponents();
    const max = this.props_.get("max");
    const px2 = mapRange$6(x, -max, +max, 0, 100);
    const py2 = mapRange$6(y2, -max, +max, 0, 100);
    const ipy = this.props_.get("invertsY") ? 100 - py2 : py2;
    this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
    this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
    this.markerElem_.style.left = `${px2}%`;
    this.markerElem_.style.top = `${ipy}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
};
function computeOffset$7(ev, keyScales, invertsY) {
  return [
    getStepForKey$6(keyScales[0], getHorizontalStepKeys$6(ev)),
    getStepForKey$6(keyScales[1], getVerticalStepKeys$6(ev)) *
      (invertsY ? 1 : -1),
  ];
}
let Point2dPickerController$6 = class Point2dPickerController {
  constructor(doc, config) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new Point2dPickerView$6(doc, {
      layout: config.layout,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$6(this.view.padElement);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
    this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const max = this.props.get("max");
    const px2 = mapRange$6(d.point.x, 0, d.bounds.width, -max, +max);
    const py2 = mapRange$6(
      this.props.get("invertsY") ? d.bounds.height - d.point.y : d.point.y,
      0,
      d.bounds.height,
      -max,
      +max,
    );
    this.value.setRawValue(new Point2d$6(px2, py2), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onPadKeyDown_(ev) {
    if (isArrowKey$6(ev.key)) {
      ev.preventDefault();
    }
    const [dx, dy] = computeOffset$7(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(
      new Point2d$6(this.value.rawValue.x + dx, this.value.rawValue.y + dy),
      {
        forceEmit: false,
        last: false,
      },
    );
  }
  onPadKeyUp_(ev) {
    const [dx, dy] = computeOffset$7(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let Point2dController$6 = class Point2dController {
  constructor(doc, config) {
    var _a, _b;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$6.create(config.expanded);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$6(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const padC = new Point2dPickerController$6(doc, {
      layout: config.pickerLayout,
      props: new ValueMap$6({
        invertsY: createValue$6(config.invertsY),
        max: createValue$6(config.max),
        xKeyScale: config.axes[0].textProps.value("keyScale"),
        yKeyScale: config.axes[1].textProps.value("keyScale"),
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    padC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = padC;
    this.textC_ = new PointNdTextController$6(doc, {
      assembly: Point2dAssembly$6,
      axes: config.axes,
      parser: config.parser,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new Point2dView$6(doc, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: config.pickerLayout,
      viewProps: this.viewProps,
    });
    this.view.textElement.appendChild(this.textC_.view.element);
    (_a = this.view.buttonElement) === null || _a === void 0
      ? void 0
      : _a.addEventListener("blur", this.onPadButtonBlur_);
    (_b = this.view.buttonElement) === null || _b === void 0
      ? void 0
      : _b.addEventListener("click", this.onPadButtonClick_);
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(this.pickerC_.view.element);
      connectValues$6({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$6(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$6(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$6(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.view.buttonElement &&
      !supportsTouch$6(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.view.buttonElement.focus();
      }
    }
  }
};
function point2dFromUnknown$6(value) {
  return Point2d$6.isObject(value)
    ? new Point2d$6(value.x, value.y)
    : new Point2d$6();
}
function writePoint2d$6(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
}
function createConstraint$5$6(params, initialValue) {
  return new PointNdConstraint$6({
    assembly: Point2dAssembly$6,
    components: [
      createDimensionConstraint$6(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$6(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
    ],
  });
}
function getSuitableMaxDimensionValue$6(params, rawValue) {
  var _a, _b;
  if (!isEmpty$6(params.min) || !isEmpty$6(params.max)) {
    return Math.max(
      Math.abs((_a = params.min) !== null && _a !== void 0 ? _a : 0),
      Math.abs((_b = params.max) !== null && _b !== void 0 ? _b : 0),
    );
  }
  const step = getSuitableKeyScale$6(params);
  return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
}
function getSuitableMax$6(params, initialValue) {
  var _a, _b;
  const xr = getSuitableMaxDimensionValue$6(
    deepMerge$6(params, (_a = params.x) !== null && _a !== void 0 ? _a : {}),
    initialValue.x,
  );
  const yr = getSuitableMaxDimensionValue$6(
    deepMerge$6(params, (_b = params.y) !== null && _b !== void 0 ? _b : {}),
    initialValue.y,
  );
  return Math.max(xr, yr);
}
function shouldInvertY$6(params) {
  if (!("y" in params)) {
    return false;
  }
  const yParams = params.y;
  if (!yParams) {
    return false;
  }
  return "inverted" in yParams ? !!yParams.inverted : false;
}
createPlugin$6({
  id: "input-point2d",
  type: "input",
  accept: (value, params) => {
    if (!Point2d$6.isObject(value)) {
      return null;
    }
    const result = parseRecord$6(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$6(p)), {
        expanded: p.optional.boolean,
        picker: p.optional.custom(parsePickerLayout$6),
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$6),
        y: p.optional.object(
          Object.assign(Object.assign({}, createPointDimensionParser$6(p)), {
            inverted: p.optional.boolean,
          }),
        ),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: () => point2dFromUnknown$6,
    constraint: (args) => createConstraint$5$6(args.params, args.initialValue),
    equals: Point2d$6.equals,
    writer: () => writePoint2d$6,
  },
  controller: (args) => {
    var _a, _b;
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y];
    return new Point2dController$6(doc, {
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a2;
        return createPointAxis$6({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$6(
            args.params,
            (_a2 = dParams[i]) !== null && _a2 !== void 0 ? _a2 : {},
          ),
        });
      }),
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      invertsY: shouldInvertY$6(args.params),
      max: getSuitableMax$6(args.params, value.rawValue),
      parser: parseNumber$6,
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point3d$6 = class Point3d {
  constructor(x = 0, y2 = 0, z = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(obj) {
    if (isEmpty$6(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
    };
  }
};
const Point3dAssembly$6 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point3d$6(...comps),
};
function point3dFromUnknown$6(value) {
  return Point3d$6.isObject(value)
    ? new Point3d$6(value.x, value.y, value.z)
    : new Point3d$6();
}
function writePoint3d$6(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
}
function createConstraint$4$6(params, initialValue) {
  return new PointNdConstraint$6({
    assembly: Point3dAssembly$6,
    components: [
      createDimensionConstraint$6(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$6(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$6(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
    ],
  });
}
createPlugin$6({
  id: "input-point3d",
  type: "input",
  accept: (value, params) => {
    if (!Point3d$6.isObject(value)) {
      return null;
    }
    const result = parseRecord$6(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$6(p)), {
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$6),
        y: p.optional.custom(parsePointDimensionParams$6),
        z: p.optional.custom(parsePointDimensionParams$6),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point3dFromUnknown$6,
    constraint: (args) => createConstraint$4$6(args.params, args.initialValue),
    equals: Point3d$6.equals,
    writer: (_args) => writePoint3d$6,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y, args.params.z];
    return new PointNdTextController$6(args.document, {
      assembly: Point3dAssembly$6,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$6({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$6(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$6,
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point4d$6 = class Point4d {
  constructor(x = 0, y2 = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
    this.w = w;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(obj) {
    if (isEmpty$6(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    const w = obj.w;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number" ||
      typeof w !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w,
    };
  }
};
const Point4dAssembly$6 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point4d$6(...comps),
};
function point4dFromUnknown$6(value) {
  return Point4d$6.isObject(value)
    ? new Point4d$6(value.x, value.y, value.z, value.w)
    : new Point4d$6();
}
function writePoint4d$6(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
  target.writeProperty("w", value.w);
}
function createConstraint$3$6(params, initialValue) {
  return new PointNdConstraint$6({
    assembly: Point4dAssembly$6,
    components: [
      createDimensionConstraint$6(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$6(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$6(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
      createDimensionConstraint$6(
        Object.assign(Object.assign({}, params), params.w),
        initialValue.w,
      ),
    ],
  });
}
createPlugin$6({
  id: "input-point4d",
  type: "input",
  accept: (value, params) => {
    if (!Point4d$6.isObject(value)) {
      return null;
    }
    const result = parseRecord$6(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$6(p)), {
        readonly: p.optional.constant(false),
        w: p.optional.custom(parsePointDimensionParams$6),
        x: p.optional.custom(parsePointDimensionParams$6),
        y: p.optional.custom(parsePointDimensionParams$6),
        z: p.optional.custom(parsePointDimensionParams$6),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point4dFromUnknown$6,
    constraint: (args) => createConstraint$3$6(args.params, args.initialValue),
    equals: Point4d$6.equals,
    writer: (_args) => writePoint4d$6,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [
      args.params.x,
      args.params.y,
      args.params.z,
      args.params.w,
    ];
    return new PointNdTextController$6(args.document, {
      assembly: Point4dAssembly$6,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$6({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$6(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$6,
      value,
      viewProps: args.viewProps,
    });
  },
});
function createConstraint$2$6(params) {
  const constraints = [];
  const lc = createListConstraint$6(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$6(constraints);
}
createPlugin$6({
  id: "input-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$6(params, (p) => ({
      readonly: p.optional.constant(false),
      options: p.optional.custom(parseListOptions$6),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$6,
    constraint: (args) => createConstraint$2$6(args.params),
    writer: (_args) => writePrimitive$6,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$6(c, ListConstraint$6);
    if (lc) {
      return new ListController$6(doc, {
        props: new ValueMap$6({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new TextController$6(doc, {
      parser: (v) => v,
      props: ValueMap$6.fromObject({
        formatter: formatString$6,
      }),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "string") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$6) {
      return new ListInputBindingApi$6(args.controller);
    }
    return null;
  },
});
const Constants$6 = {
  monitor: {
    defaultInterval: 200,
    defaultRows: 3,
  },
};
const cn$2$6 = ClassName$6("mll");
let MultiLogView$6 = class MultiLogView {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$2$6());
    config.viewProps.bindClassModifiers(this.element);
    const textareaElem = doc.createElement("textarea");
    textareaElem.classList.add(cn$2$6("i"));
    textareaElem.style.height = `calc(var(${getCssVar$6("containerUnitSize")}) * ${config.rows})`;
    textareaElem.readOnly = true;
    config.viewProps.bindDisabled(textareaElem);
    this.element.appendChild(textareaElem);
    this.textareaElem_ = textareaElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const elem = this.textareaElem_;
    const shouldScroll =
      elem.scrollTop === elem.scrollHeight - elem.clientHeight;
    const lines = [];
    this.value.rawValue.forEach((value) => {
      if (value !== void 0) {
        lines.push(this.formatter_(value));
      }
    });
    elem.textContent = lines.join("\n");
    if (shouldScroll) {
      elem.scrollTop = elem.scrollHeight;
    }
  }
  onValueUpdate_() {
    this.update_();
  }
};
let MultiLogController$6 = class MultiLogController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new MultiLogView$6(doc, {
      formatter: config.formatter,
      rows: config.rows,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
const cn$1$6 = ClassName$6("sgl");
let SingleLogView$6 = class SingleLogView {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$1$6());
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$1$6("i"));
    inputElem.readOnly = true;
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const values = this.value.rawValue;
    const lastValue = values[values.length - 1];
    this.inputElement.value =
      lastValue !== void 0 ? this.formatter_(lastValue) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
};
let SingleLogController$6 = class SingleLogController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SingleLogView$6(doc, {
      formatter: config.formatter,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
createPlugin$6({
  id: "monitor-bool",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$6(params, (p) => ({
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$6,
  },
  controller: (args) => {
    var _a;
    if (args.value.rawValue.length === 1) {
      return new SingleLogController$6(args.document, {
        formatter: BooleanFormatter$6,
        value: args.value,
        viewProps: args.viewProps,
      });
    }
    return new MultiLogController$6(args.document, {
      formatter: BooleanFormatter$6,
      rows:
        (_a = args.params.rows) !== null && _a !== void 0
          ? _a
          : Constants$6.monitor.defaultRows,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let GraphLogMonitorBindingApi$6 = class GraphLogMonitorBindingApi extends BindingApi$6 {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.props.set("min", min);
  }
};
const cn$w = ClassName$6("grl");
let GraphLogView$6 = class GraphLogView {
  constructor(doc, config) {
    this.onCursorChange_ = this.onCursorChange_.bind(this);
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$w());
    config.viewProps.bindClassModifiers(this.element);
    this.formatter_ = config.formatter;
    this.props_ = config.props;
    this.cursor_ = config.cursor;
    this.cursor_.emitter.on("change", this.onCursorChange_);
    const svgElem = doc.createElementNS(SVG_NS$6, "svg");
    svgElem.classList.add(cn$w("g"));
    svgElem.style.height = `calc(var(${getCssVar$6("containerUnitSize")}) * ${config.rows})`;
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const lineElem = doc.createElementNS(SVG_NS$6, "polyline");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(cn$w("t"), ClassName$6("tt")());
    this.element.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const bounds = this.svgElem_.getBoundingClientRect();
    const maxIndex = this.value.rawValue.length - 1;
    const min = this.props_.get("min");
    const max = this.props_.get("max");
    const points = [];
    this.value.rawValue.forEach((v, index) => {
      if (v === void 0) {
        return;
      }
      const x = mapRange$6(index, 0, maxIndex, 0, bounds.width);
      const y2 = mapRange$6(v, min, max, bounds.height, 0);
      points.push([x, y2].join(","));
    });
    this.lineElem_.setAttributeNS(null, "points", points.join(" "));
    const tooltipElem = this.tooltipElem_;
    const value = this.value.rawValue[this.cursor_.rawValue];
    if (value === void 0) {
      tooltipElem.classList.remove(cn$w("t", "a"));
      return;
    }
    const tx = mapRange$6(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
    const ty = mapRange$6(value, min, max, bounds.height, 0);
    tooltipElem.style.left = `${tx}px`;
    tooltipElem.style.top = `${ty}px`;
    tooltipElem.textContent = `${this.formatter_(value)}`;
    if (!tooltipElem.classList.contains(cn$w("t", "a"))) {
      tooltipElem.classList.add(cn$w("t", "a"), cn$w("t", "in"));
      forceReflow$6(tooltipElem);
      tooltipElem.classList.remove(cn$w("t", "in"));
    }
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
};
let GraphLogController$6 = class GraphLogController {
  constructor(doc, config) {
    this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.cursor_ = createValue$6(-1);
    this.view = new GraphLogView$6(doc, {
      cursor: this.cursor_,
      formatter: config.formatter,
      rows: config.rows,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    if (!supportsTouch$6(doc)) {
      this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
      this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    } else {
      const ph = new PointerHandler$6(this.view.element);
      ph.emitter.on("down", this.onGraphPointerDown_);
      ph.emitter.on("move", this.onGraphPointerMove_);
      ph.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(state) {
    return importBladeState$6(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        this.props.set("max", result.max);
        this.props.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$6(null, {
      max: this.props.get("max"),
      min: this.props.get("min"),
    });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(ev) {
    const bounds = this.view.element.getBoundingClientRect();
    this.cursor_.rawValue = Math.floor(
      mapRange$6(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length),
    );
  }
  onGraphPointerDown_(ev) {
    this.onGraphPointerMove_(ev);
  }
  onGraphPointerMove_(ev) {
    if (!ev.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(
      mapRange$6(
        ev.data.point.x,
        0,
        ev.data.bounds.width,
        0,
        this.value.rawValue.length,
      ),
    );
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
};
function createFormatter$8(params) {
  return !isEmpty$6(params.format) ? params.format : createNumberFormatter$6(2);
}
function createTextMonitor$6(args) {
  var _a;
  if (args.value.rawValue.length === 1) {
    return new SingleLogController$6(args.document, {
      formatter: createFormatter$8(args.params),
      value: args.value,
      viewProps: args.viewProps,
    });
  }
  return new MultiLogController$6(args.document, {
    formatter: createFormatter$8(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$6.monitor.defaultRows,
    value: args.value,
    viewProps: args.viewProps,
  });
}
function createGraphMonitor$6(args) {
  var _a, _b, _c;
  return new GraphLogController$6(args.document, {
    formatter: createFormatter$8(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$6.monitor.defaultRows,
    props: ValueMap$6.fromObject({
      max: (_b = args.params.max) !== null && _b !== void 0 ? _b : 100,
      min: (_c = args.params.min) !== null && _c !== void 0 ? _c : 0,
    }),
    value: args.value,
    viewProps: args.viewProps,
  });
}
function shouldShowGraph$6(params) {
  return params.view === "graph";
}
createPlugin$6({
  id: "monitor-number",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$6(params, (p) => ({
      format: p.optional.function,
      max: p.optional.number,
      min: p.optional.number,
      readonly: p.required.constant(true),
      rows: p.optional.number,
      view: p.optional.string,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    defaultBufferSize: (params) => (shouldShowGraph$6(params) ? 64 : 1),
    reader: (_args) => numberFromUnknown$6,
  },
  controller: (args) => {
    if (shouldShowGraph$6(args.params)) {
      return createGraphMonitor$6(args);
    }
    return createTextMonitor$6(args);
  },
  api: (args) => {
    if (args.controller.valueController instanceof GraphLogController$6) {
      return new GraphLogMonitorBindingApi$6(args.controller);
    }
    return null;
  },
});
createPlugin$6({
  id: "monitor-string",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$6(params, (p) => ({
      multiline: p.optional.boolean,
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$6,
  },
  controller: (args) => {
    var _a;
    const value = args.value;
    const multiline = value.rawValue.length > 1 || args.params.multiline;
    if (multiline) {
      return new MultiLogController$6(args.document, {
        formatter: formatString$6,
        rows:
          (_a = args.params.rows) !== null && _a !== void 0
            ? _a
            : Constants$6.monitor.defaultRows,
        value,
        viewProps: args.viewProps,
      });
    }
    return new SingleLogController$6(args.document, {
      formatter: formatString$6,
      value,
      viewProps: args.viewProps,
    });
  },
});
class ButtonCellApi {
  constructor(controller) {
    this.controller_ = controller;
  }
  get disabled() {
    return this.controller_.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller_.viewProps.set("disabled", disabled);
  }
  get title() {
    var _a;
    return (_a = this.controller_.props.get("title")) !== null && _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller_.props.set("title", title);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller_.emitter;
    emitter.on(eventName, () => {
      bh(new TpEvent$6(this));
    });
    return this;
  }
}
class TpButtonGridEvent extends TpEvent$6 {
  constructor(target, cell, index) {
    super(target);
    this.cell = cell;
    this.index = index;
  }
}
class ButtonGridApi extends BladeApi$6 {
  constructor(controller) {
    super(controller);
    this.cellToApiMap_ = /* @__PURE__ */ new Map();
    this.emitter_ = new Emitter$6();
    const gc = this.controller.valueController;
    gc.cellControllers.forEach((cc, i) => {
      const api = new ButtonCellApi(cc);
      this.cellToApiMap_.set(cc, api);
      cc.emitter.on("click", () => {
        const x = i % gc.size[0];
        const y2 = Math.floor(i / gc.size[0]);
        this.emitter_.emit("click", {
          event: new TpButtonGridEvent(this, api, [x, y2]),
        });
      });
    });
  }
  cell(x, y2) {
    const gc = this.controller.valueController;
    const cc = gc.cellControllers[y2 * gc.size[0] + x];
    return this.cellToApiMap_.get(cc);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev.event);
    });
    return this;
  }
}
class ButtonGridController {
  constructor(doc, config) {
    this.size = config.size;
    const [w, h] = this.size;
    const bcs = [];
    for (let y2 = 0; y2 < h; y2++) {
      for (let x = 0; x < w; x++) {
        const bc = new ButtonController$6(doc, {
          props: ValueMap$6.fromObject(
            Object.assign({}, config.cellConfig(x, y2)),
          ),
          viewProps: ViewProps$6.create(),
        });
        bcs.push(bc);
      }
    }
    this.cellCs_ = bcs;
    this.viewProps = ViewProps$6.create();
    this.viewProps.handleDispose(() => {
      this.cellCs_.forEach((c) => {
        c.viewProps.set("disposed", true);
      });
    });
    this.view = new PlainView(doc, {
      viewProps: this.viewProps,
      viewName: "btngrid",
    });
    this.view.element.style.gridTemplateColumns = `repeat(${w}, 1fr)`;
    this.cellCs_.forEach((bc) => {
      this.view.element.appendChild(bc.view.element);
    });
  }
  get cellControllers() {
    return this.cellCs_;
  }
}
class ButtonGridBladeController extends BladeController$6 {
  constructor(doc, config) {
    const bc = config.valueController;
    const lc = new LabelController$6(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: bc.viewProps,
    });
    this.valueController = bc;
    this.labelController = lc;
  }
}
createPlugin$6({
  id: "buttongrid",
  type: "blade",
  accept(params) {
    const result = parseRecord$6(params, (p) => ({
      cells: p.required.function,
      size: p.required.array(p.required.number),
      view: p.required.constant("buttongrid"),
      label: p.optional.string,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new ButtonGridBladeController(args.document, {
      blade: args.blade,
      labelProps: ValueMap$6.fromObject({
        label: args.params.label,
      }),
      valueController: new ButtonGridController(args.document, {
        cellConfig: args.params.cells,
        size: args.params.size,
      }),
    });
  },
  api(args) {
    if (args.controller instanceof ButtonGridBladeController) {
      return new ButtonGridApi(args.controller);
    }
    return null;
  },
});
class CubicBezierApi extends BladeApi$6 {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get value() {
    return this.controller.valueController.value.rawValue;
  }
  set value(value) {
    this.controller.valueController.value.rawValue = value;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.controller.valueController.value.emitter.on(eventName, (ev) => {
      bh(new TpChangeEvent$6(this, ev.rawValue, ev.options.last));
    });
    return this;
  }
}
function interpolate(x1, x2, t) {
  return x1 * (1 - t) + x2 * t;
}
const MAX_ITERATION = 20;
const X_DELTA = 1e-3;
const CACHE_RESOLUTION = 100;
function y(cb, x) {
  let dt = 0.25;
  let t = 0.5;
  let y2 = -1;
  for (let i = 0; i < MAX_ITERATION; i++) {
    const [tx, ty] = cb.curve(t);
    t += dt * (tx < x ? 1 : -1);
    y2 = ty;
    dt *= 0.5;
    if (Math.abs(x - tx) < X_DELTA) {
      break;
    }
  }
  return y2;
}
class CubicBezier {
  constructor(x1 = 0, y1 = 0, x2 = 1, y2 = 1) {
    this.cache_ = [];
    this.comps_ = [x1, y1, x2, y2];
  }
  get x1() {
    return this.comps_[0];
  }
  get y1() {
    return this.comps_[1];
  }
  get x2() {
    return this.comps_[2];
  }
  get y2() {
    return this.comps_[3];
  }
  static isObject(obj) {
    if (isEmpty$6(obj)) {
      return false;
    }
    if (!Array.isArray(obj)) {
      return false;
    }
    return (
      typeof obj[0] === "number" &&
      typeof obj[1] === "number" &&
      typeof obj[2] === "number" &&
      typeof obj[3] === "number"
    );
  }
  static equals(v1, v2) {
    return (
      v1.x1 === v2.x1 && v1.y1 === v2.y1 && v1.x2 === v2.x2 && v1.y2 === v2.y2
    );
  }
  curve(t) {
    const x01 = interpolate(0, this.x1, t);
    const y01 = interpolate(0, this.y1, t);
    const x12 = interpolate(this.x1, this.x2, t);
    const y12 = interpolate(this.y1, this.y2, t);
    const x23 = interpolate(this.x2, 1, t);
    const y23 = interpolate(this.y2, 1, t);
    const xr0 = interpolate(x01, x12, t);
    const yr0 = interpolate(y01, y12, t);
    const xr1 = interpolate(x12, x23, t);
    const yr1 = interpolate(y12, y23, t);
    return [interpolate(xr0, xr1, t), interpolate(yr0, yr1, t)];
  }
  y(x) {
    if (this.cache_.length === 0) {
      const cache = [];
      for (let i = 0; i < CACHE_RESOLUTION; i++) {
        cache.push(y(this, mapRange$6(i, 0, CACHE_RESOLUTION - 1, 0, 1)));
      }
      this.cache_ = cache;
    }
    return this.cache_[
      Math.round(
        mapRange$6(constrainRange$6(x, 0, 1), 0, 1, 0, CACHE_RESOLUTION - 1),
      )
    ];
  }
  toObject() {
    return [this.comps_[0], this.comps_[1], this.comps_[2], this.comps_[3]];
  }
}
const CubicBezierAssembly = {
  toComponents: (p) => p.toObject(),
  fromComponents: (comps) => new CubicBezier(...comps),
};
function cubicBezierToString(cb) {
  const formatter = createNumberFormatter$6(2);
  const comps = cb.toObject().map((c) => formatter(c));
  return `cubic-bezier(${comps.join(", ")})`;
}
const COMPS_EMPTY = [0, 0.5, 0.5, 1];
function cubicBezierFromString(text) {
  const m = text.match(
    /^cubic-bezier\s*\(\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*,\s*([0-9.]+)\s*\)$/,
  );
  if (!m) {
    return new CubicBezier(...COMPS_EMPTY);
  }
  const comps = [m[1], m[2], m[3], m[4]].reduce((comps2, comp) => {
    if (!comps2) {
      return null;
    }
    const n = Number(comp);
    if (isNaN(n)) {
      return null;
    }
    return [...comps2, n];
  }, []);
  return new CubicBezier(
    ...(comps !== null && comps !== void 0 ? comps : COMPS_EMPTY),
  );
}
const className$7 = ClassName$6("cbz");
class CubicBezierView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(className$7());
    config.viewProps.bindClassModifiers(this.element);
    config.foldable.bindExpandedClass(
      this.element,
      className$7(void 0, "expanded"),
    );
    bindValueMap$6(
      config.foldable,
      "completed",
      valueToClassName$6(this.element, className$7(void 0, "cpl")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(className$7("h"));
    this.element.appendChild(headElem);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(className$7("b"));
    config.viewProps.bindDisabled(buttonElem);
    const iconElem = doc.createElementNS(SVG_NS$6, "svg");
    iconElem.innerHTML = '<path d="M2 13C8 13 8 3 14 3"/>';
    buttonElem.appendChild(iconElem);
    headElem.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(className$7("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(className$7("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
}
const className$6 = ClassName$6("cbzp");
class CubicBezierPickerView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(className$6());
    config.viewProps.bindClassModifiers(this.element);
    const graphElem = doc.createElement("div");
    graphElem.classList.add(className$6("g"));
    this.element.appendChild(graphElem);
    this.graphElement = graphElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(className$6("t"));
    this.element.appendChild(textElem);
    this.textElement = textElem;
  }
}
function waitToBeAddedToDom(elem, callback) {
  const ob = new MutationObserver((ml) => {
    for (const m of ml) {
      if (m.type !== "childList") {
        continue;
      }
      m.addedNodes.forEach((elem2) => {
        if (!elem2.contains(elem2)) {
          return;
        }
        callback();
        ob.disconnect();
      });
    }
  });
  const doc = elem.ownerDocument;
  ob.observe(doc.body, {
    attributes: true,
    childList: true,
    subtree: true,
  });
}
const className$5$1 = ClassName$6("cbzg");
function compose(h1, h2) {
  return (input) => h2(h1(input));
}
class CubicBezierGraphView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(className$5$1());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const previewElem = doc.createElement("div");
    previewElem.classList.add(className$5$1("p"));
    this.element.appendChild(previewElem);
    this.previewElement = previewElem;
    const svgElem = doc.createElementNS(SVG_NS$6, "svg");
    svgElem.classList.add(className$5$1("g"));
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const guideElem = doc.createElementNS(SVG_NS$6, "path");
    guideElem.classList.add(className$5$1("u"));
    this.svgElem_.appendChild(guideElem);
    this.guideElem_ = guideElem;
    const lineElem = doc.createElementNS(SVG_NS$6, "polyline");
    lineElem.classList.add(className$5$1("l"));
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    this.handleElems_ = [doc.createElement("div"), doc.createElement("div")];
    this.handleElems_.forEach((elem) => {
      elem.classList.add(className$5$1("h"));
      this.element.appendChild(elem);
    });
    this.vectorElems_ = [
      doc.createElementNS(SVG_NS$6, "line"),
      doc.createElementNS(SVG_NS$6, "line"),
    ];
    this.vectorElems_.forEach((elem) => {
      elem.classList.add(className$5$1("v"));
      this.svgElem_.appendChild(elem);
    });
    this.value_ = config.value;
    this.value_.emitter.on("change", this.onValueChange_.bind(this));
    this.sel_ = config.selection;
    this.handleElems_.forEach((elem, index) => {
      bindValue$6(
        this.sel_,
        compose(
          (selection) => selection === index,
          valueToClassName$6(elem, className$5$1("h", "sel")),
        ),
      );
    });
    waitToBeAddedToDom(this.element, () => {
      this.refresh();
    });
  }
  getVertMargin_(h) {
    return h * 0.25;
  }
  valueToPosition(x, y2) {
    const { clientWidth: w, clientHeight: h } = this.element;
    const vm = this.getVertMargin_(h);
    return {
      x: mapRange$6(x, 0, 1, 0, w),
      y: mapRange$6(y2, 0, 1, h - vm, vm),
    };
  }
  positionToValue(x, y2) {
    const bounds = this.element.getBoundingClientRect();
    const w = bounds.width;
    const h = bounds.height;
    const vm = this.getVertMargin_(h);
    return {
      x: constrainRange$6(mapRange$6(x, 0, w, 0, 1), 0, 1),
      y: mapRange$6(y2, h - vm, vm, 0, 1),
    };
  }
  refresh() {
    this.guideElem_.setAttributeNS(
      null,
      "d",
      [0, 1]
        .map((index) => {
          const p1 = this.valueToPosition(0, index);
          const p2 = this.valueToPosition(1, index);
          return [`M ${p1.x},${p1.y}`, `L ${p2.x},${p2.y}`].join(" ");
        })
        .join(" "),
    );
    const bezier = this.value_.rawValue;
    const points = [];
    let t = 0;
    for (;;) {
      const p = this.valueToPosition(...bezier.curve(t));
      points.push([p.x, p.y].join(","));
      if (t >= 1) {
        break;
      }
      t = Math.min(t + 0.05, 1);
    }
    this.lineElem_.setAttributeNS(null, "points", points.join(" "));
    const obj = bezier.toObject();
    [0, 1].forEach((index) => {
      const p1 = this.valueToPosition(index, index);
      const p2 = this.valueToPosition(obj[index * 2], obj[index * 2 + 1]);
      const vElem = this.vectorElems_[index];
      vElem.setAttributeNS(null, "x1", String(p1.x));
      vElem.setAttributeNS(null, "y1", String(p1.y));
      vElem.setAttributeNS(null, "x2", String(p2.x));
      vElem.setAttributeNS(null, "y2", String(p2.y));
      const hElem = this.handleElems_[index];
      hElem.style.left = `${p2.x}px`;
      hElem.style.top = `${p2.y}px`;
    });
  }
  onValueChange_() {
    this.refresh();
  }
}
const TICK_COUNT = 24;
const PREVIEW_DELAY = 400;
const PREVIEW_DURATION = 1e3;
const className$4$1 = ClassName$6("cbzprv");
class CubicBezierPreviewView {
  constructor(doc, config) {
    this.stopped_ = true;
    this.startTime_ = -1;
    this.onDispose_ = this.onDispose_.bind(this);
    this.onTimer_ = this.onTimer_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(className$4$1());
    config.viewProps.bindClassModifiers(this.element);
    const svgElem = doc.createElementNS(SVG_NS$6, "svg");
    svgElem.classList.add(className$4$1("g"));
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const ticksElem = doc.createElementNS(SVG_NS$6, "path");
    ticksElem.classList.add(className$4$1("t"));
    this.svgElem_.appendChild(ticksElem);
    this.ticksElem_ = ticksElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(className$4$1("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.value_ = config.value;
    this.value_.emitter.on("change", this.onValueChange_);
    config.viewProps.handleDispose(this.onDispose_);
    waitToBeAddedToDom(this.element, () => {
      this.refresh();
    });
  }
  play() {
    this.stop();
    this.updateMarker_(0);
    this.markerElem_.classList.add(className$4$1("m", "a"));
    this.startTime_ = /* @__PURE__ */ new Date().getTime() + PREVIEW_DELAY;
    this.stopped_ = false;
    requestAnimationFrame(this.onTimer_);
  }
  stop() {
    this.stopped_ = true;
    this.markerElem_.classList.remove(className$4$1("m", "a"));
  }
  onDispose_() {
    this.stop();
  }
  updateMarker_(progress) {
    const p = this.value_.rawValue.y(constrainRange$6(progress, 0, 1));
    this.markerElem_.style.left = `${p * 100}%`;
  }
  refresh() {
    const { clientWidth: w, clientHeight: h } = this.svgElem_;
    const ds = [];
    const bezier = this.value_.rawValue;
    for (let i = 0; i < TICK_COUNT; i++) {
      const px2 = mapRange$6(i, 0, TICK_COUNT - 1, 0, 1);
      const x = mapRange$6(bezier.y(px2), 0, 1, 0, w);
      ds.push(`M ${x},0 v${h}`);
    }
    this.ticksElem_.setAttributeNS(null, "d", ds.join(" "));
  }
  onTimer_() {
    if (this.startTime_ === null) {
      return;
    }
    const dt = /* @__PURE__ */ new Date().getTime() - this.startTime_;
    const p = dt / PREVIEW_DURATION;
    this.updateMarker_(p);
    if (dt > PREVIEW_DURATION + PREVIEW_DELAY) {
      this.stop();
    }
    if (!this.stopped_) {
      requestAnimationFrame(this.onTimer_);
    }
  }
  onValueChange_() {
    this.refresh();
    this.play();
  }
}
function getDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
function lockAngle(x1, y1, x2, y2) {
  const d = getDistance(x1, y1, x2, y2);
  const a = Math.atan2(y2 - y1, x2 - x1);
  const la = (Math.round(a / (Math.PI / 4)) * Math.PI) / 4;
  return {
    x: x1 + Math.cos(la) * d,
    y: y1 + Math.sin(la) * d,
  };
}
class CubicBezierGraphController {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.keyScale_ = config.keyScale;
    this.value = config.value;
    this.sel_ = createValue$6(0);
    this.viewProps = config.viewProps;
    this.view = new CubicBezierGraphView(doc, {
      selection: this.sel_,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
    this.prevView_ = new CubicBezierPreviewView(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.prevView_.element.addEventListener("mousedown", (ev) => {
      ev.stopImmediatePropagation();
      ev.preventDefault();
      this.prevView_.play();
    });
    this.view.previewElement.appendChild(this.prevView_.element);
    const ptHandler = new PointerHandler$6(this.view.element);
    ptHandler.emitter.on("down", this.onPointerDown_);
    ptHandler.emitter.on("move", this.onPointerMove_);
    ptHandler.emitter.on("up", this.onPointerUp_);
  }
  refresh() {
    this.view.refresh();
    this.prevView_.refresh();
    this.prevView_.play();
  }
  updateValue_(point, locksAngle, opts) {
    const index = this.sel_.rawValue;
    const comps = this.value.rawValue.toObject();
    const vp = this.view.positionToValue(point.x, point.y);
    const v = locksAngle ? lockAngle(index, index, vp.x, vp.y) : vp;
    comps[index * 2] = v.x;
    comps[index * 2 + 1] = v.y;
    this.value.setRawValue(new CubicBezier(...comps), opts);
  }
  onPointerDown_(ev) {
    const data = ev.data;
    if (!data.point) {
      return;
    }
    const bezier = this.value.rawValue;
    const p1 = this.view.valueToPosition(bezier.x1, bezier.y1);
    const d1 = getDistance(data.point.x, data.point.y, p1.x, p1.y);
    const p2 = this.view.valueToPosition(bezier.x2, bezier.y2);
    const d2 = getDistance(data.point.x, data.point.y, p2.x, p2.y);
    this.sel_.rawValue = d1 <= d2 ? 0 : 1;
    this.updateValue_(data.point, ev.shiftKey, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    const data = ev.data;
    if (!data.point) {
      return;
    }
    this.updateValue_(data.point, ev.shiftKey, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    const data = ev.data;
    if (!data.point) {
      return;
    }
    this.updateValue_(data.point, ev.shiftKey, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    if (isArrowKey$6(ev.key)) {
      ev.preventDefault();
    }
    const index = this.sel_.rawValue;
    const comps = this.value.rawValue.toObject();
    const keyScale = this.keyScale_.rawValue;
    comps[index * 2] += getStepForKey$6(keyScale, getHorizontalStepKeys$6(ev));
    comps[index * 2 + 1] += getStepForKey$6(
      keyScale,
      getVerticalStepKeys$6(ev),
    );
    this.value.setRawValue(new CubicBezier(...comps), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    if (isArrowKey$6(ev.key)) {
      ev.preventDefault();
    }
    const keyScale = this.keyScale_.rawValue;
    const xStep = getStepForKey$6(keyScale, getHorizontalStepKeys$6(ev));
    const yStep = getStepForKey$6(keyScale, getVerticalStepKeys$6(ev));
    if (xStep === 0 && yStep === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
}
class CubicBezierPickerController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new CubicBezierPickerView(doc, {
      viewProps: this.viewProps,
    });
    this.gc_ = new CubicBezierGraphController(doc, {
      keyScale: config.axis.textProps.value("keyScale"),
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.graphElement.appendChild(this.gc_.view.element);
    const xAxis = Object.assign(Object.assign({}, config.axis), {
      constraint: new RangeConstraint$6({ max: 1, min: 0 }),
    });
    const yAxis = Object.assign(Object.assign({}, config.axis), {
      constraint: void 0,
    });
    this.tc_ = new PointNdTextController$6(doc, {
      assembly: CubicBezierAssembly,
      axes: [xAxis, yAxis, xAxis, yAxis],
      parser: parseNumber$6,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.textElement.appendChild(this.tc_.view.element);
  }
  get allFocusableElements() {
    return [
      this.gc_.view.element,
      ...this.tc_.view.textViews.map((v) => v.inputElement),
    ];
  }
  refresh() {
    this.gc_.refresh();
  }
}
class CubicBezierController {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$6.create(config.expanded);
    this.view = new CubicBezierView(doc, {
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout,
      viewProps: this.viewProps,
    });
    this.view.buttonElement.addEventListener("blur", this.onButtonBlur_);
    this.view.buttonElement.addEventListener("click", this.onButtonClick_);
    this.tc_ = new TextController$6(doc, {
      parser: cubicBezierFromString,
      props: ValueMap$6.fromObject({
        formatter: cubicBezierToString,
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.textElement.appendChild(this.tc_.view.element);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$6(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const pickerC = new CubicBezierPickerController(doc, {
      axis: config.axis,
      value: this.value,
      viewProps: this.viewProps,
    });
    pickerC.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = pickerC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(this.pickerC_.view.element);
      bindValue$6(this.popC_.shows, (shows) => {
        if (shows) {
          pickerC.refresh();
        }
      });
      connectValues$6({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$6(this.foldable_, this.view.pickerElement);
    }
  }
  onButtonBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const nextTarget = forceCast$6(ev.relatedTarget);
    if (!nextTarget || !this.popC_.view.element.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$6(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.view.buttonElement &&
      !supportsTouch$6(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (!this.popC_) {
      return;
    }
    if (ev.key === "Escape") {
      this.popC_.shows.rawValue = false;
    }
  }
}
function createConstraint$1$6() {
  return new PointNdConstraint$6({
    assembly: CubicBezierAssembly,
    components: [0, 1, 2, 3].map((index) =>
      index % 2 === 0
        ? new RangeConstraint$6({
            min: 0,
            max: 1,
          })
        : void 0,
    ),
  });
}
createPlugin$6({
  id: "cubicbezier",
  type: "blade",
  accept(params) {
    const result = parseRecord$6(params, (p) => ({
      value: p.required.array(p.required.number),
      view: p.required.constant("cubicbezier"),
      expanded: p.optional.boolean,
      label: p.optional.string,
      picker: p.optional.custom((v) => {
        return v === "inline" || v === "popup" ? v : void 0;
      }),
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    var _a, _b;
    const rv = new CubicBezier(...args.params.value);
    const v = createValue$6(rv, {
      constraint: createConstraint$1$6(),
      equals: CubicBezier.equals,
    });
    const vc = new CubicBezierController(args.document, {
      axis: {
        textProps: ValueMap$6.fromObject({
          keyScale: 0.1,
          pointerScale: 0.01,
          formatter: createNumberFormatter$6(2),
        }),
      },
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      value: v,
      viewProps: args.viewProps,
    });
    return new LabeledValueBladeController(args.document, {
      blade: args.blade,
      props: ValueMap$6.fromObject({
        label: args.params.label,
      }),
      value: v,
      valueController: vc,
    });
  },
  api(args) {
    if (!(args.controller instanceof LabeledValueBladeController)) {
      return null;
    }
    if (!(args.controller.valueController instanceof CubicBezierController)) {
      return null;
    }
    return new CubicBezierApi(args.controller);
  },
});
class FpsGraphBladeApi extends BladeApi$6 {
  get fps() {
    return this.controller.valueController.fps;
  }
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.props.set("min", min);
  }
  begin() {
    this.controller.valueController.begin();
  }
  end() {
    this.controller.valueController.end();
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller.valueController.ticker.emitter;
    emitter.on(eventName, () => {
      bh(new TpEvent$6(this));
    });
    return this;
  }
}
const MAX_TIMESTAMPS = 20;
class Fpswatch {
  constructor() {
    this.start_ = null;
    this.duration_ = 0;
    this.fps_ = null;
    this.frameCount_ = 0;
    this.timestamps_ = [];
  }
  get duration() {
    return this.duration_;
  }
  get fps() {
    return this.fps_;
  }
  begin(now2) {
    this.start_ = now2.getTime();
  }
  calculateFps_(nowTime) {
    if (this.timestamps_.length === 0) {
      return null;
    }
    const ts = this.timestamps_[0];
    return (1e3 * (this.frameCount_ - ts.frameCount)) / (nowTime - ts.time);
  }
  compactTimestamps_() {
    if (this.timestamps_.length <= MAX_TIMESTAMPS) {
      return;
    }
    const len = this.timestamps_.length - MAX_TIMESTAMPS;
    this.timestamps_.splice(0, len);
    const df = this.timestamps_[0].frameCount;
    this.timestamps_.forEach((ts) => {
      ts.frameCount -= df;
    });
    this.frameCount_ -= df;
  }
  end(now2) {
    if (this.start_ === null) {
      return;
    }
    const t = now2.getTime();
    this.duration_ = t - this.start_;
    this.start_ = null;
    this.fps_ = this.calculateFps_(t);
    this.timestamps_.push({
      frameCount: this.frameCount_,
      time: t,
    });
    ++this.frameCount_;
    this.compactTimestamps_();
  }
}
const className$3$1 = ClassName$6("fps");
class FpsView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(className$3$1());
    config.viewProps.bindClassModifiers(this.element);
    this.graphElement = doc.createElement("div");
    this.graphElement.classList.add(className$3$1("g"));
    this.element.appendChild(this.graphElement);
    const labelElement = doc.createElement("div");
    labelElement.classList.add(className$3$1("l"));
    this.element.appendChild(labelElement);
    const valueElement = doc.createElement("span");
    valueElement.classList.add(className$3$1("v"));
    valueElement.textContent = "--";
    labelElement.appendChild(valueElement);
    this.valueElement = valueElement;
    const unitElement = doc.createElement("span");
    unitElement.classList.add(className$3$1("u"));
    unitElement.textContent = "FPS";
    labelElement.appendChild(unitElement);
  }
}
class FpsGraphController {
  constructor(doc, config) {
    this.stopwatch_ = new Fpswatch();
    this.onTick_ = this.onTick_.bind(this);
    this.ticker = config.ticker;
    this.ticker.emitter.on("tick", this.onTick_);
    this.props = config.props;
    this.value_ = config.value;
    this.viewProps = config.viewProps;
    this.view = new FpsView(doc, {
      viewProps: this.viewProps,
    });
    this.graphC_ = new GraphLogController$6(doc, {
      formatter: createNumberFormatter$6(0),
      props: this.props,
      rows: config.rows,
      value: this.value_,
      viewProps: this.viewProps,
    });
    this.view.graphElement.appendChild(this.graphC_.view.element);
    this.viewProps.handleDispose(() => {
      this.graphC_.viewProps.set("disposed", true);
      this.ticker.dispose();
    });
  }
  get fps() {
    return this.stopwatch_.fps;
  }
  begin() {
    this.stopwatch_.begin(/* @__PURE__ */ new Date());
  }
  end() {
    this.stopwatch_.end(/* @__PURE__ */ new Date());
  }
  onTick_() {
    const fps = this.fps;
    if (fps !== null) {
      const buffer = this.value_.rawValue;
      this.value_.rawValue = createPushedBuffer(buffer, fps);
      this.view.valueElement.textContent = fps.toFixed(0);
    }
  }
}
class FpsGraphBladeController extends BladeController$6 {
  constructor(doc, config) {
    const fc = config.valueController;
    const lc = new LabelController$6(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: fc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: fc.viewProps,
    });
    this.valueController = fc;
    this.labelController = lc;
  }
}
function createTicker$1(document2, interval) {
  return interval === 0
    ? new ManualTicker$1()
    : new IntervalTicker$1(
        document2,
        interval !== null && interval !== void 0
          ? interval
          : Constants$6.monitor.defaultInterval,
      );
}
createPlugin$6({
  id: "fpsgraph",
  type: "blade",
  accept(params) {
    const result = parseRecord$6(params, (p) => ({
      view: p.required.constant("fpsgraph"),
      interval: p.optional.number,
      label: p.optional.string,
      rows: p.optional.number,
      max: p.optional.number,
      min: p.optional.number,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    var _a, _b, _c, _d;
    const interval =
      (_a = args.params.interval) !== null && _a !== void 0 ? _a : 500;
    return new FpsGraphBladeController(args.document, {
      blade: args.blade,
      labelProps: ValueMap$6.fromObject({
        label: args.params.label,
      }),
      valueController: new FpsGraphController(args.document, {
        props: ValueMap$6.fromObject({
          max: (_b = args.params.max) !== null && _b !== void 0 ? _b : 90,
          min: (_c = args.params.min) !== null && _c !== void 0 ? _c : 0,
        }),
        rows: (_d = args.params.rows) !== null && _d !== void 0 ? _d : 2,
        ticker: createTicker$1(args.document, interval),
        value: createValue$6(initializeBuffer(80)),
        viewProps: args.viewProps,
      }),
    });
  },
  api(args) {
    if (!(args.controller instanceof FpsGraphBladeController)) {
      return null;
    }
    return new FpsGraphBladeApi(args.controller);
  },
});
class Interval {
  constructor(min, max) {
    this.min = min;
    this.max = max;
  }
  static isObject(obj) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    const min = obj.min;
    const max = obj.max;
    if (typeof min !== "number" || typeof max !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.min === v2.min && v1.max === v2.max;
  }
  get length() {
    return this.max - this.min;
  }
  toObject() {
    return {
      min: this.min,
      max: this.max,
    };
  }
}
const IntervalAssembly = {
  fromComponents: (comps) => new Interval(comps[0], comps[1]),
  toComponents: (p) => [p.min, p.max],
};
class IntervalConstraint {
  constructor(edge) {
    this.edge = edge;
  }
  constrain(value) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (value.min <= value.max) {
      return new Interval(
        (_b =
          (_a = this.edge) === null || _a === void 0
            ? void 0
            : _a.constrain(value.min)) !== null && _b !== void 0
          ? _b
          : value.min,
        (_d =
          (_c = this.edge) === null || _c === void 0
            ? void 0
            : _c.constrain(value.max)) !== null && _d !== void 0
          ? _d
          : value.max,
      );
    }
    const c = (value.min + value.max) / 2;
    return new Interval(
      (_f =
        (_e = this.edge) === null || _e === void 0
          ? void 0
          : _e.constrain(c)) !== null && _f !== void 0
        ? _f
        : c,
      (_h =
        (_g = this.edge) === null || _g === void 0
          ? void 0
          : _g.constrain(c)) !== null && _h !== void 0
        ? _h
        : c,
    );
  }
}
const className$2$2 = ClassName$6("rsltxt");
class RangeSliderTextView {
  constructor(doc, config) {
    this.sliderView_ = config.sliderView;
    this.textView_ = config.textView;
    this.element = doc.createElement("div");
    this.element.classList.add(className$2$2());
    const sliderElem = doc.createElement("div");
    sliderElem.classList.add(className$2$2("s"));
    sliderElem.appendChild(this.sliderView_.element);
    this.element.appendChild(sliderElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(className$2$2("t"));
    textElem.appendChild(this.textView_.element);
    this.element.appendChild(textElem);
  }
}
const className$1$3 = ClassName$6("rsl");
class RangeSliderView {
  constructor(doc, config) {
    this.onSliderPropsChange_ = this.onSliderPropsChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.sliderProps_ = config.sliderProps;
    this.sliderProps_.emitter.on("change", this.onSliderPropsChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(className$1$3());
    config.viewProps.bindClassModifiers(this.element);
    this.value_ = config.value;
    this.value_.emitter.on("change", this.onValueChange_);
    const trackElem = doc.createElement("div");
    trackElem.classList.add(className$1$3("t"));
    this.element.appendChild(trackElem);
    this.trackElement = trackElem;
    const barElem = doc.createElement("div");
    barElem.classList.add(className$1$3("b"));
    trackElem.appendChild(barElem);
    this.barElement = barElem;
    const knobElems = ["min", "max"].map((modifier) => {
      const elem = doc.createElement("div");
      elem.classList.add(className$1$3("k"), className$1$3("k", modifier));
      trackElem.appendChild(elem);
      return elem;
    });
    this.knobElements = [knobElems[0], knobElems[1]];
    this.update_();
  }
  valueToX_(value) {
    const min = this.sliderProps_.get("min");
    const max = this.sliderProps_.get("max");
    return constrainRange$6(mapRange$6(value, min, max, 0, 1), 0, 1) * 100;
  }
  update_() {
    const v = this.value_.rawValue;
    if (v.length === 0) {
      this.element.classList.add(className$1$3(void 0, "zero"));
    } else {
      this.element.classList.remove(className$1$3(void 0, "zero"));
    }
    const xs = [this.valueToX_(v.min), this.valueToX_(v.max)];
    this.barElement.style.left = `${xs[0]}%`;
    this.barElement.style.right = `${100 - xs[1]}%`;
    this.knobElements.forEach((elem, index) => {
      elem.style.left = `${xs[index]}%`;
    });
  }
  onSliderPropsChange_() {
    this.update_();
  }
  onValueChange_() {
    this.update_();
  }
}
class RangeSliderController {
  constructor(doc, config) {
    this.grabbing_ = null;
    this.grabOffset_ = 0;
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.sliderProps = config.sliderProps;
    this.viewProps = config.viewProps;
    this.value = config.value;
    this.view = new RangeSliderView(doc, {
      sliderProps: this.sliderProps,
      value: this.value,
      viewProps: config.viewProps,
    });
    const ptHandler = new PointerHandler$6(this.view.trackElement);
    ptHandler.emitter.on("down", this.onPointerDown_);
    ptHandler.emitter.on("move", this.onPointerMove_);
    ptHandler.emitter.on("up", this.onPointerUp_);
  }
  ofs_() {
    if (this.grabbing_ === "min") {
      return this.view.knobElements[0].getBoundingClientRect().width / 2;
    }
    if (this.grabbing_ === "max") {
      return -this.view.knobElements[1].getBoundingClientRect().width / 2;
    }
    return 0;
  }
  valueFromData_(data) {
    if (!data.point) {
      return null;
    }
    const p = (data.point.x + this.ofs_()) / data.bounds.width;
    const min = this.sliderProps.get("min");
    const max = this.sliderProps.get("max");
    return mapRange$6(p, 0, 1, min, max);
  }
  onPointerDown_(ev) {
    if (!ev.data.point) {
      return;
    }
    const p = ev.data.point.x / ev.data.bounds.width;
    const v = this.value.rawValue;
    const min = this.sliderProps.get("min");
    const max = this.sliderProps.get("max");
    const pmin = mapRange$6(v.min, min, max, 0, 1);
    const pmax = mapRange$6(v.max, min, max, 0, 1);
    if (Math.abs(pmax - p) <= 0.025) {
      this.grabbing_ = "max";
    } else if (Math.abs(pmin - p) <= 0.025) {
      this.grabbing_ = "min";
    } else if (p >= pmin && p <= pmax) {
      this.grabbing_ = "length";
      this.grabOffset_ = mapRange$6(p - pmin, 0, 1, 0, max - min);
    } else if (p < pmin) {
      this.grabbing_ = "min";
      this.onPointerMove_(ev);
    } else if (p > pmax) {
      this.grabbing_ = "max";
      this.onPointerMove_(ev);
    }
  }
  applyPointToValue_(data, opts) {
    const v = this.valueFromData_(data);
    if (v === null) {
      return;
    }
    const rmin = this.sliderProps.get("min");
    const rmax = this.sliderProps.get("max");
    if (this.grabbing_ === "min") {
      this.value.setRawValue(new Interval(v, this.value.rawValue.max), opts);
    } else if (this.grabbing_ === "max") {
      this.value.setRawValue(new Interval(this.value.rawValue.min, v), opts);
    } else if (this.grabbing_ === "length") {
      const len = this.value.rawValue.length;
      let min = v - this.grabOffset_;
      let max = min + len;
      if (min < rmin) {
        min = rmin;
        max = rmin + len;
      } else if (max > rmax) {
        min = rmax - len;
        max = rmax;
      }
      this.value.setRawValue(new Interval(min, max), opts);
    }
  }
  onPointerMove_(ev) {
    this.applyPointToValue_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.applyPointToValue_(ev.data, {
      forceEmit: true,
      last: true,
    });
    this.grabbing_ = null;
  }
}
class RangeSliderTextController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.sc_ = new RangeSliderController(doc, config);
    const axis = {
      constraint: config.constraint,
      textProps: config.textProps,
    };
    this.tc_ = new PointNdTextController$6(doc, {
      assembly: IntervalAssembly,
      axes: [axis, axis],
      parser: config.parser,
      value: this.value,
      viewProps: config.viewProps,
    });
    this.view = new RangeSliderTextView(doc, {
      sliderView: this.sc_.view,
      textView: this.tc_.view,
    });
  }
  get textController() {
    return this.tc_;
  }
}
function intervalFromUnknown(value) {
  return Interval.isObject(value)
    ? new Interval(value.min, value.max)
    : new Interval(0, 0);
}
function writeInterval(target, value) {
  target.writeProperty("max", value.max);
  target.writeProperty("min", value.min);
}
function createConstraint$c(params) {
  const constraints = [];
  const rc = createRangeConstraint$6(params);
  if (rc) {
    constraints.push(rc);
  }
  const sc = createStepConstraint$6(params);
  if (sc) {
    constraints.push(sc);
  }
  return new IntervalConstraint(new CompositeConstraint$6(constraints));
}
createPlugin$6({
  id: "input-interval",
  type: "input",
  accept: (exValue, params) => {
    if (!Interval.isObject(exValue)) {
      return null;
    }
    const result = parseRecord$6(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser$6(p)), {
        readonly: p.optional.constant(false),
      }),
    );
    return result
      ? {
          initialValue: new Interval(exValue.min, exValue.max),
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => intervalFromUnknown,
    constraint: (args) => createConstraint$c(args.params),
    equals: Interval.equals,
    writer: (_args) => writeInterval,
  },
  controller(args) {
    const v = args.value;
    const c = args.constraint;
    if (!(c instanceof IntervalConstraint)) {
      throw TpError$6.shouldNeverHappen();
    }
    const midValue = (v.rawValue.min + v.rawValue.max) / 2;
    const textProps = ValueMap$6.fromObject(
      createNumberTextPropsObject$6(args.params, midValue),
    );
    const drc = c.edge && findConstraint$6(c.edge, DefiniteRangeConstraint$6);
    if (drc) {
      return new RangeSliderTextController(args.document, {
        constraint: c.edge,
        parser: parseNumber$6,
        sliderProps: new ValueMap$6({
          keyScale: textProps.value("keyScale"),
          max: drc.values.value("max"),
          min: drc.values.value("min"),
        }),
        textProps,
        value: v,
        viewProps: args.viewProps,
      });
    }
    const axis = {
      constraint: c.edge,
      textProps,
    };
    return new PointNdTextController$6(args.document, {
      assembly: IntervalAssembly,
      axes: [axis, axis],
      parser: parseNumber$6,
      value: v,
      viewProps: args.viewProps,
    });
  },
});
class RadioCellApi {
  constructor(controller) {
    this.controller_ = controller;
  }
  get disabled() {
    return this.controller_.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller_.viewProps.set("disabled", disabled);
  }
  get title() {
    var _a;
    return (_a = this.controller_.props.get("title")) !== null && _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller_.props.set("title", title);
  }
}
class TpRadioGridChangeEvent extends TpChangeEvent$6 {
  constructor(target, cell, index, value, last) {
    super(target, value, last);
    this.cell = cell;
    this.index = index;
  }
}
class RadioGridApi extends BladeApi$6 {
  constructor(controller) {
    super(controller);
    this.cellToApiMap_ = /* @__PURE__ */ new Map();
    const gc = this.controller.valueController;
    gc.cellControllers.forEach((cc) => {
      const api = new RadioCellApi(cc);
      this.cellToApiMap_.set(cc, api);
    });
  }
  get value() {
    return this.controller.value;
  }
  cell(x, y2) {
    const gc = this.controller.valueController;
    const cc = gc.cellControllers[y2 * gc.size[0] + x];
    return this.cellToApiMap_.get(cc);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.controller.value.emitter.on(eventName, (ev) => {
      const gc = this.controller.valueController;
      const cc = gc.findCellByValue(ev.rawValue);
      if (!cc) {
        return;
      }
      const capi = this.cellToApiMap_.get(cc);
      if (!capi) {
        return;
      }
      const i = gc.cellControllers.indexOf(cc);
      bh(
        new TpRadioGridChangeEvent(
          this,
          capi,
          [i % gc.size[0], Math.floor(i / gc.size[0])],
          ev.rawValue,
        ),
      );
    });
  }
}
const className$8 = ClassName$6("rad");
class RadioView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(className$8());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("label");
    labelElem.classList.add(className$8("l"));
    this.element.appendChild(labelElem);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(className$8("i"));
    inputElem.name = config.name;
    inputElem.type = "radio";
    config.viewProps.bindDisabled(inputElem);
    labelElem.appendChild(inputElem);
    this.inputElement = inputElem;
    const bodyElem = doc.createElement("div");
    bodyElem.classList.add(className$8("b"));
    labelElem.appendChild(bodyElem);
    const titleElem = doc.createElement("div");
    titleElem.classList.add(className$8("t"));
    bodyElem.appendChild(titleElem);
    bindValueMap$6(config.props, "title", (title) => {
      titleElem.textContent = title;
    });
  }
}
class RadioController {
  constructor(doc, config) {
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new RadioView(doc, {
      name: config.name,
      props: this.props,
      viewProps: this.viewProps,
    });
  }
}
class RadioGridController {
  constructor(doc, config) {
    this.cellCs_ = [];
    this.cellValues_ = [];
    this.onCellInputChange_ = this.onCellInputChange_.bind(this);
    this.size = config.size;
    const [w, h] = this.size;
    for (let y2 = 0; y2 < h; y2++) {
      for (let x = 0; x < w; x++) {
        const bc = new RadioController(doc, {
          name: config.groupName,
          props: ValueMap$6.fromObject(
            Object.assign({}, config.cellConfig(x, y2)),
          ),
          viewProps: ViewProps$6.create(),
        });
        this.cellCs_.push(bc);
        this.cellValues_.push(config.cellConfig(x, y2).value);
      }
    }
    this.value = config.value;
    bindValue$6(this.value, (value) => {
      const cc = this.findCellByValue(value);
      if (!cc) {
        return;
      }
      cc.view.inputElement.checked = true;
    });
    this.viewProps = ViewProps$6.create();
    this.view = new PlainView(doc, {
      viewProps: this.viewProps,
      viewName: "radgrid",
    });
    this.view.element.style.gridTemplateColumns = `repeat(${w}, 1fr)`;
    this.cellCs_.forEach((bc) => {
      bc.view.inputElement.addEventListener("change", this.onCellInputChange_);
      this.view.element.appendChild(bc.view.element);
    });
  }
  get cellControllers() {
    return this.cellCs_;
  }
  findCellByValue(value) {
    const index = this.cellValues_.findIndex((v) => v === value);
    if (index < 0) {
      return null;
    }
    return this.cellCs_[index];
  }
  onCellInputChange_(ev) {
    const inputElem = ev.currentTarget;
    const index = this.cellCs_.findIndex(
      (c) => c.view.inputElement === inputElem,
    );
    if (index < 0) {
      return;
    }
    this.value.rawValue = this.cellValues_[index];
  }
}
(function () {
  return createPlugin$6({
    id: "radiogrid",
    type: "blade",
    accept(params) {
      const result = parseRecord$6(params, (p) => ({
        cells: p.required.function,
        groupName: p.required.string,
        size: p.required.array(p.required.number),
        value: p.required.raw,
        view: p.required.constant("radiogrid"),
        label: p.optional.string,
      }));
      return result ? { params: result } : null;
    },
    controller(args) {
      const value = createValue$6(args.params.value);
      return new LabeledValueBladeController(args.document, {
        blade: args.blade,
        props: ValueMap$6.fromObject({
          label: args.params.label,
        }),
        value,
        valueController: new RadioGridController(args.document, {
          groupName: args.params.groupName,
          cellConfig: args.params.cells,
          size: args.params.size,
          value,
        }),
      });
    },
    api(args) {
      if (!(args.controller instanceof LabeledValueBladeController)) {
        return null;
      }
      if (!(args.controller.valueController instanceof RadioGridController)) {
        return null;
      }
      return new RadioGridApi(args.controller);
    },
  });
})();
function createRadioGridInputPlugin(config) {
  return createPlugin$6({
    id: "input-radiogrid",
    type: "input",
    accept(value, params) {
      if (!config.isType(value)) {
        return null;
      }
      const result = parseRecord$6(params, (p) => ({
        cells: p.required.function,
        groupName: p.required.string,
        size: p.required.array(p.required.number),
        view: p.required.constant("radiogrid"),
      }));
      return result
        ? {
            initialValue: value,
            params: result,
          }
        : null;
    },
    binding: config.binding,
    controller: (args) => {
      return new RadioGridController(args.document, {
        cellConfig: args.params.cells,
        groupName: args.params.groupName,
        size: args.params.size,
        value: args.value,
      });
    },
  });
}
createRadioGridInputPlugin({
  isType: (value) => {
    return typeof value === "number";
  },
  binding: {
    reader: (_args) => numberFromUnknown$6,
    writer: (_args) => writePrimitive$6,
  },
});
createRadioGridInputPlugin({
  isType: (value) => {
    return typeof value === "string";
  },
  binding: {
    reader: (_args) => stringFromUnknown$6,
    writer: (_args) => writePrimitive$6,
  },
});
createRadioGridInputPlugin({
  isType: (value) => {
    return typeof value === "boolean";
  },
  binding: {
    reader: (_args) => boolFromUnknown$6,
    writer: (_args) => writePrimitive$6,
  },
});
function forceCast$5(v) {
  return v;
}
function isEmpty$5(value) {
  return value === null || value === void 0;
}
function isObject$1$5(value) {
  return value !== null && typeof value === "object";
}
function isRecord$5(value) {
  return value !== null && typeof value === "object";
}
function deepEqualsArray$5(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (let i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
function deepMerge$5(r1, r2) {
  const keys = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(r1), ...Object.keys(r2)]),
  );
  return keys.reduce((result, key2) => {
    const v1 = r1[key2];
    const v2 = r2[key2];
    return isRecord$5(v1) && isRecord$5(v2)
      ? Object.assign(Object.assign({}, result), {
          [key2]: deepMerge$5(v1, v2),
        })
      : Object.assign(Object.assign({}, result), {
          [key2]: key2 in r2 ? v2 : v1,
        });
  }, {});
}
function isBinding$5(value) {
  if (!isObject$1$5(value)) {
    return false;
  }
  return "target" in value;
}
const CREATE_MESSAGE_MAP$5 = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (context) => `Invalid parameters for '${context.name}'`,
  nomatchingcontroller: (context) =>
    `No matching controller for '${context.key}'`,
  nomatchingview: (context) =>
    `No matching view for '${JSON.stringify(context.params)}'`,
  notbindable: () => `Value is not bindable`,
  notcompatible: (context) => `Not compatible with  plugin '${context.id}'`,
  propertynotfound: (context) => `Property '${context.name}' not found`,
  shouldneverhappen: () => "This error should never happen",
};
let TpError$5 = class TpError2 {
  static alreadyDisposed() {
    return new TpError2({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new TpError2({
      type: "notbindable",
    });
  }
  static notCompatible(bundleId, id) {
    return new TpError2({
      type: "notcompatible",
      context: {
        id: `${bundleId}.${id}`,
      },
    });
  }
  static propertyNotFound(name) {
    return new TpError2({
      type: "propertynotfound",
      context: {
        name,
      },
    });
  }
  static shouldNeverHappen() {
    return new TpError2({ type: "shouldneverhappen" });
  }
  constructor(config) {
    var _a;
    this.message =
      (_a = CREATE_MESSAGE_MAP$5[config.type](forceCast$5(config.context))) !==
        null && _a !== void 0
        ? _a
        : "Unexpected error";
    this.name = this.constructor.name;
    this.stack = new Error(this.message).stack;
    this.type = config.type;
  }
  toString() {
    return this.message;
  }
};
let BindingTarget$5 = class BindingTarget2 {
  constructor(obj, key2) {
    this.obj_ = obj;
    this.key = key2;
  }
  static isBindable(obj) {
    if (obj === null) {
      return false;
    }
    if (typeof obj !== "object" && typeof obj !== "function") {
      return false;
    }
    return true;
  }
  read() {
    return this.obj_[this.key];
  }
  write(value) {
    this.obj_[this.key] = value;
  }
  writeProperty(name, value) {
    const valueObj = this.read();
    if (!BindingTarget2.isBindable(valueObj)) {
      throw TpError$5.notBindable();
    }
    if (!(name in valueObj)) {
      throw TpError$5.propertyNotFound(name);
    }
    valueObj[name] = value;
  }
};
let Emitter$5 = class Emitter2 {
  constructor() {
    this.observers_ = {};
  }
  on(eventName, handler) {
    let observers = this.observers_[eventName];
    if (!observers) {
      observers = this.observers_[eventName] = [];
    }
    observers.push({
      handler,
    });
    return this;
  }
  off(eventName, handler) {
    const observers = this.observers_[eventName];
    if (observers) {
      this.observers_[eventName] = observers.filter((observer) => {
        return observer.handler !== handler;
      });
    }
    return this;
  }
  emit(eventName, event) {
    const observers = this.observers_[eventName];
    if (!observers) {
      return;
    }
    observers.forEach((observer) => {
      observer.handler(event);
    });
  }
};
let ComplexValue$5 = class ComplexValue2 {
  constructor(initialValue, config) {
    var _a;
    this.constraint_ =
      config === null || config === void 0 ? void 0 : config.constraint;
    this.equals_ =
      (_a = config === null || config === void 0 ? void 0 : config.equals) !==
        null && _a !== void 0
        ? _a
        : (v1, v2) => v1 === v2;
    this.emitter = new Emitter$5();
    this.rawValue_ = initialValue;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(rawValue) {
    this.setRawValue(rawValue, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(rawValue, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const constrainedValue = this.constraint_
      ? this.constraint_.constrain(rawValue)
      : rawValue;
    const prevValue = this.rawValue_;
    const changed = !this.equals_(prevValue, constrainedValue);
    if (!changed && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.rawValue_ = constrainedValue;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: constrainedValue,
      sender: this,
    });
  }
};
let PrimitiveValue$5 = class PrimitiveValue2 {
  constructor(initialValue) {
    this.emitter = new Emitter$5();
    this.value_ = initialValue;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(value) {
    this.setRawValue(value, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(value, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const prevValue = this.value_;
    if (prevValue === value && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.value_ = value;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: this.value_,
      sender: this,
    });
  }
};
let ReadonlyPrimitiveValue$5 = class ReadonlyPrimitiveValue2 {
  constructor(value) {
    this.emitter = new Emitter$5();
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value_ = value;
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit(
      "beforechange",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
  onValueChange_(ev) {
    this.emitter.emit(
      "change",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
};
function createValue$5(initialValue, config) {
  const constraint =
    config === null || config === void 0 ? void 0 : config.constraint;
  const equals2 = config === null || config === void 0 ? void 0 : config.equals;
  if (!constraint && !equals2) {
    return new PrimitiveValue$5(initialValue);
  }
  return new ComplexValue$5(initialValue, config);
}
function createReadonlyValue$5(value) {
  return [
    new ReadonlyPrimitiveValue$5(value),
    (rawValue, options) => {
      value.setRawValue(rawValue, options);
    },
  ];
}
let ValueMap$5 = class ValueMap2 {
  constructor(valueMap) {
    this.emitter = new Emitter$5();
    this.valMap_ = valueMap;
    for (const key2 in this.valMap_) {
      const v = this.valMap_[key2];
      v.emitter.on("change", () => {
        this.emitter.emit("change", {
          key: key2,
          sender: this,
        });
      });
    }
  }
  static createCore(initialValue) {
    const keys = Object.keys(initialValue);
    return keys.reduce((o, key2) => {
      return Object.assign(o, {
        [key2]: createValue$5(initialValue[key2]),
      });
    }, {});
  }
  static fromObject(initialValue) {
    const core = this.createCore(initialValue);
    return new ValueMap2(core);
  }
  get(key2) {
    return this.valMap_[key2].rawValue;
  }
  set(key2, value) {
    this.valMap_[key2].rawValue = value;
  }
  value(key2) {
    return this.valMap_[key2];
  }
};
let DefiniteRangeConstraint$5 = class DefiniteRangeConstraint2 {
  constructor(config) {
    this.values = ValueMap$5.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    return Math.min(Math.max(value, min), max);
  }
};
let RangeConstraint$5 = class RangeConstraint2 {
  constructor(config) {
    this.values = ValueMap$5.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    let result = value;
    if (!isEmpty$5(min)) {
      result = Math.max(result, min);
    }
    if (!isEmpty$5(max)) {
      result = Math.min(result, max);
    }
    return result;
  }
};
let StepConstraint$5 = class StepConstraint2 {
  constructor(step, origin = 0) {
    this.step = step;
    this.origin = origin;
  }
  constrain(value) {
    const o = this.origin % this.step;
    const r = Math.round((value - o) / this.step);
    return o + r * this.step;
  }
};
let NumberLiteralNode$5 = class NumberLiteralNode2 {
  constructor(text) {
    this.text = text;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
};
const BINARY_OPERATION_MAP$5 = {
  "**": (v1, v2) => Math.pow(v1, v2),
  "*": (v1, v2) => v1 * v2,
  "/": (v1, v2) => v1 / v2,
  "%": (v1, v2) => v1 % v2,
  "+": (v1, v2) => v1 + v2,
  "-": (v1, v2) => v1 - v2,
  "<<": (v1, v2) => v1 << v2,
  ">>": (v1, v2) => v1 >> v2,
  ">>>": (v1, v2) => v1 >>> v2,
  "&": (v1, v2) => v1 & v2,
  "^": (v1, v2) => v1 ^ v2,
  "|": (v1, v2) => v1 | v2,
};
let BinaryOperationNode$5 = class BinaryOperationNode2 {
  constructor(operator, left, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  evaluate() {
    const op = BINARY_OPERATION_MAP$5[this.operator];
    if (!op) {
      throw new Error(`unexpected binary operator: '${this.operator}`);
    }
    return op(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")",
    ].join(" ");
  }
};
const UNARY_OPERATION_MAP$5 = {
  "+": (v) => v,
  "-": (v) => -v,
  "~": (v) => ~v,
};
let UnaryOperationNode$5 = class UnaryOperationNode2 {
  constructor(operator, expr) {
    this.operator = operator;
    this.expression = expr;
  }
  evaluate() {
    const op = UNARY_OPERATION_MAP$5[this.operator];
    if (!op) {
      throw new Error(`unexpected unary operator: '${this.operator}`);
    }
    return op(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
};
function combineReader$5(parsers) {
  return (text, cursor) => {
    for (let i = 0; i < parsers.length; i++) {
      const result = parsers[i](text, cursor);
      if (result !== "") {
        return result;
      }
    }
    return "";
  };
}
function readWhitespace$5(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^\s+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readNonZeroDigit$5(text, cursor) {
  const ch = text.substr(cursor, 1);
  return ch.match(/^[1-9]$/) ? ch : "";
}
function readDecimalDigits$5(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readSignedInteger$5(text, cursor) {
  const ds = readDecimalDigits$5(text, cursor);
  if (ds !== "") {
    return ds;
  }
  const sign2 = text.substr(cursor, 1);
  cursor += 1;
  if (sign2 !== "-" && sign2 !== "+") {
    return "";
  }
  const sds = readDecimalDigits$5(text, cursor);
  if (sds === "") {
    return "";
  }
  return sign2 + sds;
}
function readExponentPart$5(text, cursor) {
  const e = text.substr(cursor, 1);
  cursor += 1;
  if (e.toLowerCase() !== "e") {
    return "";
  }
  const si = readSignedInteger$5(text, cursor);
  if (si === "") {
    return "";
  }
  return e + si;
}
function readDecimalIntegerLiteral$5(text, cursor) {
  const ch = text.substr(cursor, 1);
  if (ch === "0") {
    return ch;
  }
  const nzd = readNonZeroDigit$5(text, cursor);
  cursor += nzd.length;
  if (nzd === "") {
    return "";
  }
  return nzd + readDecimalDigits$5(text, cursor);
}
function readDecimalLiteral1$5(text, cursor) {
  const dil = readDecimalIntegerLiteral$5(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$5(text, cursor);
  cursor += dds.length;
  return dil + dot2 + dds + readExponentPart$5(text, cursor);
}
function readDecimalLiteral2$5(text, cursor) {
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$5(text, cursor);
  cursor += dds.length;
  if (dds === "") {
    return "";
  }
  return dot2 + dds + readExponentPart$5(text, cursor);
}
function readDecimalLiteral3$5(text, cursor) {
  const dil = readDecimalIntegerLiteral$5(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  return dil + readExponentPart$5(text, cursor);
}
const readDecimalLiteral$5 = combineReader$5([
  readDecimalLiteral1$5,
  readDecimalLiteral2$5,
  readDecimalLiteral3$5,
]);
function parseBinaryDigits$5(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[01]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readBinaryIntegerLiteral$5(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0b") {
    return "";
  }
  const bds = parseBinaryDigits$5(text, cursor);
  if (bds === "") {
    return "";
  }
  return prefix + bds;
}
function readOctalDigits$5(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-7]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readOctalIntegerLiteral$5(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0o") {
    return "";
  }
  const ods = readOctalDigits$5(text, cursor);
  if (ods === "") {
    return "";
  }
  return prefix + ods;
}
function readHexDigits$5(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9a-f]+/i);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readHexIntegerLiteral$5(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0x") {
    return "";
  }
  const hds = readHexDigits$5(text, cursor);
  if (hds === "") {
    return "";
  }
  return prefix + hds;
}
const readNonDecimalIntegerLiteral$5 = combineReader$5([
  readBinaryIntegerLiteral$5,
  readOctalIntegerLiteral$5,
  readHexIntegerLiteral$5,
]);
const readNumericLiteral$5 = combineReader$5([
  readNonDecimalIntegerLiteral$5,
  readDecimalLiteral$5,
]);
function parseLiteral$5(text, cursor) {
  const num = readNumericLiteral$5(text, cursor);
  cursor += num.length;
  if (num === "") {
    return null;
  }
  return {
    evaluable: new NumberLiteralNode$5(num),
    cursor,
  };
}
function parseParenthesizedExpression$5(text, cursor) {
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "(") {
    return null;
  }
  const expr = parseExpression$5(text, cursor);
  if (!expr) {
    return null;
  }
  cursor = expr.cursor;
  cursor += readWhitespace$5(text, cursor).length;
  const cl = text.substr(cursor, 1);
  cursor += cl.length;
  if (cl !== ")") {
    return null;
  }
  return {
    evaluable: expr.evaluable,
    cursor,
  };
}
function parsePrimaryExpression$5(text, cursor) {
  var _a;
  return (_a = parseLiteral$5(text, cursor)) !== null && _a !== void 0
    ? _a
    : parseParenthesizedExpression$5(text, cursor);
}
function parseUnaryExpression$5(text, cursor) {
  const expr = parsePrimaryExpression$5(text, cursor);
  if (expr) {
    return expr;
  }
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "+" && op !== "-" && op !== "~") {
    return null;
  }
  const num = parseUnaryExpression$5(text, cursor);
  if (!num) {
    return null;
  }
  cursor = num.cursor;
  return {
    cursor,
    evaluable: new UnaryOperationNode$5(op, num.evaluable),
  };
}
function readBinaryOperator$5(ops, text, cursor) {
  cursor += readWhitespace$5(text, cursor).length;
  const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
  if (!op) {
    return null;
  }
  cursor += op.length;
  cursor += readWhitespace$5(text, cursor).length;
  return {
    cursor,
    operator: op,
  };
}
function createBinaryOperationExpressionParser$5(exprParser, ops) {
  return (text, cursor) => {
    const firstExpr = exprParser(text, cursor);
    if (!firstExpr) {
      return null;
    }
    cursor = firstExpr.cursor;
    let expr = firstExpr.evaluable;
    for (;;) {
      const op = readBinaryOperator$5(ops, text, cursor);
      if (!op) {
        break;
      }
      cursor = op.cursor;
      const nextExpr = exprParser(text, cursor);
      if (!nextExpr) {
        return null;
      }
      cursor = nextExpr.cursor;
      expr = new BinaryOperationNode$5(op.operator, expr, nextExpr.evaluable);
    }
    return expr
      ? {
          cursor,
          evaluable: expr,
        }
      : null;
  };
}
const parseBinaryOperationExpression$5 = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"],
].reduce((parser, ops) => {
  return createBinaryOperationExpressionParser$5(parser, ops);
}, parseUnaryExpression$5);
function parseExpression$5(text, cursor) {
  cursor += readWhitespace$5(text, cursor).length;
  return parseBinaryOperationExpression$5(text, cursor);
}
function parseEcmaNumberExpression$5(text) {
  const expr = parseExpression$5(text, 0);
  if (!expr) {
    return null;
  }
  const cursor = expr.cursor + readWhitespace$5(text, expr.cursor).length;
  if (cursor !== text.length) {
    return null;
  }
  return expr.evaluable;
}
function parseNumber$5(text) {
  var _a;
  const r = parseEcmaNumberExpression$5(text);
  return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null &&
    _a !== void 0
    ? _a
    : null;
}
function numberFromUnknown$5(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const pv = parseNumber$5(value);
    if (!isEmpty$5(pv)) {
      return pv;
    }
  }
  return 0;
}
function createNumberFormatter$5(digits) {
  return (value) => {
    return value.toFixed(Math.max(Math.min(digits, 20), 0));
  };
}
function mapRange$5(value, start1, end1, start2, end2) {
  const p = (value - start1) / (end1 - start1);
  return start2 + p * (end2 - start2);
}
function getDecimalDigits$5(value) {
  const text = String(value.toFixed(10));
  const frac = text.split(".")[1];
  return frac.replace(/0+$/, "").length;
}
function constrainRange$5(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function loopRange$5(value, max) {
  return ((value % max) + max) % max;
}
function getSuitableDecimalDigits$5(params, rawValue) {
  return !isEmpty$5(params.step)
    ? getDecimalDigits$5(params.step)
    : Math.max(getDecimalDigits$5(rawValue), 2);
}
function getSuitableKeyScale$5(params) {
  var _a;
  return (_a = params.step) !== null && _a !== void 0 ? _a : 1;
}
function getSuitablePointerScale$5(params, rawValue) {
  var _a;
  const base2 = Math.abs(
    (_a = params.step) !== null && _a !== void 0 ? _a : rawValue,
  );
  return base2 === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base2)) - 1);
}
function createStepConstraint$5(params, initialValue) {
  if (!isEmpty$5(params.step)) {
    return new StepConstraint$5(params.step, initialValue);
  }
  return null;
}
function createRangeConstraint$5(params) {
  if (!isEmpty$5(params.max) && !isEmpty$5(params.min)) {
    return new DefiniteRangeConstraint$5({
      max: params.max,
      min: params.min,
    });
  }
  if (!isEmpty$5(params.max) || !isEmpty$5(params.min)) {
    return new RangeConstraint$5({
      max: params.max,
      min: params.min,
    });
  }
  return null;
}
function createNumberTextPropsObject$5(params, initialValue) {
  var _a, _b, _c;
  return {
    formatter:
      (_a = params.format) !== null && _a !== void 0
        ? _a
        : createNumberFormatter$5(
            getSuitableDecimalDigits$5(params, initialValue),
          ),
    keyScale:
      (_b = params.keyScale) !== null && _b !== void 0
        ? _b
        : getSuitableKeyScale$5(params),
    pointerScale:
      (_c = params.pointerScale) !== null && _c !== void 0
        ? _c
        : getSuitablePointerScale$5(params, initialValue),
  };
}
function createNumberTextInputParamsParser$5(p) {
  return {
    format: p.optional.function,
    keyScale: p.optional.number,
    max: p.optional.number,
    min: p.optional.number,
    pointerScale: p.optional.number,
    step: p.optional.number,
  };
}
function createPointAxis$5(config) {
  return {
    constraint: config.constraint,
    textProps: ValueMap$5.fromObject(
      createNumberTextPropsObject$5(config.params, config.initialValue),
    ),
  };
}
let BladeApi$5 = class BladeApi2 {
  constructor(controller) {
    this.controller = controller;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller.viewProps.set("disabled", disabled);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(hidden) {
    this.controller.viewProps.set("hidden", hidden);
  }
  dispose() {
    this.controller.viewProps.set("disposed", true);
  }
  importState(state) {
    return this.controller.importState(state);
  }
  exportState() {
    return this.controller.exportState();
  }
};
let TpEvent$5 = class TpEvent2 {
  constructor(target) {
    this.target = target;
  }
};
let TpChangeEvent$5 = class TpChangeEvent2 extends TpEvent$5 {
  constructor(target, value, last) {
    super(target);
    this.value = value;
    this.last = last !== null && last !== void 0 ? last : true;
  }
};
let TpFoldEvent$5 = class TpFoldEvent2 extends TpEvent$5 {
  constructor(target, expanded) {
    super(target);
    this.expanded = expanded;
  }
};
let TpTabSelectEvent$5 = class TpTabSelectEvent2 extends TpEvent$5 {
  constructor(target, index) {
    super(target);
    this.index = index;
  }
};
let BindingApi$5 = class BindingApi2 extends BladeApi$5 {
  constructor(controller) {
    super(controller);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.emitter_ = new Emitter$5();
    this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(tag) {
    this.controller.tag = tag;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(ev) {
    const value = this.controller.value;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$5(
        this,
        forceCast$5(value.binding.target.read()),
        ev.options.last,
      ),
    );
  }
};
function parseObject$5(value, keyToParserMap) {
  const keys = Object.keys(keyToParserMap);
  const result = keys.reduce((tmp2, key2) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const parser = keyToParserMap[key2];
    const result2 = parser(value[key2]);
    return result2.succeeded
      ? Object.assign(Object.assign({}, tmp2), { [key2]: result2.value })
      : void 0;
  }, {});
  return forceCast$5(result);
}
function parseArray$5(value, parseItem) {
  return value.reduce((tmp2, item) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const result = parseItem(item);
    if (!result.succeeded || result.value === void 0) {
      return void 0;
    }
    return [...tmp2, result.value];
  }, []);
}
function isObject$6(value) {
  if (value === null) {
    return false;
  }
  return typeof value === "object";
}
function createMicroParserBuilder$5(parse) {
  return (optional) => (v) => {
    if (!optional && v === void 0) {
      return {
        succeeded: false,
        value: void 0,
      };
    }
    if (optional && v === void 0) {
      return {
        succeeded: true,
        value: void 0,
      };
    }
    const result = parse(v);
    return result !== void 0
      ? {
          succeeded: true,
          value: result,
        }
      : {
          succeeded: false,
          value: void 0,
        };
  };
}
function createMicroParserBuilders$5(optional) {
  return {
    custom: (parse) => createMicroParserBuilder$5(parse)(optional),
    boolean: createMicroParserBuilder$5((v) =>
      typeof v === "boolean" ? v : void 0,
    )(optional),
    number: createMicroParserBuilder$5((v) =>
      typeof v === "number" ? v : void 0,
    )(optional),
    string: createMicroParserBuilder$5((v) =>
      typeof v === "string" ? v : void 0,
    )(optional),
    function: createMicroParserBuilder$5((v) =>
      typeof v === "function" ? v : void 0,
    )(optional),
    constant: (value) =>
      createMicroParserBuilder$5((v) => (v === value ? value : void 0))(
        optional,
      ),
    raw: createMicroParserBuilder$5((v) => v)(optional),
    object: (keyToParserMap) =>
      createMicroParserBuilder$5((v) => {
        if (!isObject$6(v)) {
          return void 0;
        }
        return parseObject$5(v, keyToParserMap);
      })(optional),
    array: (itemParser) =>
      createMicroParserBuilder$5((v) => {
        if (!Array.isArray(v)) {
          return void 0;
        }
        return parseArray$5(v, itemParser);
      })(optional),
  };
}
const MicroParsers$5 = {
  optional: createMicroParserBuilders$5(true),
  required: createMicroParserBuilders$5(false),
};
function parseRecord$5(value, keyToParserMap) {
  const map = keyToParserMap(MicroParsers$5);
  const result = MicroParsers$5.required.object(map)(value);
  return result.succeeded ? result.value : void 0;
}
function importBladeState$5(state, superImport, parser, callback) {
  if (superImport && !superImport(state)) {
    return false;
  }
  const result = parseRecord$5(state, parser);
  return result ? callback(result) : false;
}
function exportBladeState$5(superExport, thisState) {
  var _a;
  return deepMerge$5(
    (_a =
      superExport === null || superExport === void 0
        ? void 0
        : superExport()) !== null && _a !== void 0
      ? _a
      : {},
    thisState,
  );
}
function isValueBladeController$5(bc) {
  return "value" in bc;
}
function isBindingValue$5(v) {
  if (!isObject$1$5(v) || !("binding" in v)) {
    return false;
  }
  const b = v.binding;
  return isBinding$5(b);
}
const SVG_NS$5 = "http://www.w3.org/2000/svg";
function forceReflow$5(element) {
  element.offsetHeight;
}
function disableTransitionTemporarily$5(element, callback) {
  const t = element.style.transition;
  element.style.transition = "none";
  callback();
  element.style.transition = t;
}
function supportsTouch$5(doc) {
  return doc.ontouchstart !== void 0;
}
function getCanvasContext$5(canvasElement) {
  const win = canvasElement.ownerDocument.defaultView;
  if (!win) {
    return null;
  }
  const isBrowser = "document" in win;
  return isBrowser
    ? canvasElement.getContext("2d", {
        willReadFrequently: true,
      })
    : null;
}
const ICON_ID_TO_INNER_HTML_MAP$5 = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad:
    '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function createSvgIconElement$5(document2, iconId) {
  const elem = document2.createElementNS(SVG_NS$5, "svg");
  elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP$5[iconId];
  return elem;
}
function insertElementAt$5(parentElement, element, index) {
  parentElement.insertBefore(element, parentElement.children[index]);
}
function removeElement$5(element) {
  if (element.parentElement) {
    element.parentElement.removeChild(element);
  }
}
function removeChildElements$5(element) {
  while (element.children.length > 0) {
    element.removeChild(element.children[0]);
  }
}
function removeChildNodes$5(element) {
  while (element.childNodes.length > 0) {
    element.removeChild(element.childNodes[0]);
  }
}
function findNextTarget$5(ev) {
  if (ev.relatedTarget) {
    return forceCast$5(ev.relatedTarget);
  }
  if ("explicitOriginalTarget" in ev) {
    return ev.explicitOriginalTarget;
  }
  return null;
}
function bindValue$5(value, applyValue) {
  value.emitter.on("change", (ev) => {
    applyValue(ev.rawValue);
  });
  applyValue(value.rawValue);
}
function bindValueMap$5(valueMap, key2, applyValue) {
  bindValue$5(valueMap.value(key2), applyValue);
}
const PREFIX$5 = "tp";
function ClassName$5(viewName) {
  const fn = (opt_elementName, opt_modifier) => {
    return [
      PREFIX$5,
      "-",
      viewName,
      "v",
      opt_elementName ? `_${opt_elementName}` : "",
      opt_modifier ? `-${opt_modifier}` : "",
    ].join("");
  };
  return fn;
}
const cn$q$5 = ClassName$5("lbl");
function createLabelNode$5(doc, label) {
  const frag = doc.createDocumentFragment();
  const lineNodes = label.split("\n").map((line) => {
    return doc.createTextNode(line);
  });
  lineNodes.forEach((lineNode, index) => {
    if (index > 0) {
      frag.appendChild(doc.createElement("br"));
    }
    frag.appendChild(lineNode);
  });
  return frag;
}
let LabelView$5 = class LabelView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$q$5());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("div");
    labelElem.classList.add(cn$q$5("l"));
    bindValueMap$5(config.props, "label", (value) => {
      if (isEmpty$5(value)) {
        this.element.classList.add(cn$q$5(void 0, "nol"));
      } else {
        this.element.classList.remove(cn$q$5(void 0, "nol"));
        removeChildNodes$5(labelElem);
        labelElem.appendChild(createLabelNode$5(doc, value));
      }
    });
    this.element.appendChild(labelElem);
    this.labelElement = labelElem;
    const valueElem = doc.createElement("div");
    valueElem.classList.add(cn$q$5("v"));
    this.element.appendChild(valueElem);
    this.valueElement = valueElem;
  }
};
let LabelController$5 = class LabelController2 {
  constructor(doc, config) {
    this.props = config.props;
    this.valueController = config.valueController;
    this.viewProps = config.valueController.viewProps;
    this.view = new LabelView$5(doc, {
      props: config.props,
      viewProps: this.viewProps,
    });
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(state) {
    return importBladeState$5(
      state,
      null,
      (p) => ({
        label: p.optional.string,
      }),
      (result) => {
        this.props.set("label", result.label);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$5(null, {
      label: this.props.get("label"),
    });
  }
};
function getAllBladePositions$5() {
  return ["veryfirst", "first", "last", "verylast"];
}
const cn$p$5 = ClassName$5("");
const POS_TO_CLASS_NAME_MAP$5 = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst",
};
let BladeController$5 = class BladeController2 {
  constructor(config) {
    this.parent_ = null;
    this.blade = config.blade;
    this.view = config.view;
    this.viewProps = config.viewProps;
    const elem = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      getAllBladePositions$5().forEach((pos) => {
        elem.classList.remove(cn$p$5(void 0, POS_TO_CLASS_NAME_MAP$5[pos]));
      });
      this.blade.get("positions").forEach((pos) => {
        elem.classList.add(cn$p$5(void 0, POS_TO_CLASS_NAME_MAP$5[pos]));
      });
    });
    this.viewProps.handleDispose(() => {
      removeElement$5(elem);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(parent) {
    this.parent_ = parent;
    this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(state) {
    return importBladeState$5(
      state,
      null,
      (p) => ({
        disabled: p.required.boolean,
        hidden: p.required.boolean,
      }),
      (result) => {
        this.viewProps.importState(result);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$5(
      null,
      Object.assign({}, this.viewProps.exportState()),
    );
  }
};
let ButtonApi$5 = class ButtonApi2 extends BladeApi$5 {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get title() {
    var _a;
    return (_a = this.controller.buttonController.props.get("title")) !==
      null && _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.buttonController.props.set("title", title);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller.buttonController.emitter;
    emitter.on(eventName, () => {
      bh(new TpEvent$5(this));
    });
    return this;
  }
};
function applyClass$5(elem, className2, active) {
  if (active) {
    elem.classList.add(className2);
  } else {
    elem.classList.remove(className2);
  }
}
function valueToClassName$5(elem, className2) {
  return (value) => {
    applyClass$5(elem, className2, value);
  };
}
function bindValueToTextContent$5(value, elem) {
  bindValue$5(value, (text) => {
    elem.textContent = text !== null && text !== void 0 ? text : "";
  });
}
const cn$o$5 = ClassName$5("btn");
let ButtonView$5 = class ButtonView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$o$5());
    config.viewProps.bindClassModifiers(this.element);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$o$5("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$o$5("t"));
    bindValueToTextContent$5(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
  }
};
let ButtonController$5 = class ButtonController2 {
  constructor(doc, config) {
    this.emitter = new Emitter$5();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new ButtonView$5(doc, {
      props: this.props,
      viewProps: this.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(state) {
    return importBladeState$5(
      state,
      null,
      (p) => ({
        title: p.optional.string,
      }),
      (result) => {
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$5(null, {
      title: this.props.get("title"),
    });
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let ButtonBladeController$5 = class ButtonBladeController2 extends BladeController$5 {
  constructor(doc, config) {
    const bc = new ButtonController$5(doc, {
      props: config.buttonProps,
      viewProps: config.viewProps,
    });
    const lc = new LabelController$5(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: config.viewProps,
    });
    this.buttonController = bc;
    this.labelController = lc;
  }
  importState(state) {
    return importBladeState$5(
      state,
      (s) =>
        super.importState(s) &&
        this.buttonController.importProps(s) &&
        this.labelController.importProps(s),
      () => ({}),
      () => true,
    );
  }
  exportState() {
    return exportBladeState$5(
      () => super.exportState(),
      Object.assign(
        Object.assign({}, this.buttonController.exportProps()),
        this.labelController.exportProps(),
      ),
    );
  }
};
let Semver$5 = class Semver2 {
  constructor(text) {
    const [core, prerelease] = text.split("-");
    const coreComps = core.split(".");
    this.major = parseInt(coreComps[0], 10);
    this.minor = parseInt(coreComps[1], 10);
    this.patch = parseInt(coreComps[2], 10);
    this.prerelease =
      prerelease !== null && prerelease !== void 0 ? prerelease : null;
  }
  toString() {
    const core = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
  }
};
const VERSION$5 = new Semver$5("2.0.1");
function createPlugin$5(plugin) {
  return Object.assign({ core: VERSION$5 }, plugin);
}
createPlugin$5({
  id: "button",
  type: "blade",
  accept(params) {
    const result = parseRecord$5(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("button"),
      label: p.optional.string,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new ButtonBladeController$5(args.document, {
      blade: args.blade,
      buttonProps: ValueMap$5.fromObject({
        title: args.params.title,
      }),
      labelProps: ValueMap$5.fromObject({
        label: args.params.label,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (args.controller instanceof ButtonBladeController$5) {
      return new ButtonApi$5(args.controller);
    }
    return null;
  },
});
function addButtonAsBlade$5(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "button" }),
  );
}
function addFolderAsBlade$5(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "folder" }),
  );
}
function addTabAsBlade$5(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "tab" }),
  );
}
function isRefreshable$5(value) {
  if (!isObject$1$5(value)) {
    return false;
  }
  return "refresh" in value && typeof value.refresh === "function";
}
function createBindingTarget$5(obj, key2) {
  if (!BindingTarget$5.isBindable(obj)) {
    throw TpError$5.notBindable();
  }
  return new BindingTarget$5(obj, key2);
}
let RackApi$5 = class RackApi2 {
  constructor(controller, pool) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.controller_ = controller;
    this.emitter_ = new Emitter$5();
    this.pool_ = pool;
    const rack = this.controller_.rack;
    rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((bc) => this.pool_.createApi(bc));
  }
  addBinding(object, key2, opt_params) {
    const params =
      opt_params !== null && opt_params !== void 0 ? opt_params : {};
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBinding(
      doc,
      createBindingTarget$5(object, key2),
      params,
    );
    const api = this.pool_.createBindingApi(bc);
    return this.add(api, params.index);
  }
  addFolder(params) {
    return addFolderAsBlade$5(this, params);
  }
  addButton(params) {
    return addButtonAsBlade$5(this, params);
  }
  addTab(params) {
    return addTabAsBlade$5(this, params);
  }
  add(api, opt_index) {
    const bc = api.controller;
    this.controller_.rack.add(bc, opt_index);
    return api;
  }
  remove(api) {
    this.controller_.rack.remove(api.controller);
  }
  addBlade(params) {
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBlade(doc, params);
    const api = this.pool_.createApi(bc);
    return this.add(api, params.index);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.children.forEach((c) => {
      if (isRefreshable$5(c)) {
        c.refresh();
      }
    });
  }
  onRackValueChange_(ev) {
    const bc = ev.bladeController;
    const api = this.pool_.createApi(bc);
    const binding = isBindingValue$5(bc.value) ? bc.value.binding : null;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$5(
        api,
        binding ? binding.target.read() : bc.value.rawValue,
        ev.options.last,
      ),
    );
  }
};
let ContainerBladeApi$5 = class ContainerBladeApi2 extends BladeApi$5 {
  constructor(controller, pool) {
    super(controller);
    this.rackApi_ = new RackApi$5(controller.rackController, pool);
  }
  refresh() {
    this.rackApi_.refresh();
  }
};
let ContainerBladeController$5 = class ContainerBladeController2 extends BladeController$5 {
  constructor(config) {
    super({
      blade: config.blade,
      view: config.view,
      viewProps: config.rackController.viewProps,
    });
    this.rackController = config.rackController;
  }
  importState(state) {
    return importBladeState$5(
      state,
      (s) => super.importState(s),
      (p) => ({
        children: p.required.array(p.required.raw),
      }),
      (result) => {
        return this.rackController.rack.children.every((c, index) => {
          return c.importState(result.children[index]);
        });
      },
    );
  }
  exportState() {
    return exportBladeState$5(() => super.exportState(), {
      children: this.rackController.rack.children.map((c) => c.exportState()),
    });
  }
};
function isContainerBladeController$5(bc) {
  return "rackController" in bc;
}
let NestedOrderedSet$5 = class NestedOrderedSet2 {
  constructor(extract) {
    this.emitter = new Emitter$5();
    this.items_ = [];
    this.cache_ = /* @__PURE__ */ new Set();
    this.onSubListAdd_ = this.onSubListAdd_.bind(this);
    this.onSubListRemove_ = this.onSubListRemove_.bind(this);
    this.extract_ = extract;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(callback) {
    for (const item of this.allItems()) {
      if (callback(item)) {
        return item;
      }
    }
    return null;
  }
  includes(item) {
    return this.cache_.has(item);
  }
  add(item, opt_index) {
    if (this.includes(item)) {
      throw TpError$5.shouldNeverHappen();
    }
    const index = opt_index !== void 0 ? opt_index : this.items_.length;
    this.items_.splice(index, 0, item);
    this.cache_.add(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.emitter.on("add", this.onSubListAdd_);
      subList.emitter.on("remove", this.onSubListRemove_);
      subList.allItems().forEach((i) => {
        this.cache_.add(i);
      });
    }
    this.emitter.emit("add", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    this.cache_.delete(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.allItems().forEach((i) => {
        this.cache_.delete(i);
      });
      subList.emitter.off("add", this.onSubListAdd_);
      subList.emitter.off("remove", this.onSubListRemove_);
    }
    this.emitter.emit("remove", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  onSubListAdd_(ev) {
    this.cache_.add(ev.item);
    this.emitter.emit("add", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
  onSubListRemove_(ev) {
    this.cache_.delete(ev.item);
    this.emitter.emit("remove", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
};
function findValueBladeController$5(bcs, v) {
  for (let i = 0; i < bcs.length; i++) {
    const bc = bcs[i];
    if (isValueBladeController$5(bc) && bc.value === v) {
      return bc;
    }
  }
  return null;
}
function findSubBladeControllerSet$5(bc) {
  return isContainerBladeController$5(bc)
    ? bc.rackController.rack["bcSet_"]
    : null;
}
let Rack$5 = class Rack2 {
  constructor(config) {
    var _a, _b;
    this.emitter = new Emitter$5();
    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
    this.onSetAdd_ = this.onSetAdd_.bind(this);
    this.onSetRemove_ = this.onSetRemove_.bind(this);
    this.onChildDispose_ = this.onChildDispose_.bind(this);
    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
    this.onChildValueChange_ = this.onChildValueChange_.bind(this);
    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
    this.onRackLayout_ = this.onRackLayout_.bind(this);
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
    (_b = this.blade_) === null || _b === void 0
      ? void 0
      : _b
          .value("positions")
          .emitter.on("change", this.onBladePositionsChange_);
    this.viewProps = config.viewProps;
    this.bcSet_ = new NestedOrderedSet$5(findSubBladeControllerSet$5);
    this.bcSet_.emitter.on("add", this.onSetAdd_);
    this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(bc, opt_index) {
    var _a;
    (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
    bc.parent = this;
    this.bcSet_.add(bc, opt_index);
  }
  remove(bc) {
    bc.parent = null;
    this.bcSet_.remove(bc);
  }
  find(finder) {
    return this.bcSet_.allItems().filter(finder);
  }
  onSetAdd_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("add", {
      bladeController: ev.item,
      index: ev.index,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
    bc.blade
      .value("positions")
      .emitter.on("change", this.onChildPositionsChange_);
    bc.viewProps.handleDispose(this.onChildDispose_);
    if (isValueBladeController$5(bc)) {
      bc.value.emitter.on("change", this.onChildValueChange_);
    } else if (isContainerBladeController$5(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.on("layout", this.onRackLayout_);
        emitter.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("remove", {
      bladeController: ev.item,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    if (isValueBladeController$5(bc)) {
      bc.value.emitter.off("change", this.onChildValueChange_);
    } else if (isContainerBladeController$5(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.off("layout", this.onRackLayout_);
        emitter.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const visibleItems = this.bcSet_.items.filter(
      (bc) => !bc.viewProps.get("hidden"),
    );
    const firstVisibleItem = visibleItems[0];
    const lastVisibleItem = visibleItems[visibleItems.length - 1];
    this.bcSet_.items.forEach((bc) => {
      const ps = [];
      if (bc === firstVisibleItem) {
        ps.push("first");
        if (
          !this.blade_ ||
          this.blade_.get("positions").includes("veryfirst")
        ) {
          ps.push("veryfirst");
        }
      }
      if (bc === lastVisibleItem) {
        ps.push("last");
        if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
          ps.push("verylast");
        }
      }
      bc.blade.set("positions", ps);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildViewPropsChange_(_ev) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildDispose_() {
    const disposedUcs = this.bcSet_.items.filter((bc) => {
      return bc.viewProps.get("disposed");
    });
    disposedUcs.forEach((bc) => {
      this.bcSet_.remove(bc);
    });
  }
  onChildValueChange_(ev) {
    const bc = findValueBladeController$5(
      this.find(isValueBladeController$5),
      ev.sender,
    );
    if (!bc) {
      throw TpError$5.alreadyDisposed();
    }
    this.emitter.emit("valuechange", {
      bladeController: bc,
      options: ev.options,
      sender: this,
    });
  }
  onRackLayout_(_) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onRackValueChange_(ev) {
    this.emitter.emit("valuechange", {
      bladeController: ev.bladeController,
      options: ev.options,
      sender: this,
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
};
let RackController$5 = class RackController2 {
  constructor(config) {
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    this.element = config.element;
    this.viewProps = config.viewProps;
    const rack = new Rack$5({
      blade: config.root ? void 0 : config.blade,
      viewProps: config.viewProps,
    });
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.rack = rack;
    this.viewProps.handleDispose(() => {
      for (let i = this.rack.children.length - 1; i >= 0; i--) {
        const bc = this.rack.children[i];
        bc.viewProps.set("disposed", true);
      }
    });
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    insertElementAt$5(this.element, ev.bladeController.view.element, ev.index);
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    removeElement$5(ev.bladeController.view.element);
  }
};
function createBlade$5() {
  return new ValueMap$5({
    positions: createValue$5([], {
      equals: deepEqualsArray$5,
    }),
  });
}
let Foldable$5 = class Foldable2 extends ValueMap$5 {
  constructor(valueMap) {
    super(valueMap);
  }
  static create(expanded) {
    const coreObj = {
      completed: true,
      expanded,
      expandedHeight: null,
      shouldFixHeight: false,
      temporaryExpanded: null,
    };
    const core = ValueMap$5.createCore(coreObj);
    return new Foldable2(core);
  }
  get styleExpanded() {
    var _a;
    return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0
      ? _a
      : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded) {
      return "0";
    }
    const exHeight = this.get("expandedHeight");
    if (this.get("shouldFixHeight") && !isEmpty$5(exHeight)) {
      return `${exHeight}px`;
    }
    return "auto";
  }
  bindExpandedClass(elem, expandedClassName) {
    const onExpand = () => {
      const expanded = this.styleExpanded;
      if (expanded) {
        elem.classList.add(expandedClassName);
      } else {
        elem.classList.remove(expandedClassName);
      }
    };
    bindValueMap$5(this, "expanded", onExpand);
    bindValueMap$5(this, "temporaryExpanded", onExpand);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", false);
    this.set("expandedHeight", null);
    this.set("completed", true);
  }
};
function computeExpandedFolderHeight$5(folder, containerElement) {
  let height = 0;
  disableTransitionTemporarily$5(containerElement, () => {
    folder.set("expandedHeight", null);
    folder.set("temporaryExpanded", true);
    forceReflow$5(containerElement);
    height = containerElement.clientHeight;
    folder.set("temporaryExpanded", null);
    forceReflow$5(containerElement);
  });
  return height;
}
function applyHeight$5(foldable, elem) {
  elem.style.height = foldable.styleHeight;
}
function bindFoldable$5(foldable, elem) {
  foldable.value("expanded").emitter.on("beforechange", () => {
    foldable.set("completed", false);
    if (isEmpty$5(foldable.get("expandedHeight"))) {
      const h = computeExpandedFolderHeight$5(foldable, elem);
      if (h > 0) {
        foldable.set("expandedHeight", h);
      }
    }
    foldable.set("shouldFixHeight", true);
    forceReflow$5(elem);
  });
  foldable.emitter.on("change", () => {
    applyHeight$5(foldable, elem);
  });
  applyHeight$5(foldable, elem);
  elem.addEventListener("transitionend", (ev) => {
    if (ev.propertyName !== "height") {
      return;
    }
    foldable.cleanUpTransition();
  });
}
let FolderApi$5 = class FolderApi2 extends ContainerBladeApi$5 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$5();
    this.controller.foldable.value("expanded").emitter.on("change", (ev) => {
      this.emitter_.emit("fold", new TpFoldEvent$5(this, ev.sender.rawValue));
    });
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(expanded) {
    this.controller.foldable.set("expanded", expanded);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(title) {
    this.controller.props.set("title", title);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    return this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
};
const bladeContainerClassName$5 = ClassName$5("cnt");
let FolderView$5 = class FolderView2 {
  constructor(doc, config) {
    var _a;
    this.className_ = ClassName$5(
      (_a = config.viewName) !== null && _a !== void 0 ? _a : "fld",
    );
    this.element = doc.createElement("div");
    this.element.classList.add(this.className_(), bladeContainerClassName$5());
    config.viewProps.bindClassModifiers(this.element);
    this.foldable_ = config.foldable;
    this.foldable_.bindExpandedClass(
      this.element,
      this.className_(void 0, "expanded"),
    );
    bindValueMap$5(
      this.foldable_,
      "completed",
      valueToClassName$5(this.element, this.className_(void 0, "cpl")),
    );
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(this.className_("b"));
    bindValueMap$5(config.props, "title", (title) => {
      if (isEmpty$5(title)) {
        this.element.classList.add(this.className_(void 0, "not"));
      } else {
        this.element.classList.remove(this.className_(void 0, "not"));
      }
    });
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(this.className_("i"));
    this.element.appendChild(indentElem);
    const titleElem = doc.createElement("div");
    titleElem.classList.add(this.className_("t"));
    bindValueToTextContent$5(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(this.className_("m"));
    this.buttonElement.appendChild(markElem);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(this.className_("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
let FolderController$5 = class FolderController2 extends ContainerBladeController$5 {
  constructor(doc, config) {
    var _a;
    const foldable = Foldable$5.create(
      (_a = config.expanded) !== null && _a !== void 0 ? _a : true,
    );
    const view = new FolderView$5(doc, {
      foldable,
      props: config.props,
      viewName: config.root ? "rot" : void 0,
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$5({
          blade: config.blade,
          element: view.containerElement,
          root: config.root,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onTitleClick_ = this.onTitleClick_.bind(this);
    this.props = config.props;
    this.foldable = foldable;
    bindFoldable$5(this.foldable, this.view.containerElement);
    this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    });
    this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    });
    this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(state) {
    return importBladeState$5(
      state,
      (s) => super.importState(s),
      (p) => ({
        expanded: p.required.boolean,
        title: p.optional.string,
      }),
      (result) => {
        this.foldable.set("expanded", result.expanded);
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$5(() => super.exportState(), {
      expanded: this.foldable.get("expanded"),
      title: this.props.get("title"),
    });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
};
createPlugin$5({
  id: "folder",
  type: "blade",
  accept(params) {
    const result = parseRecord$5(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("folder"),
      expanded: p.optional.boolean,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new FolderController$5(args.document, {
      blade: args.blade,
      expanded: args.params.expanded,
      props: ValueMap$5.fromObject({
        title: args.params.title,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (!(args.controller instanceof FolderController$5)) {
      return null;
    }
    return new FolderApi$5(args.controller, args.pool);
  },
});
const cn$n$5 = ClassName$5("");
function valueToModifier$5(elem, modifier) {
  return valueToClassName$5(elem, cn$n$5(void 0, modifier));
}
let ViewProps$5 = class ViewProps2 extends ValueMap$5 {
  constructor(valueMap) {
    var _a;
    super(valueMap);
    this.onDisabledChange_ = this.onDisabledChange_.bind(this);
    this.onParentChange_ = this.onParentChange_.bind(this);
    this.onParentGlobalDisabledChange_ =
      this.onParentGlobalDisabledChange_.bind(this);
    [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue$5(
      createValue$5(this.getGlobalDisabled_()),
    );
    this.value("disabled").emitter.on("change", this.onDisabledChange_);
    this.value("parent").emitter.on("change", this.onParentChange_);
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
  }
  static create(opt_initialValue) {
    var _a, _b, _c;
    const initialValue =
      opt_initialValue !== null && opt_initialValue !== void 0
        ? opt_initialValue
        : {};
    return new ViewProps2(
      ValueMap$5.createCore({
        disabled:
          (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
        disposed: false,
        hidden:
          (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
        parent:
          (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null,
      }),
    );
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(elem) {
    bindValue$5(this.globalDisabled_, valueToModifier$5(elem, "disabled"));
    bindValueMap$5(this, "hidden", valueToModifier$5(elem, "hidden"));
  }
  bindDisabled(target) {
    bindValue$5(this.globalDisabled_, (disabled) => {
      target.disabled = disabled;
    });
  }
  bindTabIndex(elem) {
    bindValue$5(this.globalDisabled_, (disabled) => {
      elem.tabIndex = disabled ? -1 : 0;
    });
  }
  handleDispose(callback) {
    this.value("disposed").emitter.on("change", (disposed) => {
      if (disposed) {
        callback();
      }
    });
  }
  importState(state) {
    this.set("disabled", state.disabled);
    this.set("hidden", state.hidden);
  }
  exportState() {
    return {
      disabled: this.get("disabled"),
      hidden: this.get("hidden"),
    };
  }
  getGlobalDisabled_() {
    const parent = this.get("parent");
    const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
    return parentDisabled || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(ev) {
    var _a;
    const prevParent = ev.previousRawValue;
    prevParent === null || prevParent === void 0
      ? void 0
      : prevParent.globalDisabled.emitter.off(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    this.updateGlobalDisabled_();
  }
};
const cn$m$5 = ClassName$5("tbp");
let TabPageView$5 = class TabPageView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$m$5());
    config.viewProps.bindClassModifiers(this.element);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(cn$m$5("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
const cn$l$5 = ClassName$5("tbi");
let TabItemView$5 = class TabItemView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$l$5());
    config.viewProps.bindClassModifiers(this.element);
    bindValueMap$5(config.props, "selected", (selected) => {
      if (selected) {
        this.element.classList.add(cn$l$5(void 0, "sel"));
      } else {
        this.element.classList.remove(cn$l$5(void 0, "sel"));
      }
    });
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$l$5("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$l$5("t"));
    bindValueToTextContent$5(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
  }
};
let TabItemController$5 = class TabItemController2 {
  constructor(doc, config) {
    this.emitter = new Emitter$5();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new TabItemView$5(doc, {
      props: config.props,
      viewProps: config.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let TabPageController$5 = class TabPageController2 extends ContainerBladeController$5 {
  constructor(doc, config) {
    const view = new TabPageView$5(doc, {
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$5({
          blade: config.blade,
          element: view.containerElement,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onItemClick_ = this.onItemClick_.bind(this);
    this.ic_ = new TabItemController$5(doc, {
      props: config.itemProps,
      viewProps: ViewProps$5.create(),
    });
    this.ic_.emitter.on("click", this.onItemClick_);
    this.props = config.props;
    bindValueMap$5(this.props, "selected", (selected) => {
      this.itemController.props.set("selected", selected);
      this.viewProps.set("hidden", !selected);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(state) {
    return importBladeState$5(
      state,
      (s) => super.importState(s),
      (p) => ({
        selected: p.required.boolean,
        title: p.required.string,
      }),
      (result) => {
        this.ic_.props.set("selected", result.selected);
        this.ic_.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$5(() => super.exportState(), {
      selected: this.ic_.props.get("selected"),
      title: this.ic_.props.get("title"),
    });
  }
  onItemClick_() {
    this.props.set("selected", true);
  }
};
let TabApi$5 = class TabApi2 extends ContainerBladeApi$5 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$5();
    this.onSelect_ = this.onSelect_.bind(this);
    this.pool_ = pool;
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
    this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(params) {
    const doc = this.controller.view.element.ownerDocument;
    const pc = new TabPageController$5(doc, {
      blade: createBlade$5(),
      itemProps: ValueMap$5.fromObject({
        selected: false,
        title: params.title,
      }),
      props: ValueMap$5.fromObject({
        selected: false,
      }),
      viewProps: ViewProps$5.create(),
    });
    const papi = this.pool_.createApi(pc);
    return this.rackApi_.add(papi, params.index);
  }
  removePage(index) {
    this.rackApi_.remove(this.rackApi_.children[index]);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  onSelect_(ev) {
    this.emitter_.emit("select", new TpTabSelectEvent$5(this, ev.rawValue));
  }
};
let TabPageApi$5 = class TabPageApi2 extends ContainerBladeApi$5 {
  get title() {
    var _a;
    return (_a = this.controller.itemController.props.get("title")) !== null &&
      _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.itemController.props.set("title", title);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(selected) {
    this.controller.props.set("selected", selected);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
};
const INDEX_NOT_SELECTED$5 = -1;
let Tab$5 = class Tab2 {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
    this.empty = createValue$5(true);
    this.selectedIndex = createValue$5(INDEX_NOT_SELECTED$5);
    this.items_ = [];
  }
  add(item, opt_index) {
    const index =
      opt_index !== null && opt_index !== void 0
        ? opt_index
        : this.items_.length;
    this.items_.splice(index, 0, item);
    item.emitter.on("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    item.emitter.off("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = INDEX_NOT_SELECTED$5;
      this.empty.rawValue = true;
      return;
    }
    const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
    if (firstSelIndex < 0) {
      this.items_.forEach((s, i) => {
        s.rawValue = i === 0;
      });
      this.selectedIndex.rawValue = 0;
    } else {
      this.items_.forEach((s, i) => {
        s.rawValue = i === firstSelIndex;
      });
      this.selectedIndex.rawValue = firstSelIndex;
    }
    this.empty.rawValue = false;
  }
  onItemSelectedChange_(ev) {
    if (ev.rawValue) {
      const index = this.items_.findIndex((s) => s === ev.sender);
      this.items_.forEach((s, i) => {
        s.rawValue = i === index;
      });
      this.selectedIndex.rawValue = index;
    } else {
      this.keepSelection_();
    }
  }
};
const cn$k$5 = ClassName$5("tab");
let TabView$5 = class TabView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$k$5(), bladeContainerClassName$5());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$5(
      config.empty,
      valueToClassName$5(this.element, cn$k$5(void 0, "nop")),
    );
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$k$5("t"));
    this.element.appendChild(titleElem);
    this.itemsElement = titleElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(cn$k$5("i"));
    this.element.appendChild(indentElem);
    const contentsElem = doc.createElement("div");
    contentsElem.classList.add(cn$k$5("c"));
    this.element.appendChild(contentsElem);
    this.contentsElement = contentsElem;
  }
};
let TabController$5 = class TabController2 extends ContainerBladeController$5 {
  constructor(doc, config) {
    const tab = new Tab$5();
    const view = new TabView$5(doc, {
      empty: tab.empty,
      viewProps: config.viewProps,
    });
    super({
      blade: config.blade,
      rackController: new RackController$5({
        blade: config.blade,
        element: view.contentsElement,
        viewProps: config.viewProps,
      }),
      view,
    });
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    const rack = this.rackController.rack;
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.tab = tab;
  }
  add(pc, opt_index) {
    this.rackController.rack.add(pc, opt_index);
  }
  remove(index) {
    this.rackController.rack.remove(this.rackController.rack.children[index]);
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    insertElementAt$5(
      this.view.itemsElement,
      pc.itemController.view.element,
      ev.index,
    );
    pc.itemController.viewProps.set("parent", this.viewProps);
    this.tab.add(pc.props.value("selected"));
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    removeElement$5(pc.itemController.view.element);
    pc.itemController.viewProps.set("parent", null);
    this.tab.remove(pc.props.value("selected"));
  }
};
createPlugin$5({
  id: "tab",
  type: "blade",
  accept(params) {
    const result = parseRecord$5(params, (p) => ({
      pages: p.required.array(p.required.object({ title: p.required.string })),
      view: p.required.constant("tab"),
    }));
    if (!result || result.pages.length === 0) {
      return null;
    }
    return { params: result };
  },
  controller(args) {
    const c = new TabController$5(args.document, {
      blade: args.blade,
      viewProps: args.viewProps,
    });
    args.params.pages.forEach((p) => {
      const pc = new TabPageController$5(args.document, {
        blade: createBlade$5(),
        itemProps: ValueMap$5.fromObject({
          selected: false,
          title: p.title,
        }),
        props: ValueMap$5.fromObject({
          selected: false,
        }),
        viewProps: ViewProps$5.create(),
      });
      c.add(pc);
    });
    return c;
  },
  api(args) {
    if (args.controller instanceof TabController$5) {
      return new TabApi$5(args.controller, args.pool);
    }
    if (args.controller instanceof TabPageController$5) {
      return new TabPageApi$5(args.controller, args.pool);
    }
    return null;
  },
});
let ListInputBindingApi$5 = class ListInputBindingApi2 extends BindingApi$5 {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(options) {
    this.controller.valueController.props.set("options", options);
  }
};
let CompositeConstraint$5 = class CompositeConstraint2 {
  constructor(constraints) {
    this.constraints = constraints;
  }
  constrain(value) {
    return this.constraints.reduce((result, c) => {
      return c.constrain(result);
    }, value);
  }
};
function findConstraint$5(c, constraintClass) {
  if (c instanceof constraintClass) {
    return c;
  }
  if (c instanceof CompositeConstraint$5) {
    const result = c.constraints.reduce((tmpResult, sc) => {
      if (tmpResult) {
        return tmpResult;
      }
      return sc instanceof constraintClass ? sc : null;
    }, null);
    if (result) {
      return result;
    }
  }
  return null;
}
let ListConstraint$5 = class ListConstraint2 {
  constructor(options) {
    this.values = ValueMap$5.fromObject({
      options,
    });
  }
  constrain(value) {
    const opts = this.values.get("options");
    if (opts.length === 0) {
      return value;
    }
    const matched =
      opts.filter((item) => {
        return item.value === value;
      }).length > 0;
    return matched ? value : opts[0].value;
  }
};
function parseListOptions$5(value) {
  var _a;
  const p = MicroParsers$5;
  if (Array.isArray(value)) {
    return (_a = parseRecord$5({ items: value }, (p2) => ({
      items: p2.required.array(
        p2.required.object({
          text: p2.required.string,
          value: p2.required.raw,
        }),
      ),
    }))) === null || _a === void 0
      ? void 0
      : _a.items;
  }
  if (typeof value === "object") {
    return p.required.raw(value).value;
  }
  return void 0;
}
function normalizeListOptions$5(options) {
  if (Array.isArray(options)) {
    return options;
  }
  const items = [];
  Object.keys(options).forEach((text) => {
    items.push({ text, value: options[text] });
  });
  return items;
}
function createListConstraint$5(options) {
  return !isEmpty$5(options)
    ? new ListConstraint$5(normalizeListOptions$5(forceCast$5(options)))
    : null;
}
const cn$j$5 = ClassName$5("lst");
let ListView$5 = class ListView2 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$j$5());
    config.viewProps.bindClassModifiers(this.element);
    const selectElem = doc.createElement("select");
    selectElem.classList.add(cn$j$5("s"));
    config.viewProps.bindDisabled(selectElem);
    this.element.appendChild(selectElem);
    this.selectElement = selectElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(cn$j$5("m"));
    markElem.appendChild(createSvgIconElement$5(doc, "dropdown"));
    this.element.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value_ = config.value;
    bindValueMap$5(this.props_, "options", (opts) => {
      removeChildElements$5(this.selectElement);
      opts.forEach((item) => {
        const optionElem = doc.createElement("option");
        optionElem.textContent = item.text;
        this.selectElement.appendChild(optionElem);
      });
      this.update_();
    });
  }
  update_() {
    const values = this.props_.get("options").map((o) => o.value);
    this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
};
let ListController$5 = class ListController2 {
  constructor(doc, config) {
    this.onSelectChange_ = this.onSelectChange_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ListView$5(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const selectElem = forceCast$5(e.currentTarget);
    this.value.rawValue =
      this.props.get("options")[selectElem.selectedIndex].value;
  }
  importProps(state) {
    return importBladeState$5(
      state,
      null,
      (p) => ({
        options: p.required.custom(parseListOptions$5),
      }),
      (result) => {
        this.props.set("options", normalizeListOptions$5(result.options));
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$5(null, {
      options: this.props.get("options"),
    });
  }
};
const cn$i$5 = ClassName$5("pop");
let PopupView$5 = class PopupView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$i$5());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$5(
      config.shows,
      valueToClassName$5(this.element, cn$i$5(void 0, "v")),
    );
  }
};
let PopupController$5 = class PopupController2 {
  constructor(doc, config) {
    this.shows = createValue$5(false);
    this.viewProps = config.viewProps;
    this.view = new PopupView$5(doc, {
      shows: this.shows,
      viewProps: this.viewProps,
    });
  }
};
const cn$h$5 = ClassName$5("txt");
let TextView$5 = class TextView2 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$h$5());
    config.viewProps.bindClassModifiers(this.element);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$h$5("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onChange_);
    this.value_ = config.value;
    this.refresh();
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let TextController$5 = class TextController2 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new TextView$5(doc, {
      props: config.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$5(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$5(parsedValue)) {
      this.value.rawValue = parsedValue;
    }
    this.view.refresh();
  }
};
function boolToString$5(value) {
  return String(value);
}
function boolFromUnknown$5(value) {
  if (value === "false") {
    return false;
  }
  return !!value;
}
function BooleanFormatter$5(value) {
  return boolToString$5(value);
}
function composeParsers$5(parsers) {
  return (text) => {
    return parsers.reduce((result, parser) => {
      if (result !== null) {
        return result;
      }
      return parser(text);
    }, null);
  };
}
const innerFormatter$5 = createNumberFormatter$5(0);
function formatPercentage$5(value) {
  return innerFormatter$5(value) + "%";
}
function stringFromUnknown$5(value) {
  return String(value);
}
function formatString$5(value) {
  return value;
}
function connectValues$5({ primary, secondary, forward, backward }) {
  let changing = false;
  function preventFeedback(callback) {
    if (changing) {
      return;
    }
    changing = true;
    callback();
    changing = false;
  }
  primary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  secondary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      primary.setRawValue(
        backward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  preventFeedback(() => {
    secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), {
      forceEmit: false,
      last: true,
    });
  });
}
function getStepForKey$5(keyScale, keys) {
  const step = keyScale * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
  if (keys.upKey) {
    return +step;
  } else if (keys.downKey) {
    return -step;
  }
  return 0;
}
function getVerticalStepKeys$5(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowDown",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowUp",
  };
}
function getHorizontalStepKeys$5(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowLeft",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowRight",
  };
}
function isVerticalArrowKey$5(key2) {
  return key2 === "ArrowUp" || key2 === "ArrowDown";
}
function isArrowKey$5(key2) {
  return (
    isVerticalArrowKey$5(key2) || key2 === "ArrowLeft" || key2 === "ArrowRight"
  );
}
function computeOffset$1$5(ev, elem) {
  var _a, _b;
  const win = elem.ownerDocument.defaultView;
  const rect = elem.getBoundingClientRect();
  return {
    x:
      ev.pageX -
      (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) +
        rect.left),
    y:
      ev.pageY -
      (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) +
        rect.top),
  };
}
let PointerHandler$5 = class PointerHandler2 {
  constructor(element) {
    this.lastTouch_ = null;
    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onTouchEnd_ = this.onTouchEnd_.bind(this);
    this.onTouchMove_ = this.onTouchMove_.bind(this);
    this.onTouchStart_ = this.onTouchStart_.bind(this);
    this.elem_ = element;
    this.emitter = new Emitter$5();
    element.addEventListener("touchstart", this.onTouchStart_, {
      passive: false,
    });
    element.addEventListener("touchmove", this.onTouchMove_, {
      passive: true,
    });
    element.addEventListener("touchend", this.onTouchEnd_);
    element.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(offset) {
    const rect = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: rect.width,
        height: rect.height,
      },
      point: offset
        ? {
            x: offset.x,
            y: offset.y,
          }
        : null,
    };
  }
  onMouseDown_(ev) {
    var _a;
    ev.preventDefault();
    (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
    const doc = this.elem_.ownerDocument;
    doc.addEventListener("mousemove", this.onDocumentMouseMove_);
    doc.addEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$5(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseMove_(ev) {
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$5(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseUp_(ev) {
    const doc = this.elem_.ownerDocument;
    doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
    doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$5(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onTouchStart_(ev) {
    ev.preventDefault();
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchMove_(ev) {
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchEnd_(ev) {
    var _a;
    const touch =
      (_a = ev.targetTouches.item(0)) !== null && _a !== void 0
        ? _a
        : this.lastTouch_;
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
};
const cn$g$5 = ClassName$5("txt");
let NumberTextView$5 = class NumberTextView2 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$g$5(), cn$g$5(void 0, "num"));
    if (config.arrayPosition) {
      this.element.classList.add(cn$g$5(void 0, config.arrayPosition));
    }
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$g$5("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    this.onDraggingChange_ = this.onDraggingChange_.bind(this);
    this.dragging_ = config.dragging;
    this.dragging_.emitter.on("change", this.onDraggingChange_);
    this.element.classList.add(cn$g$5());
    this.inputElement.classList.add(cn$g$5("i"));
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$g$5("k"));
    this.element.appendChild(knobElem);
    this.knobElement = knobElem;
    const guideElem = doc.createElementNS(SVG_NS$5, "svg");
    guideElem.classList.add(cn$g$5("g"));
    this.knobElement.appendChild(guideElem);
    const bodyElem = doc.createElementNS(SVG_NS$5, "path");
    bodyElem.classList.add(cn$g$5("gb"));
    guideElem.appendChild(bodyElem);
    this.guideBodyElem_ = bodyElem;
    const headElem = doc.createElementNS(SVG_NS$5, "path");
    headElem.classList.add(cn$g$5("gh"));
    guideElem.appendChild(headElem);
    this.guideHeadElem_ = headElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(ClassName$5("tt")());
    this.knobElement.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.refresh();
  }
  onDraggingChange_(ev) {
    if (ev.rawValue === null) {
      this.element.classList.remove(cn$g$5(void 0, "drg"));
      return;
    }
    this.element.classList.add(cn$g$5(void 0, "drg"));
    const x = ev.rawValue / this.props_.get("pointerScale");
    const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
    const adx = constrainRange$5(-aox, -4, 4);
    this.guideHeadElem_.setAttributeNS(
      null,
      "d",
      [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(
        " ",
      ),
    );
    this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
    const formatter = this.props_.get("formatter");
    this.tooltipElem_.textContent = formatter(this.value.rawValue);
    this.tooltipElem_.style.left = `${x}px`;
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let NumberTextController$5 = class NumberTextController2 {
  constructor(doc, config) {
    var _a;
    this.originRawValue_ = 0;
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.sliderProps_ =
      (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.dragging_ = createValue$5(null);
    this.view = new NumberTextView$5(doc, {
      arrayPosition: config.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
    this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
    this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const ph = new PointerHandler$5(this.view.knobElement);
    ph.emitter.on("down", this.onPointerDown_);
    ph.emitter.on("move", this.onPointerMove_);
    ph.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(value) {
    var _a, _b;
    const min =
      (_a = this.sliderProps_) === null || _a === void 0
        ? void 0
        : _a.get("min");
    const max =
      (_b = this.sliderProps_) === null || _b === void 0
        ? void 0
        : _b.get("max");
    let v = value;
    if (min !== void 0) {
      v = Math.max(v, min);
    }
    if (max !== void 0) {
      v = Math.min(v, max);
    }
    return v;
  }
  onInputChange_(e) {
    const inputElem = forceCast$5(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$5(parsedValue)) {
      this.value.rawValue = this.constrainValue_(parsedValue);
    }
    this.view.refresh();
  }
  onInputKeyDown_(ev) {
    const step = getStepForKey$5(
      this.props.get("keyScale"),
      getVerticalStepKeys$5(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
      forceEmit: false,
      last: false,
    });
  }
  onInputKeyUp_(ev) {
    const step = getStepForKey$5(
      this.props.get("keyScale"),
      getVerticalStepKeys$5(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue;
    this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(data) {
    if (!data.point) {
      return null;
    }
    const dx = data.point.x - data.bounds.width / 2;
    return this.constrainValue_(
      this.originRawValue_ + dx * this.props.get("pointerScale"),
    );
  }
  onPointerMove_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: false,
      last: false,
    });
    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
  }
  onPointerUp_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: true,
      last: true,
    });
    this.dragging_.rawValue = null;
  }
};
const cn$f$5 = ClassName$5("sld");
let SliderView$5 = class SliderView2 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$f$5());
    config.viewProps.bindClassModifiers(this.element);
    const trackElem = doc.createElement("div");
    trackElem.classList.add(cn$f$5("t"));
    config.viewProps.bindTabIndex(trackElem);
    this.element.appendChild(trackElem);
    this.trackElement = trackElem;
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$f$5("k"));
    this.trackElement.appendChild(knobElem);
    this.knobElement = knobElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const p = constrainRange$5(
      mapRange$5(
        this.value.rawValue,
        this.props_.get("min"),
        this.props_.get("max"),
        0,
        100,
      ),
      0,
      100,
    );
    this.knobElement.style.width = `${p}%`;
  }
  onChange_() {
    this.update_();
  }
};
let SliderController$5 = class SliderController2 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.props = config.props;
    this.view = new SliderView$5(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$5(this.view.trackElement);
    this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
    this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    this.value.setRawValue(
      mapRange$5(
        constrainRange$5(d.point.x, 0, d.bounds.width),
        0,
        d.bounds.width,
        this.props.get("min"),
        this.props.get("max"),
      ),
      opts,
    );
  }
  onPointerDownOrMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$5(
      this.props.get("keyScale"),
      getHorizontalStepKeys$5(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue + step, {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$5(
      this.props.get("keyScale"),
      getHorizontalStepKeys$5(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$e$5 = ClassName$5("sldtxt");
let SliderTextView$5 = class SliderTextView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$e$5());
    const sliderElem = doc.createElement("div");
    sliderElem.classList.add(cn$e$5("s"));
    this.sliderView_ = config.sliderView;
    sliderElem.appendChild(this.sliderView_.element);
    this.element.appendChild(sliderElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$e$5("t"));
    this.textView_ = config.textView;
    textElem.appendChild(this.textView_.element);
    this.element.appendChild(textElem);
  }
};
let SliderTextController$5 = class SliderTextController2 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.sliderC_ = new SliderController$5(doc, {
      props: config.sliderProps,
      value: config.value,
      viewProps: this.viewProps,
    });
    this.textC_ = new NumberTextController$5(doc, {
      parser: config.parser,
      props: config.textProps,
      sliderProps: config.sliderProps,
      value: config.value,
      viewProps: config.viewProps,
    });
    this.view = new SliderTextView$5(doc, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view,
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(state) {
    return importBladeState$5(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        const sliderProps = this.sliderC_.props;
        sliderProps.set("max", result.max);
        sliderProps.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    const sliderProps = this.sliderC_.props;
    return exportBladeState$5(null, {
      max: sliderProps.get("max"),
      min: sliderProps.get("min"),
    });
  }
};
function createSliderTextProps$5(config) {
  return {
    sliderProps: new ValueMap$5({
      keyScale: config.keyScale,
      max: config.max,
      min: config.min,
    }),
    textProps: new ValueMap$5({
      formatter: createValue$5(config.formatter),
      keyScale: config.keyScale,
      pointerScale: createValue$5(config.pointerScale),
    }),
  };
}
const CSS_VAR_MAP$5 = {
  containerUnitSize: "cnt-usz",
};
function getCssVar$5(key2) {
  return `--${CSS_VAR_MAP$5[key2]}`;
}
function createPointDimensionParser$5(p) {
  return createNumberTextInputParamsParser$5(p);
}
function parsePointDimensionParams$5(value) {
  if (!isRecord$5(value)) {
    return void 0;
  }
  return parseRecord$5(value, createPointDimensionParser$5);
}
function createDimensionConstraint$5(params, initialValue) {
  if (!params) {
    return void 0;
  }
  const constraints = [];
  const cs = createStepConstraint$5(params, initialValue);
  if (cs) {
    constraints.push(cs);
  }
  const rs = createRangeConstraint$5(params);
  if (rs) {
    constraints.push(rs);
  }
  return new CompositeConstraint$5(constraints);
}
function parsePickerLayout$5(value) {
  if (value === "inline" || value === "popup") {
    return value;
  }
  return void 0;
}
function writePrimitive$5(target, value) {
  target.write(value);
}
const cn$d$5 = ClassName$5("ckb");
let CheckboxView$5 = class CheckboxView2 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$d$5());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("label");
    labelElem.classList.add(cn$d$5("l"));
    this.element.appendChild(labelElem);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$d$5("i"));
    inputElem.type = "checkbox";
    labelElem.appendChild(inputElem);
    this.inputElement = inputElem;
    config.viewProps.bindDisabled(this.inputElement);
    const wrapperElem = doc.createElement("div");
    wrapperElem.classList.add(cn$d$5("w"));
    labelElem.appendChild(wrapperElem);
    const markElem = createSvgIconElement$5(doc, "check");
    wrapperElem.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
};
let CheckboxController$5 = class CheckboxController2 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new CheckboxView$5(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$5(e.currentTarget);
    this.value.rawValue = inputElem.checked;
  }
};
function createConstraint$6$5(params) {
  const constraints = [];
  const lc = createListConstraint$5(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$5(constraints);
}
createPlugin$5({
  id: "input-bool",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$5(params, (p) => ({
      options: p.optional.custom(parseListOptions$5),
      readonly: p.optional.constant(false),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$5,
    constraint: (args) => createConstraint$6$5(args.params),
    writer: (_args) => writePrimitive$5,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$5(c, ListConstraint$5);
    if (lc) {
      return new ListController$5(doc, {
        props: new ValueMap$5({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new CheckboxController$5(doc, {
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "boolean") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$5) {
      return new ListInputBindingApi$5(args.controller);
    }
    return null;
  },
});
const cn$c$5 = ClassName$5("col");
let ColorView$5 = class ColorView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$c$5());
    config.foldable.bindExpandedClass(this.element, cn$c$5(void 0, "expanded"));
    bindValueMap$5(
      config.foldable,
      "completed",
      valueToClassName$5(this.element, cn$c$5(void 0, "cpl")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$c$5("h"));
    this.element.appendChild(headElem);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$c$5("s"));
    headElem.appendChild(swatchElem);
    this.swatchElement = swatchElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$c$5("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$c$5("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
function rgbToHslInt$5(r, g, b) {
  const rp = constrainRange$5(r / 255, 0, 1);
  const gp = constrainRange$5(g / 255, 0, 1);
  const bp = constrainRange$5(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const c = cmax - cmin;
  let h = 0;
  let s = 0;
  const l = (cmin + cmax) / 2;
  if (c !== 0) {
    s = c / (1 - Math.abs(cmax + cmin - 1));
    if (rp === cmax) {
      h = (gp - bp) / c;
    } else if (gp === cmax) {
      h = 2 + (bp - rp) / c;
    } else {
      h = 4 + (rp - gp) / c;
    }
    h = h / 6 + (h < 0 ? 1 : 0);
  }
  return [h * 360, s * 100, l * 100];
}
function hslToRgbInt$5(h, s, l) {
  const hp = ((h % 360) + 360) % 360;
  const sp = constrainRange$5(s / 100, 0, 1);
  const lp = constrainRange$5(l / 100, 0, 1);
  const c = (1 - Math.abs(2 * lp - 1)) * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = lp - c / 2;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function rgbToHsvInt$5(r, g, b) {
  const rp = constrainRange$5(r / 255, 0, 1);
  const gp = constrainRange$5(g / 255, 0, 1);
  const bp = constrainRange$5(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const d = cmax - cmin;
  let h;
  if (d === 0) {
    h = 0;
  } else if (cmax === rp) {
    h = 60 * (((((gp - bp) / d) % 6) + 6) % 6);
  } else if (cmax === gp) {
    h = 60 * ((bp - rp) / d + 2);
  } else {
    h = 60 * ((rp - gp) / d + 4);
  }
  const s = cmax === 0 ? 0 : d / cmax;
  const v = cmax;
  return [h, s * 100, v * 100];
}
function hsvToRgbInt$5(h, s, v) {
  const hp = loopRange$5(h, 360);
  const sp = constrainRange$5(s / 100, 0, 1);
  const vp = constrainRange$5(v / 100, 0, 1);
  const c = vp * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = vp - c;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function hslToHsvInt$5(h, s, l) {
  const sd = l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100);
  return [
    h,
    sd !== 0 ? (s * (100 - Math.abs(2 * l - 100))) / sd : 0,
    l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100),
  ];
}
function hsvToHslInt$5(h, s, v) {
  const sd = 100 - Math.abs((v * (200 - s)) / 100 - 100);
  return [h, sd !== 0 ? (s * v) / sd : 0, (v * (200 - s)) / (2 * 100)];
}
function removeAlphaComponent$5(comps) {
  return [comps[0], comps[1], comps[2]];
}
function appendAlphaComponent$5(comps, alpha) {
  return [comps[0], comps[1], comps[2], alpha];
}
const MODE_CONVERTER_MAP$5 = {
  hsl: {
    hsl: (h, s, l) => [h, s, l],
    hsv: hslToHsvInt$5,
    rgb: hslToRgbInt$5,
  },
  hsv: {
    hsl: hsvToHslInt$5,
    hsv: (h, s, v) => [h, s, v],
    rgb: hsvToRgbInt$5,
  },
  rgb: {
    hsl: rgbToHslInt$5,
    hsv: rgbToHsvInt$5,
    rgb: (r, g, b) => [r, g, b],
  },
};
function getColorMaxComponents$5(mode, type) {
  return [
    type === "float" ? 1 : mode === "rgb" ? 255 : 360,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
  ];
}
function loopHueRange$5(hue, max) {
  return hue === max ? max : loopRange$5(hue, max);
}
function constrainColorComponents$5(components, mode, type) {
  var _a;
  const ms = getColorMaxComponents$5(mode, type);
  return [
    mode === "rgb"
      ? constrainRange$5(components[0], 0, ms[0])
      : loopHueRange$5(components[0], ms[0]),
    constrainRange$5(components[1], 0, ms[1]),
    constrainRange$5(components[2], 0, ms[2]),
    constrainRange$5(
      (_a = components[3]) !== null && _a !== void 0 ? _a : 1,
      0,
      1,
    ),
  ];
}
function convertColorType$5(comps, mode, from, to) {
  const fms = getColorMaxComponents$5(mode, from);
  const tms = getColorMaxComponents$5(mode, to);
  return comps.map((c, index) => (c / fms[index]) * tms[index]);
}
function convertColor$5(components, from, to) {
  const intComps = convertColorType$5(components, from.mode, from.type, "int");
  const result = MODE_CONVERTER_MAP$5[from.mode][to.mode](...intComps);
  return convertColorType$5(result, to.mode, "int", to.type);
}
let IntColor$5 = class IntColor2 {
  static black() {
    return new IntColor2([0, 0, 0], "rgb");
  }
  constructor(comps, mode) {
    this.type = "int";
    this.mode = mode;
    this.comps_ = constrainColorComponents$5(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$5(
      convertColor$5(
        removeAlphaComponent$5(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const cn$b$5 = ClassName$5("colp");
let ColorPickerView$5 = class ColorPickerView2 {
  constructor(doc, config) {
    this.alphaViews_ = null;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$b$5());
    config.viewProps.bindClassModifiers(this.element);
    const hsvElem = doc.createElement("div");
    hsvElem.classList.add(cn$b$5("hsv"));
    const svElem = doc.createElement("div");
    svElem.classList.add(cn$b$5("sv"));
    this.svPaletteView_ = config.svPaletteView;
    svElem.appendChild(this.svPaletteView_.element);
    hsvElem.appendChild(svElem);
    const hElem = doc.createElement("div");
    hElem.classList.add(cn$b$5("h"));
    this.hPaletteView_ = config.hPaletteView;
    hElem.appendChild(this.hPaletteView_.element);
    hsvElem.appendChild(hElem);
    this.element.appendChild(hsvElem);
    const rgbElem = doc.createElement("div");
    rgbElem.classList.add(cn$b$5("rgb"));
    this.textsView_ = config.textsView;
    rgbElem.appendChild(this.textsView_.element);
    this.element.appendChild(rgbElem);
    if (config.alphaViews) {
      this.alphaViews_ = {
        palette: config.alphaViews.palette,
        text: config.alphaViews.text,
      };
      const aElem = doc.createElement("div");
      aElem.classList.add(cn$b$5("a"));
      const apElem = doc.createElement("div");
      apElem.classList.add(cn$b$5("ap"));
      apElem.appendChild(this.alphaViews_.palette.element);
      aElem.appendChild(apElem);
      const atElem = doc.createElement("div");
      atElem.classList.add(cn$b$5("at"));
      atElem.appendChild(this.alphaViews_.text.element);
      aElem.appendChild(atElem);
      this.element.appendChild(aElem);
    }
  }
  get allFocusableElements() {
    const elems = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textsView_.modeSelectElement,
      ...this.textsView_.inputViews.map((v) => v.inputElement),
    ];
    if (this.alphaViews_) {
      elems.push(
        this.alphaViews_.palette.element,
        this.alphaViews_.text.inputElement,
      );
    }
    return elems;
  }
};
function parseColorType$5(value) {
  return value === "int" ? "int" : value === "float" ? "float" : void 0;
}
function parseColorInputParams$5(params) {
  return parseRecord$5(params, (p) => ({
    color: p.optional.object({
      alpha: p.optional.boolean,
      type: p.optional.custom(parseColorType$5),
    }),
    expanded: p.optional.boolean,
    picker: p.optional.custom(parsePickerLayout$5),
    readonly: p.optional.constant(false),
  }));
}
function getKeyScaleForColor$5(forAlpha) {
  return forAlpha ? 0.1 : 1;
}
function extractColorType$5(params) {
  var _a;
  return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
}
let FloatColor$5 = class FloatColor2 {
  constructor(comps, mode) {
    this.type = "float";
    this.mode = mode;
    this.comps_ = constrainColorComponents$5(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$5(
      convertColor$5(
        removeAlphaComponent$5(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const TYPE_TO_CONSTRUCTOR_MAP$5 = {
  int: (comps, mode) => new IntColor$5(comps, mode),
  float: (comps, mode) => new FloatColor$5(comps, mode),
};
function createColor$5(comps, mode, type) {
  return TYPE_TO_CONSTRUCTOR_MAP$5[type](comps, mode);
}
function isFloatColor$5(c) {
  return c.type === "float";
}
function isIntColor$5(c) {
  return c.type === "int";
}
function convertFloatToInt$5(cf) {
  const comps = cf.getComponents();
  const ms = getColorMaxComponents$5(cf.mode, "int");
  return new IntColor$5(
    [
      Math.round(mapRange$5(comps[0], 0, 1, 0, ms[0])),
      Math.round(mapRange$5(comps[1], 0, 1, 0, ms[1])),
      Math.round(mapRange$5(comps[2], 0, 1, 0, ms[2])),
      comps[3],
    ],
    cf.mode,
  );
}
function convertIntToFloat$5(ci) {
  const comps = ci.getComponents();
  const ms = getColorMaxComponents$5(ci.mode, "int");
  return new FloatColor$5(
    [
      mapRange$5(comps[0], 0, ms[0], 0, 1),
      mapRange$5(comps[1], 0, ms[1], 0, 1),
      mapRange$5(comps[2], 0, ms[2], 0, 1),
      comps[3],
    ],
    ci.mode,
  );
}
function mapColorType$5(c, type) {
  if (c.type === type) {
    return c;
  }
  if (isIntColor$5(c) && type === "float") {
    return convertIntToFloat$5(c);
  }
  if (isFloatColor$5(c) && type === "int") {
    return convertFloatToInt$5(c);
  }
  throw TpError$5.shouldNeverHappen();
}
function equalsStringColorFormat$5(f1, f2) {
  return (
    f1.alpha === f2.alpha &&
    f1.mode === f2.mode &&
    f1.notation === f2.notation &&
    f1.type === f2.type
  );
}
function parseCssNumberOrPercentage$5(text, max) {
  const m = text.match(/^(.+)%$/);
  if (!m) {
    return Math.min(parseFloat(text), max);
  }
  return Math.min(parseFloat(m[1]) * 0.01 * max, max);
}
const ANGLE_TO_DEG_MAP$5 = {
  deg: (angle) => angle,
  grad: (angle) => (angle * 360) / 400,
  rad: (angle) => (angle * 360) / (2 * Math.PI),
  turn: (angle) => angle * 360,
};
function parseCssNumberOrAngle$5(text) {
  const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!m) {
    return parseFloat(text);
  }
  const angle = parseFloat(m[1]);
  const unit = m[2];
  return ANGLE_TO_DEG_MAP$5[unit](angle);
}
function parseFunctionalRgbColorComponents$5(text) {
  const m = text.match(
    /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$5(m[1], 255),
    parseCssNumberOrPercentage$5(m[2], 255),
    parseCssNumberOrPercentage$5(m[3], 255),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbColor$5(text) {
  const comps = parseFunctionalRgbColorComponents$5(text);
  return comps ? new IntColor$5(comps, "rgb") : null;
}
function parseFunctionalRgbaColorComponents$5(text) {
  const m = text.match(
    /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$5(m[1], 255),
    parseCssNumberOrPercentage$5(m[2], 255),
    parseCssNumberOrPercentage$5(m[3], 255),
    parseCssNumberOrPercentage$5(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbaColor$5(text) {
  const comps = parseFunctionalRgbaColorComponents$5(text);
  return comps ? new IntColor$5(comps, "rgb") : null;
}
function parseFunctionalHslColorComponents$5(text) {
  const m = text.match(
    /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$5(m[1]),
    parseCssNumberOrPercentage$5(m[2], 100),
    parseCssNumberOrPercentage$5(m[3], 100),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalHslColor$5(text) {
  const comps = parseFunctionalHslColorComponents$5(text);
  return comps ? new IntColor$5(comps, "hsl") : null;
}
function parseHslaColorComponents$5(text) {
  const m = text.match(
    /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$5(m[1]),
    parseCssNumberOrPercentage$5(m[2], 100),
    parseCssNumberOrPercentage$5(m[3], 100),
    parseCssNumberOrPercentage$5(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalHslaColor$5(text) {
  const comps = parseHslaColorComponents$5(text);
  return comps ? new IntColor$5(comps, "hsl") : null;
}
function parseHexRgbColorComponents$5(text) {
  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
    ];
  }
  return null;
}
function parseHexRgbColor$5(text) {
  const comps = parseHexRgbColorComponents$5(text);
  return comps ? new IntColor$5(comps, "rgb") : null;
}
function parseHexRgbaColorComponents$5(text) {
  const mRgb = text.match(
    /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/,
  );
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
      mapRange$5(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
      mapRange$5(parseInt(mRrggbb[4], 16), 0, 255, 0, 1),
    ];
  }
  return null;
}
function parseHexRgbaColor$5(text) {
  const comps = parseHexRgbaColorComponents$5(text);
  return comps ? new IntColor$5(comps, "rgb") : null;
}
function parseObjectRgbColorComponents$5(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function createObjectRgbColorParser$5(type) {
  return (text) => {
    const comps = parseObjectRgbColorComponents$5(text);
    return comps ? createColor$5(comps, "rgb", type) : null;
  };
}
function parseObjectRgbaColorComponents$5(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseFloat(m[1]),
    parseFloat(m[2]),
    parseFloat(m[3]),
    parseFloat(m[4]),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function createObjectRgbaColorParser$5(type) {
  return (text) => {
    const comps = parseObjectRgbaColorComponents$5(text);
    return comps ? createColor$5(comps, "rgb", type) : null;
  };
}
const PARSER_AND_RESULT$5 = [
  {
    parser: parseHexRgbColorComponents$5,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseHexRgbaColorComponents$5,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseFunctionalRgbColorComponents$5,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalRgbaColorComponents$5,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalHslColorComponents$5,
    result: {
      alpha: false,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseHslaColorComponents$5,
    result: {
      alpha: true,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseObjectRgbColorComponents$5,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "object",
    },
  },
  {
    parser: parseObjectRgbaColorComponents$5,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "object",
    },
  },
];
function detectStringColor$5(text) {
  return PARSER_AND_RESULT$5.reduce((prev, { parser, result: detection }) => {
    if (prev) {
      return prev;
    }
    return parser(text) ? detection : null;
  }, null);
}
function detectStringColorFormat$5(text, type = "int") {
  const r = detectStringColor$5(text);
  if (!r) {
    return null;
  }
  if (r.notation === "hex" && type !== "float") {
    return Object.assign(Object.assign({}, r), { type: "int" });
  }
  if (r.notation === "func") {
    return Object.assign(Object.assign({}, r), { type });
  }
  return null;
}
function createColorStringParser$5(type) {
  const parsers = [
    parseHexRgbColor$5,
    parseHexRgbaColor$5,
    parseFunctionalRgbColor$5,
    parseFunctionalRgbaColor$5,
    parseFunctionalHslColor$5,
    parseFunctionalHslaColor$5,
  ];
  if (type === "int") {
    parsers.push(
      createObjectRgbColorParser$5("int"),
      createObjectRgbaColorParser$5("int"),
    );
  }
  if (type === "float") {
    parsers.push(
      createObjectRgbColorParser$5("float"),
      createObjectRgbaColorParser$5("float"),
    );
  }
  const parser = composeParsers$5(parsers);
  return (text) => {
    const result = parser(text);
    return result ? mapColorType$5(result, type) : null;
  };
}
function readIntColorString$5(value) {
  const parser = createColorStringParser$5("int");
  if (typeof value !== "string") {
    return IntColor$5.black();
  }
  const result = parser(value);
  return result !== null && result !== void 0 ? result : IntColor$5.black();
}
function zerofill$5(comp) {
  const hex = constrainRange$5(Math.floor(comp), 0, 255).toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function colorToHexRgbString$5(value, prefix = "#") {
  const hexes = removeAlphaComponent$5(value.getComponents("rgb"))
    .map(zerofill$5)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToHexRgbaString$5(value, prefix = "#") {
  const rgbaComps = value.getComponents("rgb");
  const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
    .map(zerofill$5)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToFunctionalRgbString$5(value) {
  const formatter = createNumberFormatter$5(0);
  const ci = mapColorType$5(value, "int");
  const comps = removeAlphaComponent$5(ci.getComponents("rgb")).map((comp) =>
    formatter(comp),
  );
  return `rgb(${comps.join(", ")})`;
}
function colorToFunctionalRgbaString$5(value) {
  const aFormatter = createNumberFormatter$5(2);
  const rgbFormatter = createNumberFormatter$5(0);
  const ci = mapColorType$5(value, "int");
  const comps = ci.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return formatter(comp);
  });
  return `rgba(${comps.join(", ")})`;
}
function colorToFunctionalHslString$5(value) {
  const formatters = [
    createNumberFormatter$5(0),
    formatPercentage$5,
    formatPercentage$5,
  ];
  const ci = mapColorType$5(value, "int");
  const comps = removeAlphaComponent$5(ci.getComponents("hsl")).map(
    (comp, index) => formatters[index](comp),
  );
  return `hsl(${comps.join(", ")})`;
}
function colorToFunctionalHslaString$5(value) {
  const formatters = [
    createNumberFormatter$5(0),
    formatPercentage$5,
    formatPercentage$5,
    createNumberFormatter$5(2),
  ];
  const ci = mapColorType$5(value, "int");
  const comps = ci
    .getComponents("hsl")
    .map((comp, index) => formatters[index](comp));
  return `hsla(${comps.join(", ")})`;
}
function colorToObjectRgbString$5(value, type) {
  const formatter = createNumberFormatter$5(type === "float" ? 2 : 0);
  const names = ["r", "g", "b"];
  const cc = mapColorType$5(value, type);
  const comps = removeAlphaComponent$5(cc.getComponents("rgb")).map(
    (comp, index) => `${names[index]}: ${formatter(comp)}`,
  );
  return `{${comps.join(", ")}}`;
}
function createObjectRgbColorFormatter$5(type) {
  return (value) => colorToObjectRgbString$5(value, type);
}
function colorToObjectRgbaString$5(value, type) {
  const aFormatter = createNumberFormatter$5(2);
  const rgbFormatter = createNumberFormatter$5(type === "float" ? 2 : 0);
  const names = ["r", "g", "b", "a"];
  const cc = mapColorType$5(value, type);
  const comps = cc.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return `${names[index]}: ${formatter(comp)}`;
  });
  return `{${comps.join(", ")}}`;
}
function createObjectRgbaColorFormatter$5(type) {
  return (value) => colorToObjectRgbaString$5(value, type);
}
const FORMAT_AND_STRINGIFIERS$5 = [
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbString$5,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbaString$5,
  },
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbString$5,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbaString$5,
  },
  {
    format: {
      alpha: false,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslString$5,
  },
  {
    format: {
      alpha: true,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslaString$5,
  },
  ...["int", "float"].reduce((prev, type) => {
    return [
      ...prev,
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbColorFormatter$5(type),
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbaColorFormatter$5(type),
      },
    ];
  }, []),
];
function findColorStringifier$5(format) {
  return FORMAT_AND_STRINGIFIERS$5.reduce((prev, fas) => {
    if (prev) {
      return prev;
    }
    return equalsStringColorFormat$5(fas.format, format)
      ? fas.stringifier
      : null;
  }, null);
}
const cn$a$5 = ClassName$5("apl");
let APaletteView$5 = class APaletteView2 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$a$5());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const barElem = doc.createElement("div");
    barElem.classList.add(cn$a$5("b"));
    this.element.appendChild(barElem);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$a$5("c"));
    barElem.appendChild(colorElem);
    this.colorElem_ = colorElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$a$5("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    const previewElem = doc.createElement("div");
    previewElem.classList.add(cn$a$5("p"));
    this.markerElem_.appendChild(previewElem);
    this.previewElem_ = previewElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const rgbaComps = c.getComponents("rgb");
    const leftColor = new IntColor$5(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 0],
      "rgb",
    );
    const rightColor = new IntColor$5(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 255],
      "rgb",
    );
    const gradientComps = [
      "to right",
      colorToFunctionalRgbaString$5(leftColor),
      colorToFunctionalRgbaString$5(rightColor),
    ];
    this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
    this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString$5(c);
    const left = mapRange$5(rgbaComps[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let APaletteController$5 = class APaletteController2 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new APaletteView$5(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$5(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const alpha = d.point.x / d.bounds.width;
    const c = this.value.rawValue;
    const [h, s, v] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$5([h, s, v, alpha], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$5(
      getKeyScaleForColor$5(true),
      getHorizontalStepKeys$5(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$5([h, s, v, a + step], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$5(
      getKeyScaleForColor$5(true),
      getHorizontalStepKeys$5(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$9$5 = ClassName$5("coltxt");
function createModeSelectElement$5(doc) {
  const selectElem = doc.createElement("select");
  const items = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" },
    { text: "HEX", value: "hex" },
  ];
  selectElem.appendChild(
    items.reduce((frag, item) => {
      const optElem = doc.createElement("option");
      optElem.textContent = item.text;
      optElem.value = item.value;
      frag.appendChild(optElem);
      return frag;
    }, doc.createDocumentFragment()),
  );
  return selectElem;
}
let ColorTextsView$5 = class ColorTextsView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$9$5());
    config.viewProps.bindClassModifiers(this.element);
    const modeElem = doc.createElement("div");
    modeElem.classList.add(cn$9$5("m"));
    this.modeElem_ = createModeSelectElement$5(doc);
    this.modeElem_.classList.add(cn$9$5("ms"));
    modeElem.appendChild(this.modeSelectElement);
    config.viewProps.bindDisabled(this.modeElem_);
    const modeMarkerElem = doc.createElement("div");
    modeMarkerElem.classList.add(cn$9$5("mm"));
    modeMarkerElem.appendChild(createSvgIconElement$5(doc, "dropdown"));
    modeElem.appendChild(modeMarkerElem);
    this.element.appendChild(modeElem);
    const inputsElem = doc.createElement("div");
    inputsElem.classList.add(cn$9$5("w"));
    this.element.appendChild(inputsElem);
    this.inputsElem_ = inputsElem;
    this.inputViews_ = config.inputViews;
    this.applyInputViews_();
    bindValue$5(config.mode, (mode) => {
      this.modeElem_.value = mode;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(inputViews) {
    this.inputViews_ = inputViews;
    this.applyInputViews_();
  }
  applyInputViews_() {
    removeChildElements$5(this.inputsElem_);
    const doc = this.element.ownerDocument;
    this.inputViews_.forEach((v) => {
      const compElem = doc.createElement("div");
      compElem.classList.add(cn$9$5("c"));
      compElem.appendChild(v.element);
      this.inputsElem_.appendChild(compElem);
    });
  }
};
function createFormatter$2$5(type) {
  return createNumberFormatter$5(type === "float" ? 2 : 0);
}
function createConstraint$5$5(mode, type, index) {
  const max = getColorMaxComponents$5(mode, type)[index];
  return new DefiniteRangeConstraint$5({
    min: 0,
    max,
  });
}
function createComponentController$5(doc, config, index) {
  return new NumberTextController$5(doc, {
    arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
    parser: config.parser,
    props: ValueMap$5.fromObject({
      formatter: createFormatter$2$5(config.colorType),
      keyScale: getKeyScaleForColor$5(false),
      pointerScale: config.colorType === "float" ? 0.01 : 1,
    }),
    value: createValue$5(0, {
      constraint: createConstraint$5$5(
        config.colorMode,
        config.colorType,
        index,
      ),
    }),
    viewProps: config.viewProps,
  });
}
function createComponentControllers$5(doc, config) {
  const cc = {
    colorMode: config.colorMode,
    colorType: config.colorType,
    parser: parseNumber$5,
    viewProps: config.viewProps,
  };
  return [0, 1, 2].map((i) => {
    const c = createComponentController$5(doc, cc, i);
    connectValues$5({
      primary: config.value,
      secondary: c.value,
      forward(p) {
        const mc = mapColorType$5(p, config.colorType);
        return mc.getComponents(config.colorMode)[i];
      },
      backward(p, s) {
        const pickedMode = config.colorMode;
        const mc = mapColorType$5(p, config.colorType);
        const comps = mc.getComponents(pickedMode);
        comps[i] = s;
        const c2 = createColor$5(
          appendAlphaComponent$5(removeAlphaComponent$5(comps), comps[3]),
          pickedMode,
          config.colorType,
        );
        return mapColorType$5(c2, "int");
      },
    });
    return c;
  });
}
function createHexController$5(doc, config) {
  const c = new TextController$5(doc, {
    parser: createColorStringParser$5("int"),
    props: ValueMap$5.fromObject({
      formatter: colorToHexRgbString$5,
    }),
    value: createValue$5(IntColor$5.black()),
    viewProps: config.viewProps,
  });
  connectValues$5({
    primary: config.value,
    secondary: c.value,
    forward: (p) =>
      new IntColor$5(removeAlphaComponent$5(p.getComponents()), p.mode),
    backward: (p, s) =>
      new IntColor$5(
        appendAlphaComponent$5(
          removeAlphaComponent$5(s.getComponents(p.mode)),
          p.getComponents()[3],
        ),
        p.mode,
      ),
  });
  return [c];
}
function isColorMode$5(mode) {
  return mode !== "hex";
}
let ColorTextsController$5 = class ColorTextsController2 {
  constructor(doc, config) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
    this.colorType_ = config.colorType;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.colorMode = createValue$5(this.value.rawValue.mode);
    this.ccs_ = this.createComponentControllers_(doc);
    this.view = new ColorTextsView$5(doc, {
      mode: this.colorMode,
      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
      viewProps: this.viewProps,
    });
    this.view.modeSelectElement.addEventListener(
      "change",
      this.onModeSelectChange_,
    );
  }
  createComponentControllers_(doc) {
    const mode = this.colorMode.rawValue;
    if (isColorMode$5(mode)) {
      return createComponentControllers$5(doc, {
        colorMode: mode,
        colorType: this.colorType_,
        value: this.value,
        viewProps: this.viewProps,
      });
    }
    return createHexController$5(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
  onModeSelectChange_(ev) {
    const selectElem = ev.currentTarget;
    this.colorMode.rawValue = selectElem.value;
    this.ccs_ = this.createComponentControllers_(
      this.view.element.ownerDocument,
    );
    this.view.inputViews = this.ccs_.map((cc) => cc.view);
  }
};
const cn$8$5 = ClassName$5("hpl");
let HPaletteView$5 = class HPaletteView2 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$8$5());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$8$5("c"));
    this.element.appendChild(colorElem);
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$8$5("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const [h] = c.getComponents("hsv");
    this.markerElem_.style.backgroundColor = colorToFunctionalRgbString$5(
      new IntColor$5([h, 100, 100], "hsv"),
    );
    const left = mapRange$5(h, 0, 360, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let HPaletteController$5 = class HPaletteController2 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new HPaletteView$5(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$5(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const hue = mapRange$5(
      constrainRange$5(d.point.x, 0, d.bounds.width),
      0,
      d.bounds.width,
      0,
      360,
    );
    const c = this.value.rawValue;
    const [, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$5([hue, s, v, a], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$5(
      getKeyScaleForColor$5(false),
      getHorizontalStepKeys$5(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$5([h + step, s, v, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$5(
      getKeyScaleForColor$5(false),
      getHorizontalStepKeys$5(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$7$5 = ClassName$5("svp");
const CANVAS_RESOL$5 = 64;
let SvPaletteView$5 = class SvPaletteView2 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$7$5());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const canvasElem = doc.createElement("canvas");
    canvasElem.height = CANVAS_RESOL$5;
    canvasElem.width = CANVAS_RESOL$5;
    canvasElem.classList.add(cn$7$5("c"));
    this.element.appendChild(canvasElem);
    this.canvasElement = canvasElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$7$5("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const ctx = getCanvasContext$5(this.canvasElement);
    if (!ctx) {
      return;
    }
    const c = this.value.rawValue;
    const hsvComps = c.getComponents("hsv");
    const width = this.canvasElement.width;
    const height = this.canvasElement.height;
    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;
    for (let iy = 0; iy < height; iy++) {
      for (let ix = 0; ix < width; ix++) {
        const s = mapRange$5(ix, 0, width, 0, 100);
        const v = mapRange$5(iy, 0, height, 100, 0);
        const rgbComps = hsvToRgbInt$5(hsvComps[0], s, v);
        const i = (iy * width + ix) * 4;
        data[i] = rgbComps[0];
        data[i + 1] = rgbComps[1];
        data[i + 2] = rgbComps[2];
        data[i + 3] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    const left = mapRange$5(hsvComps[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${left}%`;
    const top = mapRange$5(hsvComps[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${top}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let SvPaletteController$5 = class SvPaletteController2 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SvPaletteView$5(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$5(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const saturation = mapRange$5(d.point.x, 0, d.bounds.width, 0, 100);
    const value = mapRange$5(d.point.y, 0, d.bounds.height, 100, 0);
    const [h, , , a] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(
      new IntColor$5([h, saturation, value, a], "hsv"),
      opts,
    );
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    if (isArrowKey$5(ev.key)) {
      ev.preventDefault();
    }
    const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
    const keyScale = getKeyScaleForColor$5(false);
    const ds = getStepForKey$5(keyScale, getHorizontalStepKeys$5(ev));
    const dv = getStepForKey$5(keyScale, getVerticalStepKeys$5(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(new IntColor$5([h, s + ds, v + dv, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const keyScale = getKeyScaleForColor$5(false);
    const ds = getStepForKey$5(keyScale, getHorizontalStepKeys$5(ev));
    const dv = getStepForKey$5(keyScale, getVerticalStepKeys$5(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let ColorPickerController$5 = class ColorPickerController2 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.hPaletteC_ = new HPaletteController$5(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.svPaletteC_ = new SvPaletteController$5(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.alphaIcs_ = config.supportsAlpha
      ? {
          palette: new APaletteController$5(doc, {
            value: this.value,
            viewProps: this.viewProps,
          }),
          text: new NumberTextController$5(doc, {
            parser: parseNumber$5,
            props: ValueMap$5.fromObject({
              pointerScale: 0.01,
              keyScale: 0.1,
              formatter: createNumberFormatter$5(2),
            }),
            value: createValue$5(0, {
              constraint: new DefiniteRangeConstraint$5({ min: 0, max: 1 }),
            }),
            viewProps: this.viewProps,
          }),
        }
      : null;
    if (this.alphaIcs_) {
      connectValues$5({
        primary: this.value,
        secondary: this.alphaIcs_.text.value,
        forward: (p) => p.getComponents()[3],
        backward: (p, s) => {
          const comps = p.getComponents();
          comps[3] = s;
          return new IntColor$5(comps, p.mode);
        },
      });
    }
    this.textsC_ = new ColorTextsController$5(doc, {
      colorType: config.colorType,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorPickerView$5(doc, {
      alphaViews: this.alphaIcs_
        ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view,
          }
        : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: config.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textsView: this.textsC_.view,
      viewProps: this.viewProps,
    });
  }
  get textsController() {
    return this.textsC_;
  }
};
const cn$6$5 = ClassName$5("colsw");
let ColorSwatchView$5 = class ColorSwatchView2 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$6$5());
    config.viewProps.bindClassModifiers(this.element);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$6$5("sw"));
    this.element.appendChild(swatchElem);
    this.swatchElem_ = swatchElem;
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$6$5("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    this.update_();
  }
  update_() {
    const value = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = colorToHexRgbaString$5(value);
  }
  onValueChange_() {
    this.update_();
  }
};
let ColorSwatchController$5 = class ColorSwatchController2 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ColorSwatchView$5(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
let ColorController$5 = class ColorController2 {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$5.create(config.expanded);
    this.swatchC_ = new ColorSwatchController$5(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    const buttonElem = this.swatchC_.view.buttonElement;
    buttonElem.addEventListener("blur", this.onButtonBlur_);
    buttonElem.addEventListener("click", this.onButtonClick_);
    this.textC_ = new TextController$5(doc, {
      parser: config.parser,
      props: ValueMap$5.fromObject({
        formatter: config.formatter,
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorView$5(doc, {
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout,
    });
    this.view.swatchElement.appendChild(this.swatchC_.view.element);
    this.view.textElement.appendChild(this.textC_.view.element);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$5(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const pickerC = new ColorPickerController$5(doc, {
      colorType: config.colorType,
      supportsAlpha: config.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps,
    });
    pickerC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = pickerC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(pickerC.view.element);
      connectValues$5({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$5(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$5(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$5(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.swatchC_.view.buttonElement &&
      !supportsTouch$5(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.swatchC_.view.buttonElement.focus();
      }
    }
  }
};
function colorToRgbNumber$5(value) {
  return removeAlphaComponent$5(value.getComponents("rgb")).reduce(
    (result, comp) => {
      return (result << 8) | (Math.floor(comp) & 255);
    },
    0,
  );
}
function colorToRgbaNumber$5(value) {
  return (
    value.getComponents("rgb").reduce((result, comp, index) => {
      const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
      return (result << 8) | hex;
    }, 0) >>> 0
  );
}
function numberToRgbColor$5(num) {
  return new IntColor$5(
    [(num >> 16) & 255, (num >> 8) & 255, num & 255],
    "rgb",
  );
}
function numberToRgbaColor$5(num) {
  return new IntColor$5(
    [
      (num >> 24) & 255,
      (num >> 16) & 255,
      (num >> 8) & 255,
      mapRange$5(num & 255, 0, 255, 0, 1),
    ],
    "rgb",
  );
}
function colorFromRgbNumber$5(value) {
  if (typeof value !== "number") {
    return IntColor$5.black();
  }
  return numberToRgbColor$5(value);
}
function colorFromRgbaNumber$5(value) {
  if (typeof value !== "number") {
    return IntColor$5.black();
  }
  return numberToRgbaColor$5(value);
}
function isRgbColorComponent$5(obj, key2) {
  if (typeof obj !== "object" || isEmpty$5(obj)) {
    return false;
  }
  return key2 in obj && typeof obj[key2] === "number";
}
function isRgbColorObject$5(obj) {
  return (
    isRgbColorComponent$5(obj, "r") &&
    isRgbColorComponent$5(obj, "g") &&
    isRgbColorComponent$5(obj, "b")
  );
}
function isRgbaColorObject$5(obj) {
  return isRgbColorObject$5(obj) && isRgbColorComponent$5(obj, "a");
}
function isColorObject$5(obj) {
  return isRgbColorObject$5(obj);
}
function equalsColor$5(v1, v2) {
  if (v1.mode !== v2.mode) {
    return false;
  }
  if (v1.type !== v2.type) {
    return false;
  }
  const comps1 = v1.getComponents();
  const comps2 = v2.getComponents();
  for (let i = 0; i < comps1.length; i++) {
    if (comps1[i] !== comps2[i]) {
      return false;
    }
  }
  return true;
}
function createColorComponentsFromRgbObject$5(obj) {
  return "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
}
function createColorStringWriter$5(format) {
  const stringify = findColorStringifier$5(format);
  return stringify
    ? (target, value) => {
        writePrimitive$5(target, stringify(value));
      }
    : null;
}
function createColorNumberWriter$5(supportsAlpha) {
  const colorToNumber = supportsAlpha
    ? colorToRgbaNumber$5
    : colorToRgbNumber$5;
  return (target, value) => {
    writePrimitive$5(target, colorToNumber(value));
  };
}
function writeRgbaColorObject$5(target, value, type) {
  const cc = mapColorType$5(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
  target.writeProperty("a", obj.a);
}
function writeRgbColorObject$5(target, value, type) {
  const cc = mapColorType$5(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
}
function createColorObjectWriter$5(supportsAlpha, type) {
  return (target, inValue) => {
    if (supportsAlpha) {
      writeRgbaColorObject$5(target, inValue, type);
    } else {
      writeRgbColorObject$5(target, inValue, type);
    }
  };
}
function shouldSupportAlpha$1$5(inputParams) {
  var _a;
  if (
    (_a =
      inputParams === null || inputParams === void 0
        ? void 0
        : inputParams.color) === null || _a === void 0
      ? void 0
      : _a.alpha
  ) {
    return true;
  }
  return false;
}
function createFormatter$1$5(supportsAlpha) {
  return supportsAlpha
    ? (v) => colorToHexRgbaString$5(v, "0x")
    : (v) => colorToHexRgbString$5(v, "0x");
}
function isForColor$5(params) {
  if ("color" in params) {
    return true;
  }
  if (params.view === "color") {
    return true;
  }
  return false;
}
createPlugin$5({
  id: "input-color-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    if (!isForColor$5(params)) {
      return null;
    }
    const result = parseColorInputParams$5(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            supportsAlpha: shouldSupportAlpha$1$5(params),
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => {
      return args.params.supportsAlpha
        ? colorFromRgbaNumber$5
        : colorFromRgbNumber$5;
    },
    equals: equalsColor$5,
    writer: (args) => {
      return createColorNumberWriter$5(args.params.supportsAlpha);
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$5(args.document, {
      colorType: "int",
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createFormatter$1$5(args.params.supportsAlpha),
      parser: createColorStringParser$5("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
function colorFromObject$5(value, type) {
  if (!isColorObject$5(value)) {
    return mapColorType$5(IntColor$5.black(), type);
  }
  if (type === "int") {
    const comps = createColorComponentsFromRgbObject$5(value);
    return new IntColor$5(comps, "rgb");
  }
  if (type === "float") {
    const comps = createColorComponentsFromRgbObject$5(value);
    return new FloatColor$5(comps, "rgb");
  }
  return mapColorType$5(IntColor$5.black(), "int");
}
function shouldSupportAlpha$6(initialValue) {
  return isRgbaColorObject$5(initialValue);
}
function createColorObjectBindingReader$5(type) {
  return (value) => {
    const c = colorFromObject$5(value, type);
    return mapColorType$5(c, "int");
  };
}
function createColorObjectFormatter$5(supportsAlpha, type) {
  return (value) => {
    if (supportsAlpha) {
      return colorToObjectRgbaString$5(value, type);
    }
    return colorToObjectRgbString$5(value, type);
  };
}
createPlugin$5({
  id: "input-color-object",
  type: "input",
  accept: (value, params) => {
    var _a;
    if (!isColorObject$5(value)) {
      return null;
    }
    const result = parseColorInputParams$5(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            colorType:
              (_a = extractColorType$5(params)) !== null && _a !== void 0
                ? _a
                : "int",
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => createColorObjectBindingReader$5(args.params.colorType),
    equals: equalsColor$5,
    writer: (args) =>
      createColorObjectWriter$5(
        shouldSupportAlpha$6(args.initialValue),
        args.params.colorType,
      ),
  },
  controller: (args) => {
    var _a, _b;
    const supportsAlpha = isRgbaColorObject$5(args.initialValue);
    return new ColorController$5(args.document, {
      colorType: args.params.colorType,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createColorObjectFormatter$5(
        supportsAlpha,
        args.params.colorType,
      ),
      parser: createColorStringParser$5("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
createPlugin$5({
  id: "input-color-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    if (params.view === "text") {
      return null;
    }
    const format = detectStringColorFormat$5(value, extractColorType$5(params));
    if (!format) {
      return null;
    }
    const stringifier = findColorStringifier$5(format);
    if (!stringifier) {
      return null;
    }
    const result = parseColorInputParams$5(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            format,
            stringifier,
          }),
        }
      : null;
  },
  binding: {
    reader: () => readIntColorString$5,
    equals: equalsColor$5,
    writer: (args) => {
      const writer = createColorStringWriter$5(args.params.format);
      if (!writer) {
        throw TpError$5.notBindable();
      }
      return writer;
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$5(args.document, {
      colorType: args.params.format.type,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: args.params.stringifier,
      parser: createColorStringParser$5("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.format.alpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let PointNdConstraint$5 = class PointNdConstraint2 {
  constructor(config) {
    this.components = config.components;
    this.asm_ = config.assembly;
  }
  constrain(value) {
    const comps = this.asm_.toComponents(value).map((comp, index) => {
      var _a, _b;
      return (_b =
        (_a = this.components[index]) === null || _a === void 0
          ? void 0
          : _a.constrain(comp)) !== null && _b !== void 0
        ? _b
        : comp;
    });
    return this.asm_.fromComponents(comps);
  }
};
const cn$5$5 = ClassName$5("pndtxt");
let PointNdTextView$5 = class PointNdTextView2 {
  constructor(doc, config) {
    this.textViews = config.textViews;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$5$5());
    this.textViews.forEach((v) => {
      const axisElem = doc.createElement("div");
      axisElem.classList.add(cn$5$5("a"));
      axisElem.appendChild(v.element);
      this.element.appendChild(axisElem);
    });
  }
};
function createAxisController$5(doc, config, index) {
  return new NumberTextController$5(doc, {
    arrayPosition:
      index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
    parser: config.parser,
    props: config.axes[index].textProps,
    value: createValue$5(0, {
      constraint: config.axes[index].constraint,
    }),
    viewProps: config.viewProps,
  });
}
let PointNdTextController$5 = class PointNdTextController2 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.acs_ = config.axes.map((_, index) =>
      createAxisController$5(doc, config, index),
    );
    this.acs_.forEach((c, index) => {
      connectValues$5({
        primary: this.value,
        secondary: c.value,
        forward: (p) => config.assembly.toComponents(p)[index],
        backward: (p, s) => {
          const comps = config.assembly.toComponents(p);
          comps[index] = s;
          return config.assembly.fromComponents(comps);
        },
      });
    });
    this.view = new PointNdTextView$5(doc, {
      textViews: this.acs_.map((ac) => ac.view),
    });
  }
  get textControllers() {
    return this.acs_;
  }
};
let SliderInputBindingApi$5 = class SliderInputBindingApi2 extends BindingApi$5 {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.sliderController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(max) {
    this.controller.valueController.sliderController.props.set("min", max);
  }
};
function createConstraint$4$5(params, initialValue) {
  const constraints = [];
  const sc = createStepConstraint$5(params, initialValue);
  if (sc) {
    constraints.push(sc);
  }
  const rc = createRangeConstraint$5(params);
  if (rc) {
    constraints.push(rc);
  }
  const lc = createListConstraint$5(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$5(constraints);
}
createPlugin$5({
  id: "input-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$5(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser$5(p)), {
        options: p.optional.custom(parseListOptions$5),
        readonly: p.optional.constant(false),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown$5,
    constraint: (args) => createConstraint$4$5(args.params, args.initialValue),
    writer: (_args) => writePrimitive$5,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$5(c, ListConstraint$5);
    if (lc) {
      return new ListController$5(args.document, {
        props: new ValueMap$5({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    const textPropsObj = createNumberTextPropsObject$5(
      args.params,
      value.rawValue,
    );
    const drc = c && findConstraint$5(c, DefiniteRangeConstraint$5);
    if (drc) {
      return new SliderTextController$5(
        args.document,
        Object.assign(
          Object.assign(
            {},
            createSliderTextProps$5(
              Object.assign(Object.assign({}, textPropsObj), {
                keyScale: createValue$5(textPropsObj.keyScale),
                max: drc.values.value("max"),
                min: drc.values.value("min"),
              }),
            ),
          ),
          { parser: parseNumber$5, value, viewProps: args.viewProps },
        ),
      );
    }
    return new NumberTextController$5(args.document, {
      parser: parseNumber$5,
      props: ValueMap$5.fromObject(textPropsObj),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "number") {
      return null;
    }
    if (args.controller.valueController instanceof SliderTextController$5) {
      return new SliderInputBindingApi$5(args.controller);
    }
    if (args.controller.valueController instanceof ListController$5) {
      return new ListInputBindingApi$5(args.controller);
    }
    return null;
  },
});
let Point2d$5 = class Point2d2 {
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(obj) {
    if (isEmpty$5(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    if (typeof x !== "number" || typeof y2 !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
    };
  }
};
const Point2dAssembly$5 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point2d$5(...comps),
};
const cn$4$5 = ClassName$5("p2d");
let Point2dView$5 = class Point2dView2 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$4$5());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$5(
      config.expanded,
      valueToClassName$5(this.element, cn$4$5(void 0, "expanded")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$4$5("h"));
    this.element.appendChild(headElem);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$4$5("b"));
    buttonElem.appendChild(createSvgIconElement$5(doc, "p2dpad"));
    config.viewProps.bindDisabled(buttonElem);
    headElem.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$4$5("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$4$5("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
const cn$3$5 = ClassName$5("p2dp");
let Point2dPickerView$5 = class Point2dPickerView2 {
  constructor(doc, config) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this);
    this.onPropsChange_ = this.onPropsChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onPropsChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$3$5());
    if (config.layout === "popup") {
      this.element.classList.add(cn$3$5(void 0, "p"));
    }
    config.viewProps.bindClassModifiers(this.element);
    const padElem = doc.createElement("div");
    padElem.classList.add(cn$3$5("p"));
    config.viewProps.bindTabIndex(padElem);
    this.element.appendChild(padElem);
    this.padElement = padElem;
    const svgElem = doc.createElementNS(SVG_NS$5, "svg");
    svgElem.classList.add(cn$3$5("g"));
    this.padElement.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const xAxisElem = doc.createElementNS(SVG_NS$5, "line");
    xAxisElem.classList.add(cn$3$5("ax"));
    xAxisElem.setAttributeNS(null, "x1", "0");
    xAxisElem.setAttributeNS(null, "y1", "50%");
    xAxisElem.setAttributeNS(null, "x2", "100%");
    xAxisElem.setAttributeNS(null, "y2", "50%");
    this.svgElem_.appendChild(xAxisElem);
    const yAxisElem = doc.createElementNS(SVG_NS$5, "line");
    yAxisElem.classList.add(cn$3$5("ax"));
    yAxisElem.setAttributeNS(null, "x1", "50%");
    yAxisElem.setAttributeNS(null, "y1", "0");
    yAxisElem.setAttributeNS(null, "x2", "50%");
    yAxisElem.setAttributeNS(null, "y2", "100%");
    this.svgElem_.appendChild(yAxisElem);
    const lineElem = doc.createElementNS(SVG_NS$5, "line");
    lineElem.classList.add(cn$3$5("l"));
    lineElem.setAttributeNS(null, "x1", "50%");
    lineElem.setAttributeNS(null, "y1", "50%");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$3$5("m"));
    this.padElement.appendChild(markerElem);
    this.markerElem_ = markerElem;
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [x, y2] = this.value.rawValue.getComponents();
    const max = this.props_.get("max");
    const px2 = mapRange$5(x, -max, +max, 0, 100);
    const py2 = mapRange$5(y2, -max, +max, 0, 100);
    const ipy = this.props_.get("invertsY") ? 100 - py2 : py2;
    this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
    this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
    this.markerElem_.style.left = `${px2}%`;
    this.markerElem_.style.top = `${ipy}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
};
function computeOffset$6(ev, keyScales, invertsY) {
  return [
    getStepForKey$5(keyScales[0], getHorizontalStepKeys$5(ev)),
    getStepForKey$5(keyScales[1], getVerticalStepKeys$5(ev)) *
      (invertsY ? 1 : -1),
  ];
}
let Point2dPickerController$5 = class Point2dPickerController2 {
  constructor(doc, config) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new Point2dPickerView$5(doc, {
      layout: config.layout,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$5(this.view.padElement);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
    this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const max = this.props.get("max");
    const px2 = mapRange$5(d.point.x, 0, d.bounds.width, -max, +max);
    const py2 = mapRange$5(
      this.props.get("invertsY") ? d.bounds.height - d.point.y : d.point.y,
      0,
      d.bounds.height,
      -max,
      +max,
    );
    this.value.setRawValue(new Point2d$5(px2, py2), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onPadKeyDown_(ev) {
    if (isArrowKey$5(ev.key)) {
      ev.preventDefault();
    }
    const [dx, dy] = computeOffset$6(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(
      new Point2d$5(this.value.rawValue.x + dx, this.value.rawValue.y + dy),
      {
        forceEmit: false,
        last: false,
      },
    );
  }
  onPadKeyUp_(ev) {
    const [dx, dy] = computeOffset$6(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let Point2dController$5 = class Point2dController2 {
  constructor(doc, config) {
    var _a, _b;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$5.create(config.expanded);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$5(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const padC = new Point2dPickerController$5(doc, {
      layout: config.pickerLayout,
      props: new ValueMap$5({
        invertsY: createValue$5(config.invertsY),
        max: createValue$5(config.max),
        xKeyScale: config.axes[0].textProps.value("keyScale"),
        yKeyScale: config.axes[1].textProps.value("keyScale"),
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    padC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = padC;
    this.textC_ = new PointNdTextController$5(doc, {
      assembly: Point2dAssembly$5,
      axes: config.axes,
      parser: config.parser,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new Point2dView$5(doc, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: config.pickerLayout,
      viewProps: this.viewProps,
    });
    this.view.textElement.appendChild(this.textC_.view.element);
    (_a = this.view.buttonElement) === null || _a === void 0
      ? void 0
      : _a.addEventListener("blur", this.onPadButtonBlur_);
    (_b = this.view.buttonElement) === null || _b === void 0
      ? void 0
      : _b.addEventListener("click", this.onPadButtonClick_);
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(this.pickerC_.view.element);
      connectValues$5({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$5(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$5(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$5(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.view.buttonElement &&
      !supportsTouch$5(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.view.buttonElement.focus();
      }
    }
  }
};
function point2dFromUnknown$5(value) {
  return Point2d$5.isObject(value)
    ? new Point2d$5(value.x, value.y)
    : new Point2d$5();
}
function writePoint2d$5(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
}
function createConstraint$3$5(params, initialValue) {
  return new PointNdConstraint$5({
    assembly: Point2dAssembly$5,
    components: [
      createDimensionConstraint$5(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$5(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
    ],
  });
}
function getSuitableMaxDimensionValue$5(params, rawValue) {
  var _a, _b;
  if (!isEmpty$5(params.min) || !isEmpty$5(params.max)) {
    return Math.max(
      Math.abs((_a = params.min) !== null && _a !== void 0 ? _a : 0),
      Math.abs((_b = params.max) !== null && _b !== void 0 ? _b : 0),
    );
  }
  const step = getSuitableKeyScale$5(params);
  return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
}
function getSuitableMax$5(params, initialValue) {
  var _a, _b;
  const xr = getSuitableMaxDimensionValue$5(
    deepMerge$5(params, (_a = params.x) !== null && _a !== void 0 ? _a : {}),
    initialValue.x,
  );
  const yr = getSuitableMaxDimensionValue$5(
    deepMerge$5(params, (_b = params.y) !== null && _b !== void 0 ? _b : {}),
    initialValue.y,
  );
  return Math.max(xr, yr);
}
function shouldInvertY$5(params) {
  if (!("y" in params)) {
    return false;
  }
  const yParams = params.y;
  if (!yParams) {
    return false;
  }
  return "inverted" in yParams ? !!yParams.inverted : false;
}
createPlugin$5({
  id: "input-point2d",
  type: "input",
  accept: (value, params) => {
    if (!Point2d$5.isObject(value)) {
      return null;
    }
    const result = parseRecord$5(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$5(p)), {
        expanded: p.optional.boolean,
        picker: p.optional.custom(parsePickerLayout$5),
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$5),
        y: p.optional.object(
          Object.assign(Object.assign({}, createPointDimensionParser$5(p)), {
            inverted: p.optional.boolean,
          }),
        ),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: () => point2dFromUnknown$5,
    constraint: (args) => createConstraint$3$5(args.params, args.initialValue),
    equals: Point2d$5.equals,
    writer: () => writePoint2d$5,
  },
  controller: (args) => {
    var _a, _b;
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y];
    return new Point2dController$5(doc, {
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a2;
        return createPointAxis$5({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$5(
            args.params,
            (_a2 = dParams[i]) !== null && _a2 !== void 0 ? _a2 : {},
          ),
        });
      }),
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      invertsY: shouldInvertY$5(args.params),
      max: getSuitableMax$5(args.params, value.rawValue),
      parser: parseNumber$5,
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point3d$5 = class Point3d2 {
  constructor(x = 0, y2 = 0, z = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(obj) {
    if (isEmpty$5(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
    };
  }
};
const Point3dAssembly$5 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point3d$5(...comps),
};
function point3dFromUnknown$5(value) {
  return Point3d$5.isObject(value)
    ? new Point3d$5(value.x, value.y, value.z)
    : new Point3d$5();
}
function writePoint3d$5(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
}
function createConstraint$2$5(params, initialValue) {
  return new PointNdConstraint$5({
    assembly: Point3dAssembly$5,
    components: [
      createDimensionConstraint$5(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$5(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$5(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
    ],
  });
}
createPlugin$5({
  id: "input-point3d",
  type: "input",
  accept: (value, params) => {
    if (!Point3d$5.isObject(value)) {
      return null;
    }
    const result = parseRecord$5(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$5(p)), {
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$5),
        y: p.optional.custom(parsePointDimensionParams$5),
        z: p.optional.custom(parsePointDimensionParams$5),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point3dFromUnknown$5,
    constraint: (args) => createConstraint$2$5(args.params, args.initialValue),
    equals: Point3d$5.equals,
    writer: (_args) => writePoint3d$5,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y, args.params.z];
    return new PointNdTextController$5(args.document, {
      assembly: Point3dAssembly$5,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$5({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$5(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$5,
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point4d$5 = class Point4d2 {
  constructor(x = 0, y2 = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
    this.w = w;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(obj) {
    if (isEmpty$5(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    const w = obj.w;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number" ||
      typeof w !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w,
    };
  }
};
const Point4dAssembly$5 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point4d$5(...comps),
};
function point4dFromUnknown$5(value) {
  return Point4d$5.isObject(value)
    ? new Point4d$5(value.x, value.y, value.z, value.w)
    : new Point4d$5();
}
function writePoint4d$5(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
  target.writeProperty("w", value.w);
}
function createConstraint$1$5(params, initialValue) {
  return new PointNdConstraint$5({
    assembly: Point4dAssembly$5,
    components: [
      createDimensionConstraint$5(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$5(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$5(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
      createDimensionConstraint$5(
        Object.assign(Object.assign({}, params), params.w),
        initialValue.w,
      ),
    ],
  });
}
createPlugin$5({
  id: "input-point4d",
  type: "input",
  accept: (value, params) => {
    if (!Point4d$5.isObject(value)) {
      return null;
    }
    const result = parseRecord$5(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$5(p)), {
        readonly: p.optional.constant(false),
        w: p.optional.custom(parsePointDimensionParams$5),
        x: p.optional.custom(parsePointDimensionParams$5),
        y: p.optional.custom(parsePointDimensionParams$5),
        z: p.optional.custom(parsePointDimensionParams$5),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point4dFromUnknown$5,
    constraint: (args) => createConstraint$1$5(args.params, args.initialValue),
    equals: Point4d$5.equals,
    writer: (_args) => writePoint4d$5,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [
      args.params.x,
      args.params.y,
      args.params.z,
      args.params.w,
    ];
    return new PointNdTextController$5(args.document, {
      assembly: Point4dAssembly$5,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$5({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$5(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$5,
      value,
      viewProps: args.viewProps,
    });
  },
});
function createConstraint$b(params) {
  const constraints = [];
  const lc = createListConstraint$5(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$5(constraints);
}
createPlugin$5({
  id: "input-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$5(params, (p) => ({
      readonly: p.optional.constant(false),
      options: p.optional.custom(parseListOptions$5),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$5,
    constraint: (args) => createConstraint$b(args.params),
    writer: (_args) => writePrimitive$5,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$5(c, ListConstraint$5);
    if (lc) {
      return new ListController$5(doc, {
        props: new ValueMap$5({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new TextController$5(doc, {
      parser: (v) => v,
      props: ValueMap$5.fromObject({
        formatter: formatString$5,
      }),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "string") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$5) {
      return new ListInputBindingApi$5(args.controller);
    }
    return null;
  },
});
const Constants$5 = {
  monitor: {
    defaultInterval: 200,
    defaultRows: 3,
  },
};
const cn$2$5 = ClassName$5("mll");
let MultiLogView$5 = class MultiLogView2 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$2$5());
    config.viewProps.bindClassModifiers(this.element);
    const textareaElem = doc.createElement("textarea");
    textareaElem.classList.add(cn$2$5("i"));
    textareaElem.style.height = `calc(var(${getCssVar$5("containerUnitSize")}) * ${config.rows})`;
    textareaElem.readOnly = true;
    config.viewProps.bindDisabled(textareaElem);
    this.element.appendChild(textareaElem);
    this.textareaElem_ = textareaElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const elem = this.textareaElem_;
    const shouldScroll =
      elem.scrollTop === elem.scrollHeight - elem.clientHeight;
    const lines = [];
    this.value.rawValue.forEach((value) => {
      if (value !== void 0) {
        lines.push(this.formatter_(value));
      }
    });
    elem.textContent = lines.join("\n");
    if (shouldScroll) {
      elem.scrollTop = elem.scrollHeight;
    }
  }
  onValueUpdate_() {
    this.update_();
  }
};
let MultiLogController$5 = class MultiLogController2 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new MultiLogView$5(doc, {
      formatter: config.formatter,
      rows: config.rows,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
const cn$1$5 = ClassName$5("sgl");
let SingleLogView$5 = class SingleLogView2 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$1$5());
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$1$5("i"));
    inputElem.readOnly = true;
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const values = this.value.rawValue;
    const lastValue = values[values.length - 1];
    this.inputElement.value =
      lastValue !== void 0 ? this.formatter_(lastValue) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
};
let SingleLogController$5 = class SingleLogController2 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SingleLogView$5(doc, {
      formatter: config.formatter,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
createPlugin$5({
  id: "monitor-bool",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$5(params, (p) => ({
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$5,
  },
  controller: (args) => {
    var _a;
    if (args.value.rawValue.length === 1) {
      return new SingleLogController$5(args.document, {
        formatter: BooleanFormatter$5,
        value: args.value,
        viewProps: args.viewProps,
      });
    }
    return new MultiLogController$5(args.document, {
      formatter: BooleanFormatter$5,
      rows:
        (_a = args.params.rows) !== null && _a !== void 0
          ? _a
          : Constants$5.monitor.defaultRows,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let GraphLogMonitorBindingApi$5 = class GraphLogMonitorBindingApi2 extends BindingApi$5 {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.props.set("min", min);
  }
};
const cn$v = ClassName$5("grl");
let GraphLogView$5 = class GraphLogView2 {
  constructor(doc, config) {
    this.onCursorChange_ = this.onCursorChange_.bind(this);
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$v());
    config.viewProps.bindClassModifiers(this.element);
    this.formatter_ = config.formatter;
    this.props_ = config.props;
    this.cursor_ = config.cursor;
    this.cursor_.emitter.on("change", this.onCursorChange_);
    const svgElem = doc.createElementNS(SVG_NS$5, "svg");
    svgElem.classList.add(cn$v("g"));
    svgElem.style.height = `calc(var(${getCssVar$5("containerUnitSize")}) * ${config.rows})`;
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const lineElem = doc.createElementNS(SVG_NS$5, "polyline");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(cn$v("t"), ClassName$5("tt")());
    this.element.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const bounds = this.svgElem_.getBoundingClientRect();
    const maxIndex = this.value.rawValue.length - 1;
    const min = this.props_.get("min");
    const max = this.props_.get("max");
    const points = [];
    this.value.rawValue.forEach((v, index) => {
      if (v === void 0) {
        return;
      }
      const x = mapRange$5(index, 0, maxIndex, 0, bounds.width);
      const y2 = mapRange$5(v, min, max, bounds.height, 0);
      points.push([x, y2].join(","));
    });
    this.lineElem_.setAttributeNS(null, "points", points.join(" "));
    const tooltipElem = this.tooltipElem_;
    const value = this.value.rawValue[this.cursor_.rawValue];
    if (value === void 0) {
      tooltipElem.classList.remove(cn$v("t", "a"));
      return;
    }
    const tx = mapRange$5(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
    const ty = mapRange$5(value, min, max, bounds.height, 0);
    tooltipElem.style.left = `${tx}px`;
    tooltipElem.style.top = `${ty}px`;
    tooltipElem.textContent = `${this.formatter_(value)}`;
    if (!tooltipElem.classList.contains(cn$v("t", "a"))) {
      tooltipElem.classList.add(cn$v("t", "a"), cn$v("t", "in"));
      forceReflow$5(tooltipElem);
      tooltipElem.classList.remove(cn$v("t", "in"));
    }
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
};
let GraphLogController$5 = class GraphLogController2 {
  constructor(doc, config) {
    this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.cursor_ = createValue$5(-1);
    this.view = new GraphLogView$5(doc, {
      cursor: this.cursor_,
      formatter: config.formatter,
      rows: config.rows,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    if (!supportsTouch$5(doc)) {
      this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
      this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    } else {
      const ph = new PointerHandler$5(this.view.element);
      ph.emitter.on("down", this.onGraphPointerDown_);
      ph.emitter.on("move", this.onGraphPointerMove_);
      ph.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(state) {
    return importBladeState$5(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        this.props.set("max", result.max);
        this.props.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$5(null, {
      max: this.props.get("max"),
      min: this.props.get("min"),
    });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(ev) {
    const bounds = this.view.element.getBoundingClientRect();
    this.cursor_.rawValue = Math.floor(
      mapRange$5(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length),
    );
  }
  onGraphPointerDown_(ev) {
    this.onGraphPointerMove_(ev);
  }
  onGraphPointerMove_(ev) {
    if (!ev.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(
      mapRange$5(
        ev.data.point.x,
        0,
        ev.data.bounds.width,
        0,
        this.value.rawValue.length,
      ),
    );
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
};
function createFormatter$7(params) {
  return !isEmpty$5(params.format) ? params.format : createNumberFormatter$5(2);
}
function createTextMonitor$5(args) {
  var _a;
  if (args.value.rawValue.length === 1) {
    return new SingleLogController$5(args.document, {
      formatter: createFormatter$7(args.params),
      value: args.value,
      viewProps: args.viewProps,
    });
  }
  return new MultiLogController$5(args.document, {
    formatter: createFormatter$7(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$5.monitor.defaultRows,
    value: args.value,
    viewProps: args.viewProps,
  });
}
function createGraphMonitor$5(args) {
  var _a, _b, _c;
  return new GraphLogController$5(args.document, {
    formatter: createFormatter$7(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$5.monitor.defaultRows,
    props: ValueMap$5.fromObject({
      max: (_b = args.params.max) !== null && _b !== void 0 ? _b : 100,
      min: (_c = args.params.min) !== null && _c !== void 0 ? _c : 0,
    }),
    value: args.value,
    viewProps: args.viewProps,
  });
}
function shouldShowGraph$5(params) {
  return params.view === "graph";
}
createPlugin$5({
  id: "monitor-number",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$5(params, (p) => ({
      format: p.optional.function,
      max: p.optional.number,
      min: p.optional.number,
      readonly: p.required.constant(true),
      rows: p.optional.number,
      view: p.optional.string,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    defaultBufferSize: (params) => (shouldShowGraph$5(params) ? 64 : 1),
    reader: (_args) => numberFromUnknown$5,
  },
  controller: (args) => {
    if (shouldShowGraph$5(args.params)) {
      return createGraphMonitor$5(args);
    }
    return createTextMonitor$5(args);
  },
  api: (args) => {
    if (args.controller.valueController instanceof GraphLogController$5) {
      return new GraphLogMonitorBindingApi$5(args.controller);
    }
    return null;
  },
});
createPlugin$5({
  id: "monitor-string",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$5(params, (p) => ({
      multiline: p.optional.boolean,
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$5,
  },
  controller: (args) => {
    var _a;
    const value = args.value;
    const multiline = value.rawValue.length > 1 || args.params.multiline;
    if (multiline) {
      return new MultiLogController$5(args.document, {
        formatter: formatString$5,
        rows:
          (_a = args.params.rows) !== null && _a !== void 0
            ? _a
            : Constants$5.monitor.defaultRows,
        value,
        viewProps: args.viewProps,
      });
    }
    return new SingleLogController$5(args.document, {
      formatter: formatString$5,
      value,
      viewProps: args.viewProps,
    });
  },
});
function createPlaceholderImage() {
  const svg = `
	<svg width="320" height="50" xmlns="http://www.w3.org/2000/svg">
  <style>
    text {
      font-family: "Menlo", monospace;
      font-size: 12px;
			fill: gray;
    }
  </style>
  <text x="50%" y="55%" text-anchor="middle">
    No Image
  </text>
</svg>`;
  const blob = new Blob([svg], { type: "image/svg+xml" });
  const image = new Image();
  image.src = URL.createObjectURL(blob);
  return image;
}
function loadImage(src) {
  const image = new Image();
  image.crossOrigin = "anonymous";
  image.src = src;
  return image;
}
const className$5 = ClassName$5("img");
class PluginView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(className$5());
    config.viewProps.bindClassModifiers(this.element);
    this.input = doc.createElement("input");
    this.input.classList.add(className$5("input"));
    this.input.setAttribute("type", "file");
    this.input.setAttribute("accept", config.extensions.join(","));
    this.image_ = doc.createElement("img");
    this.image_.id = "tpimg_" + Math.random().toString(36).slice(2);
    this.image_.classList.add(className$5("image"));
    this.image_.classList.add(className$5(`image_${config.imageFit}`));
    this.image_.crossOrigin = "anonymous";
    this.image_.onclick = (event) => {
      config.clickCallback
        ? config.clickCallback(event, this.input)
        : this.input.click();
    };
    this.element.classList.add(className$5("area_root"));
    this.element.appendChild(this.image_);
    this.element.appendChild(this.input);
  }
  changeImage(src) {
    this.image_.src = src;
  }
  changeDraggingState(state) {
    const el = this.element;
    if (state) {
      el === null || el === void 0
        ? void 0
        : el.classList.add(className$5("area_dragging"));
    } else {
      el === null || el === void 0
        ? void 0
        : el.classList.remove(className$5("area_dragging"));
    }
  }
}
let placeholderImage = null;
class PluginController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new PluginView(doc, {
      viewProps: this.viewProps,
      extensions: config.extensions,
      imageFit: config.imageFit,
      clickCallback: config.clickCallback,
    });
    this.onFile = this.onFile.bind(this);
    this.onDrop = this.onDrop.bind(this);
    this.onDragStart = this.onDragStart.bind(this);
    this.onDragOver = this.onDragOver.bind(this);
    this.onDragLeave = this.onDragLeave.bind(this);
    this.view.input.addEventListener("change", this.onFile);
    this.view.element.addEventListener("drop", this.onDrop);
    this.view.element.addEventListener("dragstart", this.onDragStart);
    this.view.element.addEventListener("dragover", this.onDragOver);
    this.view.element.addEventListener("dragleave", this.onDragLeave);
    this.viewProps.handleDispose(() => {
      this.view.input.removeEventListener("change", this.onFile);
      this.view.element.removeEventListener("drop", this.onDrop);
      this.view.element.removeEventListener("dragstart", this.onDragStart);
      this.view.element.removeEventListener("dragover", this.onDragOver);
      this.view.element.removeEventListener("dragleave", this.onDragLeave);
    });
    this.value.emitter.on("change", () => this.handleValueChange());
    this.handleValueChange();
  }
  onFile(event) {
    const files = (event === null || event === void 0 ? void 0 : event.target)
      .files;
    if (!files || !files.length) return;
    const file = files[0];
    this.setValue(file);
  }
  onDrop(event) {
    event.preventDefault();
    try {
      const { dataTransfer } = event;
      const file =
        dataTransfer === null || dataTransfer === void 0
          ? void 0
          : dataTransfer.files[0];
      if (file) {
        this.setValue(file);
      } else {
        const imgId =
          dataTransfer === null || dataTransfer === void 0
            ? void 0
            : dataTransfer.getData("img-id");
        if (imgId) {
          const img = document.getElementById(imgId);
          this.setValue(img);
        } else {
          const url =
            dataTransfer === null || dataTransfer === void 0
              ? void 0
              : dataTransfer.getData("url");
          if (!url) throw new Error("No url");
          this.setValue(url);
        }
      }
    } catch (e) {
      console.error("Could not parse the dropped image", e);
    } finally {
      this.view.changeDraggingState(false);
    }
  }
  onDragStart(event) {
    var _a, _b;
    (_a = event.dataTransfer) === null || _a === void 0
      ? void 0
      : _a.setData("img-id", this.view.image_.id);
    (_b = event.dataTransfer) === null || _b === void 0
      ? void 0
      : _b.setDragImage(this.view.image_, 0, 0);
  }
  onDragOver(event) {
    event.preventDefault();
    this.view.changeDraggingState(true);
  }
  onDragLeave() {
    this.view.changeDraggingState(false);
  }
  handleImage(image) {
    if (image instanceof HTMLImageElement) {
      this.updateImage(image.src);
    } else if (typeof image === "string" || !image) {
      if (image === "placeholder" || !image) {
        image = this.handlePlaceholderImage().src;
      }
      this.updateImage(image);
    } else {
      this.setValue(image);
    }
  }
  updateImage(src) {
    this.view.changeImage(src);
  }
  setValue(src) {
    if (src instanceof HTMLImageElement) {
      this.value.setRawValue(src);
    } else if (src instanceof File) {
      const url = URL.createObjectURL(src) + "#" + src.name;
      src.src = url;
      const img = loadImage(url);
      this.value.setRawValue(img || src);
    } else if (src) {
      this.value.setRawValue(loadImage(src));
    } else {
      this.value.setRawValue(this.handlePlaceholderImage());
    }
  }
  handleValueChange() {
    this.handleImage(this.value.rawValue);
  }
  handlePlaceholderImage() {
    if (!placeholderImage) {
      placeholderImage = createPlaceholderImage();
    }
    return placeholderImage;
  }
}
const DEFAULT_EXTENSIONS = [".jpg", ".png", ".gif"];
createPlugin$5({
  id: "input-image",
  type: "input",
  accept(exValue, params) {
    if (!(exValue instanceof HTMLImageElement || typeof exValue === "string")) {
      return null;
    }
    const result = parseRecord$5(params, (p) => ({
      view: p.required.constant("input-image"),
      acceptUrl: p.optional.boolean,
      clickCallback: p.optional.function,
      imageFit: p.optional.custom((v) =>
        v === "contain" || v === "cover" ? v : void 0,
      ),
      extensions: p.optional.array(p.required.string),
    }));
    if (!result) {
      return null;
    }
    return {
      initialValue: exValue,
      params: result,
    };
  },
  binding: {
    reader(_args) {
      return (exValue) => {
        if (exValue.src !== void 0) {
          return exValue.src === "" ? "placeholder" : exValue.src;
        } else {
          return typeof exValue === "string" ? exValue : exValue;
        }
      };
    },
    writer(_args) {
      return (target, inValue) => {
        target.write(inValue);
      };
    },
  },
  controller(args) {
    var _a, _b;
    return new PluginController(args.document, {
      value: args.value,
      imageFit:
        (_a = args.params.imageFit) !== null && _a !== void 0 ? _a : "cover",
      clickCallback: args.params.clickCallback,
      viewProps: args.viewProps,
      extensions:
        (_b = args.params.extensions) !== null && _b !== void 0
          ? _b
          : DEFAULT_EXTENSIONS,
    });
  },
});
function forceCast$4(v) {
  return v;
}
function isEmpty$4(value) {
  return value === null || value === void 0;
}
function isObject$1$4(value) {
  return value !== null && typeof value === "object";
}
function isRecord$4(value) {
  return value !== null && typeof value === "object";
}
function deepEqualsArray$4(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (let i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
function deepMerge$4(r1, r2) {
  const keys = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(r1), ...Object.keys(r2)]),
  );
  return keys.reduce((result, key2) => {
    const v1 = r1[key2];
    const v2 = r2[key2];
    return isRecord$4(v1) && isRecord$4(v2)
      ? Object.assign(Object.assign({}, result), {
          [key2]: deepMerge$4(v1, v2),
        })
      : Object.assign(Object.assign({}, result), {
          [key2]: key2 in r2 ? v2 : v1,
        });
  }, {});
}
function isBinding$4(value) {
  if (!isObject$1$4(value)) {
    return false;
  }
  return "target" in value;
}
const CREATE_MESSAGE_MAP$4 = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (context) => `Invalid parameters for '${context.name}'`,
  nomatchingcontroller: (context) =>
    `No matching controller for '${context.key}'`,
  nomatchingview: (context) =>
    `No matching view for '${JSON.stringify(context.params)}'`,
  notbindable: () => `Value is not bindable`,
  notcompatible: (context) => `Not compatible with  plugin '${context.id}'`,
  propertynotfound: (context) => `Property '${context.name}' not found`,
  shouldneverhappen: () => "This error should never happen",
};
let TpError$4 = class TpError3 {
  static alreadyDisposed() {
    return new TpError3({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new TpError3({
      type: "notbindable",
    });
  }
  static notCompatible(bundleId, id) {
    return new TpError3({
      type: "notcompatible",
      context: {
        id: `${bundleId}.${id}`,
      },
    });
  }
  static propertyNotFound(name) {
    return new TpError3({
      type: "propertynotfound",
      context: {
        name,
      },
    });
  }
  static shouldNeverHappen() {
    return new TpError3({ type: "shouldneverhappen" });
  }
  constructor(config) {
    var _a;
    this.message =
      (_a = CREATE_MESSAGE_MAP$4[config.type](forceCast$4(config.context))) !==
        null && _a !== void 0
        ? _a
        : "Unexpected error";
    this.name = this.constructor.name;
    this.stack = new Error(this.message).stack;
    this.type = config.type;
  }
  toString() {
    return this.message;
  }
};
let BindingTarget$4 = class BindingTarget3 {
  constructor(obj, key2) {
    this.obj_ = obj;
    this.key = key2;
  }
  static isBindable(obj) {
    if (obj === null) {
      return false;
    }
    if (typeof obj !== "object" && typeof obj !== "function") {
      return false;
    }
    return true;
  }
  read() {
    return this.obj_[this.key];
  }
  write(value) {
    this.obj_[this.key] = value;
  }
  writeProperty(name, value) {
    const valueObj = this.read();
    if (!BindingTarget3.isBindable(valueObj)) {
      throw TpError$4.notBindable();
    }
    if (!(name in valueObj)) {
      throw TpError$4.propertyNotFound(name);
    }
    valueObj[name] = value;
  }
};
let Emitter$4 = class Emitter3 {
  constructor() {
    this.observers_ = {};
  }
  on(eventName, handler) {
    let observers = this.observers_[eventName];
    if (!observers) {
      observers = this.observers_[eventName] = [];
    }
    observers.push({
      handler,
    });
    return this;
  }
  off(eventName, handler) {
    const observers = this.observers_[eventName];
    if (observers) {
      this.observers_[eventName] = observers.filter((observer) => {
        return observer.handler !== handler;
      });
    }
    return this;
  }
  emit(eventName, event) {
    const observers = this.observers_[eventName];
    if (!observers) {
      return;
    }
    observers.forEach((observer) => {
      observer.handler(event);
    });
  }
};
let ComplexValue$4 = class ComplexValue3 {
  constructor(initialValue, config) {
    var _a;
    this.constraint_ =
      config === null || config === void 0 ? void 0 : config.constraint;
    this.equals_ =
      (_a = config === null || config === void 0 ? void 0 : config.equals) !==
        null && _a !== void 0
        ? _a
        : (v1, v2) => v1 === v2;
    this.emitter = new Emitter$4();
    this.rawValue_ = initialValue;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(rawValue) {
    this.setRawValue(rawValue, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(rawValue, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const constrainedValue = this.constraint_
      ? this.constraint_.constrain(rawValue)
      : rawValue;
    const prevValue = this.rawValue_;
    const changed = !this.equals_(prevValue, constrainedValue);
    if (!changed && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.rawValue_ = constrainedValue;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: constrainedValue,
      sender: this,
    });
  }
};
let PrimitiveValue$4 = class PrimitiveValue3 {
  constructor(initialValue) {
    this.emitter = new Emitter$4();
    this.value_ = initialValue;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(value) {
    this.setRawValue(value, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(value, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const prevValue = this.value_;
    if (prevValue === value && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.value_ = value;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: this.value_,
      sender: this,
    });
  }
};
let ReadonlyPrimitiveValue$4 = class ReadonlyPrimitiveValue3 {
  constructor(value) {
    this.emitter = new Emitter$4();
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value_ = value;
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit(
      "beforechange",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
  onValueChange_(ev) {
    this.emitter.emit(
      "change",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
};
function createValue$4(initialValue, config) {
  const constraint =
    config === null || config === void 0 ? void 0 : config.constraint;
  const equals2 = config === null || config === void 0 ? void 0 : config.equals;
  if (!constraint && !equals2) {
    return new PrimitiveValue$4(initialValue);
  }
  return new ComplexValue$4(initialValue, config);
}
function createReadonlyValue$4(value) {
  return [
    new ReadonlyPrimitiveValue$4(value),
    (rawValue, options) => {
      value.setRawValue(rawValue, options);
    },
  ];
}
let ValueMap$4 = class ValueMap3 {
  constructor(valueMap) {
    this.emitter = new Emitter$4();
    this.valMap_ = valueMap;
    for (const key2 in this.valMap_) {
      const v = this.valMap_[key2];
      v.emitter.on("change", () => {
        this.emitter.emit("change", {
          key: key2,
          sender: this,
        });
      });
    }
  }
  static createCore(initialValue) {
    const keys = Object.keys(initialValue);
    return keys.reduce((o, key2) => {
      return Object.assign(o, {
        [key2]: createValue$4(initialValue[key2]),
      });
    }, {});
  }
  static fromObject(initialValue) {
    const core = this.createCore(initialValue);
    return new ValueMap3(core);
  }
  get(key2) {
    return this.valMap_[key2].rawValue;
  }
  set(key2, value) {
    this.valMap_[key2].rawValue = value;
  }
  value(key2) {
    return this.valMap_[key2];
  }
};
let DefiniteRangeConstraint$4 = class DefiniteRangeConstraint3 {
  constructor(config) {
    this.values = ValueMap$4.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    return Math.min(Math.max(value, min), max);
  }
};
let RangeConstraint$4 = class RangeConstraint3 {
  constructor(config) {
    this.values = ValueMap$4.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    let result = value;
    if (!isEmpty$4(min)) {
      result = Math.max(result, min);
    }
    if (!isEmpty$4(max)) {
      result = Math.min(result, max);
    }
    return result;
  }
};
let StepConstraint$4 = class StepConstraint3 {
  constructor(step, origin = 0) {
    this.step = step;
    this.origin = origin;
  }
  constrain(value) {
    const o = this.origin % this.step;
    const r = Math.round((value - o) / this.step);
    return o + r * this.step;
  }
};
let NumberLiteralNode$4 = class NumberLiteralNode3 {
  constructor(text) {
    this.text = text;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
};
const BINARY_OPERATION_MAP$4 = {
  "**": (v1, v2) => Math.pow(v1, v2),
  "*": (v1, v2) => v1 * v2,
  "/": (v1, v2) => v1 / v2,
  "%": (v1, v2) => v1 % v2,
  "+": (v1, v2) => v1 + v2,
  "-": (v1, v2) => v1 - v2,
  "<<": (v1, v2) => v1 << v2,
  ">>": (v1, v2) => v1 >> v2,
  ">>>": (v1, v2) => v1 >>> v2,
  "&": (v1, v2) => v1 & v2,
  "^": (v1, v2) => v1 ^ v2,
  "|": (v1, v2) => v1 | v2,
};
let BinaryOperationNode$4 = class BinaryOperationNode3 {
  constructor(operator, left, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  evaluate() {
    const op = BINARY_OPERATION_MAP$4[this.operator];
    if (!op) {
      throw new Error(`unexpected binary operator: '${this.operator}`);
    }
    return op(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")",
    ].join(" ");
  }
};
const UNARY_OPERATION_MAP$4 = {
  "+": (v) => v,
  "-": (v) => -v,
  "~": (v) => ~v,
};
let UnaryOperationNode$4 = class UnaryOperationNode3 {
  constructor(operator, expr) {
    this.operator = operator;
    this.expression = expr;
  }
  evaluate() {
    const op = UNARY_OPERATION_MAP$4[this.operator];
    if (!op) {
      throw new Error(`unexpected unary operator: '${this.operator}`);
    }
    return op(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
};
function combineReader$4(parsers) {
  return (text, cursor) => {
    for (let i = 0; i < parsers.length; i++) {
      const result = parsers[i](text, cursor);
      if (result !== "") {
        return result;
      }
    }
    return "";
  };
}
function readWhitespace$4(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^\s+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readNonZeroDigit$4(text, cursor) {
  const ch = text.substr(cursor, 1);
  return ch.match(/^[1-9]$/) ? ch : "";
}
function readDecimalDigits$4(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readSignedInteger$4(text, cursor) {
  const ds = readDecimalDigits$4(text, cursor);
  if (ds !== "") {
    return ds;
  }
  const sign2 = text.substr(cursor, 1);
  cursor += 1;
  if (sign2 !== "-" && sign2 !== "+") {
    return "";
  }
  const sds = readDecimalDigits$4(text, cursor);
  if (sds === "") {
    return "";
  }
  return sign2 + sds;
}
function readExponentPart$4(text, cursor) {
  const e = text.substr(cursor, 1);
  cursor += 1;
  if (e.toLowerCase() !== "e") {
    return "";
  }
  const si = readSignedInteger$4(text, cursor);
  if (si === "") {
    return "";
  }
  return e + si;
}
function readDecimalIntegerLiteral$4(text, cursor) {
  const ch = text.substr(cursor, 1);
  if (ch === "0") {
    return ch;
  }
  const nzd = readNonZeroDigit$4(text, cursor);
  cursor += nzd.length;
  if (nzd === "") {
    return "";
  }
  return nzd + readDecimalDigits$4(text, cursor);
}
function readDecimalLiteral1$4(text, cursor) {
  const dil = readDecimalIntegerLiteral$4(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$4(text, cursor);
  cursor += dds.length;
  return dil + dot2 + dds + readExponentPart$4(text, cursor);
}
function readDecimalLiteral2$4(text, cursor) {
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$4(text, cursor);
  cursor += dds.length;
  if (dds === "") {
    return "";
  }
  return dot2 + dds + readExponentPart$4(text, cursor);
}
function readDecimalLiteral3$4(text, cursor) {
  const dil = readDecimalIntegerLiteral$4(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  return dil + readExponentPart$4(text, cursor);
}
const readDecimalLiteral$4 = combineReader$4([
  readDecimalLiteral1$4,
  readDecimalLiteral2$4,
  readDecimalLiteral3$4,
]);
function parseBinaryDigits$4(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[01]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readBinaryIntegerLiteral$4(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0b") {
    return "";
  }
  const bds = parseBinaryDigits$4(text, cursor);
  if (bds === "") {
    return "";
  }
  return prefix + bds;
}
function readOctalDigits$4(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-7]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readOctalIntegerLiteral$4(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0o") {
    return "";
  }
  const ods = readOctalDigits$4(text, cursor);
  if (ods === "") {
    return "";
  }
  return prefix + ods;
}
function readHexDigits$4(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9a-f]+/i);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readHexIntegerLiteral$4(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0x") {
    return "";
  }
  const hds = readHexDigits$4(text, cursor);
  if (hds === "") {
    return "";
  }
  return prefix + hds;
}
const readNonDecimalIntegerLiteral$4 = combineReader$4([
  readBinaryIntegerLiteral$4,
  readOctalIntegerLiteral$4,
  readHexIntegerLiteral$4,
]);
const readNumericLiteral$4 = combineReader$4([
  readNonDecimalIntegerLiteral$4,
  readDecimalLiteral$4,
]);
function parseLiteral$4(text, cursor) {
  const num = readNumericLiteral$4(text, cursor);
  cursor += num.length;
  if (num === "") {
    return null;
  }
  return {
    evaluable: new NumberLiteralNode$4(num),
    cursor,
  };
}
function parseParenthesizedExpression$4(text, cursor) {
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "(") {
    return null;
  }
  const expr = parseExpression$4(text, cursor);
  if (!expr) {
    return null;
  }
  cursor = expr.cursor;
  cursor += readWhitespace$4(text, cursor).length;
  const cl = text.substr(cursor, 1);
  cursor += cl.length;
  if (cl !== ")") {
    return null;
  }
  return {
    evaluable: expr.evaluable,
    cursor,
  };
}
function parsePrimaryExpression$4(text, cursor) {
  var _a;
  return (_a = parseLiteral$4(text, cursor)) !== null && _a !== void 0
    ? _a
    : parseParenthesizedExpression$4(text, cursor);
}
function parseUnaryExpression$4(text, cursor) {
  const expr = parsePrimaryExpression$4(text, cursor);
  if (expr) {
    return expr;
  }
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "+" && op !== "-" && op !== "~") {
    return null;
  }
  const num = parseUnaryExpression$4(text, cursor);
  if (!num) {
    return null;
  }
  cursor = num.cursor;
  return {
    cursor,
    evaluable: new UnaryOperationNode$4(op, num.evaluable),
  };
}
function readBinaryOperator$4(ops, text, cursor) {
  cursor += readWhitespace$4(text, cursor).length;
  const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
  if (!op) {
    return null;
  }
  cursor += op.length;
  cursor += readWhitespace$4(text, cursor).length;
  return {
    cursor,
    operator: op,
  };
}
function createBinaryOperationExpressionParser$4(exprParser, ops) {
  return (text, cursor) => {
    const firstExpr = exprParser(text, cursor);
    if (!firstExpr) {
      return null;
    }
    cursor = firstExpr.cursor;
    let expr = firstExpr.evaluable;
    for (;;) {
      const op = readBinaryOperator$4(ops, text, cursor);
      if (!op) {
        break;
      }
      cursor = op.cursor;
      const nextExpr = exprParser(text, cursor);
      if (!nextExpr) {
        return null;
      }
      cursor = nextExpr.cursor;
      expr = new BinaryOperationNode$4(op.operator, expr, nextExpr.evaluable);
    }
    return expr
      ? {
          cursor,
          evaluable: expr,
        }
      : null;
  };
}
const parseBinaryOperationExpression$4 = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"],
].reduce((parser, ops) => {
  return createBinaryOperationExpressionParser$4(parser, ops);
}, parseUnaryExpression$4);
function parseExpression$4(text, cursor) {
  cursor += readWhitespace$4(text, cursor).length;
  return parseBinaryOperationExpression$4(text, cursor);
}
function parseEcmaNumberExpression$4(text) {
  const expr = parseExpression$4(text, 0);
  if (!expr) {
    return null;
  }
  const cursor = expr.cursor + readWhitespace$4(text, expr.cursor).length;
  if (cursor !== text.length) {
    return null;
  }
  return expr.evaluable;
}
function parseNumber$4(text) {
  var _a;
  const r = parseEcmaNumberExpression$4(text);
  return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null &&
    _a !== void 0
    ? _a
    : null;
}
function numberFromUnknown$4(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const pv = parseNumber$4(value);
    if (!isEmpty$4(pv)) {
      return pv;
    }
  }
  return 0;
}
function createNumberFormatter$4(digits) {
  return (value) => {
    return value.toFixed(Math.max(Math.min(digits, 20), 0));
  };
}
function mapRange$4(value, start1, end1, start2, end2) {
  const p = (value - start1) / (end1 - start1);
  return start2 + p * (end2 - start2);
}
function getDecimalDigits$4(value) {
  const text = String(value.toFixed(10));
  const frac = text.split(".")[1];
  return frac.replace(/0+$/, "").length;
}
function constrainRange$4(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function loopRange$4(value, max) {
  return ((value % max) + max) % max;
}
function getSuitableDecimalDigits$4(params, rawValue) {
  return !isEmpty$4(params.step)
    ? getDecimalDigits$4(params.step)
    : Math.max(getDecimalDigits$4(rawValue), 2);
}
function getSuitableKeyScale$4(params) {
  var _a;
  return (_a = params.step) !== null && _a !== void 0 ? _a : 1;
}
function getSuitablePointerScale$4(params, rawValue) {
  var _a;
  const base2 = Math.abs(
    (_a = params.step) !== null && _a !== void 0 ? _a : rawValue,
  );
  return base2 === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base2)) - 1);
}
function createStepConstraint$4(params, initialValue) {
  if (!isEmpty$4(params.step)) {
    return new StepConstraint$4(params.step, initialValue);
  }
  return null;
}
function createRangeConstraint$4(params) {
  if (!isEmpty$4(params.max) && !isEmpty$4(params.min)) {
    return new DefiniteRangeConstraint$4({
      max: params.max,
      min: params.min,
    });
  }
  if (!isEmpty$4(params.max) || !isEmpty$4(params.min)) {
    return new RangeConstraint$4({
      max: params.max,
      min: params.min,
    });
  }
  return null;
}
function createNumberTextPropsObject$4(params, initialValue) {
  var _a, _b, _c;
  return {
    formatter:
      (_a = params.format) !== null && _a !== void 0
        ? _a
        : createNumberFormatter$4(
            getSuitableDecimalDigits$4(params, initialValue),
          ),
    keyScale:
      (_b = params.keyScale) !== null && _b !== void 0
        ? _b
        : getSuitableKeyScale$4(params),
    pointerScale:
      (_c = params.pointerScale) !== null && _c !== void 0
        ? _c
        : getSuitablePointerScale$4(params, initialValue),
  };
}
function createNumberTextInputParamsParser$4(p) {
  return {
    format: p.optional.function,
    keyScale: p.optional.number,
    max: p.optional.number,
    min: p.optional.number,
    pointerScale: p.optional.number,
    step: p.optional.number,
  };
}
function createPointAxis$4(config) {
  return {
    constraint: config.constraint,
    textProps: ValueMap$4.fromObject(
      createNumberTextPropsObject$4(config.params, config.initialValue),
    ),
  };
}
let BladeApi$4 = class BladeApi3 {
  constructor(controller) {
    this.controller = controller;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller.viewProps.set("disabled", disabled);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(hidden) {
    this.controller.viewProps.set("hidden", hidden);
  }
  dispose() {
    this.controller.viewProps.set("disposed", true);
  }
  importState(state) {
    return this.controller.importState(state);
  }
  exportState() {
    return this.controller.exportState();
  }
};
let TpEvent$4 = class TpEvent3 {
  constructor(target) {
    this.target = target;
  }
};
let TpChangeEvent$4 = class TpChangeEvent3 extends TpEvent$4 {
  constructor(target, value, last) {
    super(target);
    this.value = value;
    this.last = last !== null && last !== void 0 ? last : true;
  }
};
let TpFoldEvent$4 = class TpFoldEvent3 extends TpEvent$4 {
  constructor(target, expanded) {
    super(target);
    this.expanded = expanded;
  }
};
let TpTabSelectEvent$4 = class TpTabSelectEvent3 extends TpEvent$4 {
  constructor(target, index) {
    super(target);
    this.index = index;
  }
};
let BindingApi$4 = class BindingApi3 extends BladeApi$4 {
  constructor(controller) {
    super(controller);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.emitter_ = new Emitter$4();
    this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(tag) {
    this.controller.tag = tag;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(ev) {
    const value = this.controller.value;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$4(
        this,
        forceCast$4(value.binding.target.read()),
        ev.options.last,
      ),
    );
  }
};
function parseObject$4(value, keyToParserMap) {
  const keys = Object.keys(keyToParserMap);
  const result = keys.reduce((tmp2, key2) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const parser = keyToParserMap[key2];
    const result2 = parser(value[key2]);
    return result2.succeeded
      ? Object.assign(Object.assign({}, tmp2), { [key2]: result2.value })
      : void 0;
  }, {});
  return forceCast$4(result);
}
function parseArray$4(value, parseItem) {
  return value.reduce((tmp2, item) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const result = parseItem(item);
    if (!result.succeeded || result.value === void 0) {
      return void 0;
    }
    return [...tmp2, result.value];
  }, []);
}
function isObject$5(value) {
  if (value === null) {
    return false;
  }
  return typeof value === "object";
}
function createMicroParserBuilder$4(parse) {
  return (optional) => (v) => {
    if (!optional && v === void 0) {
      return {
        succeeded: false,
        value: void 0,
      };
    }
    if (optional && v === void 0) {
      return {
        succeeded: true,
        value: void 0,
      };
    }
    const result = parse(v);
    return result !== void 0
      ? {
          succeeded: true,
          value: result,
        }
      : {
          succeeded: false,
          value: void 0,
        };
  };
}
function createMicroParserBuilders$4(optional) {
  return {
    custom: (parse) => createMicroParserBuilder$4(parse)(optional),
    boolean: createMicroParserBuilder$4((v) =>
      typeof v === "boolean" ? v : void 0,
    )(optional),
    number: createMicroParserBuilder$4((v) =>
      typeof v === "number" ? v : void 0,
    )(optional),
    string: createMicroParserBuilder$4((v) =>
      typeof v === "string" ? v : void 0,
    )(optional),
    function: createMicroParserBuilder$4((v) =>
      typeof v === "function" ? v : void 0,
    )(optional),
    constant: (value) =>
      createMicroParserBuilder$4((v) => (v === value ? value : void 0))(
        optional,
      ),
    raw: createMicroParserBuilder$4((v) => v)(optional),
    object: (keyToParserMap) =>
      createMicroParserBuilder$4((v) => {
        if (!isObject$5(v)) {
          return void 0;
        }
        return parseObject$4(v, keyToParserMap);
      })(optional),
    array: (itemParser) =>
      createMicroParserBuilder$4((v) => {
        if (!Array.isArray(v)) {
          return void 0;
        }
        return parseArray$4(v, itemParser);
      })(optional),
  };
}
const MicroParsers$4 = {
  optional: createMicroParserBuilders$4(true),
  required: createMicroParserBuilders$4(false),
};
function parseRecord$4(value, keyToParserMap) {
  const map = keyToParserMap(MicroParsers$4);
  const result = MicroParsers$4.required.object(map)(value);
  return result.succeeded ? result.value : void 0;
}
function importBladeState$4(state, superImport, parser, callback) {
  if (superImport && !superImport(state)) {
    return false;
  }
  const result = parseRecord$4(state, parser);
  return result ? callback(result) : false;
}
function exportBladeState$4(superExport, thisState) {
  var _a;
  return deepMerge$4(
    (_a =
      superExport === null || superExport === void 0
        ? void 0
        : superExport()) !== null && _a !== void 0
      ? _a
      : {},
    thisState,
  );
}
function isValueBladeController$4(bc) {
  return "value" in bc;
}
function isBindingValue$4(v) {
  if (!isObject$1$4(v) || !("binding" in v)) {
    return false;
  }
  const b = v.binding;
  return isBinding$4(b);
}
const SVG_NS$4 = "http://www.w3.org/2000/svg";
function forceReflow$4(element) {
  element.offsetHeight;
}
function disableTransitionTemporarily$4(element, callback) {
  const t = element.style.transition;
  element.style.transition = "none";
  callback();
  element.style.transition = t;
}
function supportsTouch$4(doc) {
  return doc.ontouchstart !== void 0;
}
function getCanvasContext$4(canvasElement) {
  const win = canvasElement.ownerDocument.defaultView;
  if (!win) {
    return null;
  }
  const isBrowser = "document" in win;
  return isBrowser
    ? canvasElement.getContext("2d", {
        willReadFrequently: true,
      })
    : null;
}
const ICON_ID_TO_INNER_HTML_MAP$4 = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad:
    '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function createSvgIconElement$4(document2, iconId) {
  const elem = document2.createElementNS(SVG_NS$4, "svg");
  elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP$4[iconId];
  return elem;
}
function insertElementAt$4(parentElement, element, index) {
  parentElement.insertBefore(element, parentElement.children[index]);
}
function removeElement$4(element) {
  if (element.parentElement) {
    element.parentElement.removeChild(element);
  }
}
function removeChildElements$4(element) {
  while (element.children.length > 0) {
    element.removeChild(element.children[0]);
  }
}
function removeChildNodes$4(element) {
  while (element.childNodes.length > 0) {
    element.removeChild(element.childNodes[0]);
  }
}
function findNextTarget$4(ev) {
  if (ev.relatedTarget) {
    return forceCast$4(ev.relatedTarget);
  }
  if ("explicitOriginalTarget" in ev) {
    return ev.explicitOriginalTarget;
  }
  return null;
}
function bindValue$4(value, applyValue) {
  value.emitter.on("change", (ev) => {
    applyValue(ev.rawValue);
  });
  applyValue(value.rawValue);
}
function bindValueMap$4(valueMap, key2, applyValue) {
  bindValue$4(valueMap.value(key2), applyValue);
}
const PREFIX$4 = "tp";
function ClassName$4(viewName) {
  const fn = (opt_elementName, opt_modifier) => {
    return [
      PREFIX$4,
      "-",
      viewName,
      "v",
      opt_elementName ? `_${opt_elementName}` : "",
      opt_modifier ? `-${opt_modifier}` : "",
    ].join("");
  };
  return fn;
}
const cn$q$4 = ClassName$4("lbl");
function createLabelNode$4(doc, label) {
  const frag = doc.createDocumentFragment();
  const lineNodes = label.split("\n").map((line) => {
    return doc.createTextNode(line);
  });
  lineNodes.forEach((lineNode, index) => {
    if (index > 0) {
      frag.appendChild(doc.createElement("br"));
    }
    frag.appendChild(lineNode);
  });
  return frag;
}
let LabelView$4 = class LabelView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$q$4());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("div");
    labelElem.classList.add(cn$q$4("l"));
    bindValueMap$4(config.props, "label", (value) => {
      if (isEmpty$4(value)) {
        this.element.classList.add(cn$q$4(void 0, "nol"));
      } else {
        this.element.classList.remove(cn$q$4(void 0, "nol"));
        removeChildNodes$4(labelElem);
        labelElem.appendChild(createLabelNode$4(doc, value));
      }
    });
    this.element.appendChild(labelElem);
    this.labelElement = labelElem;
    const valueElem = doc.createElement("div");
    valueElem.classList.add(cn$q$4("v"));
    this.element.appendChild(valueElem);
    this.valueElement = valueElem;
  }
};
let LabelController$4 = class LabelController3 {
  constructor(doc, config) {
    this.props = config.props;
    this.valueController = config.valueController;
    this.viewProps = config.valueController.viewProps;
    this.view = new LabelView$4(doc, {
      props: config.props,
      viewProps: this.viewProps,
    });
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(state) {
    return importBladeState$4(
      state,
      null,
      (p) => ({
        label: p.optional.string,
      }),
      (result) => {
        this.props.set("label", result.label);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$4(null, {
      label: this.props.get("label"),
    });
  }
};
function getAllBladePositions$4() {
  return ["veryfirst", "first", "last", "verylast"];
}
const cn$p$4 = ClassName$4("");
const POS_TO_CLASS_NAME_MAP$4 = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst",
};
let BladeController$4 = class BladeController3 {
  constructor(config) {
    this.parent_ = null;
    this.blade = config.blade;
    this.view = config.view;
    this.viewProps = config.viewProps;
    const elem = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      getAllBladePositions$4().forEach((pos) => {
        elem.classList.remove(cn$p$4(void 0, POS_TO_CLASS_NAME_MAP$4[pos]));
      });
      this.blade.get("positions").forEach((pos) => {
        elem.classList.add(cn$p$4(void 0, POS_TO_CLASS_NAME_MAP$4[pos]));
      });
    });
    this.viewProps.handleDispose(() => {
      removeElement$4(elem);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(parent) {
    this.parent_ = parent;
    this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(state) {
    return importBladeState$4(
      state,
      null,
      (p) => ({
        disabled: p.required.boolean,
        hidden: p.required.boolean,
      }),
      (result) => {
        this.viewProps.importState(result);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$4(
      null,
      Object.assign({}, this.viewProps.exportState()),
    );
  }
};
let ButtonApi$4 = class ButtonApi3 extends BladeApi$4 {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get title() {
    var _a;
    return (_a = this.controller.buttonController.props.get("title")) !==
      null && _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.buttonController.props.set("title", title);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller.buttonController.emitter;
    emitter.on(eventName, () => {
      bh(new TpEvent$4(this));
    });
    return this;
  }
};
function applyClass$4(elem, className2, active) {
  if (active) {
    elem.classList.add(className2);
  } else {
    elem.classList.remove(className2);
  }
}
function valueToClassName$4(elem, className2) {
  return (value) => {
    applyClass$4(elem, className2, value);
  };
}
function bindValueToTextContent$4(value, elem) {
  bindValue$4(value, (text) => {
    elem.textContent = text !== null && text !== void 0 ? text : "";
  });
}
const cn$o$4 = ClassName$4("btn");
let ButtonView$4 = class ButtonView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$o$4());
    config.viewProps.bindClassModifiers(this.element);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$o$4("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$o$4("t"));
    bindValueToTextContent$4(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
  }
};
let ButtonController$4 = class ButtonController3 {
  constructor(doc, config) {
    this.emitter = new Emitter$4();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new ButtonView$4(doc, {
      props: this.props,
      viewProps: this.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(state) {
    return importBladeState$4(
      state,
      null,
      (p) => ({
        title: p.optional.string,
      }),
      (result) => {
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$4(null, {
      title: this.props.get("title"),
    });
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let ButtonBladeController$4 = class ButtonBladeController3 extends BladeController$4 {
  constructor(doc, config) {
    const bc = new ButtonController$4(doc, {
      props: config.buttonProps,
      viewProps: config.viewProps,
    });
    const lc = new LabelController$4(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: config.viewProps,
    });
    this.buttonController = bc;
    this.labelController = lc;
  }
  importState(state) {
    return importBladeState$4(
      state,
      (s) =>
        super.importState(s) &&
        this.buttonController.importProps(s) &&
        this.labelController.importProps(s),
      () => ({}),
      () => true,
    );
  }
  exportState() {
    return exportBladeState$4(
      () => super.exportState(),
      Object.assign(
        Object.assign({}, this.buttonController.exportProps()),
        this.labelController.exportProps(),
      ),
    );
  }
};
let Semver$4 = class Semver3 {
  constructor(text) {
    const [core, prerelease] = text.split("-");
    const coreComps = core.split(".");
    this.major = parseInt(coreComps[0], 10);
    this.minor = parseInt(coreComps[1], 10);
    this.patch = parseInt(coreComps[2], 10);
    this.prerelease =
      prerelease !== null && prerelease !== void 0 ? prerelease : null;
  }
  toString() {
    const core = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
  }
};
const VERSION$4 = new Semver$4("2.0.0-beta.2");
function createPlugin$4(plugin) {
  return Object.assign({ core: VERSION$4 }, plugin);
}
createPlugin$4({
  id: "button",
  type: "blade",
  accept(params) {
    const result = parseRecord$4(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("button"),
      label: p.optional.string,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new ButtonBladeController$4(args.document, {
      blade: args.blade,
      buttonProps: ValueMap$4.fromObject({
        title: args.params.title,
      }),
      labelProps: ValueMap$4.fromObject({
        label: args.params.label,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (args.controller instanceof ButtonBladeController$4) {
      return new ButtonApi$4(args.controller);
    }
    return null;
  },
});
function addButtonAsBlade$4(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "button" }),
  );
}
function addFolderAsBlade$4(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "folder" }),
  );
}
function addTabAsBlade$4(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "tab" }),
  );
}
function isRefreshable$4(value) {
  if (!isObject$1$4(value)) {
    return false;
  }
  return "refresh" in value && typeof value.refresh === "function";
}
function createBindingTarget$4(obj, key2) {
  if (!BindingTarget$4.isBindable(obj)) {
    throw TpError$4.notBindable();
  }
  return new BindingTarget$4(obj, key2);
}
let RackApi$4 = class RackApi3 {
  constructor(controller, pool) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.controller_ = controller;
    this.emitter_ = new Emitter$4();
    this.pool_ = pool;
    const rack = this.controller_.rack;
    rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((bc) => this.pool_.createApi(bc));
  }
  addBinding(object, key2, opt_params) {
    const params =
      opt_params !== null && opt_params !== void 0 ? opt_params : {};
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBinding(
      doc,
      createBindingTarget$4(object, key2),
      params,
    );
    const api = this.pool_.createBindingApi(bc);
    return this.add(api, params.index);
  }
  addFolder(params) {
    return addFolderAsBlade$4(this, params);
  }
  addButton(params) {
    return addButtonAsBlade$4(this, params);
  }
  addTab(params) {
    return addTabAsBlade$4(this, params);
  }
  add(api, opt_index) {
    const bc = api.controller;
    this.controller_.rack.add(bc, opt_index);
    return api;
  }
  remove(api) {
    this.controller_.rack.remove(api.controller);
  }
  addBlade(params) {
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBlade(doc, params);
    const api = this.pool_.createApi(bc);
    return this.add(api, params.index);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.children.forEach((c) => {
      if (isRefreshable$4(c)) {
        c.refresh();
      }
    });
  }
  onRackValueChange_(ev) {
    const bc = ev.bladeController;
    const api = this.pool_.createApi(bc);
    const binding = isBindingValue$4(bc.value) ? bc.value.binding : null;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$4(
        api,
        binding ? binding.target.read() : bc.value.rawValue,
        ev.options.last,
      ),
    );
  }
};
let ContainerBladeApi$4 = class ContainerBladeApi3 extends BladeApi$4 {
  constructor(controller, pool) {
    super(controller);
    this.rackApi_ = new RackApi$4(controller.rackController, pool);
  }
};
let ContainerBladeController$4 = class ContainerBladeController3 extends BladeController$4 {
  constructor(config) {
    super({
      blade: config.blade,
      view: config.view,
      viewProps: config.rackController.viewProps,
    });
    this.rackController = config.rackController;
  }
  importState(state) {
    return importBladeState$4(
      state,
      (s) => super.importState(s),
      (p) => ({
        children: p.required.array(p.required.raw),
      }),
      (result) => {
        return this.rackController.rack.children.every((c, index) => {
          return c.importState(result.children[index]);
        });
      },
    );
  }
  exportState() {
    return exportBladeState$4(() => super.exportState(), {
      children: this.rackController.rack.children.map((c) => c.exportState()),
    });
  }
};
function isContainerBladeController$4(bc) {
  return "rackController" in bc;
}
let NestedOrderedSet$4 = class NestedOrderedSet3 {
  constructor(extract) {
    this.emitter = new Emitter$4();
    this.items_ = [];
    this.cache_ = /* @__PURE__ */ new Set();
    this.onSubListAdd_ = this.onSubListAdd_.bind(this);
    this.onSubListRemove_ = this.onSubListRemove_.bind(this);
    this.extract_ = extract;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(callback) {
    for (const item of this.allItems()) {
      if (callback(item)) {
        return item;
      }
    }
    return null;
  }
  includes(item) {
    return this.cache_.has(item);
  }
  add(item, opt_index) {
    if (this.includes(item)) {
      throw TpError$4.shouldNeverHappen();
    }
    const index = opt_index !== void 0 ? opt_index : this.items_.length;
    this.items_.splice(index, 0, item);
    this.cache_.add(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.emitter.on("add", this.onSubListAdd_);
      subList.emitter.on("remove", this.onSubListRemove_);
      subList.allItems().forEach((i) => {
        this.cache_.add(i);
      });
    }
    this.emitter.emit("add", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    this.cache_.delete(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.allItems().forEach((i) => {
        this.cache_.delete(i);
      });
      subList.emitter.off("add", this.onSubListAdd_);
      subList.emitter.off("remove", this.onSubListRemove_);
    }
    this.emitter.emit("remove", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  onSubListAdd_(ev) {
    this.cache_.add(ev.item);
    this.emitter.emit("add", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
  onSubListRemove_(ev) {
    this.cache_.delete(ev.item);
    this.emitter.emit("remove", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
};
function findValueBladeController$4(bcs, v) {
  for (let i = 0; i < bcs.length; i++) {
    const bc = bcs[i];
    if (isValueBladeController$4(bc) && bc.value === v) {
      return bc;
    }
  }
  return null;
}
function findSubBladeControllerSet$4(bc) {
  return isContainerBladeController$4(bc)
    ? bc.rackController.rack["bcSet_"]
    : null;
}
let Rack$4 = class Rack3 {
  constructor(config) {
    var _a, _b;
    this.emitter = new Emitter$4();
    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
    this.onSetAdd_ = this.onSetAdd_.bind(this);
    this.onSetRemove_ = this.onSetRemove_.bind(this);
    this.onChildDispose_ = this.onChildDispose_.bind(this);
    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
    this.onChildValueChange_ = this.onChildValueChange_.bind(this);
    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
    this.onRackLayout_ = this.onRackLayout_.bind(this);
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
    (_b = this.blade_) === null || _b === void 0
      ? void 0
      : _b
          .value("positions")
          .emitter.on("change", this.onBladePositionsChange_);
    this.viewProps = config.viewProps;
    this.bcSet_ = new NestedOrderedSet$4(findSubBladeControllerSet$4);
    this.bcSet_.emitter.on("add", this.onSetAdd_);
    this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(bc, opt_index) {
    var _a;
    (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
    bc.parent = this;
    this.bcSet_.add(bc, opt_index);
  }
  remove(bc) {
    bc.parent = null;
    this.bcSet_.remove(bc);
  }
  find(finder) {
    return this.bcSet_.allItems().filter(finder);
  }
  onSetAdd_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("add", {
      bladeController: ev.item,
      index: ev.index,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
    bc.blade
      .value("positions")
      .emitter.on("change", this.onChildPositionsChange_);
    bc.viewProps.handleDispose(this.onChildDispose_);
    if (isValueBladeController$4(bc)) {
      bc.value.emitter.on("change", this.onChildValueChange_);
    } else if (isContainerBladeController$4(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.on("layout", this.onRackLayout_);
        emitter.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("remove", {
      bladeController: ev.item,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    if (isValueBladeController$4(bc)) {
      bc.value.emitter.off("change", this.onChildValueChange_);
    } else if (isContainerBladeController$4(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.off("layout", this.onRackLayout_);
        emitter.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const visibleItems = this.bcSet_.items.filter(
      (bc) => !bc.viewProps.get("hidden"),
    );
    const firstVisibleItem = visibleItems[0];
    const lastVisibleItem = visibleItems[visibleItems.length - 1];
    this.bcSet_.items.forEach((bc) => {
      const ps = [];
      if (bc === firstVisibleItem) {
        ps.push("first");
        if (
          !this.blade_ ||
          this.blade_.get("positions").includes("veryfirst")
        ) {
          ps.push("veryfirst");
        }
      }
      if (bc === lastVisibleItem) {
        ps.push("last");
        if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
          ps.push("verylast");
        }
      }
      bc.blade.set("positions", ps);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildViewPropsChange_(_ev) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildDispose_() {
    const disposedUcs = this.bcSet_.items.filter((bc) => {
      return bc.viewProps.get("disposed");
    });
    disposedUcs.forEach((bc) => {
      this.bcSet_.remove(bc);
    });
  }
  onChildValueChange_(ev) {
    const bc = findValueBladeController$4(
      this.find(isValueBladeController$4),
      ev.sender,
    );
    if (!bc) {
      throw TpError$4.alreadyDisposed();
    }
    this.emitter.emit("valuechange", {
      bladeController: bc,
      options: ev.options,
      sender: this,
    });
  }
  onRackLayout_(_) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onRackValueChange_(ev) {
    this.emitter.emit("valuechange", {
      bladeController: ev.bladeController,
      options: ev.options,
      sender: this,
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
};
let RackController$4 = class RackController3 {
  constructor(config) {
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    this.element = config.element;
    this.viewProps = config.viewProps;
    const rack = new Rack$4({
      blade: config.root ? void 0 : config.blade,
      viewProps: config.viewProps,
    });
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.rack = rack;
    this.viewProps.handleDispose(() => {
      for (let i = this.rack.children.length - 1; i >= 0; i--) {
        const bc = this.rack.children[i];
        bc.viewProps.set("disposed", true);
      }
    });
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    insertElementAt$4(this.element, ev.bladeController.view.element, ev.index);
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    removeElement$4(ev.bladeController.view.element);
  }
};
function createBlade$4() {
  return new ValueMap$4({
    positions: createValue$4([], {
      equals: deepEqualsArray$4,
    }),
  });
}
let Foldable$4 = class Foldable3 extends ValueMap$4 {
  constructor(valueMap) {
    super(valueMap);
  }
  static create(expanded) {
    const coreObj = {
      completed: true,
      expanded,
      expandedHeight: null,
      shouldFixHeight: false,
      temporaryExpanded: null,
    };
    const core = ValueMap$4.createCore(coreObj);
    return new Foldable3(core);
  }
  get styleExpanded() {
    var _a;
    return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0
      ? _a
      : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded) {
      return "0";
    }
    const exHeight = this.get("expandedHeight");
    if (this.get("shouldFixHeight") && !isEmpty$4(exHeight)) {
      return `${exHeight}px`;
    }
    return "auto";
  }
  bindExpandedClass(elem, expandedClassName) {
    const onExpand = () => {
      const expanded = this.styleExpanded;
      if (expanded) {
        elem.classList.add(expandedClassName);
      } else {
        elem.classList.remove(expandedClassName);
      }
    };
    bindValueMap$4(this, "expanded", onExpand);
    bindValueMap$4(this, "temporaryExpanded", onExpand);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", false);
    this.set("expandedHeight", null);
    this.set("completed", true);
  }
};
function computeExpandedFolderHeight$4(folder, containerElement) {
  let height = 0;
  disableTransitionTemporarily$4(containerElement, () => {
    folder.set("expandedHeight", null);
    folder.set("temporaryExpanded", true);
    forceReflow$4(containerElement);
    height = containerElement.clientHeight;
    folder.set("temporaryExpanded", null);
    forceReflow$4(containerElement);
  });
  return height;
}
function applyHeight$4(foldable, elem) {
  elem.style.height = foldable.styleHeight;
}
function bindFoldable$4(foldable, elem) {
  foldable.value("expanded").emitter.on("beforechange", () => {
    foldable.set("completed", false);
    if (isEmpty$4(foldable.get("expandedHeight"))) {
      const h = computeExpandedFolderHeight$4(foldable, elem);
      if (h > 0) {
        foldable.set("expandedHeight", h);
      }
    }
    foldable.set("shouldFixHeight", true);
    forceReflow$4(elem);
  });
  foldable.emitter.on("change", () => {
    applyHeight$4(foldable, elem);
  });
  applyHeight$4(foldable, elem);
  elem.addEventListener("transitionend", (ev) => {
    if (ev.propertyName !== "height") {
      return;
    }
    foldable.cleanUpTransition();
  });
}
let FolderApi$4 = class FolderApi3 extends ContainerBladeApi$4 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$4();
    this.controller.foldable.value("expanded").emitter.on("change", (ev) => {
      this.emitter_.emit("fold", new TpFoldEvent$4(this, ev.sender.rawValue));
    });
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(expanded) {
    this.controller.foldable.set("expanded", expanded);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(title) {
    this.controller.props.set("title", title);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    return this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.rackApi_.refresh();
  }
};
const bladeContainerClassName$4 = ClassName$4("cnt");
let FolderView$4 = class FolderView3 {
  constructor(doc, config) {
    var _a;
    this.className_ = ClassName$4(
      (_a = config.viewName) !== null && _a !== void 0 ? _a : "fld",
    );
    this.element = doc.createElement("div");
    this.element.classList.add(this.className_(), bladeContainerClassName$4());
    config.viewProps.bindClassModifiers(this.element);
    this.foldable_ = config.foldable;
    this.foldable_.bindExpandedClass(
      this.element,
      this.className_(void 0, "expanded"),
    );
    bindValueMap$4(
      this.foldable_,
      "completed",
      valueToClassName$4(this.element, this.className_(void 0, "cpl")),
    );
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(this.className_("b"));
    bindValueMap$4(config.props, "title", (title) => {
      if (isEmpty$4(title)) {
        this.element.classList.add(this.className_(void 0, "not"));
      } else {
        this.element.classList.remove(this.className_(void 0, "not"));
      }
    });
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(this.className_("i"));
    this.element.appendChild(indentElem);
    const titleElem = doc.createElement("div");
    titleElem.classList.add(this.className_("t"));
    bindValueToTextContent$4(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(this.className_("m"));
    this.buttonElement.appendChild(markElem);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(this.className_("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
let FolderController$4 = class FolderController3 extends ContainerBladeController$4 {
  constructor(doc, config) {
    var _a;
    const foldable = Foldable$4.create(
      (_a = config.expanded) !== null && _a !== void 0 ? _a : true,
    );
    const view = new FolderView$4(doc, {
      foldable,
      props: config.props,
      viewName: config.root ? "rot" : void 0,
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$4({
          blade: config.blade,
          element: view.containerElement,
          root: config.root,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onTitleClick_ = this.onTitleClick_.bind(this);
    this.props = config.props;
    this.foldable = foldable;
    bindFoldable$4(this.foldable, this.view.containerElement);
    this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    });
    this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    });
    this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(state) {
    return importBladeState$4(
      state,
      (s) => super.importState(s),
      (p) => ({
        expanded: p.required.boolean,
        title: p.optional.string,
      }),
      (result) => {
        this.foldable.set("expanded", result.expanded);
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$4(() => super.exportState(), {
      expanded: this.foldable.get("expanded"),
      title: this.props.get("title"),
    });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
};
createPlugin$4({
  id: "folder",
  type: "blade",
  accept(params) {
    const result = parseRecord$4(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("folder"),
      expanded: p.optional.boolean,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new FolderController$4(args.document, {
      blade: args.blade,
      expanded: args.params.expanded,
      props: ValueMap$4.fromObject({
        title: args.params.title,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (!(args.controller instanceof FolderController$4)) {
      return null;
    }
    return new FolderApi$4(args.controller, args.pool);
  },
});
const cn$n$4 = ClassName$4("");
function valueToModifier$4(elem, modifier) {
  return valueToClassName$4(elem, cn$n$4(void 0, modifier));
}
let ViewProps$4 = class ViewProps3 extends ValueMap$4 {
  constructor(valueMap) {
    var _a;
    super(valueMap);
    this.onDisabledChange_ = this.onDisabledChange_.bind(this);
    this.onParentChange_ = this.onParentChange_.bind(this);
    this.onParentGlobalDisabledChange_ =
      this.onParentGlobalDisabledChange_.bind(this);
    [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue$4(
      createValue$4(this.getGlobalDisabled_()),
    );
    this.value("disabled").emitter.on("change", this.onDisabledChange_);
    this.value("parent").emitter.on("change", this.onParentChange_);
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
  }
  static create(opt_initialValue) {
    var _a, _b, _c;
    const initialValue =
      opt_initialValue !== null && opt_initialValue !== void 0
        ? opt_initialValue
        : {};
    return new ViewProps3(
      ValueMap$4.createCore({
        disabled:
          (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
        disposed: false,
        hidden:
          (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
        parent:
          (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null,
      }),
    );
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(elem) {
    bindValue$4(this.globalDisabled_, valueToModifier$4(elem, "disabled"));
    bindValueMap$4(this, "hidden", valueToModifier$4(elem, "hidden"));
  }
  bindDisabled(target) {
    bindValue$4(this.globalDisabled_, (disabled) => {
      target.disabled = disabled;
    });
  }
  bindTabIndex(elem) {
    bindValue$4(this.globalDisabled_, (disabled) => {
      elem.tabIndex = disabled ? -1 : 0;
    });
  }
  handleDispose(callback) {
    this.value("disposed").emitter.on("change", (disposed) => {
      if (disposed) {
        callback();
      }
    });
  }
  importState(state) {
    this.set("disabled", state.disabled);
    this.set("hidden", state.hidden);
  }
  exportState() {
    return {
      disabled: this.get("disabled"),
      hidden: this.get("hidden"),
    };
  }
  getGlobalDisabled_() {
    const parent = this.get("parent");
    const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
    return parentDisabled || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(ev) {
    var _a;
    const prevParent = ev.previousRawValue;
    prevParent === null || prevParent === void 0
      ? void 0
      : prevParent.globalDisabled.emitter.off(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    this.updateGlobalDisabled_();
  }
};
const cn$m$4 = ClassName$4("tbp");
let TabPageView$4 = class TabPageView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$m$4());
    config.viewProps.bindClassModifiers(this.element);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(cn$m$4("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
const cn$l$4 = ClassName$4("tbi");
let TabItemView$4 = class TabItemView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$l$4());
    config.viewProps.bindClassModifiers(this.element);
    bindValueMap$4(config.props, "selected", (selected) => {
      if (selected) {
        this.element.classList.add(cn$l$4(void 0, "sel"));
      } else {
        this.element.classList.remove(cn$l$4(void 0, "sel"));
      }
    });
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$l$4("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$l$4("t"));
    bindValueToTextContent$4(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
  }
};
let TabItemController$4 = class TabItemController3 {
  constructor(doc, config) {
    this.emitter = new Emitter$4();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new TabItemView$4(doc, {
      props: config.props,
      viewProps: config.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let TabPageController$4 = class TabPageController3 extends ContainerBladeController$4 {
  constructor(doc, config) {
    const view = new TabPageView$4(doc, {
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$4({
          blade: config.blade,
          element: view.containerElement,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onItemClick_ = this.onItemClick_.bind(this);
    this.ic_ = new TabItemController$4(doc, {
      props: config.itemProps,
      viewProps: ViewProps$4.create(),
    });
    this.ic_.emitter.on("click", this.onItemClick_);
    this.props = config.props;
    bindValueMap$4(this.props, "selected", (selected) => {
      this.itemController.props.set("selected", selected);
      this.viewProps.set("hidden", !selected);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(state) {
    return importBladeState$4(
      state,
      (s) => super.importState(s),
      (p) => ({
        selected: p.required.boolean,
        title: p.required.string,
      }),
      (result) => {
        this.ic_.props.set("selected", result.selected);
        this.ic_.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$4(() => super.exportState(), {
      selected: this.ic_.props.get("selected"),
      title: this.ic_.props.get("title"),
    });
  }
  onItemClick_() {
    this.props.set("selected", true);
  }
};
let TabApi$4 = class TabApi3 extends ContainerBladeApi$4 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$4();
    this.onSelect_ = this.onSelect_.bind(this);
    this.pool_ = pool;
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
    this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(params) {
    const doc = this.controller.view.element.ownerDocument;
    const pc = new TabPageController$4(doc, {
      blade: createBlade$4(),
      itemProps: ValueMap$4.fromObject({
        selected: false,
        title: params.title,
      }),
      props: ValueMap$4.fromObject({
        selected: false,
      }),
      viewProps: ViewProps$4.create(),
    });
    const papi = this.pool_.createApi(pc);
    return this.rackApi_.add(papi, params.index);
  }
  removePage(index) {
    this.rackApi_.remove(this.rackApi_.children[index]);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  onSelect_(ev) {
    this.emitter_.emit("select", new TpTabSelectEvent$4(this, ev.rawValue));
  }
};
let TabPageApi$4 = class TabPageApi3 extends ContainerBladeApi$4 {
  get title() {
    var _a;
    return (_a = this.controller.itemController.props.get("title")) !== null &&
      _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.itemController.props.set("title", title);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(selected) {
    this.controller.props.set("selected", selected);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  refresh() {
    this.rackApi_.refresh();
  }
};
const INDEX_NOT_SELECTED$4 = -1;
let Tab$4 = class Tab3 {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
    this.empty = createValue$4(true);
    this.selectedIndex = createValue$4(INDEX_NOT_SELECTED$4);
    this.items_ = [];
  }
  add(item, opt_index) {
    const index =
      opt_index !== null && opt_index !== void 0
        ? opt_index
        : this.items_.length;
    this.items_.splice(index, 0, item);
    item.emitter.on("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    item.emitter.off("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = INDEX_NOT_SELECTED$4;
      this.empty.rawValue = true;
      return;
    }
    const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
    if (firstSelIndex < 0) {
      this.items_.forEach((s, i) => {
        s.rawValue = i === 0;
      });
      this.selectedIndex.rawValue = 0;
    } else {
      this.items_.forEach((s, i) => {
        s.rawValue = i === firstSelIndex;
      });
      this.selectedIndex.rawValue = firstSelIndex;
    }
    this.empty.rawValue = false;
  }
  onItemSelectedChange_(ev) {
    if (ev.rawValue) {
      const index = this.items_.findIndex((s) => s === ev.sender);
      this.items_.forEach((s, i) => {
        s.rawValue = i === index;
      });
      this.selectedIndex.rawValue = index;
    } else {
      this.keepSelection_();
    }
  }
};
const cn$k$4 = ClassName$4("tab");
let TabView$4 = class TabView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$k$4(), bladeContainerClassName$4());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$4(
      config.empty,
      valueToClassName$4(this.element, cn$k$4(void 0, "nop")),
    );
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$k$4("t"));
    this.element.appendChild(titleElem);
    this.itemsElement = titleElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(cn$k$4("i"));
    this.element.appendChild(indentElem);
    const contentsElem = doc.createElement("div");
    contentsElem.classList.add(cn$k$4("c"));
    this.element.appendChild(contentsElem);
    this.contentsElement = contentsElem;
  }
};
let TabController$4 = class TabController3 extends ContainerBladeController$4 {
  constructor(doc, config) {
    const tab = new Tab$4();
    const view = new TabView$4(doc, {
      empty: tab.empty,
      viewProps: config.viewProps,
    });
    super({
      blade: config.blade,
      rackController: new RackController$4({
        blade: config.blade,
        element: view.contentsElement,
        viewProps: config.viewProps,
      }),
      view,
    });
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    const rack = this.rackController.rack;
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.tab = tab;
  }
  add(pc, opt_index) {
    this.rackController.rack.add(pc, opt_index);
  }
  remove(index) {
    this.rackController.rack.remove(this.rackController.rack.children[index]);
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    insertElementAt$4(
      this.view.itemsElement,
      pc.itemController.view.element,
      ev.index,
    );
    pc.itemController.viewProps.set("parent", this.viewProps);
    this.tab.add(pc.props.value("selected"));
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    removeElement$4(pc.itemController.view.element);
    pc.itemController.viewProps.set("parent", null);
    this.tab.remove(pc.props.value("selected"));
  }
};
createPlugin$4({
  id: "tab",
  type: "blade",
  accept(params) {
    const result = parseRecord$4(params, (p) => ({
      pages: p.required.array(p.required.object({ title: p.required.string })),
      view: p.required.constant("tab"),
    }));
    if (!result || result.pages.length === 0) {
      return null;
    }
    return { params: result };
  },
  controller(args) {
    const c = new TabController$4(args.document, {
      blade: args.blade,
      viewProps: args.viewProps,
    });
    args.params.pages.forEach((p) => {
      const pc = new TabPageController$4(args.document, {
        blade: createBlade$4(),
        itemProps: ValueMap$4.fromObject({
          selected: false,
          title: p.title,
        }),
        props: ValueMap$4.fromObject({
          selected: false,
        }),
        viewProps: ViewProps$4.create(),
      });
      c.add(pc);
    });
    return c;
  },
  api(args) {
    if (args.controller instanceof TabController$4) {
      return new TabApi$4(args.controller, args.pool);
    }
    if (args.controller instanceof TabPageController$4) {
      return new TabPageApi$4(args.controller, args.pool);
    }
    return null;
  },
});
let ListInputBindingApi$4 = class ListInputBindingApi3 extends BindingApi$4 {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(options) {
    this.controller.valueController.props.set("options", options);
  }
};
let CompositeConstraint$4 = class CompositeConstraint3 {
  constructor(constraints) {
    this.constraints = constraints;
  }
  constrain(value) {
    return this.constraints.reduce((result, c) => {
      return c.constrain(result);
    }, value);
  }
};
function findConstraint$4(c, constraintClass) {
  if (c instanceof constraintClass) {
    return c;
  }
  if (c instanceof CompositeConstraint$4) {
    const result = c.constraints.reduce((tmpResult, sc) => {
      if (tmpResult) {
        return tmpResult;
      }
      return sc instanceof constraintClass ? sc : null;
    }, null);
    if (result) {
      return result;
    }
  }
  return null;
}
let ListConstraint$4 = class ListConstraint3 {
  constructor(options) {
    this.values = ValueMap$4.fromObject({
      options,
    });
  }
  constrain(value) {
    const opts = this.values.get("options");
    if (opts.length === 0) {
      return value;
    }
    const matched =
      opts.filter((item) => {
        return item.value === value;
      }).length > 0;
    return matched ? value : opts[0].value;
  }
};
function parseListOptions$4(value) {
  var _a;
  const p = MicroParsers$4;
  if (Array.isArray(value)) {
    return (_a = parseRecord$4({ items: value }, (p2) => ({
      items: p2.required.array(
        p2.required.object({
          text: p2.required.string,
          value: p2.required.raw,
        }),
      ),
    }))) === null || _a === void 0
      ? void 0
      : _a.items;
  }
  if (typeof value === "object") {
    return p.required.raw(value).value;
  }
  return void 0;
}
function normalizeListOptions$4(options) {
  if (Array.isArray(options)) {
    return options;
  }
  const items = [];
  Object.keys(options).forEach((text) => {
    items.push({ text, value: options[text] });
  });
  return items;
}
function createListConstraint$4(options) {
  return !isEmpty$4(options)
    ? new ListConstraint$4(normalizeListOptions$4(forceCast$4(options)))
    : null;
}
const cn$j$4 = ClassName$4("lst");
let ListView$4 = class ListView3 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$j$4());
    config.viewProps.bindClassModifiers(this.element);
    const selectElem = doc.createElement("select");
    selectElem.classList.add(cn$j$4("s"));
    config.viewProps.bindDisabled(selectElem);
    this.element.appendChild(selectElem);
    this.selectElement = selectElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(cn$j$4("m"));
    markElem.appendChild(createSvgIconElement$4(doc, "dropdown"));
    this.element.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value_ = config.value;
    bindValueMap$4(this.props_, "options", (opts) => {
      removeChildElements$4(this.selectElement);
      opts.forEach((item) => {
        const optionElem = doc.createElement("option");
        optionElem.textContent = item.text;
        this.selectElement.appendChild(optionElem);
      });
      this.update_();
    });
  }
  update_() {
    const values = this.props_.get("options").map((o) => o.value);
    this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
};
let ListController$4 = class ListController3 {
  constructor(doc, config) {
    this.onSelectChange_ = this.onSelectChange_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ListView$4(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const selectElem = forceCast$4(e.currentTarget);
    this.value.rawValue =
      this.props.get("options")[selectElem.selectedIndex].value;
  }
  importProps(state) {
    return importBladeState$4(
      state,
      null,
      (p) => ({
        options: p.required.custom(parseListOptions$4),
      }),
      (result) => {
        this.props.set("options", normalizeListOptions$4(result.options));
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$4(null, {
      options: this.props.get("options"),
    });
  }
};
const cn$i$4 = ClassName$4("pop");
let PopupView$4 = class PopupView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$i$4());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$4(
      config.shows,
      valueToClassName$4(this.element, cn$i$4(void 0, "v")),
    );
  }
};
let PopupController$4 = class PopupController3 {
  constructor(doc, config) {
    this.shows = createValue$4(false);
    this.viewProps = config.viewProps;
    this.view = new PopupView$4(doc, {
      shows: this.shows,
      viewProps: this.viewProps,
    });
  }
};
const cn$h$4 = ClassName$4("txt");
let TextView$4 = class TextView3 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$h$4());
    config.viewProps.bindClassModifiers(this.element);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$h$4("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onChange_);
    this.value_ = config.value;
    this.refresh();
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let TextController$4 = class TextController3 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new TextView$4(doc, {
      props: config.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$4(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$4(parsedValue)) {
      this.value.rawValue = parsedValue;
    }
    this.view.refresh();
  }
};
function boolToString$4(value) {
  return String(value);
}
function boolFromUnknown$4(value) {
  if (value === "false") {
    return false;
  }
  return !!value;
}
function BooleanFormatter$4(value) {
  return boolToString$4(value);
}
function composeParsers$4(parsers) {
  return (text) => {
    return parsers.reduce((result, parser) => {
      if (result !== null) {
        return result;
      }
      return parser(text);
    }, null);
  };
}
const innerFormatter$4 = createNumberFormatter$4(0);
function formatPercentage$4(value) {
  return innerFormatter$4(value) + "%";
}
function stringFromUnknown$4(value) {
  return String(value);
}
function formatString$4(value) {
  return value;
}
function connectValues$4({ primary, secondary, forward, backward }) {
  let changing = false;
  function preventFeedback(callback) {
    if (changing) {
      return;
    }
    changing = true;
    callback();
    changing = false;
  }
  primary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  secondary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      primary.setRawValue(
        backward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  preventFeedback(() => {
    secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), {
      forceEmit: false,
      last: true,
    });
  });
}
function getStepForKey$4(keyScale, keys) {
  const step = keyScale * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
  if (keys.upKey) {
    return +step;
  } else if (keys.downKey) {
    return -step;
  }
  return 0;
}
function getVerticalStepKeys$4(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowDown",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowUp",
  };
}
function getHorizontalStepKeys$4(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowLeft",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowRight",
  };
}
function isVerticalArrowKey$4(key2) {
  return key2 === "ArrowUp" || key2 === "ArrowDown";
}
function isArrowKey$4(key2) {
  return (
    isVerticalArrowKey$4(key2) || key2 === "ArrowLeft" || key2 === "ArrowRight"
  );
}
function computeOffset$1$4(ev, elem) {
  var _a, _b;
  const win = elem.ownerDocument.defaultView;
  const rect = elem.getBoundingClientRect();
  return {
    x:
      ev.pageX -
      (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) +
        rect.left),
    y:
      ev.pageY -
      (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) +
        rect.top),
  };
}
let PointerHandler$4 = class PointerHandler3 {
  constructor(element) {
    this.lastTouch_ = null;
    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onTouchEnd_ = this.onTouchEnd_.bind(this);
    this.onTouchMove_ = this.onTouchMove_.bind(this);
    this.onTouchStart_ = this.onTouchStart_.bind(this);
    this.elem_ = element;
    this.emitter = new Emitter$4();
    element.addEventListener("touchstart", this.onTouchStart_, {
      passive: false,
    });
    element.addEventListener("touchmove", this.onTouchMove_, {
      passive: true,
    });
    element.addEventListener("touchend", this.onTouchEnd_);
    element.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(offset) {
    const rect = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: rect.width,
        height: rect.height,
      },
      point: offset
        ? {
            x: offset.x,
            y: offset.y,
          }
        : null,
    };
  }
  onMouseDown_(ev) {
    var _a;
    ev.preventDefault();
    (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
    const doc = this.elem_.ownerDocument;
    doc.addEventListener("mousemove", this.onDocumentMouseMove_);
    doc.addEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$4(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseMove_(ev) {
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$4(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseUp_(ev) {
    const doc = this.elem_.ownerDocument;
    doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
    doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$4(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onTouchStart_(ev) {
    ev.preventDefault();
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchMove_(ev) {
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchEnd_(ev) {
    var _a;
    const touch =
      (_a = ev.targetTouches.item(0)) !== null && _a !== void 0
        ? _a
        : this.lastTouch_;
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
};
const cn$g$4 = ClassName$4("txt");
let NumberTextView$4 = class NumberTextView3 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$g$4(), cn$g$4(void 0, "num"));
    if (config.arrayPosition) {
      this.element.classList.add(cn$g$4(void 0, config.arrayPosition));
    }
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$g$4("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    this.onDraggingChange_ = this.onDraggingChange_.bind(this);
    this.dragging_ = config.dragging;
    this.dragging_.emitter.on("change", this.onDraggingChange_);
    this.element.classList.add(cn$g$4());
    this.inputElement.classList.add(cn$g$4("i"));
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$g$4("k"));
    this.element.appendChild(knobElem);
    this.knobElement = knobElem;
    const guideElem = doc.createElementNS(SVG_NS$4, "svg");
    guideElem.classList.add(cn$g$4("g"));
    this.knobElement.appendChild(guideElem);
    const bodyElem = doc.createElementNS(SVG_NS$4, "path");
    bodyElem.classList.add(cn$g$4("gb"));
    guideElem.appendChild(bodyElem);
    this.guideBodyElem_ = bodyElem;
    const headElem = doc.createElementNS(SVG_NS$4, "path");
    headElem.classList.add(cn$g$4("gh"));
    guideElem.appendChild(headElem);
    this.guideHeadElem_ = headElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(ClassName$4("tt")());
    this.knobElement.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.refresh();
  }
  onDraggingChange_(ev) {
    if (ev.rawValue === null) {
      this.element.classList.remove(cn$g$4(void 0, "drg"));
      return;
    }
    this.element.classList.add(cn$g$4(void 0, "drg"));
    const x = ev.rawValue / this.props_.get("pointerScale");
    const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
    const adx = constrainRange$4(-aox, -4, 4);
    this.guideHeadElem_.setAttributeNS(
      null,
      "d",
      [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(
        " ",
      ),
    );
    this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
    const formatter = this.props_.get("formatter");
    this.tooltipElem_.textContent = formatter(this.value.rawValue);
    this.tooltipElem_.style.left = `${x}px`;
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let NumberTextController$4 = class NumberTextController3 {
  constructor(doc, config) {
    var _a;
    this.originRawValue_ = 0;
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.sliderProps_ =
      (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.dragging_ = createValue$4(null);
    this.view = new NumberTextView$4(doc, {
      arrayPosition: config.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
    this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
    this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const ph = new PointerHandler$4(this.view.knobElement);
    ph.emitter.on("down", this.onPointerDown_);
    ph.emitter.on("move", this.onPointerMove_);
    ph.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(value) {
    var _a, _b;
    const min =
      (_a = this.sliderProps_) === null || _a === void 0
        ? void 0
        : _a.get("min");
    const max =
      (_b = this.sliderProps_) === null || _b === void 0
        ? void 0
        : _b.get("max");
    let v = value;
    if (min !== void 0) {
      v = Math.max(v, min);
    }
    if (max !== void 0) {
      v = Math.min(v, max);
    }
    return v;
  }
  onInputChange_(e) {
    const inputElem = forceCast$4(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$4(parsedValue)) {
      this.value.rawValue = this.constrainValue_(parsedValue);
    }
    this.view.refresh();
  }
  onInputKeyDown_(ev) {
    const step = getStepForKey$4(
      this.props.get("keyScale"),
      getVerticalStepKeys$4(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
      forceEmit: false,
      last: false,
    });
  }
  onInputKeyUp_(ev) {
    const step = getStepForKey$4(
      this.props.get("keyScale"),
      getVerticalStepKeys$4(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue;
    this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(data) {
    if (!data.point) {
      return null;
    }
    const dx = data.point.x - data.bounds.width / 2;
    return this.constrainValue_(
      this.originRawValue_ + dx * this.props.get("pointerScale"),
    );
  }
  onPointerMove_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: false,
      last: false,
    });
    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
  }
  onPointerUp_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: true,
      last: true,
    });
    this.dragging_.rawValue = null;
  }
};
const cn$f$4 = ClassName$4("sld");
let SliderView$4 = class SliderView3 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$f$4());
    config.viewProps.bindClassModifiers(this.element);
    const trackElem = doc.createElement("div");
    trackElem.classList.add(cn$f$4("t"));
    config.viewProps.bindTabIndex(trackElem);
    this.element.appendChild(trackElem);
    this.trackElement = trackElem;
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$f$4("k"));
    this.trackElement.appendChild(knobElem);
    this.knobElement = knobElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const p = constrainRange$4(
      mapRange$4(
        this.value.rawValue,
        this.props_.get("min"),
        this.props_.get("max"),
        0,
        100,
      ),
      0,
      100,
    );
    this.knobElement.style.width = `${p}%`;
  }
  onChange_() {
    this.update_();
  }
};
let SliderController$4 = class SliderController3 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.props = config.props;
    this.view = new SliderView$4(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$4(this.view.trackElement);
    this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
    this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    this.value.setRawValue(
      mapRange$4(
        constrainRange$4(d.point.x, 0, d.bounds.width),
        0,
        d.bounds.width,
        this.props.get("min"),
        this.props.get("max"),
      ),
      opts,
    );
  }
  onPointerDownOrMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$4(
      this.props.get("keyScale"),
      getHorizontalStepKeys$4(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue + step, {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$4(
      this.props.get("keyScale"),
      getHorizontalStepKeys$4(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$e$4 = ClassName$4("sldtxt");
let SliderTextView$4 = class SliderTextView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$e$4());
    const sliderElem = doc.createElement("div");
    sliderElem.classList.add(cn$e$4("s"));
    this.sliderView_ = config.sliderView;
    sliderElem.appendChild(this.sliderView_.element);
    this.element.appendChild(sliderElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$e$4("t"));
    this.textView_ = config.textView;
    textElem.appendChild(this.textView_.element);
    this.element.appendChild(textElem);
  }
};
let SliderTextController$4 = class SliderTextController3 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.sliderC_ = new SliderController$4(doc, {
      props: config.sliderProps,
      value: config.value,
      viewProps: this.viewProps,
    });
    this.textC_ = new NumberTextController$4(doc, {
      parser: config.parser,
      props: config.textProps,
      sliderProps: config.sliderProps,
      value: config.value,
      viewProps: config.viewProps,
    });
    this.view = new SliderTextView$4(doc, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view,
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(state) {
    return importBladeState$4(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        const sliderProps = this.sliderC_.props;
        sliderProps.set("max", result.max);
        sliderProps.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    const sliderProps = this.sliderC_.props;
    return exportBladeState$4(null, {
      max: sliderProps.get("max"),
      min: sliderProps.get("min"),
    });
  }
};
function createSliderTextProps$4(config) {
  return {
    sliderProps: new ValueMap$4({
      keyScale: config.keyScale,
      max: config.max,
      min: config.min,
    }),
    textProps: new ValueMap$4({
      formatter: createValue$4(config.formatter),
      keyScale: config.keyScale,
      pointerScale: createValue$4(config.pointerScale),
    }),
  };
}
const CSS_VAR_MAP$4 = {
  containerUnitSize: "cnt-usz",
};
function getCssVar$4(key2) {
  return `--${CSS_VAR_MAP$4[key2]}`;
}
function createPointDimensionParser$4(p) {
  return createNumberTextInputParamsParser$4(p);
}
function parsePointDimensionParams$4(value) {
  if (!isRecord$4(value)) {
    return void 0;
  }
  return parseRecord$4(value, createPointDimensionParser$4);
}
function createDimensionConstraint$4(params, initialValue) {
  if (!params) {
    return void 0;
  }
  const constraints = [];
  const cs = createStepConstraint$4(params, initialValue);
  if (cs) {
    constraints.push(cs);
  }
  const rs = createRangeConstraint$4(params);
  if (rs) {
    constraints.push(rs);
  }
  return new CompositeConstraint$4(constraints);
}
function parsePickerLayout$4(value) {
  if (value === "inline" || value === "popup") {
    return value;
  }
  return void 0;
}
function writePrimitive$4(target, value) {
  target.write(value);
}
const cn$d$4 = ClassName$4("ckb");
let CheckboxView$4 = class CheckboxView3 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$d$4());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("label");
    labelElem.classList.add(cn$d$4("l"));
    this.element.appendChild(labelElem);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$d$4("i"));
    inputElem.type = "checkbox";
    labelElem.appendChild(inputElem);
    this.inputElement = inputElem;
    config.viewProps.bindDisabled(this.inputElement);
    const wrapperElem = doc.createElement("div");
    wrapperElem.classList.add(cn$d$4("w"));
    labelElem.appendChild(wrapperElem);
    const markElem = createSvgIconElement$4(doc, "check");
    wrapperElem.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
};
let CheckboxController$4 = class CheckboxController3 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new CheckboxView$4(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$4(e.currentTarget);
    this.value.rawValue = inputElem.checked;
  }
};
function createConstraint$7$1(params) {
  const constraints = [];
  const lc = createListConstraint$4(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$4(constraints);
}
createPlugin$4({
  id: "input-bool",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$4(params, (p) => ({
      options: p.optional.custom(parseListOptions$4),
      readonly: p.optional.constant(false),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$4,
    constraint: (args) => createConstraint$7$1(args.params),
    writer: (_args) => writePrimitive$4,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$4(c, ListConstraint$4);
    if (lc) {
      return new ListController$4(doc, {
        props: new ValueMap$4({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new CheckboxController$4(doc, {
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "boolean") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$4) {
      return new ListInputBindingApi$4(args.controller);
    }
    return null;
  },
});
const cn$c$4 = ClassName$4("col");
let ColorView$4 = class ColorView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$c$4());
    config.foldable.bindExpandedClass(this.element, cn$c$4(void 0, "expanded"));
    bindValueMap$4(
      config.foldable,
      "completed",
      valueToClassName$4(this.element, cn$c$4(void 0, "cpl")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$c$4("h"));
    this.element.appendChild(headElem);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$c$4("s"));
    headElem.appendChild(swatchElem);
    this.swatchElement = swatchElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$c$4("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$c$4("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
function rgbToHslInt$4(r, g, b) {
  const rp = constrainRange$4(r / 255, 0, 1);
  const gp = constrainRange$4(g / 255, 0, 1);
  const bp = constrainRange$4(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const c = cmax - cmin;
  let h = 0;
  let s = 0;
  const l = (cmin + cmax) / 2;
  if (c !== 0) {
    s = c / (1 - Math.abs(cmax + cmin - 1));
    if (rp === cmax) {
      h = (gp - bp) / c;
    } else if (gp === cmax) {
      h = 2 + (bp - rp) / c;
    } else {
      h = 4 + (rp - gp) / c;
    }
    h = h / 6 + (h < 0 ? 1 : 0);
  }
  return [h * 360, s * 100, l * 100];
}
function hslToRgbInt$4(h, s, l) {
  const hp = ((h % 360) + 360) % 360;
  const sp = constrainRange$4(s / 100, 0, 1);
  const lp = constrainRange$4(l / 100, 0, 1);
  const c = (1 - Math.abs(2 * lp - 1)) * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = lp - c / 2;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function rgbToHsvInt$4(r, g, b) {
  const rp = constrainRange$4(r / 255, 0, 1);
  const gp = constrainRange$4(g / 255, 0, 1);
  const bp = constrainRange$4(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const d = cmax - cmin;
  let h;
  if (d === 0) {
    h = 0;
  } else if (cmax === rp) {
    h = 60 * (((((gp - bp) / d) % 6) + 6) % 6);
  } else if (cmax === gp) {
    h = 60 * ((bp - rp) / d + 2);
  } else {
    h = 60 * ((rp - gp) / d + 4);
  }
  const s = cmax === 0 ? 0 : d / cmax;
  const v = cmax;
  return [h, s * 100, v * 100];
}
function hsvToRgbInt$4(h, s, v) {
  const hp = loopRange$4(h, 360);
  const sp = constrainRange$4(s / 100, 0, 1);
  const vp = constrainRange$4(v / 100, 0, 1);
  const c = vp * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = vp - c;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function hslToHsvInt$4(h, s, l) {
  const sd = l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100);
  return [
    h,
    sd !== 0 ? (s * (100 - Math.abs(2 * l - 100))) / sd : 0,
    l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100),
  ];
}
function hsvToHslInt$4(h, s, v) {
  const sd = 100 - Math.abs((v * (200 - s)) / 100 - 100);
  return [h, sd !== 0 ? (s * v) / sd : 0, (v * (200 - s)) / (2 * 100)];
}
function removeAlphaComponent$4(comps) {
  return [comps[0], comps[1], comps[2]];
}
function appendAlphaComponent$4(comps, alpha) {
  return [comps[0], comps[1], comps[2], alpha];
}
const MODE_CONVERTER_MAP$4 = {
  hsl: {
    hsl: (h, s, l) => [h, s, l],
    hsv: hslToHsvInt$4,
    rgb: hslToRgbInt$4,
  },
  hsv: {
    hsl: hsvToHslInt$4,
    hsv: (h, s, v) => [h, s, v],
    rgb: hsvToRgbInt$4,
  },
  rgb: {
    hsl: rgbToHslInt$4,
    hsv: rgbToHsvInt$4,
    rgb: (r, g, b) => [r, g, b],
  },
};
function getColorMaxComponents$4(mode, type) {
  return [
    type === "float" ? 1 : mode === "rgb" ? 255 : 360,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
  ];
}
function loopHueRange$4(hue, max) {
  return hue === max ? max : loopRange$4(hue, max);
}
function constrainColorComponents$4(components, mode, type) {
  var _a;
  const ms = getColorMaxComponents$4(mode, type);
  return [
    mode === "rgb"
      ? constrainRange$4(components[0], 0, ms[0])
      : loopHueRange$4(components[0], ms[0]),
    constrainRange$4(components[1], 0, ms[1]),
    constrainRange$4(components[2], 0, ms[2]),
    constrainRange$4(
      (_a = components[3]) !== null && _a !== void 0 ? _a : 1,
      0,
      1,
    ),
  ];
}
function convertColorType$4(comps, mode, from, to) {
  const fms = getColorMaxComponents$4(mode, from);
  const tms = getColorMaxComponents$4(mode, to);
  return comps.map((c, index) => (c / fms[index]) * tms[index]);
}
function convertColor$4(components, from, to) {
  const intComps = convertColorType$4(components, from.mode, from.type, "int");
  const result = MODE_CONVERTER_MAP$4[from.mode][to.mode](...intComps);
  return convertColorType$4(result, to.mode, "int", to.type);
}
let IntColor$4 = class IntColor3 {
  static black() {
    return new IntColor3([0, 0, 0], "rgb");
  }
  constructor(comps, mode) {
    this.type = "int";
    this.mode = mode;
    this.comps_ = constrainColorComponents$4(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$4(
      convertColor$4(
        removeAlphaComponent$4(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const cn$b$4 = ClassName$4("colp");
let ColorPickerView$4 = class ColorPickerView3 {
  constructor(doc, config) {
    this.alphaViews_ = null;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$b$4());
    config.viewProps.bindClassModifiers(this.element);
    const hsvElem = doc.createElement("div");
    hsvElem.classList.add(cn$b$4("hsv"));
    const svElem = doc.createElement("div");
    svElem.classList.add(cn$b$4("sv"));
    this.svPaletteView_ = config.svPaletteView;
    svElem.appendChild(this.svPaletteView_.element);
    hsvElem.appendChild(svElem);
    const hElem = doc.createElement("div");
    hElem.classList.add(cn$b$4("h"));
    this.hPaletteView_ = config.hPaletteView;
    hElem.appendChild(this.hPaletteView_.element);
    hsvElem.appendChild(hElem);
    this.element.appendChild(hsvElem);
    const rgbElem = doc.createElement("div");
    rgbElem.classList.add(cn$b$4("rgb"));
    this.textsView_ = config.textsView;
    rgbElem.appendChild(this.textsView_.element);
    this.element.appendChild(rgbElem);
    if (config.alphaViews) {
      this.alphaViews_ = {
        palette: config.alphaViews.palette,
        text: config.alphaViews.text,
      };
      const aElem = doc.createElement("div");
      aElem.classList.add(cn$b$4("a"));
      const apElem = doc.createElement("div");
      apElem.classList.add(cn$b$4("ap"));
      apElem.appendChild(this.alphaViews_.palette.element);
      aElem.appendChild(apElem);
      const atElem = doc.createElement("div");
      atElem.classList.add(cn$b$4("at"));
      atElem.appendChild(this.alphaViews_.text.element);
      aElem.appendChild(atElem);
      this.element.appendChild(aElem);
    }
  }
  get allFocusableElements() {
    const elems = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textsView_.modeSelectElement,
      ...this.textsView_.inputViews.map((v) => v.inputElement),
    ];
    if (this.alphaViews_) {
      elems.push(
        this.alphaViews_.palette.element,
        this.alphaViews_.text.inputElement,
      );
    }
    return elems;
  }
};
function parseColorType$4(value) {
  return value === "int" ? "int" : value === "float" ? "float" : void 0;
}
function parseColorInputParams$4(params) {
  return parseRecord$4(params, (p) => ({
    color: p.optional.object({
      alpha: p.optional.boolean,
      type: p.optional.custom(parseColorType$4),
    }),
    expanded: p.optional.boolean,
    picker: p.optional.custom(parsePickerLayout$4),
    readonly: p.optional.constant(false),
  }));
}
function getKeyScaleForColor$4(forAlpha) {
  return forAlpha ? 0.1 : 1;
}
function extractColorType$4(params) {
  var _a;
  return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
}
let FloatColor$4 = class FloatColor3 {
  constructor(comps, mode) {
    this.type = "float";
    this.mode = mode;
    this.comps_ = constrainColorComponents$4(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$4(
      convertColor$4(
        removeAlphaComponent$4(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const TYPE_TO_CONSTRUCTOR_MAP$4 = {
  int: (comps, mode) => new IntColor$4(comps, mode),
  float: (comps, mode) => new FloatColor$4(comps, mode),
};
function createColor$4(comps, mode, type) {
  return TYPE_TO_CONSTRUCTOR_MAP$4[type](comps, mode);
}
function isFloatColor$4(c) {
  return c.type === "float";
}
function isIntColor$4(c) {
  return c.type === "int";
}
function convertFloatToInt$4(cf) {
  const comps = cf.getComponents();
  const ms = getColorMaxComponents$4(cf.mode, "int");
  return new IntColor$4(
    [
      Math.round(mapRange$4(comps[0], 0, 1, 0, ms[0])),
      Math.round(mapRange$4(comps[1], 0, 1, 0, ms[1])),
      Math.round(mapRange$4(comps[2], 0, 1, 0, ms[2])),
      comps[3],
    ],
    cf.mode,
  );
}
function convertIntToFloat$4(ci) {
  const comps = ci.getComponents();
  const ms = getColorMaxComponents$4(ci.mode, "int");
  return new FloatColor$4(
    [
      mapRange$4(comps[0], 0, ms[0], 0, 1),
      mapRange$4(comps[1], 0, ms[1], 0, 1),
      mapRange$4(comps[2], 0, ms[2], 0, 1),
      comps[3],
    ],
    ci.mode,
  );
}
function mapColorType$4(c, type) {
  if (c.type === type) {
    return c;
  }
  if (isIntColor$4(c) && type === "float") {
    return convertIntToFloat$4(c);
  }
  if (isFloatColor$4(c) && type === "int") {
    return convertFloatToInt$4(c);
  }
  throw TpError$4.shouldNeverHappen();
}
function equalsStringColorFormat$4(f1, f2) {
  return (
    f1.alpha === f2.alpha &&
    f1.mode === f2.mode &&
    f1.notation === f2.notation &&
    f1.type === f2.type
  );
}
function parseCssNumberOrPercentage$4(text, max) {
  const m = text.match(/^(.+)%$/);
  if (!m) {
    return Math.min(parseFloat(text), max);
  }
  return Math.min(parseFloat(m[1]) * 0.01 * max, max);
}
const ANGLE_TO_DEG_MAP$4 = {
  deg: (angle) => angle,
  grad: (angle) => (angle * 360) / 400,
  rad: (angle) => (angle * 360) / (2 * Math.PI),
  turn: (angle) => angle * 360,
};
function parseCssNumberOrAngle$4(text) {
  const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!m) {
    return parseFloat(text);
  }
  const angle = parseFloat(m[1]);
  const unit = m[2];
  return ANGLE_TO_DEG_MAP$4[unit](angle);
}
function parseFunctionalRgbColorComponents$4(text) {
  const m = text.match(
    /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$4(m[1], 255),
    parseCssNumberOrPercentage$4(m[2], 255),
    parseCssNumberOrPercentage$4(m[3], 255),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbColor$4(text) {
  const comps = parseFunctionalRgbColorComponents$4(text);
  return comps ? new IntColor$4(comps, "rgb") : null;
}
function parseFunctionalRgbaColorComponents$4(text) {
  const m = text.match(
    /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$4(m[1], 255),
    parseCssNumberOrPercentage$4(m[2], 255),
    parseCssNumberOrPercentage$4(m[3], 255),
    parseCssNumberOrPercentage$4(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbaColor$4(text) {
  const comps = parseFunctionalRgbaColorComponents$4(text);
  return comps ? new IntColor$4(comps, "rgb") : null;
}
function parseFunctionalHslColorComponents$4(text) {
  const m = text.match(
    /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$4(m[1]),
    parseCssNumberOrPercentage$4(m[2], 100),
    parseCssNumberOrPercentage$4(m[3], 100),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalHslColor$4(text) {
  const comps = parseFunctionalHslColorComponents$4(text);
  return comps ? new IntColor$4(comps, "hsl") : null;
}
function parseHslaColorComponents$4(text) {
  const m = text.match(
    /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$4(m[1]),
    parseCssNumberOrPercentage$4(m[2], 100),
    parseCssNumberOrPercentage$4(m[3], 100),
    parseCssNumberOrPercentage$4(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalHslaColor$4(text) {
  const comps = parseHslaColorComponents$4(text);
  return comps ? new IntColor$4(comps, "hsl") : null;
}
function parseHexRgbColorComponents$4(text) {
  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
    ];
  }
  return null;
}
function parseHexRgbColor$4(text) {
  const comps = parseHexRgbColorComponents$4(text);
  return comps ? new IntColor$4(comps, "rgb") : null;
}
function parseHexRgbaColorComponents$4(text) {
  const mRgb = text.match(
    /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/,
  );
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
      mapRange$4(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
      mapRange$4(parseInt(mRrggbb[4], 16), 0, 255, 0, 1),
    ];
  }
  return null;
}
function parseHexRgbaColor$4(text) {
  const comps = parseHexRgbaColorComponents$4(text);
  return comps ? new IntColor$4(comps, "rgb") : null;
}
function parseObjectRgbColorComponents$4(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function createObjectRgbColorParser$4(type) {
  return (text) => {
    const comps = parseObjectRgbColorComponents$4(text);
    return comps ? createColor$4(comps, "rgb", type) : null;
  };
}
function parseObjectRgbaColorComponents$4(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseFloat(m[1]),
    parseFloat(m[2]),
    parseFloat(m[3]),
    parseFloat(m[4]),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function createObjectRgbaColorParser$4(type) {
  return (text) => {
    const comps = parseObjectRgbaColorComponents$4(text);
    return comps ? createColor$4(comps, "rgb", type) : null;
  };
}
const PARSER_AND_RESULT$4 = [
  {
    parser: parseHexRgbColorComponents$4,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseHexRgbaColorComponents$4,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseFunctionalRgbColorComponents$4,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalRgbaColorComponents$4,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalHslColorComponents$4,
    result: {
      alpha: false,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseHslaColorComponents$4,
    result: {
      alpha: true,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseObjectRgbColorComponents$4,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "object",
    },
  },
  {
    parser: parseObjectRgbaColorComponents$4,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "object",
    },
  },
];
function detectStringColor$4(text) {
  return PARSER_AND_RESULT$4.reduce((prev, { parser, result: detection }) => {
    if (prev) {
      return prev;
    }
    return parser(text) ? detection : null;
  }, null);
}
function detectStringColorFormat$4(text, type = "int") {
  const r = detectStringColor$4(text);
  if (!r) {
    return null;
  }
  if (r.notation === "hex" && type !== "float") {
    return Object.assign(Object.assign({}, r), { type: "int" });
  }
  if (r.notation === "func") {
    return Object.assign(Object.assign({}, r), { type });
  }
  return null;
}
function createColorStringParser$4(type) {
  const parsers = [
    parseHexRgbColor$4,
    parseHexRgbaColor$4,
    parseFunctionalRgbColor$4,
    parseFunctionalRgbaColor$4,
    parseFunctionalHslColor$4,
    parseFunctionalHslaColor$4,
  ];
  if (type === "int") {
    parsers.push(
      createObjectRgbColorParser$4("int"),
      createObjectRgbaColorParser$4("int"),
    );
  }
  if (type === "float") {
    parsers.push(
      createObjectRgbColorParser$4("float"),
      createObjectRgbaColorParser$4("float"),
    );
  }
  const parser = composeParsers$4(parsers);
  return (text) => {
    const result = parser(text);
    return result ? mapColorType$4(result, type) : null;
  };
}
function readIntColorString$4(value) {
  const parser = createColorStringParser$4("int");
  if (typeof value !== "string") {
    return IntColor$4.black();
  }
  const result = parser(value);
  return result !== null && result !== void 0 ? result : IntColor$4.black();
}
function zerofill$4(comp) {
  const hex = constrainRange$4(Math.floor(comp), 0, 255).toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function colorToHexRgbString$4(value, prefix = "#") {
  const hexes = removeAlphaComponent$4(value.getComponents("rgb"))
    .map(zerofill$4)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToHexRgbaString$4(value, prefix = "#") {
  const rgbaComps = value.getComponents("rgb");
  const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
    .map(zerofill$4)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToFunctionalRgbString$4(value) {
  const formatter = createNumberFormatter$4(0);
  const ci = mapColorType$4(value, "int");
  const comps = removeAlphaComponent$4(ci.getComponents("rgb")).map((comp) =>
    formatter(comp),
  );
  return `rgb(${comps.join(", ")})`;
}
function colorToFunctionalRgbaString$4(value) {
  const aFormatter = createNumberFormatter$4(2);
  const rgbFormatter = createNumberFormatter$4(0);
  const ci = mapColorType$4(value, "int");
  const comps = ci.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return formatter(comp);
  });
  return `rgba(${comps.join(", ")})`;
}
function colorToFunctionalHslString$4(value) {
  const formatters = [
    createNumberFormatter$4(0),
    formatPercentage$4,
    formatPercentage$4,
  ];
  const ci = mapColorType$4(value, "int");
  const comps = removeAlphaComponent$4(ci.getComponents("hsl")).map(
    (comp, index) => formatters[index](comp),
  );
  return `hsl(${comps.join(", ")})`;
}
function colorToFunctionalHslaString$4(value) {
  const formatters = [
    createNumberFormatter$4(0),
    formatPercentage$4,
    formatPercentage$4,
    createNumberFormatter$4(2),
  ];
  const ci = mapColorType$4(value, "int");
  const comps = ci
    .getComponents("hsl")
    .map((comp, index) => formatters[index](comp));
  return `hsla(${comps.join(", ")})`;
}
function colorToObjectRgbString$4(value, type) {
  const formatter = createNumberFormatter$4(type === "float" ? 2 : 0);
  const names = ["r", "g", "b"];
  const cc = mapColorType$4(value, type);
  const comps = removeAlphaComponent$4(cc.getComponents("rgb")).map(
    (comp, index) => `${names[index]}: ${formatter(comp)}`,
  );
  return `{${comps.join(", ")}}`;
}
function createObjectRgbColorFormatter$4(type) {
  return (value) => colorToObjectRgbString$4(value, type);
}
function colorToObjectRgbaString$4(value, type) {
  const aFormatter = createNumberFormatter$4(2);
  const rgbFormatter = createNumberFormatter$4(type === "float" ? 2 : 0);
  const names = ["r", "g", "b", "a"];
  const cc = mapColorType$4(value, type);
  const comps = cc.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return `${names[index]}: ${formatter(comp)}`;
  });
  return `{${comps.join(", ")}}`;
}
function createObjectRgbaColorFormatter$4(type) {
  return (value) => colorToObjectRgbaString$4(value, type);
}
const FORMAT_AND_STRINGIFIERS$4 = [
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbString$4,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbaString$4,
  },
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbString$4,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbaString$4,
  },
  {
    format: {
      alpha: false,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslString$4,
  },
  {
    format: {
      alpha: true,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslaString$4,
  },
  ...["int", "float"].reduce((prev, type) => {
    return [
      ...prev,
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbColorFormatter$4(type),
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbaColorFormatter$4(type),
      },
    ];
  }, []),
];
function findColorStringifier$4(format) {
  return FORMAT_AND_STRINGIFIERS$4.reduce((prev, fas) => {
    if (prev) {
      return prev;
    }
    return equalsStringColorFormat$4(fas.format, format)
      ? fas.stringifier
      : null;
  }, null);
}
const cn$a$4 = ClassName$4("apl");
let APaletteView$4 = class APaletteView3 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$a$4());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const barElem = doc.createElement("div");
    barElem.classList.add(cn$a$4("b"));
    this.element.appendChild(barElem);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$a$4("c"));
    barElem.appendChild(colorElem);
    this.colorElem_ = colorElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$a$4("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    const previewElem = doc.createElement("div");
    previewElem.classList.add(cn$a$4("p"));
    this.markerElem_.appendChild(previewElem);
    this.previewElem_ = previewElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const rgbaComps = c.getComponents("rgb");
    const leftColor = new IntColor$4(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 0],
      "rgb",
    );
    const rightColor = new IntColor$4(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 255],
      "rgb",
    );
    const gradientComps = [
      "to right",
      colorToFunctionalRgbaString$4(leftColor),
      colorToFunctionalRgbaString$4(rightColor),
    ];
    this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
    this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString$4(c);
    const left = mapRange$4(rgbaComps[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let APaletteController$4 = class APaletteController3 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new APaletteView$4(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$4(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const alpha = d.point.x / d.bounds.width;
    const c = this.value.rawValue;
    const [h, s, v] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$4([h, s, v, alpha], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$4(
      getKeyScaleForColor$4(true),
      getHorizontalStepKeys$4(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$4([h, s, v, a + step], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$4(
      getKeyScaleForColor$4(true),
      getHorizontalStepKeys$4(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$9$4 = ClassName$4("coltxt");
function createModeSelectElement$4(doc) {
  const selectElem = doc.createElement("select");
  const items = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" },
    { text: "HEX", value: "hex" },
  ];
  selectElem.appendChild(
    items.reduce((frag, item) => {
      const optElem = doc.createElement("option");
      optElem.textContent = item.text;
      optElem.value = item.value;
      frag.appendChild(optElem);
      return frag;
    }, doc.createDocumentFragment()),
  );
  return selectElem;
}
let ColorTextsView$4 = class ColorTextsView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$9$4());
    config.viewProps.bindClassModifiers(this.element);
    const modeElem = doc.createElement("div");
    modeElem.classList.add(cn$9$4("m"));
    this.modeElem_ = createModeSelectElement$4(doc);
    this.modeElem_.classList.add(cn$9$4("ms"));
    modeElem.appendChild(this.modeSelectElement);
    config.viewProps.bindDisabled(this.modeElem_);
    const modeMarkerElem = doc.createElement("div");
    modeMarkerElem.classList.add(cn$9$4("mm"));
    modeMarkerElem.appendChild(createSvgIconElement$4(doc, "dropdown"));
    modeElem.appendChild(modeMarkerElem);
    this.element.appendChild(modeElem);
    const inputsElem = doc.createElement("div");
    inputsElem.classList.add(cn$9$4("w"));
    this.element.appendChild(inputsElem);
    this.inputsElem_ = inputsElem;
    this.inputViews_ = config.inputViews;
    this.applyInputViews_();
    bindValue$4(config.mode, (mode) => {
      this.modeElem_.value = mode;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(inputViews) {
    this.inputViews_ = inputViews;
    this.applyInputViews_();
  }
  applyInputViews_() {
    removeChildElements$4(this.inputsElem_);
    const doc = this.element.ownerDocument;
    this.inputViews_.forEach((v) => {
      const compElem = doc.createElement("div");
      compElem.classList.add(cn$9$4("c"));
      compElem.appendChild(v.element);
      this.inputsElem_.appendChild(compElem);
    });
  }
};
function createFormatter$2$4(type) {
  return createNumberFormatter$4(type === "float" ? 2 : 0);
}
function createConstraint$6$4(mode, type, index) {
  const max = getColorMaxComponents$4(mode, type)[index];
  return new DefiniteRangeConstraint$4({
    min: 0,
    max,
  });
}
function createComponentController$4(doc, config, index) {
  return new NumberTextController$4(doc, {
    arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
    parser: config.parser,
    props: ValueMap$4.fromObject({
      formatter: createFormatter$2$4(config.colorType),
      keyScale: getKeyScaleForColor$4(false),
      pointerScale: config.colorType === "float" ? 0.01 : 1,
    }),
    value: createValue$4(0, {
      constraint: createConstraint$6$4(
        config.colorMode,
        config.colorType,
        index,
      ),
    }),
    viewProps: config.viewProps,
  });
}
function createComponentControllers$4(doc, config) {
  const cc = {
    colorMode: config.colorMode,
    colorType: config.colorType,
    parser: parseNumber$4,
    viewProps: config.viewProps,
  };
  return [0, 1, 2].map((i) => {
    const c = createComponentController$4(doc, cc, i);
    connectValues$4({
      primary: config.value,
      secondary: c.value,
      forward(p) {
        const mc = mapColorType$4(p, config.colorType);
        return mc.getComponents(config.colorMode)[i];
      },
      backward(p, s) {
        const pickedMode = config.colorMode;
        const mc = mapColorType$4(p, config.colorType);
        const comps = mc.getComponents(pickedMode);
        comps[i] = s;
        const c2 = createColor$4(
          appendAlphaComponent$4(removeAlphaComponent$4(comps), comps[3]),
          pickedMode,
          config.colorType,
        );
        return mapColorType$4(c2, "int");
      },
    });
    return c;
  });
}
function createHexController$4(doc, config) {
  const c = new TextController$4(doc, {
    parser: createColorStringParser$4("int"),
    props: ValueMap$4.fromObject({
      formatter: colorToHexRgbString$4,
    }),
    value: createValue$4(IntColor$4.black()),
    viewProps: config.viewProps,
  });
  connectValues$4({
    primary: config.value,
    secondary: c.value,
    forward: (p) =>
      new IntColor$4(removeAlphaComponent$4(p.getComponents()), p.mode),
    backward: (p, s) =>
      new IntColor$4(
        appendAlphaComponent$4(
          removeAlphaComponent$4(s.getComponents(p.mode)),
          p.getComponents()[3],
        ),
        p.mode,
      ),
  });
  return [c];
}
function isColorMode$4(mode) {
  return mode !== "hex";
}
let ColorTextsController$4 = class ColorTextsController3 {
  constructor(doc, config) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
    this.colorType_ = config.colorType;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.colorMode = createValue$4(this.value.rawValue.mode);
    this.ccs_ = this.createComponentControllers_(doc);
    this.view = new ColorTextsView$4(doc, {
      mode: this.colorMode,
      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
      viewProps: this.viewProps,
    });
    this.view.modeSelectElement.addEventListener(
      "change",
      this.onModeSelectChange_,
    );
  }
  createComponentControllers_(doc) {
    const mode = this.colorMode.rawValue;
    if (isColorMode$4(mode)) {
      return createComponentControllers$4(doc, {
        colorMode: mode,
        colorType: this.colorType_,
        value: this.value,
        viewProps: this.viewProps,
      });
    }
    return createHexController$4(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
  onModeSelectChange_(ev) {
    const selectElem = ev.currentTarget;
    this.colorMode.rawValue = selectElem.value;
    this.ccs_ = this.createComponentControllers_(
      this.view.element.ownerDocument,
    );
    this.view.inputViews = this.ccs_.map((cc) => cc.view);
  }
};
const cn$8$4 = ClassName$4("hpl");
let HPaletteView$4 = class HPaletteView3 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$8$4());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$8$4("c"));
    this.element.appendChild(colorElem);
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$8$4("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const [h] = c.getComponents("hsv");
    this.markerElem_.style.backgroundColor = colorToFunctionalRgbString$4(
      new IntColor$4([h, 100, 100], "hsv"),
    );
    const left = mapRange$4(h, 0, 360, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let HPaletteController$4 = class HPaletteController3 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new HPaletteView$4(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$4(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const hue = mapRange$4(
      constrainRange$4(d.point.x, 0, d.bounds.width),
      0,
      d.bounds.width,
      0,
      360,
    );
    const c = this.value.rawValue;
    const [, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$4([hue, s, v, a], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$4(
      getKeyScaleForColor$4(false),
      getHorizontalStepKeys$4(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$4([h + step, s, v, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$4(
      getKeyScaleForColor$4(false),
      getHorizontalStepKeys$4(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$7$4 = ClassName$4("svp");
const CANVAS_RESOL$4 = 64;
let SvPaletteView$4 = class SvPaletteView3 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$7$4());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const canvasElem = doc.createElement("canvas");
    canvasElem.height = CANVAS_RESOL$4;
    canvasElem.width = CANVAS_RESOL$4;
    canvasElem.classList.add(cn$7$4("c"));
    this.element.appendChild(canvasElem);
    this.canvasElement = canvasElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$7$4("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const ctx = getCanvasContext$4(this.canvasElement);
    if (!ctx) {
      return;
    }
    const c = this.value.rawValue;
    const hsvComps = c.getComponents("hsv");
    const width = this.canvasElement.width;
    const height = this.canvasElement.height;
    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;
    for (let iy = 0; iy < height; iy++) {
      for (let ix = 0; ix < width; ix++) {
        const s = mapRange$4(ix, 0, width, 0, 100);
        const v = mapRange$4(iy, 0, height, 100, 0);
        const rgbComps = hsvToRgbInt$4(hsvComps[0], s, v);
        const i = (iy * width + ix) * 4;
        data[i] = rgbComps[0];
        data[i + 1] = rgbComps[1];
        data[i + 2] = rgbComps[2];
        data[i + 3] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    const left = mapRange$4(hsvComps[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${left}%`;
    const top = mapRange$4(hsvComps[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${top}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let SvPaletteController$4 = class SvPaletteController3 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SvPaletteView$4(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$4(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const saturation = mapRange$4(d.point.x, 0, d.bounds.width, 0, 100);
    const value = mapRange$4(d.point.y, 0, d.bounds.height, 100, 0);
    const [h, , , a] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(
      new IntColor$4([h, saturation, value, a], "hsv"),
      opts,
    );
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    if (isArrowKey$4(ev.key)) {
      ev.preventDefault();
    }
    const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
    const keyScale = getKeyScaleForColor$4(false);
    const ds = getStepForKey$4(keyScale, getHorizontalStepKeys$4(ev));
    const dv = getStepForKey$4(keyScale, getVerticalStepKeys$4(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(new IntColor$4([h, s + ds, v + dv, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const keyScale = getKeyScaleForColor$4(false);
    const ds = getStepForKey$4(keyScale, getHorizontalStepKeys$4(ev));
    const dv = getStepForKey$4(keyScale, getVerticalStepKeys$4(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let ColorPickerController$4 = class ColorPickerController3 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.hPaletteC_ = new HPaletteController$4(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.svPaletteC_ = new SvPaletteController$4(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.alphaIcs_ = config.supportsAlpha
      ? {
          palette: new APaletteController$4(doc, {
            value: this.value,
            viewProps: this.viewProps,
          }),
          text: new NumberTextController$4(doc, {
            parser: parseNumber$4,
            props: ValueMap$4.fromObject({
              pointerScale: 0.01,
              keyScale: 0.1,
              formatter: createNumberFormatter$4(2),
            }),
            value: createValue$4(0, {
              constraint: new DefiniteRangeConstraint$4({ min: 0, max: 1 }),
            }),
            viewProps: this.viewProps,
          }),
        }
      : null;
    if (this.alphaIcs_) {
      connectValues$4({
        primary: this.value,
        secondary: this.alphaIcs_.text.value,
        forward: (p) => p.getComponents()[3],
        backward: (p, s) => {
          const comps = p.getComponents();
          comps[3] = s;
          return new IntColor$4(comps, p.mode);
        },
      });
    }
    this.textsC_ = new ColorTextsController$4(doc, {
      colorType: config.colorType,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorPickerView$4(doc, {
      alphaViews: this.alphaIcs_
        ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view,
          }
        : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: config.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textsView: this.textsC_.view,
      viewProps: this.viewProps,
    });
  }
  get textsController() {
    return this.textsC_;
  }
};
const cn$6$4 = ClassName$4("colsw");
let ColorSwatchView$4 = class ColorSwatchView3 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$6$4());
    config.viewProps.bindClassModifiers(this.element);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$6$4("sw"));
    this.element.appendChild(swatchElem);
    this.swatchElem_ = swatchElem;
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$6$4("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    this.update_();
  }
  update_() {
    const value = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = colorToHexRgbaString$4(value);
  }
  onValueChange_() {
    this.update_();
  }
};
let ColorSwatchController$4 = class ColorSwatchController3 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ColorSwatchView$4(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
let ColorController$4 = class ColorController3 {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$4.create(config.expanded);
    this.swatchC_ = new ColorSwatchController$4(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    const buttonElem = this.swatchC_.view.buttonElement;
    buttonElem.addEventListener("blur", this.onButtonBlur_);
    buttonElem.addEventListener("click", this.onButtonClick_);
    this.textC_ = new TextController$4(doc, {
      parser: config.parser,
      props: ValueMap$4.fromObject({
        formatter: config.formatter,
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorView$4(doc, {
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout,
    });
    this.view.swatchElement.appendChild(this.swatchC_.view.element);
    this.view.textElement.appendChild(this.textC_.view.element);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$4(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const pickerC = new ColorPickerController$4(doc, {
      colorType: config.colorType,
      supportsAlpha: config.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps,
    });
    pickerC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = pickerC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(pickerC.view.element);
      connectValues$4({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$4(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$4(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$4(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.swatchC_.view.buttonElement &&
      !supportsTouch$4(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.swatchC_.view.buttonElement.focus();
      }
    }
  }
};
function colorToRgbNumber$4(value) {
  return removeAlphaComponent$4(value.getComponents("rgb")).reduce(
    (result, comp) => {
      return (result << 8) | (Math.floor(comp) & 255);
    },
    0,
  );
}
function colorToRgbaNumber$4(value) {
  return (
    value.getComponents("rgb").reduce((result, comp, index) => {
      const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
      return (result << 8) | hex;
    }, 0) >>> 0
  );
}
function numberToRgbColor$4(num) {
  return new IntColor$4(
    [(num >> 16) & 255, (num >> 8) & 255, num & 255],
    "rgb",
  );
}
function numberToRgbaColor$4(num) {
  return new IntColor$4(
    [
      (num >> 24) & 255,
      (num >> 16) & 255,
      (num >> 8) & 255,
      mapRange$4(num & 255, 0, 255, 0, 1),
    ],
    "rgb",
  );
}
function colorFromRgbNumber$4(value) {
  if (typeof value !== "number") {
    return IntColor$4.black();
  }
  return numberToRgbColor$4(value);
}
function colorFromRgbaNumber$4(value) {
  if (typeof value !== "number") {
    return IntColor$4.black();
  }
  return numberToRgbaColor$4(value);
}
function isRgbColorComponent$4(obj, key2) {
  if (typeof obj !== "object" || isEmpty$4(obj)) {
    return false;
  }
  return key2 in obj && typeof obj[key2] === "number";
}
function isRgbColorObject$4(obj) {
  return (
    isRgbColorComponent$4(obj, "r") &&
    isRgbColorComponent$4(obj, "g") &&
    isRgbColorComponent$4(obj, "b")
  );
}
function isRgbaColorObject$4(obj) {
  return isRgbColorObject$4(obj) && isRgbColorComponent$4(obj, "a");
}
function isColorObject$4(obj) {
  return isRgbColorObject$4(obj);
}
function equalsColor$4(v1, v2) {
  if (v1.mode !== v2.mode) {
    return false;
  }
  if (v1.type !== v2.type) {
    return false;
  }
  const comps1 = v1.getComponents();
  const comps2 = v2.getComponents();
  for (let i = 0; i < comps1.length; i++) {
    if (comps1[i] !== comps2[i]) {
      return false;
    }
  }
  return true;
}
function createColorComponentsFromRgbObject$4(obj) {
  return "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
}
function createColorStringWriter$4(format) {
  const stringify = findColorStringifier$4(format);
  return stringify
    ? (target, value) => {
        writePrimitive$4(target, stringify(value));
      }
    : null;
}
function createColorNumberWriter$4(supportsAlpha) {
  const colorToNumber = supportsAlpha
    ? colorToRgbaNumber$4
    : colorToRgbNumber$4;
  return (target, value) => {
    writePrimitive$4(target, colorToNumber(value));
  };
}
function writeRgbaColorObject$4(target, value, type) {
  const cc = mapColorType$4(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
  target.writeProperty("a", obj.a);
}
function writeRgbColorObject$4(target, value, type) {
  const cc = mapColorType$4(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
}
function createColorObjectWriter$4(supportsAlpha, type) {
  return (target, inValue) => {
    if (supportsAlpha) {
      writeRgbaColorObject$4(target, inValue, type);
    } else {
      writeRgbColorObject$4(target, inValue, type);
    }
  };
}
function shouldSupportAlpha$1$4(inputParams) {
  var _a;
  if (
    (_a =
      inputParams === null || inputParams === void 0
        ? void 0
        : inputParams.color) === null || _a === void 0
      ? void 0
      : _a.alpha
  ) {
    return true;
  }
  return false;
}
function createFormatter$1$4(supportsAlpha) {
  return supportsAlpha
    ? (v) => colorToHexRgbaString$4(v, "0x")
    : (v) => colorToHexRgbString$4(v, "0x");
}
function isForColor$4(params) {
  if ("color" in params) {
    return true;
  }
  if (params.view === "color") {
    return true;
  }
  return false;
}
createPlugin$4({
  id: "input-color-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    if (!isForColor$4(params)) {
      return null;
    }
    const result = parseColorInputParams$4(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            supportsAlpha: shouldSupportAlpha$1$4(params),
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => {
      return args.params.supportsAlpha
        ? colorFromRgbaNumber$4
        : colorFromRgbNumber$4;
    },
    equals: equalsColor$4,
    writer: (args) => {
      return createColorNumberWriter$4(args.params.supportsAlpha);
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$4(args.document, {
      colorType: "int",
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createFormatter$1$4(args.params.supportsAlpha),
      parser: createColorStringParser$4("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
function colorFromObject$4(value, type) {
  if (!isColorObject$4(value)) {
    return mapColorType$4(IntColor$4.black(), type);
  }
  if (type === "int") {
    const comps = createColorComponentsFromRgbObject$4(value);
    return new IntColor$4(comps, "rgb");
  }
  if (type === "float") {
    const comps = createColorComponentsFromRgbObject$4(value);
    return new FloatColor$4(comps, "rgb");
  }
  return mapColorType$4(IntColor$4.black(), "int");
}
function shouldSupportAlpha$5(initialValue) {
  return isRgbaColorObject$4(initialValue);
}
function createColorObjectBindingReader$4(type) {
  return (value) => {
    const c = colorFromObject$4(value, type);
    return mapColorType$4(c, "int");
  };
}
function createColorObjectFormatter$4(supportsAlpha, type) {
  return (value) => {
    if (supportsAlpha) {
      return colorToObjectRgbaString$4(value, type);
    }
    return colorToObjectRgbString$4(value, type);
  };
}
createPlugin$4({
  id: "input-color-object",
  type: "input",
  accept: (value, params) => {
    var _a;
    if (!isColorObject$4(value)) {
      return null;
    }
    const result = parseColorInputParams$4(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            colorType:
              (_a = extractColorType$4(params)) !== null && _a !== void 0
                ? _a
                : "int",
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => createColorObjectBindingReader$4(args.params.colorType),
    equals: equalsColor$4,
    writer: (args) =>
      createColorObjectWriter$4(
        shouldSupportAlpha$5(args.initialValue),
        args.params.colorType,
      ),
  },
  controller: (args) => {
    var _a, _b;
    const supportsAlpha = isRgbaColorObject$4(args.initialValue);
    return new ColorController$4(args.document, {
      colorType: args.params.colorType,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createColorObjectFormatter$4(
        supportsAlpha,
        args.params.colorType,
      ),
      parser: createColorStringParser$4("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
createPlugin$4({
  id: "input-color-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    if (params.view === "text") {
      return null;
    }
    const format = detectStringColorFormat$4(value, extractColorType$4(params));
    if (!format) {
      return null;
    }
    const stringifier = findColorStringifier$4(format);
    if (!stringifier) {
      return null;
    }
    const result = parseColorInputParams$4(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            format,
            stringifier,
          }),
        }
      : null;
  },
  binding: {
    reader: () => readIntColorString$4,
    equals: equalsColor$4,
    writer: (args) => {
      const writer = createColorStringWriter$4(args.params.format);
      if (!writer) {
        throw TpError$4.notBindable();
      }
      return writer;
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$4(args.document, {
      colorType: args.params.format.type,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: args.params.stringifier,
      parser: createColorStringParser$4("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.format.alpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let PointNdConstraint$4 = class PointNdConstraint3 {
  constructor(config) {
    this.components = config.components;
    this.asm_ = config.assembly;
  }
  constrain(value) {
    const comps = this.asm_.toComponents(value).map((comp, index) => {
      var _a, _b;
      return (_b =
        (_a = this.components[index]) === null || _a === void 0
          ? void 0
          : _a.constrain(comp)) !== null && _b !== void 0
        ? _b
        : comp;
    });
    return this.asm_.fromComponents(comps);
  }
};
const cn$5$4 = ClassName$4("pndtxt");
let PointNdTextView$4 = class PointNdTextView3 {
  constructor(doc, config) {
    this.textViews = config.textViews;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$5$4());
    this.textViews.forEach((v) => {
      const axisElem = doc.createElement("div");
      axisElem.classList.add(cn$5$4("a"));
      axisElem.appendChild(v.element);
      this.element.appendChild(axisElem);
    });
  }
};
function createAxisController$4(doc, config, index) {
  return new NumberTextController$4(doc, {
    arrayPosition:
      index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
    parser: config.parser,
    props: config.axes[index].textProps,
    value: createValue$4(0, {
      constraint: config.axes[index].constraint,
    }),
    viewProps: config.viewProps,
  });
}
let PointNdTextController$4 = class PointNdTextController3 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.acs_ = config.axes.map((_, index) =>
      createAxisController$4(doc, config, index),
    );
    this.acs_.forEach((c, index) => {
      connectValues$4({
        primary: this.value,
        secondary: c.value,
        forward: (p) => config.assembly.toComponents(p)[index],
        backward: (p, s) => {
          const comps = config.assembly.toComponents(p);
          comps[index] = s;
          return config.assembly.fromComponents(comps);
        },
      });
    });
    this.view = new PointNdTextView$4(doc, {
      textViews: this.acs_.map((ac) => ac.view),
    });
  }
  get textControllers() {
    return this.acs_;
  }
};
let SliderInputBindingApi$4 = class SliderInputBindingApi3 extends BindingApi$4 {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.sliderController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(max) {
    this.controller.valueController.sliderController.props.set("min", max);
  }
};
function createConstraint$5$4(params, initialValue) {
  const constraints = [];
  const sc = createStepConstraint$4(params, initialValue);
  if (sc) {
    constraints.push(sc);
  }
  const rc = createRangeConstraint$4(params);
  if (rc) {
    constraints.push(rc);
  }
  const lc = createListConstraint$4(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$4(constraints);
}
createPlugin$4({
  id: "input-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$4(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser$4(p)), {
        options: p.optional.custom(parseListOptions$4),
        readonly: p.optional.constant(false),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown$4,
    constraint: (args) => createConstraint$5$4(args.params, args.initialValue),
    writer: (_args) => writePrimitive$4,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$4(c, ListConstraint$4);
    if (lc) {
      return new ListController$4(args.document, {
        props: new ValueMap$4({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    const textPropsObj = createNumberTextPropsObject$4(
      args.params,
      value.rawValue,
    );
    const drc = c && findConstraint$4(c, DefiniteRangeConstraint$4);
    if (drc) {
      return new SliderTextController$4(
        args.document,
        Object.assign(
          Object.assign(
            {},
            createSliderTextProps$4(
              Object.assign(Object.assign({}, textPropsObj), {
                keyScale: createValue$4(textPropsObj.keyScale),
                max: drc.values.value("max"),
                min: drc.values.value("min"),
              }),
            ),
          ),
          { parser: parseNumber$4, value, viewProps: args.viewProps },
        ),
      );
    }
    return new NumberTextController$4(args.document, {
      parser: parseNumber$4,
      props: ValueMap$4.fromObject(textPropsObj),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "number") {
      return null;
    }
    if (args.controller.valueController instanceof SliderTextController$4) {
      return new SliderInputBindingApi$4(args.controller);
    }
    if (args.controller.valueController instanceof ListController$4) {
      return new ListInputBindingApi$4(args.controller);
    }
    return null;
  },
});
let Point2d$4 = class Point2d3 {
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(obj) {
    if (isEmpty$4(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    if (typeof x !== "number" || typeof y2 !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
    };
  }
};
const Point2dAssembly$4 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point2d$4(...comps),
};
const cn$4$4 = ClassName$4("p2d");
let Point2dView$4 = class Point2dView3 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$4$4());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$4(
      config.expanded,
      valueToClassName$4(this.element, cn$4$4(void 0, "expanded")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$4$4("h"));
    this.element.appendChild(headElem);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$4$4("b"));
    buttonElem.appendChild(createSvgIconElement$4(doc, "p2dpad"));
    config.viewProps.bindDisabled(buttonElem);
    headElem.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$4$4("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$4$4("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
const cn$3$4 = ClassName$4("p2dp");
let Point2dPickerView$4 = class Point2dPickerView3 {
  constructor(doc, config) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this);
    this.onPropsChange_ = this.onPropsChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onPropsChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$3$4());
    if (config.layout === "popup") {
      this.element.classList.add(cn$3$4(void 0, "p"));
    }
    config.viewProps.bindClassModifiers(this.element);
    const padElem = doc.createElement("div");
    padElem.classList.add(cn$3$4("p"));
    config.viewProps.bindTabIndex(padElem);
    this.element.appendChild(padElem);
    this.padElement = padElem;
    const svgElem = doc.createElementNS(SVG_NS$4, "svg");
    svgElem.classList.add(cn$3$4("g"));
    this.padElement.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const xAxisElem = doc.createElementNS(SVG_NS$4, "line");
    xAxisElem.classList.add(cn$3$4("ax"));
    xAxisElem.setAttributeNS(null, "x1", "0");
    xAxisElem.setAttributeNS(null, "y1", "50%");
    xAxisElem.setAttributeNS(null, "x2", "100%");
    xAxisElem.setAttributeNS(null, "y2", "50%");
    this.svgElem_.appendChild(xAxisElem);
    const yAxisElem = doc.createElementNS(SVG_NS$4, "line");
    yAxisElem.classList.add(cn$3$4("ax"));
    yAxisElem.setAttributeNS(null, "x1", "50%");
    yAxisElem.setAttributeNS(null, "y1", "0");
    yAxisElem.setAttributeNS(null, "x2", "50%");
    yAxisElem.setAttributeNS(null, "y2", "100%");
    this.svgElem_.appendChild(yAxisElem);
    const lineElem = doc.createElementNS(SVG_NS$4, "line");
    lineElem.classList.add(cn$3$4("l"));
    lineElem.setAttributeNS(null, "x1", "50%");
    lineElem.setAttributeNS(null, "y1", "50%");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$3$4("m"));
    this.padElement.appendChild(markerElem);
    this.markerElem_ = markerElem;
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [x, y2] = this.value.rawValue.getComponents();
    const max = this.props_.get("max");
    const px2 = mapRange$4(x, -max, +max, 0, 100);
    const py2 = mapRange$4(y2, -max, +max, 0, 100);
    const ipy = this.props_.get("invertsY") ? 100 - py2 : py2;
    this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
    this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
    this.markerElem_.style.left = `${px2}%`;
    this.markerElem_.style.top = `${ipy}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
};
function computeOffset$5(ev, keyScales, invertsY) {
  return [
    getStepForKey$4(keyScales[0], getHorizontalStepKeys$4(ev)),
    getStepForKey$4(keyScales[1], getVerticalStepKeys$4(ev)) *
      (invertsY ? 1 : -1),
  ];
}
let Point2dPickerController$4 = class Point2dPickerController3 {
  constructor(doc, config) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new Point2dPickerView$4(doc, {
      layout: config.layout,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$4(this.view.padElement);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
    this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const max = this.props.get("max");
    const px2 = mapRange$4(d.point.x, 0, d.bounds.width, -max, +max);
    const py2 = mapRange$4(
      this.props.get("invertsY") ? d.bounds.height - d.point.y : d.point.y,
      0,
      d.bounds.height,
      -max,
      +max,
    );
    this.value.setRawValue(new Point2d$4(px2, py2), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onPadKeyDown_(ev) {
    if (isArrowKey$4(ev.key)) {
      ev.preventDefault();
    }
    const [dx, dy] = computeOffset$5(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(
      new Point2d$4(this.value.rawValue.x + dx, this.value.rawValue.y + dy),
      {
        forceEmit: false,
        last: false,
      },
    );
  }
  onPadKeyUp_(ev) {
    const [dx, dy] = computeOffset$5(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let Point2dController$4 = class Point2dController3 {
  constructor(doc, config) {
    var _a, _b;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$4.create(config.expanded);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$4(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const padC = new Point2dPickerController$4(doc, {
      layout: config.pickerLayout,
      props: new ValueMap$4({
        invertsY: createValue$4(config.invertsY),
        max: createValue$4(config.max),
        xKeyScale: config.axes[0].textProps.value("keyScale"),
        yKeyScale: config.axes[1].textProps.value("keyScale"),
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    padC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = padC;
    this.textC_ = new PointNdTextController$4(doc, {
      assembly: Point2dAssembly$4,
      axes: config.axes,
      parser: config.parser,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new Point2dView$4(doc, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: config.pickerLayout,
      viewProps: this.viewProps,
    });
    this.view.textElement.appendChild(this.textC_.view.element);
    (_a = this.view.buttonElement) === null || _a === void 0
      ? void 0
      : _a.addEventListener("blur", this.onPadButtonBlur_);
    (_b = this.view.buttonElement) === null || _b === void 0
      ? void 0
      : _b.addEventListener("click", this.onPadButtonClick_);
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(this.pickerC_.view.element);
      connectValues$4({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$4(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$4(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$4(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.view.buttonElement &&
      !supportsTouch$4(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.view.buttonElement.focus();
      }
    }
  }
};
function point2dFromUnknown$4(value) {
  return Point2d$4.isObject(value)
    ? new Point2d$4(value.x, value.y)
    : new Point2d$4();
}
function writePoint2d$4(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
}
function createConstraint$4$4(params, initialValue) {
  return new PointNdConstraint$4({
    assembly: Point2dAssembly$4,
    components: [
      createDimensionConstraint$4(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$4(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
    ],
  });
}
function getSuitableMaxDimensionValue$4(params, rawValue) {
  var _a, _b;
  if (!isEmpty$4(params.min) || !isEmpty$4(params.max)) {
    return Math.max(
      Math.abs((_a = params.min) !== null && _a !== void 0 ? _a : 0),
      Math.abs((_b = params.max) !== null && _b !== void 0 ? _b : 0),
    );
  }
  const step = getSuitableKeyScale$4(params);
  return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
}
function getSuitableMax$4(params, initialValue) {
  var _a, _b;
  const xr = getSuitableMaxDimensionValue$4(
    deepMerge$4(params, (_a = params.x) !== null && _a !== void 0 ? _a : {}),
    initialValue.x,
  );
  const yr = getSuitableMaxDimensionValue$4(
    deepMerge$4(params, (_b = params.y) !== null && _b !== void 0 ? _b : {}),
    initialValue.y,
  );
  return Math.max(xr, yr);
}
function shouldInvertY$4(params) {
  if (!("y" in params)) {
    return false;
  }
  const yParams = params.y;
  if (!yParams) {
    return false;
  }
  return "inverted" in yParams ? !!yParams.inverted : false;
}
createPlugin$4({
  id: "input-point2d",
  type: "input",
  accept: (value, params) => {
    if (!Point2d$4.isObject(value)) {
      return null;
    }
    const result = parseRecord$4(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$4(p)), {
        expanded: p.optional.boolean,
        picker: p.optional.custom(parsePickerLayout$4),
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$4),
        y: p.optional.object(
          Object.assign(Object.assign({}, createPointDimensionParser$4(p)), {
            inverted: p.optional.boolean,
          }),
        ),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: () => point2dFromUnknown$4,
    constraint: (args) => createConstraint$4$4(args.params, args.initialValue),
    equals: Point2d$4.equals,
    writer: () => writePoint2d$4,
  },
  controller: (args) => {
    var _a, _b;
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y];
    return new Point2dController$4(doc, {
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a2;
        return createPointAxis$4({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$4(
            args.params,
            (_a2 = dParams[i]) !== null && _a2 !== void 0 ? _a2 : {},
          ),
        });
      }),
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      invertsY: shouldInvertY$4(args.params),
      max: getSuitableMax$4(args.params, value.rawValue),
      parser: parseNumber$4,
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point3d$4 = class Point3d3 {
  constructor(x = 0, y2 = 0, z = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(obj) {
    if (isEmpty$4(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
    };
  }
};
const Point3dAssembly$4 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point3d$4(...comps),
};
function point3dFromUnknown$4(value) {
  return Point3d$4.isObject(value)
    ? new Point3d$4(value.x, value.y, value.z)
    : new Point3d$4();
}
function writePoint3d$4(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
}
function createConstraint$3$4(params, initialValue) {
  return new PointNdConstraint$4({
    assembly: Point3dAssembly$4,
    components: [
      createDimensionConstraint$4(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$4(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$4(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
    ],
  });
}
createPlugin$4({
  id: "input-point3d",
  type: "input",
  accept: (value, params) => {
    if (!Point3d$4.isObject(value)) {
      return null;
    }
    const result = parseRecord$4(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$4(p)), {
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$4),
        y: p.optional.custom(parsePointDimensionParams$4),
        z: p.optional.custom(parsePointDimensionParams$4),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point3dFromUnknown$4,
    constraint: (args) => createConstraint$3$4(args.params, args.initialValue),
    equals: Point3d$4.equals,
    writer: (_args) => writePoint3d$4,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y, args.params.z];
    return new PointNdTextController$4(args.document, {
      assembly: Point3dAssembly$4,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$4({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$4(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$4,
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point4d$4 = class Point4d3 {
  constructor(x = 0, y2 = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
    this.w = w;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(obj) {
    if (isEmpty$4(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    const w = obj.w;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number" ||
      typeof w !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w,
    };
  }
};
const Point4dAssembly$4 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point4d$4(...comps),
};
function point4dFromUnknown$4(value) {
  return Point4d$4.isObject(value)
    ? new Point4d$4(value.x, value.y, value.z, value.w)
    : new Point4d$4();
}
function writePoint4d$4(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
  target.writeProperty("w", value.w);
}
function createConstraint$2$4(params, initialValue) {
  return new PointNdConstraint$4({
    assembly: Point4dAssembly$4,
    components: [
      createDimensionConstraint$4(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$4(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$4(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
      createDimensionConstraint$4(
        Object.assign(Object.assign({}, params), params.w),
        initialValue.w,
      ),
    ],
  });
}
createPlugin$4({
  id: "input-point4d",
  type: "input",
  accept: (value, params) => {
    if (!Point4d$4.isObject(value)) {
      return null;
    }
    const result = parseRecord$4(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$4(p)), {
        readonly: p.optional.constant(false),
        w: p.optional.custom(parsePointDimensionParams$4),
        x: p.optional.custom(parsePointDimensionParams$4),
        y: p.optional.custom(parsePointDimensionParams$4),
        z: p.optional.custom(parsePointDimensionParams$4),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point4dFromUnknown$4,
    constraint: (args) => createConstraint$2$4(args.params, args.initialValue),
    equals: Point4d$4.equals,
    writer: (_args) => writePoint4d$4,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [
      args.params.x,
      args.params.y,
      args.params.z,
      args.params.w,
    ];
    return new PointNdTextController$4(args.document, {
      assembly: Point4dAssembly$4,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$4({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$4(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$4,
      value,
      viewProps: args.viewProps,
    });
  },
});
function createConstraint$1$4(params) {
  const constraints = [];
  const lc = createListConstraint$4(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$4(constraints);
}
createPlugin$4({
  id: "input-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$4(params, (p) => ({
      readonly: p.optional.constant(false),
      options: p.optional.custom(parseListOptions$4),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$4,
    constraint: (args) => createConstraint$1$4(args.params),
    writer: (_args) => writePrimitive$4,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$4(c, ListConstraint$4);
    if (lc) {
      return new ListController$4(doc, {
        props: new ValueMap$4({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new TextController$4(doc, {
      parser: (v) => v,
      props: ValueMap$4.fromObject({
        formatter: formatString$4,
      }),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "string") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$4) {
      return new ListInputBindingApi$4(args.controller);
    }
    return null;
  },
});
const Constants$4 = {
  monitor: {
    defaultInterval: 200,
    defaultRows: 3,
  },
};
const cn$2$4 = ClassName$4("mll");
let MultiLogView$4 = class MultiLogView3 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$2$4());
    config.viewProps.bindClassModifiers(this.element);
    const textareaElem = doc.createElement("textarea");
    textareaElem.classList.add(cn$2$4("i"));
    textareaElem.style.height = `calc(var(${getCssVar$4("containerUnitSize")}) * ${config.rows})`;
    textareaElem.readOnly = true;
    config.viewProps.bindDisabled(textareaElem);
    this.element.appendChild(textareaElem);
    this.textareaElem_ = textareaElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const elem = this.textareaElem_;
    const shouldScroll =
      elem.scrollTop === elem.scrollHeight - elem.clientHeight;
    const lines = [];
    this.value.rawValue.forEach((value) => {
      if (value !== void 0) {
        lines.push(this.formatter_(value));
      }
    });
    elem.textContent = lines.join("\n");
    if (shouldScroll) {
      elem.scrollTop = elem.scrollHeight;
    }
  }
  onValueUpdate_() {
    this.update_();
  }
};
let MultiLogController$4 = class MultiLogController3 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new MultiLogView$4(doc, {
      formatter: config.formatter,
      rows: config.rows,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
const cn$1$4 = ClassName$4("sgl");
let SingleLogView$4 = class SingleLogView3 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$1$4());
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$1$4("i"));
    inputElem.readOnly = true;
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const values = this.value.rawValue;
    const lastValue = values[values.length - 1];
    this.inputElement.value =
      lastValue !== void 0 ? this.formatter_(lastValue) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
};
let SingleLogController$4 = class SingleLogController3 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SingleLogView$4(doc, {
      formatter: config.formatter,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
createPlugin$4({
  id: "monitor-bool",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$4(params, (p) => ({
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$4,
  },
  controller: (args) => {
    var _a;
    if (args.value.rawValue.length === 1) {
      return new SingleLogController$4(args.document, {
        formatter: BooleanFormatter$4,
        value: args.value,
        viewProps: args.viewProps,
      });
    }
    return new MultiLogController$4(args.document, {
      formatter: BooleanFormatter$4,
      rows:
        (_a = args.params.rows) !== null && _a !== void 0
          ? _a
          : Constants$4.monitor.defaultRows,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let GraphLogMonitorBindingApi$4 = class GraphLogMonitorBindingApi3 extends BindingApi$4 {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.props.set("min", min);
  }
};
const cn$u = ClassName$4("grl");
let GraphLogView$4 = class GraphLogView3 {
  constructor(doc, config) {
    this.onCursorChange_ = this.onCursorChange_.bind(this);
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$u());
    config.viewProps.bindClassModifiers(this.element);
    this.formatter_ = config.formatter;
    this.props_ = config.props;
    this.cursor_ = config.cursor;
    this.cursor_.emitter.on("change", this.onCursorChange_);
    const svgElem = doc.createElementNS(SVG_NS$4, "svg");
    svgElem.classList.add(cn$u("g"));
    svgElem.style.height = `calc(var(${getCssVar$4("containerUnitSize")}) * ${config.rows})`;
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const lineElem = doc.createElementNS(SVG_NS$4, "polyline");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(cn$u("t"), ClassName$4("tt")());
    this.element.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const bounds = this.svgElem_.getBoundingClientRect();
    const maxIndex = this.value.rawValue.length - 1;
    const min = this.props_.get("min");
    const max = this.props_.get("max");
    const points = [];
    this.value.rawValue.forEach((v, index) => {
      if (v === void 0) {
        return;
      }
      const x = mapRange$4(index, 0, maxIndex, 0, bounds.width);
      const y2 = mapRange$4(v, min, max, bounds.height, 0);
      points.push([x, y2].join(","));
    });
    this.lineElem_.setAttributeNS(null, "points", points.join(" "));
    const tooltipElem = this.tooltipElem_;
    const value = this.value.rawValue[this.cursor_.rawValue];
    if (value === void 0) {
      tooltipElem.classList.remove(cn$u("t", "a"));
      return;
    }
    const tx = mapRange$4(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
    const ty = mapRange$4(value, min, max, bounds.height, 0);
    tooltipElem.style.left = `${tx}px`;
    tooltipElem.style.top = `${ty}px`;
    tooltipElem.textContent = `${this.formatter_(value)}`;
    if (!tooltipElem.classList.contains(cn$u("t", "a"))) {
      tooltipElem.classList.add(cn$u("t", "a"), cn$u("t", "in"));
      forceReflow$4(tooltipElem);
      tooltipElem.classList.remove(cn$u("t", "in"));
    }
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
};
let GraphLogController$4 = class GraphLogController3 {
  constructor(doc, config) {
    this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.cursor_ = createValue$4(-1);
    this.view = new GraphLogView$4(doc, {
      cursor: this.cursor_,
      formatter: config.formatter,
      rows: config.rows,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    if (!supportsTouch$4(doc)) {
      this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
      this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    } else {
      const ph = new PointerHandler$4(this.view.element);
      ph.emitter.on("down", this.onGraphPointerDown_);
      ph.emitter.on("move", this.onGraphPointerMove_);
      ph.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(state) {
    return importBladeState$4(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        this.props.set("max", result.max);
        this.props.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$4(null, {
      max: this.props.get("max"),
      min: this.props.get("min"),
    });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(ev) {
    const bounds = this.view.element.getBoundingClientRect();
    this.cursor_.rawValue = Math.floor(
      mapRange$4(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length),
    );
  }
  onGraphPointerDown_(ev) {
    this.onGraphPointerMove_(ev);
  }
  onGraphPointerMove_(ev) {
    if (!ev.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(
      mapRange$4(
        ev.data.point.x,
        0,
        ev.data.bounds.width,
        0,
        this.value.rawValue.length,
      ),
    );
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
};
function createFormatter$6(params) {
  return !isEmpty$4(params.format) ? params.format : createNumberFormatter$4(2);
}
function createTextMonitor$4(args) {
  var _a;
  if (args.value.rawValue.length === 1) {
    return new SingleLogController$4(args.document, {
      formatter: createFormatter$6(args.params),
      value: args.value,
      viewProps: args.viewProps,
    });
  }
  return new MultiLogController$4(args.document, {
    formatter: createFormatter$6(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$4.monitor.defaultRows,
    value: args.value,
    viewProps: args.viewProps,
  });
}
function createGraphMonitor$4(args) {
  var _a, _b, _c;
  return new GraphLogController$4(args.document, {
    formatter: createFormatter$6(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$4.monitor.defaultRows,
    props: ValueMap$4.fromObject({
      max: (_b = args.params.max) !== null && _b !== void 0 ? _b : 100,
      min: (_c = args.params.min) !== null && _c !== void 0 ? _c : 0,
    }),
    value: args.value,
    viewProps: args.viewProps,
  });
}
function shouldShowGraph$4(params) {
  return params.view === "graph";
}
createPlugin$4({
  id: "monitor-number",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$4(params, (p) => ({
      format: p.optional.function,
      max: p.optional.number,
      min: p.optional.number,
      readonly: p.required.constant(true),
      rows: p.optional.number,
      view: p.optional.string,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    defaultBufferSize: (params) => (shouldShowGraph$4(params) ? 64 : 1),
    reader: (_args) => numberFromUnknown$4,
  },
  controller: (args) => {
    if (shouldShowGraph$4(args.params)) {
      return createGraphMonitor$4(args);
    }
    return createTextMonitor$4(args);
  },
  api: (args) => {
    if (args.controller.valueController instanceof GraphLogController$4) {
      return new GraphLogMonitorBindingApi$4(args.controller);
    }
    return null;
  },
});
createPlugin$4({
  id: "monitor-string",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$4(params, (p) => ({
      multiline: p.optional.boolean,
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$4,
  },
  controller: (args) => {
    var _a;
    const value = args.value;
    const multiline = value.rawValue.length > 1 || args.params.multiline;
    if (multiline) {
      return new MultiLogController$4(args.document, {
        formatter: formatString$4,
        rows:
          (_a = args.params.rows) !== null && _a !== void 0
            ? _a
            : Constants$4.monitor.defaultRows,
        value,
        viewProps: args.viewProps,
      });
    }
    return new SingleLogController$4(args.document, {
      formatter: formatString$4,
      value,
      viewProps: args.viewProps,
    });
  },
});
const className$1$2 = ClassName$4("ckr");
class RingView {
  constructor(doc, config) {
    this.tickElems_ = [];
    this.labelElems_ = [];
    this.boundsWidth_ = -1;
    this.onShowsTooltipChange_ = this.onShowsTooltipChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.formatters_ = config.formatters;
    this.unit_ = config.unit;
    this.element = doc.createElement("div");
    this.element.classList.add(
      className$1$2(),
      className$1$2(void 0, `m${config.seriesId}`),
    );
    config.viewProps.bindClassModifiers(this.element);
    this.value_ = config.value;
    this.value_.emitter.on("change", this.onValueChange_);
    config.showsTooltip.emitter.on("change", this.onShowsTooltipChange_);
    const wrapperElem = doc.createElement("div");
    wrapperElem.classList.add(className$1$2("w"));
    this.element.appendChild(wrapperElem);
    this.offsetElem_ = doc.createElement("div");
    this.offsetElem_.classList.add(className$1$2("o"));
    wrapperElem.appendChild(this.offsetElem_);
    this.svgElem_ = doc.createElementNS(SVG_NS$4, "svg");
    this.svgElem_.classList.add(className$1$2("g"));
    this.offsetElem_.appendChild(this.svgElem_);
    this.tooltipElem_ = doc.createElement("div");
    this.tooltipElem_.classList.add(ClassName$4("tt")(), className$1$2("tt"));
    this.element.appendChild(this.tooltipElem_);
    this.waitToBeAdded_();
  }
  // Waits to be added to DOM tree to build initial scale elements
  waitToBeAdded_() {
    const ob = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.target !== this.element || entry.intersectionRatio === 0) {
            return;
          }
          this.update();
          ob.disconnect();
        });
      },
      {
        root: null,
      },
    );
    ob.observe(this.element);
  }
  rebuildScaleIfNeeded_(bw) {
    if (this.boundsWidth_ === bw) {
      return;
    }
    this.boundsWidth_ = bw;
    this.tickElems_.forEach((elem) => {
      removeElement$4(elem);
    });
    this.tickElems_ = [];
    this.labelElems_.forEach((elem) => {
      removeElement$4(elem);
    });
    this.labelElems_ = [];
    const doc = this.element.ownerDocument;
    const tpu = this.unit_.ticks;
    const uw = this.unit_.pixels;
    const halfUnitCount = Math.ceil(bw / 2 / uw) + 1;
    const unitCount = halfUnitCount * 2 + 1;
    const tickCount = unitCount * tpu;
    const tickWidth = uw / tpu;
    for (let i = 0; i < tickCount; i++) {
      const x = i * tickWidth;
      if (i % tpu === 0) {
        const lineElem = doc.createElementNS(SVG_NS$4, "line");
        lineElem.classList.add(className$1$2("mjt"));
        lineElem.setAttributeNS(null, "x1", String(x));
        lineElem.setAttributeNS(null, "y1", "0");
        lineElem.setAttributeNS(null, "x2", String(x));
        lineElem.setAttributeNS(null, "y2", "2");
        this.svgElem_.appendChild(lineElem);
        this.tickElems_.push(lineElem);
        const labelElem = doc.createElement("div");
        labelElem.classList.add(className$1$2("l"));
        labelElem.style.left = `${x}px`;
        this.offsetElem_.appendChild(labelElem);
        this.labelElems_.push(labelElem);
      } else {
        const lineElem = doc.createElementNS(SVG_NS$4, "line");
        lineElem.classList.add(className$1$2("mnt"));
        lineElem.setAttributeNS(null, "x1", String(x));
        lineElem.setAttributeNS(null, "y1", "0");
        lineElem.setAttributeNS(null, "x2", String(x));
        lineElem.setAttributeNS(null, "y2", "2");
        this.svgElem_.appendChild(lineElem);
        this.tickElems_.push(lineElem);
      }
    }
  }
  updateScale_(bw) {
    const uv = this.unit_.value;
    const uw = this.unit_.pixels;
    const v = this.value_.rawValue;
    const halfUnitCount = Math.ceil(bw / 2 / uw) + 1;
    const ov = v - (v % uv) - uv * halfUnitCount;
    const opacity = (tv) => {
      return (
        1 -
        Math.pow(
          constrainRange$4(Math.abs(v - tv) / ((bw / 2) * (uv / uw)), 0, 1),
          10,
        )
      );
    };
    this.labelElems_.forEach((elem, i) => {
      const lv = ov + i * uv;
      elem.textContent = this.formatters_.ring(lv);
      elem.style.opacity = String(opacity(lv));
    });
    const tpu = this.unit_.ticks;
    this.tickElems_.forEach((elem, i) => {
      const lv = ov + (i / tpu) * uv;
      elem.style.opacity = String(opacity(lv));
    });
  }
  update() {
    const bw = this.element.getBoundingClientRect().width;
    const uv = this.unit_.value;
    const uw = this.unit_.pixels;
    const v = this.value_.rawValue;
    const halfUnitCount = Math.ceil(bw / 2 / uw) + 1;
    const offsetFromCenter = ((v % uv) + uv * halfUnitCount) * (uw / uv);
    const offset = bw / 2 - offsetFromCenter;
    this.offsetElem_.style.transform = `translateX(${offset}px)`;
    this.tooltipElem_.textContent = this.formatters_.text(v);
    this.rebuildScaleIfNeeded_(bw);
    this.updateScale_(bw);
  }
  onValueChange_() {
    this.update();
  }
  onShowsTooltipChange_(ev) {
    if (ev.rawValue) {
      this.element.classList.add(className$1$2(void 0, "tt"));
    } else {
      this.element.classList.remove(className$1$2(void 0, "tt"));
    }
  }
}
class RingController {
  constructor(doc, config) {
    this.ox_ = 0;
    this.ov_ = 0;
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.tooltipEnabled_ = config.tooltipEnabled;
    this.unit_ = config.unit;
    this.showsTooltip_ = createValue$4(false);
    this.view = new RingView(doc, {
      formatters: config.formatters,
      seriesId: config.seriesId,
      showsTooltip: this.showsTooltip_,
      unit: config.unit,
      value: this.value,
      viewProps: this.viewProps,
    });
    const ptHandler = new PointerHandler$4(this.view.element);
    ptHandler.emitter.on("down", this.onPointerDown_);
    ptHandler.emitter.on("move", this.onPointerMove_);
    ptHandler.emitter.on("up", this.onPointerUp_);
  }
  onPointerDown_(ev) {
    const data = ev.data;
    if (!data.point) {
      return;
    }
    this.ox_ = data.point.x;
    this.ov_ = this.value.rawValue;
    if (this.tooltipEnabled_) {
      this.showsTooltip_.rawValue = true;
    }
  }
  onPointerMove_(ev) {
    const data = ev.data;
    if (!data.point) {
      return;
    }
    const dx = data.point.x - this.ox_;
    const uw = this.unit_.pixels;
    const uv = this.unit_.value;
    this.value.setRawValue(this.ov_ - (dx / uw) * uv, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_() {
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
    this.showsTooltip_.rawValue = false;
  }
}
const className$4 = ClassName$4("ckrtxt");
class RingTextView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(className$4());
    const ringElem = doc.createElement("div");
    ringElem.classList.add(className$4("r"));
    ringElem.appendChild(config.ringView.element);
    this.element.appendChild(ringElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(className$4("t"));
    textElem.appendChild(config.textView.element);
    this.element.appendChild(textElem);
  }
}
class RingTextController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.rc_ = new RingController(doc, {
      formatters: {
        ring: config.ringFormatter,
        text: config.textProps.get("formatter"),
      },
      seriesId: config.seriesId,
      tooltipEnabled: false,
      unit: config.ringUnit,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.tc_ = new NumberTextController$4(doc, {
      parser: config.parser,
      props: config.textProps,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new RingTextView(doc, {
      ringView: this.rc_.view,
      textView: this.tc_.view,
    });
  }
}
function createConstraint$a(params) {
  const constraints = [];
  const cr = createRangeConstraint$4(params);
  if (cr) {
    constraints.push(cr);
  }
  const cs = createStepConstraint$4(params);
  if (cs) {
    constraints.push(cs);
  }
  return new CompositeConstraint$4(constraints);
}
function parseSeries(value) {
  return value === 0 || value === 1 || value === 2 ? value : void 0;
}
function getRingSeries(series) {
  return series !== void 0 ? String(series) : "0";
}
function createRingFormatter(ringUnit) {
  const f = createNumberFormatter$4(getDecimalDigits$4(ringUnit.value));
  return (value) => {
    const text = f(value);
    const ch = text.substr(0, 1);
    const hasSign = ch === "-" || ch === "+";
    return text + (hasSign ? " " : "");
  };
}
createPlugin$4({
  id: "input-ring",
  type: "input",
  accept(exValue, params) {
    if (typeof exValue !== "number") {
      return null;
    }
    const result = parseRecord$4(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser$4(p)), {
        series: p.optional.custom(parseSeries),
        unit: p.optional.object({
          pixels: p.required.number,
          ticks: p.required.number,
          value: p.required.number,
        }),
        view: p.required.constant("cameraring"),
        wide: p.optional.boolean,
      }),
    );
    return result
      ? {
          initialValue: exValue,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown$4,
    constraint: (args) => createConstraint$a(args.params),
    writer: (_args) => writePrimitive$4,
  },
  controller(args) {
    var _a, _b, _c;
    const ringUnit =
      (_a = args.params.unit) !== null && _a !== void 0
        ? _a
        : {
            ticks: 5,
            pixels: 40,
            value: 10,
          };
    const ringFormatter = createRingFormatter(ringUnit);
    const textPropsObj = createNumberTextPropsObject$4(
      args.params,
      args.initialValue,
    );
    if (args.params.wide) {
      return new RingController(args.document, {
        formatters: {
          ring: ringFormatter,
          text: textPropsObj.formatter,
        },
        seriesId:
          (_b = getRingSeries(args.params.series)) !== null && _b !== void 0
            ? _b
            : "0",
        tooltipEnabled: true,
        unit: ringUnit,
        value: args.value,
        viewProps: args.viewProps,
      });
    }
    const textProps = ValueMap$4.fromObject(textPropsObj);
    return new RingTextController(args.document, {
      parser: parseNumber$4,
      ringFormatter,
      ringUnit,
      seriesId:
        (_c = getRingSeries(args.params.series)) !== null && _c !== void 0
          ? _c
          : "0",
      textProps,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
createPlugin$4({
  id: "input-wheel",
  type: "input",
  accept(exValue, params) {
    if (typeof exValue !== "number") {
      return null;
    }
    const result = parseRecord$4(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser$4(p)), {
        amount: p.optional.number,
        view: p.required.constant("camerawheel"),
        wide: p.optional.boolean,
      }),
    );
    return result
      ? {
          initialValue: exValue,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown$4,
    constraint: (args) => createConstraint$a(args.params),
    writer: (_args) => writePrimitive$4,
  },
  controller(args) {
    var _a, _b;
    const ringFormatter = createNumberFormatter$4(0);
    const textPropsObj = createNumberTextPropsObject$4(
      args.params,
      args.initialValue,
    );
    if (args.params.wide) {
      return new RingController(args.document, {
        formatters: {
          ring: ringFormatter,
          text: textPropsObj.formatter,
        },
        seriesId: "w",
        tooltipEnabled: true,
        unit: {
          ticks: 10,
          pixels: 40,
          value:
            ((_a = args.params.amount) !== null && _a !== void 0
              ? _a
              : textPropsObj.pointerScale) * 40,
        },
        value: args.value,
        viewProps: args.viewProps,
      });
    }
    return new RingTextController(args.document, {
      parser: parseNumber$4,
      ringFormatter,
      ringUnit: {
        ticks: 10,
        pixels: 40,
        value:
          ((_b = args.params.amount) !== null && _b !== void 0
            ? _b
            : textPropsObj.pointerScale) * 40,
      },
      seriesId: "w",
      textProps: ValueMap$4.fromObject(textPropsObj),
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
function forceCast$3(v) {
  return v;
}
function isEmpty$3(value) {
  return value === null || value === void 0;
}
function isObject$1$3(value) {
  return value !== null && typeof value === "object";
}
function isRecord$3(value) {
  return value !== null && typeof value === "object";
}
function deepEqualsArray$3(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (let i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
function deepMerge$3(r1, r2) {
  const keys = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(r1), ...Object.keys(r2)]),
  );
  return keys.reduce((result, key2) => {
    const v1 = r1[key2];
    const v2 = r2[key2];
    return isRecord$3(v1) && isRecord$3(v2)
      ? Object.assign(Object.assign({}, result), {
          [key2]: deepMerge$3(v1, v2),
        })
      : Object.assign(Object.assign({}, result), {
          [key2]: key2 in r2 ? v2 : v1,
        });
  }, {});
}
function isBinding$3(value) {
  if (!isObject$1$3(value)) {
    return false;
  }
  return "target" in value;
}
const CREATE_MESSAGE_MAP$3 = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (context) => `Invalid parameters for '${context.name}'`,
  nomatchingcontroller: (context) =>
    `No matching controller for '${context.key}'`,
  nomatchingview: (context) =>
    `No matching view for '${JSON.stringify(context.params)}'`,
  notbindable: () => `Value is not bindable`,
  notcompatible: (context) => `Not compatible with  plugin '${context.id}'`,
  propertynotfound: (context) => `Property '${context.name}' not found`,
  shouldneverhappen: () => "This error should never happen",
};
let TpError$3 = class TpError4 {
  static alreadyDisposed() {
    return new TpError4({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new TpError4({
      type: "notbindable",
    });
  }
  static notCompatible(bundleId, id) {
    return new TpError4({
      type: "notcompatible",
      context: {
        id: `${bundleId}.${id}`,
      },
    });
  }
  static propertyNotFound(name) {
    return new TpError4({
      type: "propertynotfound",
      context: {
        name,
      },
    });
  }
  static shouldNeverHappen() {
    return new TpError4({ type: "shouldneverhappen" });
  }
  constructor(config) {
    var _a;
    this.message =
      (_a = CREATE_MESSAGE_MAP$3[config.type](forceCast$3(config.context))) !==
        null && _a !== void 0
        ? _a
        : "Unexpected error";
    this.name = this.constructor.name;
    this.stack = new Error(this.message).stack;
    this.type = config.type;
  }
  toString() {
    return this.message;
  }
};
let BindingTarget$3 = class BindingTarget4 {
  constructor(obj, key2) {
    this.obj_ = obj;
    this.key = key2;
  }
  static isBindable(obj) {
    if (obj === null) {
      return false;
    }
    if (typeof obj !== "object" && typeof obj !== "function") {
      return false;
    }
    return true;
  }
  read() {
    return this.obj_[this.key];
  }
  write(value) {
    this.obj_[this.key] = value;
  }
  writeProperty(name, value) {
    const valueObj = this.read();
    if (!BindingTarget4.isBindable(valueObj)) {
      throw TpError$3.notBindable();
    }
    if (!(name in valueObj)) {
      throw TpError$3.propertyNotFound(name);
    }
    valueObj[name] = value;
  }
};
let Emitter$3 = class Emitter4 {
  constructor() {
    this.observers_ = {};
  }
  on(eventName, handler) {
    let observers = this.observers_[eventName];
    if (!observers) {
      observers = this.observers_[eventName] = [];
    }
    observers.push({
      handler,
    });
    return this;
  }
  off(eventName, handler) {
    const observers = this.observers_[eventName];
    if (observers) {
      this.observers_[eventName] = observers.filter((observer) => {
        return observer.handler !== handler;
      });
    }
    return this;
  }
  emit(eventName, event) {
    const observers = this.observers_[eventName];
    if (!observers) {
      return;
    }
    observers.forEach((observer) => {
      observer.handler(event);
    });
  }
};
let ComplexValue$3 = class ComplexValue4 {
  constructor(initialValue, config) {
    var _a;
    this.constraint_ =
      config === null || config === void 0 ? void 0 : config.constraint;
    this.equals_ =
      (_a = config === null || config === void 0 ? void 0 : config.equals) !==
        null && _a !== void 0
        ? _a
        : (v1, v2) => v1 === v2;
    this.emitter = new Emitter$3();
    this.rawValue_ = initialValue;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(rawValue) {
    this.setRawValue(rawValue, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(rawValue, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const constrainedValue = this.constraint_
      ? this.constraint_.constrain(rawValue)
      : rawValue;
    const prevValue = this.rawValue_;
    const changed = !this.equals_(prevValue, constrainedValue);
    if (!changed && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.rawValue_ = constrainedValue;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: constrainedValue,
      sender: this,
    });
  }
};
let PrimitiveValue$3 = class PrimitiveValue4 {
  constructor(initialValue) {
    this.emitter = new Emitter$3();
    this.value_ = initialValue;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(value) {
    this.setRawValue(value, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(value, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const prevValue = this.value_;
    if (prevValue === value && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.value_ = value;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: this.value_,
      sender: this,
    });
  }
};
let ReadonlyPrimitiveValue$3 = class ReadonlyPrimitiveValue4 {
  constructor(value) {
    this.emitter = new Emitter$3();
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value_ = value;
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit(
      "beforechange",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
  onValueChange_(ev) {
    this.emitter.emit(
      "change",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
};
function createValue$3(initialValue, config) {
  const constraint =
    config === null || config === void 0 ? void 0 : config.constraint;
  const equals2 = config === null || config === void 0 ? void 0 : config.equals;
  if (!constraint && !equals2) {
    return new PrimitiveValue$3(initialValue);
  }
  return new ComplexValue$3(initialValue, config);
}
function createReadonlyValue$3(value) {
  return [
    new ReadonlyPrimitiveValue$3(value),
    (rawValue, options) => {
      value.setRawValue(rawValue, options);
    },
  ];
}
let ValueMap$3 = class ValueMap4 {
  constructor(valueMap) {
    this.emitter = new Emitter$3();
    this.valMap_ = valueMap;
    for (const key2 in this.valMap_) {
      const v = this.valMap_[key2];
      v.emitter.on("change", () => {
        this.emitter.emit("change", {
          key: key2,
          sender: this,
        });
      });
    }
  }
  static createCore(initialValue) {
    const keys = Object.keys(initialValue);
    return keys.reduce((o, key2) => {
      return Object.assign(o, {
        [key2]: createValue$3(initialValue[key2]),
      });
    }, {});
  }
  static fromObject(initialValue) {
    const core = this.createCore(initialValue);
    return new ValueMap4(core);
  }
  get(key2) {
    return this.valMap_[key2].rawValue;
  }
  set(key2, value) {
    this.valMap_[key2].rawValue = value;
  }
  value(key2) {
    return this.valMap_[key2];
  }
};
let DefiniteRangeConstraint$3 = class DefiniteRangeConstraint4 {
  constructor(config) {
    this.values = ValueMap$3.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    return Math.min(Math.max(value, min), max);
  }
};
let RangeConstraint$3 = class RangeConstraint4 {
  constructor(config) {
    this.values = ValueMap$3.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    let result = value;
    if (!isEmpty$3(min)) {
      result = Math.max(result, min);
    }
    if (!isEmpty$3(max)) {
      result = Math.min(result, max);
    }
    return result;
  }
};
let StepConstraint$3 = class StepConstraint4 {
  constructor(step, origin = 0) {
    this.step = step;
    this.origin = origin;
  }
  constrain(value) {
    const o = this.origin % this.step;
    const r = Math.round((value - o) / this.step);
    return o + r * this.step;
  }
};
let NumberLiteralNode$3 = class NumberLiteralNode4 {
  constructor(text) {
    this.text = text;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
};
const BINARY_OPERATION_MAP$3 = {
  "**": (v1, v2) => Math.pow(v1, v2),
  "*": (v1, v2) => v1 * v2,
  "/": (v1, v2) => v1 / v2,
  "%": (v1, v2) => v1 % v2,
  "+": (v1, v2) => v1 + v2,
  "-": (v1, v2) => v1 - v2,
  "<<": (v1, v2) => v1 << v2,
  ">>": (v1, v2) => v1 >> v2,
  ">>>": (v1, v2) => v1 >>> v2,
  "&": (v1, v2) => v1 & v2,
  "^": (v1, v2) => v1 ^ v2,
  "|": (v1, v2) => v1 | v2,
};
let BinaryOperationNode$3 = class BinaryOperationNode4 {
  constructor(operator, left, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  evaluate() {
    const op = BINARY_OPERATION_MAP$3[this.operator];
    if (!op) {
      throw new Error(`unexpected binary operator: '${this.operator}`);
    }
    return op(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")",
    ].join(" ");
  }
};
const UNARY_OPERATION_MAP$3 = {
  "+": (v) => v,
  "-": (v) => -v,
  "~": (v) => ~v,
};
let UnaryOperationNode$3 = class UnaryOperationNode4 {
  constructor(operator, expr) {
    this.operator = operator;
    this.expression = expr;
  }
  evaluate() {
    const op = UNARY_OPERATION_MAP$3[this.operator];
    if (!op) {
      throw new Error(`unexpected unary operator: '${this.operator}`);
    }
    return op(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
};
function combineReader$3(parsers) {
  return (text, cursor) => {
    for (let i = 0; i < parsers.length; i++) {
      const result = parsers[i](text, cursor);
      if (result !== "") {
        return result;
      }
    }
    return "";
  };
}
function readWhitespace$3(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^\s+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readNonZeroDigit$3(text, cursor) {
  const ch = text.substr(cursor, 1);
  return ch.match(/^[1-9]$/) ? ch : "";
}
function readDecimalDigits$3(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readSignedInteger$3(text, cursor) {
  const ds = readDecimalDigits$3(text, cursor);
  if (ds !== "") {
    return ds;
  }
  const sign2 = text.substr(cursor, 1);
  cursor += 1;
  if (sign2 !== "-" && sign2 !== "+") {
    return "";
  }
  const sds = readDecimalDigits$3(text, cursor);
  if (sds === "") {
    return "";
  }
  return sign2 + sds;
}
function readExponentPart$3(text, cursor) {
  const e = text.substr(cursor, 1);
  cursor += 1;
  if (e.toLowerCase() !== "e") {
    return "";
  }
  const si = readSignedInteger$3(text, cursor);
  if (si === "") {
    return "";
  }
  return e + si;
}
function readDecimalIntegerLiteral$3(text, cursor) {
  const ch = text.substr(cursor, 1);
  if (ch === "0") {
    return ch;
  }
  const nzd = readNonZeroDigit$3(text, cursor);
  cursor += nzd.length;
  if (nzd === "") {
    return "";
  }
  return nzd + readDecimalDigits$3(text, cursor);
}
function readDecimalLiteral1$3(text, cursor) {
  const dil = readDecimalIntegerLiteral$3(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$3(text, cursor);
  cursor += dds.length;
  return dil + dot2 + dds + readExponentPart$3(text, cursor);
}
function readDecimalLiteral2$3(text, cursor) {
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$3(text, cursor);
  cursor += dds.length;
  if (dds === "") {
    return "";
  }
  return dot2 + dds + readExponentPart$3(text, cursor);
}
function readDecimalLiteral3$3(text, cursor) {
  const dil = readDecimalIntegerLiteral$3(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  return dil + readExponentPart$3(text, cursor);
}
const readDecimalLiteral$3 = combineReader$3([
  readDecimalLiteral1$3,
  readDecimalLiteral2$3,
  readDecimalLiteral3$3,
]);
function parseBinaryDigits$3(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[01]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readBinaryIntegerLiteral$3(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0b") {
    return "";
  }
  const bds = parseBinaryDigits$3(text, cursor);
  if (bds === "") {
    return "";
  }
  return prefix + bds;
}
function readOctalDigits$3(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-7]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readOctalIntegerLiteral$3(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0o") {
    return "";
  }
  const ods = readOctalDigits$3(text, cursor);
  if (ods === "") {
    return "";
  }
  return prefix + ods;
}
function readHexDigits$3(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9a-f]+/i);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readHexIntegerLiteral$3(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0x") {
    return "";
  }
  const hds = readHexDigits$3(text, cursor);
  if (hds === "") {
    return "";
  }
  return prefix + hds;
}
const readNonDecimalIntegerLiteral$3 = combineReader$3([
  readBinaryIntegerLiteral$3,
  readOctalIntegerLiteral$3,
  readHexIntegerLiteral$3,
]);
const readNumericLiteral$3 = combineReader$3([
  readNonDecimalIntegerLiteral$3,
  readDecimalLiteral$3,
]);
function parseLiteral$3(text, cursor) {
  const num = readNumericLiteral$3(text, cursor);
  cursor += num.length;
  if (num === "") {
    return null;
  }
  return {
    evaluable: new NumberLiteralNode$3(num),
    cursor,
  };
}
function parseParenthesizedExpression$3(text, cursor) {
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "(") {
    return null;
  }
  const expr = parseExpression$3(text, cursor);
  if (!expr) {
    return null;
  }
  cursor = expr.cursor;
  cursor += readWhitespace$3(text, cursor).length;
  const cl = text.substr(cursor, 1);
  cursor += cl.length;
  if (cl !== ")") {
    return null;
  }
  return {
    evaluable: expr.evaluable,
    cursor,
  };
}
function parsePrimaryExpression$3(text, cursor) {
  var _a;
  return (_a = parseLiteral$3(text, cursor)) !== null && _a !== void 0
    ? _a
    : parseParenthesizedExpression$3(text, cursor);
}
function parseUnaryExpression$3(text, cursor) {
  const expr = parsePrimaryExpression$3(text, cursor);
  if (expr) {
    return expr;
  }
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "+" && op !== "-" && op !== "~") {
    return null;
  }
  const num = parseUnaryExpression$3(text, cursor);
  if (!num) {
    return null;
  }
  cursor = num.cursor;
  return {
    cursor,
    evaluable: new UnaryOperationNode$3(op, num.evaluable),
  };
}
function readBinaryOperator$3(ops, text, cursor) {
  cursor += readWhitespace$3(text, cursor).length;
  const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
  if (!op) {
    return null;
  }
  cursor += op.length;
  cursor += readWhitespace$3(text, cursor).length;
  return {
    cursor,
    operator: op,
  };
}
function createBinaryOperationExpressionParser$3(exprParser, ops) {
  return (text, cursor) => {
    const firstExpr = exprParser(text, cursor);
    if (!firstExpr) {
      return null;
    }
    cursor = firstExpr.cursor;
    let expr = firstExpr.evaluable;
    for (;;) {
      const op = readBinaryOperator$3(ops, text, cursor);
      if (!op) {
        break;
      }
      cursor = op.cursor;
      const nextExpr = exprParser(text, cursor);
      if (!nextExpr) {
        return null;
      }
      cursor = nextExpr.cursor;
      expr = new BinaryOperationNode$3(op.operator, expr, nextExpr.evaluable);
    }
    return expr
      ? {
          cursor,
          evaluable: expr,
        }
      : null;
  };
}
const parseBinaryOperationExpression$3 = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"],
].reduce((parser, ops) => {
  return createBinaryOperationExpressionParser$3(parser, ops);
}, parseUnaryExpression$3);
function parseExpression$3(text, cursor) {
  cursor += readWhitespace$3(text, cursor).length;
  return parseBinaryOperationExpression$3(text, cursor);
}
function parseEcmaNumberExpression$3(text) {
  const expr = parseExpression$3(text, 0);
  if (!expr) {
    return null;
  }
  const cursor = expr.cursor + readWhitespace$3(text, expr.cursor).length;
  if (cursor !== text.length) {
    return null;
  }
  return expr.evaluable;
}
function parseNumber$3(text) {
  var _a;
  const r = parseEcmaNumberExpression$3(text);
  return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null &&
    _a !== void 0
    ? _a
    : null;
}
function numberFromUnknown$3(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const pv = parseNumber$3(value);
    if (!isEmpty$3(pv)) {
      return pv;
    }
  }
  return 0;
}
function createNumberFormatter$3(digits) {
  return (value) => {
    return value.toFixed(Math.max(Math.min(digits, 20), 0));
  };
}
function mapRange$3(value, start1, end1, start2, end2) {
  const p = (value - start1) / (end1 - start1);
  return start2 + p * (end2 - start2);
}
function getDecimalDigits$3(value) {
  const text = String(value.toFixed(10));
  const frac = text.split(".")[1];
  return frac.replace(/0+$/, "").length;
}
function constrainRange$3(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function loopRange$3(value, max) {
  return ((value % max) + max) % max;
}
function getSuitableDecimalDigits$3(params, rawValue) {
  return !isEmpty$3(params.step)
    ? getDecimalDigits$3(params.step)
    : Math.max(getDecimalDigits$3(rawValue), 2);
}
function getSuitableKeyScale$3(params) {
  var _a;
  return (_a = params.step) !== null && _a !== void 0 ? _a : 1;
}
function getSuitablePointerScale$3(params, rawValue) {
  var _a;
  const base2 = Math.abs(
    (_a = params.step) !== null && _a !== void 0 ? _a : rawValue,
  );
  return base2 === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base2)) - 1);
}
function createStepConstraint$3(params, initialValue) {
  if (!isEmpty$3(params.step)) {
    return new StepConstraint$3(params.step, initialValue);
  }
  return null;
}
function createRangeConstraint$3(params) {
  if (!isEmpty$3(params.max) && !isEmpty$3(params.min)) {
    return new DefiniteRangeConstraint$3({
      max: params.max,
      min: params.min,
    });
  }
  if (!isEmpty$3(params.max) || !isEmpty$3(params.min)) {
    return new RangeConstraint$3({
      max: params.max,
      min: params.min,
    });
  }
  return null;
}
function createNumberTextPropsObject$3(params, initialValue) {
  var _a, _b, _c;
  return {
    formatter:
      (_a = params.format) !== null && _a !== void 0
        ? _a
        : createNumberFormatter$3(
            getSuitableDecimalDigits$3(params, initialValue),
          ),
    keyScale:
      (_b = params.keyScale) !== null && _b !== void 0
        ? _b
        : getSuitableKeyScale$3(params),
    pointerScale:
      (_c = params.pointerScale) !== null && _c !== void 0
        ? _c
        : getSuitablePointerScale$3(params, initialValue),
  };
}
function createNumberTextInputParamsParser$3(p) {
  return {
    format: p.optional.function,
    keyScale: p.optional.number,
    max: p.optional.number,
    min: p.optional.number,
    pointerScale: p.optional.number,
    step: p.optional.number,
  };
}
function createPointAxis$3(config) {
  return {
    constraint: config.constraint,
    textProps: ValueMap$3.fromObject(
      createNumberTextPropsObject$3(config.params, config.initialValue),
    ),
  };
}
let BladeApi$3 = class BladeApi4 {
  constructor(controller) {
    this.controller = controller;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller.viewProps.set("disabled", disabled);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(hidden) {
    this.controller.viewProps.set("hidden", hidden);
  }
  dispose() {
    this.controller.viewProps.set("disposed", true);
  }
  importState(state) {
    return this.controller.importState(state);
  }
  exportState() {
    return this.controller.exportState();
  }
};
let TpEvent$3 = class TpEvent4 {
  constructor(target) {
    this.target = target;
  }
};
let TpChangeEvent$3 = class TpChangeEvent4 extends TpEvent$3 {
  constructor(target, value, last) {
    super(target);
    this.value = value;
    this.last = last !== null && last !== void 0 ? last : true;
  }
};
let TpFoldEvent$3 = class TpFoldEvent4 extends TpEvent$3 {
  constructor(target, expanded) {
    super(target);
    this.expanded = expanded;
  }
};
let TpTabSelectEvent$3 = class TpTabSelectEvent4 extends TpEvent$3 {
  constructor(target, index) {
    super(target);
    this.index = index;
  }
};
let BindingApi$3 = class BindingApi4 extends BladeApi$3 {
  constructor(controller) {
    super(controller);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.emitter_ = new Emitter$3();
    this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(tag) {
    this.controller.tag = tag;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(ev) {
    const value = this.controller.value;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$3(
        this,
        forceCast$3(value.binding.target.read()),
        ev.options.last,
      ),
    );
  }
};
function parseObject$3(value, keyToParserMap) {
  const keys = Object.keys(keyToParserMap);
  const result = keys.reduce((tmp2, key2) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const parser = keyToParserMap[key2];
    const result2 = parser(value[key2]);
    return result2.succeeded
      ? Object.assign(Object.assign({}, tmp2), { [key2]: result2.value })
      : void 0;
  }, {});
  return forceCast$3(result);
}
function parseArray$3(value, parseItem) {
  return value.reduce((tmp2, item) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const result = parseItem(item);
    if (!result.succeeded || result.value === void 0) {
      return void 0;
    }
    return [...tmp2, result.value];
  }, []);
}
function isObject$4(value) {
  if (value === null) {
    return false;
  }
  return typeof value === "object";
}
function createMicroParserBuilder$3(parse) {
  return (optional) => (v) => {
    if (!optional && v === void 0) {
      return {
        succeeded: false,
        value: void 0,
      };
    }
    if (optional && v === void 0) {
      return {
        succeeded: true,
        value: void 0,
      };
    }
    const result = parse(v);
    return result !== void 0
      ? {
          succeeded: true,
          value: result,
        }
      : {
          succeeded: false,
          value: void 0,
        };
  };
}
function createMicroParserBuilders$3(optional) {
  return {
    custom: (parse) => createMicroParserBuilder$3(parse)(optional),
    boolean: createMicroParserBuilder$3((v) =>
      typeof v === "boolean" ? v : void 0,
    )(optional),
    number: createMicroParserBuilder$3((v) =>
      typeof v === "number" ? v : void 0,
    )(optional),
    string: createMicroParserBuilder$3((v) =>
      typeof v === "string" ? v : void 0,
    )(optional),
    function: createMicroParserBuilder$3((v) =>
      typeof v === "function" ? v : void 0,
    )(optional),
    constant: (value) =>
      createMicroParserBuilder$3((v) => (v === value ? value : void 0))(
        optional,
      ),
    raw: createMicroParserBuilder$3((v) => v)(optional),
    object: (keyToParserMap) =>
      createMicroParserBuilder$3((v) => {
        if (!isObject$4(v)) {
          return void 0;
        }
        return parseObject$3(v, keyToParserMap);
      })(optional),
    array: (itemParser) =>
      createMicroParserBuilder$3((v) => {
        if (!Array.isArray(v)) {
          return void 0;
        }
        return parseArray$3(v, itemParser);
      })(optional),
  };
}
const MicroParsers$3 = {
  optional: createMicroParserBuilders$3(true),
  required: createMicroParserBuilders$3(false),
};
function parseRecord$3(value, keyToParserMap) {
  const map = keyToParserMap(MicroParsers$3);
  const result = MicroParsers$3.required.object(map)(value);
  return result.succeeded ? result.value : void 0;
}
function importBladeState$3(state, superImport, parser, callback) {
  if (superImport && !superImport(state)) {
    return false;
  }
  const result = parseRecord$3(state, parser);
  return result ? callback(result) : false;
}
function exportBladeState$3(superExport, thisState) {
  var _a;
  return deepMerge$3(
    (_a =
      superExport === null || superExport === void 0
        ? void 0
        : superExport()) !== null && _a !== void 0
      ? _a
      : {},
    thisState,
  );
}
function isValueBladeController$3(bc) {
  return "value" in bc;
}
function isBindingValue$3(v) {
  if (!isObject$1$3(v) || !("binding" in v)) {
    return false;
  }
  const b = v.binding;
  return isBinding$3(b);
}
const SVG_NS$3 = "http://www.w3.org/2000/svg";
function forceReflow$3(element) {
  element.offsetHeight;
}
function disableTransitionTemporarily$3(element, callback) {
  const t = element.style.transition;
  element.style.transition = "none";
  callback();
  element.style.transition = t;
}
function supportsTouch$3(doc) {
  return doc.ontouchstart !== void 0;
}
function getCanvasContext$3(canvasElement) {
  const win = canvasElement.ownerDocument.defaultView;
  if (!win) {
    return null;
  }
  const isBrowser = "document" in win;
  return isBrowser
    ? canvasElement.getContext("2d", {
        willReadFrequently: true,
      })
    : null;
}
const ICON_ID_TO_INNER_HTML_MAP$3 = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad:
    '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function createSvgIconElement$3(document2, iconId) {
  const elem = document2.createElementNS(SVG_NS$3, "svg");
  elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP$3[iconId];
  return elem;
}
function insertElementAt$3(parentElement, element, index) {
  parentElement.insertBefore(element, parentElement.children[index]);
}
function removeElement$3(element) {
  if (element.parentElement) {
    element.parentElement.removeChild(element);
  }
}
function removeChildElements$3(element) {
  while (element.children.length > 0) {
    element.removeChild(element.children[0]);
  }
}
function removeChildNodes$3(element) {
  while (element.childNodes.length > 0) {
    element.removeChild(element.childNodes[0]);
  }
}
function findNextTarget$3(ev) {
  if (ev.relatedTarget) {
    return forceCast$3(ev.relatedTarget);
  }
  if ("explicitOriginalTarget" in ev) {
    return ev.explicitOriginalTarget;
  }
  return null;
}
function bindValue$3(value, applyValue) {
  value.emitter.on("change", (ev) => {
    applyValue(ev.rawValue);
  });
  applyValue(value.rawValue);
}
function bindValueMap$3(valueMap, key2, applyValue) {
  bindValue$3(valueMap.value(key2), applyValue);
}
const PREFIX$3 = "tp";
function ClassName$3(viewName) {
  const fn = (opt_elementName, opt_modifier) => {
    return [
      PREFIX$3,
      "-",
      viewName,
      "v",
      opt_elementName ? `_${opt_elementName}` : "",
      opt_modifier ? `-${opt_modifier}` : "",
    ].join("");
  };
  return fn;
}
const cn$q$3 = ClassName$3("lbl");
function createLabelNode$3(doc, label) {
  const frag = doc.createDocumentFragment();
  const lineNodes = label.split("\n").map((line) => {
    return doc.createTextNode(line);
  });
  lineNodes.forEach((lineNode, index) => {
    if (index > 0) {
      frag.appendChild(doc.createElement("br"));
    }
    frag.appendChild(lineNode);
  });
  return frag;
}
let LabelView$3 = class LabelView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$q$3());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("div");
    labelElem.classList.add(cn$q$3("l"));
    bindValueMap$3(config.props, "label", (value) => {
      if (isEmpty$3(value)) {
        this.element.classList.add(cn$q$3(void 0, "nol"));
      } else {
        this.element.classList.remove(cn$q$3(void 0, "nol"));
        removeChildNodes$3(labelElem);
        labelElem.appendChild(createLabelNode$3(doc, value));
      }
    });
    this.element.appendChild(labelElem);
    this.labelElement = labelElem;
    const valueElem = doc.createElement("div");
    valueElem.classList.add(cn$q$3("v"));
    this.element.appendChild(valueElem);
    this.valueElement = valueElem;
  }
};
let LabelController$3 = class LabelController4 {
  constructor(doc, config) {
    this.props = config.props;
    this.valueController = config.valueController;
    this.viewProps = config.valueController.viewProps;
    this.view = new LabelView$3(doc, {
      props: config.props,
      viewProps: this.viewProps,
    });
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(state) {
    return importBladeState$3(
      state,
      null,
      (p) => ({
        label: p.optional.string,
      }),
      (result) => {
        this.props.set("label", result.label);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$3(null, {
      label: this.props.get("label"),
    });
  }
};
function getAllBladePositions$3() {
  return ["veryfirst", "first", "last", "verylast"];
}
const cn$p$3 = ClassName$3("");
const POS_TO_CLASS_NAME_MAP$3 = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst",
};
let BladeController$3 = class BladeController4 {
  constructor(config) {
    this.parent_ = null;
    this.blade = config.blade;
    this.view = config.view;
    this.viewProps = config.viewProps;
    const elem = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      getAllBladePositions$3().forEach((pos) => {
        elem.classList.remove(cn$p$3(void 0, POS_TO_CLASS_NAME_MAP$3[pos]));
      });
      this.blade.get("positions").forEach((pos) => {
        elem.classList.add(cn$p$3(void 0, POS_TO_CLASS_NAME_MAP$3[pos]));
      });
    });
    this.viewProps.handleDispose(() => {
      removeElement$3(elem);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(parent) {
    this.parent_ = parent;
    this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(state) {
    return importBladeState$3(
      state,
      null,
      (p) => ({
        disabled: p.required.boolean,
        hidden: p.required.boolean,
      }),
      (result) => {
        this.viewProps.importState(result);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$3(
      null,
      Object.assign({}, this.viewProps.exportState()),
    );
  }
};
let ButtonApi$3 = class ButtonApi4 extends BladeApi$3 {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get title() {
    var _a;
    return (_a = this.controller.buttonController.props.get("title")) !==
      null && _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.buttonController.props.set("title", title);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller.buttonController.emitter;
    emitter.on(eventName, () => {
      bh(new TpEvent$3(this));
    });
    return this;
  }
};
function applyClass$3(elem, className2, active) {
  if (active) {
    elem.classList.add(className2);
  } else {
    elem.classList.remove(className2);
  }
}
function valueToClassName$3(elem, className2) {
  return (value) => {
    applyClass$3(elem, className2, value);
  };
}
function bindValueToTextContent$3(value, elem) {
  bindValue$3(value, (text) => {
    elem.textContent = text !== null && text !== void 0 ? text : "";
  });
}
const cn$o$3 = ClassName$3("btn");
let ButtonView$3 = class ButtonView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$o$3());
    config.viewProps.bindClassModifiers(this.element);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$o$3("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$o$3("t"));
    bindValueToTextContent$3(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
  }
};
let ButtonController$3 = class ButtonController4 {
  constructor(doc, config) {
    this.emitter = new Emitter$3();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new ButtonView$3(doc, {
      props: this.props,
      viewProps: this.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(state) {
    return importBladeState$3(
      state,
      null,
      (p) => ({
        title: p.optional.string,
      }),
      (result) => {
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$3(null, {
      title: this.props.get("title"),
    });
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let ButtonBladeController$3 = class ButtonBladeController4 extends BladeController$3 {
  constructor(doc, config) {
    const bc = new ButtonController$3(doc, {
      props: config.buttonProps,
      viewProps: config.viewProps,
    });
    const lc = new LabelController$3(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: config.viewProps,
    });
    this.buttonController = bc;
    this.labelController = lc;
  }
  importState(state) {
    return importBladeState$3(
      state,
      (s) =>
        super.importState(s) &&
        this.buttonController.importProps(s) &&
        this.labelController.importProps(s),
      () => ({}),
      () => true,
    );
  }
  exportState() {
    return exportBladeState$3(
      () => super.exportState(),
      Object.assign(
        Object.assign({}, this.buttonController.exportProps()),
        this.labelController.exportProps(),
      ),
    );
  }
};
let Semver$3 = class Semver4 {
  constructor(text) {
    const [core, prerelease] = text.split("-");
    const coreComps = core.split(".");
    this.major = parseInt(coreComps[0], 10);
    this.minor = parseInt(coreComps[1], 10);
    this.patch = parseInt(coreComps[2], 10);
    this.prerelease =
      prerelease !== null && prerelease !== void 0 ? prerelease : null;
  }
  toString() {
    const core = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
  }
};
const VERSION$3 = new Semver$3("2.0.1");
function createPlugin$3(plugin) {
  return Object.assign({ core: VERSION$3 }, plugin);
}
createPlugin$3({
  id: "button",
  type: "blade",
  accept(params) {
    const result = parseRecord$3(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("button"),
      label: p.optional.string,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new ButtonBladeController$3(args.document, {
      blade: args.blade,
      buttonProps: ValueMap$3.fromObject({
        title: args.params.title,
      }),
      labelProps: ValueMap$3.fromObject({
        label: args.params.label,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (args.controller instanceof ButtonBladeController$3) {
      return new ButtonApi$3(args.controller);
    }
    return null;
  },
});
function addButtonAsBlade$3(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "button" }),
  );
}
function addFolderAsBlade$3(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "folder" }),
  );
}
function addTabAsBlade$3(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "tab" }),
  );
}
function isRefreshable$3(value) {
  if (!isObject$1$3(value)) {
    return false;
  }
  return "refresh" in value && typeof value.refresh === "function";
}
function createBindingTarget$3(obj, key2) {
  if (!BindingTarget$3.isBindable(obj)) {
    throw TpError$3.notBindable();
  }
  return new BindingTarget$3(obj, key2);
}
let RackApi$3 = class RackApi4 {
  constructor(controller, pool) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.controller_ = controller;
    this.emitter_ = new Emitter$3();
    this.pool_ = pool;
    const rack = this.controller_.rack;
    rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((bc) => this.pool_.createApi(bc));
  }
  addBinding(object, key2, opt_params) {
    const params =
      opt_params !== null && opt_params !== void 0 ? opt_params : {};
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBinding(
      doc,
      createBindingTarget$3(object, key2),
      params,
    );
    const api = this.pool_.createBindingApi(bc);
    return this.add(api, params.index);
  }
  addFolder(params) {
    return addFolderAsBlade$3(this, params);
  }
  addButton(params) {
    return addButtonAsBlade$3(this, params);
  }
  addTab(params) {
    return addTabAsBlade$3(this, params);
  }
  add(api, opt_index) {
    const bc = api.controller;
    this.controller_.rack.add(bc, opt_index);
    return api;
  }
  remove(api) {
    this.controller_.rack.remove(api.controller);
  }
  addBlade(params) {
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBlade(doc, params);
    const api = this.pool_.createApi(bc);
    return this.add(api, params.index);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.children.forEach((c) => {
      if (isRefreshable$3(c)) {
        c.refresh();
      }
    });
  }
  onRackValueChange_(ev) {
    const bc = ev.bladeController;
    const api = this.pool_.createApi(bc);
    const binding = isBindingValue$3(bc.value) ? bc.value.binding : null;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$3(
        api,
        binding ? binding.target.read() : bc.value.rawValue,
        ev.options.last,
      ),
    );
  }
};
let ContainerBladeApi$3 = class ContainerBladeApi4 extends BladeApi$3 {
  constructor(controller, pool) {
    super(controller);
    this.rackApi_ = new RackApi$3(controller.rackController, pool);
  }
  refresh() {
    this.rackApi_.refresh();
  }
};
let ContainerBladeController$3 = class ContainerBladeController4 extends BladeController$3 {
  constructor(config) {
    super({
      blade: config.blade,
      view: config.view,
      viewProps: config.rackController.viewProps,
    });
    this.rackController = config.rackController;
  }
  importState(state) {
    return importBladeState$3(
      state,
      (s) => super.importState(s),
      (p) => ({
        children: p.required.array(p.required.raw),
      }),
      (result) => {
        return this.rackController.rack.children.every((c, index) => {
          return c.importState(result.children[index]);
        });
      },
    );
  }
  exportState() {
    return exportBladeState$3(() => super.exportState(), {
      children: this.rackController.rack.children.map((c) => c.exportState()),
    });
  }
};
function isContainerBladeController$3(bc) {
  return "rackController" in bc;
}
let NestedOrderedSet$3 = class NestedOrderedSet4 {
  constructor(extract) {
    this.emitter = new Emitter$3();
    this.items_ = [];
    this.cache_ = /* @__PURE__ */ new Set();
    this.onSubListAdd_ = this.onSubListAdd_.bind(this);
    this.onSubListRemove_ = this.onSubListRemove_.bind(this);
    this.extract_ = extract;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(callback) {
    for (const item of this.allItems()) {
      if (callback(item)) {
        return item;
      }
    }
    return null;
  }
  includes(item) {
    return this.cache_.has(item);
  }
  add(item, opt_index) {
    if (this.includes(item)) {
      throw TpError$3.shouldNeverHappen();
    }
    const index = opt_index !== void 0 ? opt_index : this.items_.length;
    this.items_.splice(index, 0, item);
    this.cache_.add(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.emitter.on("add", this.onSubListAdd_);
      subList.emitter.on("remove", this.onSubListRemove_);
      subList.allItems().forEach((i) => {
        this.cache_.add(i);
      });
    }
    this.emitter.emit("add", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    this.cache_.delete(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.allItems().forEach((i) => {
        this.cache_.delete(i);
      });
      subList.emitter.off("add", this.onSubListAdd_);
      subList.emitter.off("remove", this.onSubListRemove_);
    }
    this.emitter.emit("remove", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  onSubListAdd_(ev) {
    this.cache_.add(ev.item);
    this.emitter.emit("add", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
  onSubListRemove_(ev) {
    this.cache_.delete(ev.item);
    this.emitter.emit("remove", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
};
function findValueBladeController$3(bcs, v) {
  for (let i = 0; i < bcs.length; i++) {
    const bc = bcs[i];
    if (isValueBladeController$3(bc) && bc.value === v) {
      return bc;
    }
  }
  return null;
}
function findSubBladeControllerSet$3(bc) {
  return isContainerBladeController$3(bc)
    ? bc.rackController.rack["bcSet_"]
    : null;
}
let Rack$3 = class Rack4 {
  constructor(config) {
    var _a, _b;
    this.emitter = new Emitter$3();
    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
    this.onSetAdd_ = this.onSetAdd_.bind(this);
    this.onSetRemove_ = this.onSetRemove_.bind(this);
    this.onChildDispose_ = this.onChildDispose_.bind(this);
    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
    this.onChildValueChange_ = this.onChildValueChange_.bind(this);
    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
    this.onRackLayout_ = this.onRackLayout_.bind(this);
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
    (_b = this.blade_) === null || _b === void 0
      ? void 0
      : _b
          .value("positions")
          .emitter.on("change", this.onBladePositionsChange_);
    this.viewProps = config.viewProps;
    this.bcSet_ = new NestedOrderedSet$3(findSubBladeControllerSet$3);
    this.bcSet_.emitter.on("add", this.onSetAdd_);
    this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(bc, opt_index) {
    var _a;
    (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
    bc.parent = this;
    this.bcSet_.add(bc, opt_index);
  }
  remove(bc) {
    bc.parent = null;
    this.bcSet_.remove(bc);
  }
  find(finder) {
    return this.bcSet_.allItems().filter(finder);
  }
  onSetAdd_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("add", {
      bladeController: ev.item,
      index: ev.index,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
    bc.blade
      .value("positions")
      .emitter.on("change", this.onChildPositionsChange_);
    bc.viewProps.handleDispose(this.onChildDispose_);
    if (isValueBladeController$3(bc)) {
      bc.value.emitter.on("change", this.onChildValueChange_);
    } else if (isContainerBladeController$3(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.on("layout", this.onRackLayout_);
        emitter.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("remove", {
      bladeController: ev.item,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    if (isValueBladeController$3(bc)) {
      bc.value.emitter.off("change", this.onChildValueChange_);
    } else if (isContainerBladeController$3(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.off("layout", this.onRackLayout_);
        emitter.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const visibleItems = this.bcSet_.items.filter(
      (bc) => !bc.viewProps.get("hidden"),
    );
    const firstVisibleItem = visibleItems[0];
    const lastVisibleItem = visibleItems[visibleItems.length - 1];
    this.bcSet_.items.forEach((bc) => {
      const ps = [];
      if (bc === firstVisibleItem) {
        ps.push("first");
        if (
          !this.blade_ ||
          this.blade_.get("positions").includes("veryfirst")
        ) {
          ps.push("veryfirst");
        }
      }
      if (bc === lastVisibleItem) {
        ps.push("last");
        if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
          ps.push("verylast");
        }
      }
      bc.blade.set("positions", ps);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildViewPropsChange_(_ev) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildDispose_() {
    const disposedUcs = this.bcSet_.items.filter((bc) => {
      return bc.viewProps.get("disposed");
    });
    disposedUcs.forEach((bc) => {
      this.bcSet_.remove(bc);
    });
  }
  onChildValueChange_(ev) {
    const bc = findValueBladeController$3(
      this.find(isValueBladeController$3),
      ev.sender,
    );
    if (!bc) {
      throw TpError$3.alreadyDisposed();
    }
    this.emitter.emit("valuechange", {
      bladeController: bc,
      options: ev.options,
      sender: this,
    });
  }
  onRackLayout_(_) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onRackValueChange_(ev) {
    this.emitter.emit("valuechange", {
      bladeController: ev.bladeController,
      options: ev.options,
      sender: this,
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
};
let RackController$3 = class RackController4 {
  constructor(config) {
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    this.element = config.element;
    this.viewProps = config.viewProps;
    const rack = new Rack$3({
      blade: config.root ? void 0 : config.blade,
      viewProps: config.viewProps,
    });
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.rack = rack;
    this.viewProps.handleDispose(() => {
      for (let i = this.rack.children.length - 1; i >= 0; i--) {
        const bc = this.rack.children[i];
        bc.viewProps.set("disposed", true);
      }
    });
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    insertElementAt$3(this.element, ev.bladeController.view.element, ev.index);
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    removeElement$3(ev.bladeController.view.element);
  }
};
function createBlade$3() {
  return new ValueMap$3({
    positions: createValue$3([], {
      equals: deepEqualsArray$3,
    }),
  });
}
let Foldable$3 = class Foldable4 extends ValueMap$3 {
  constructor(valueMap) {
    super(valueMap);
  }
  static create(expanded) {
    const coreObj = {
      completed: true,
      expanded,
      expandedHeight: null,
      shouldFixHeight: false,
      temporaryExpanded: null,
    };
    const core = ValueMap$3.createCore(coreObj);
    return new Foldable4(core);
  }
  get styleExpanded() {
    var _a;
    return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0
      ? _a
      : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded) {
      return "0";
    }
    const exHeight = this.get("expandedHeight");
    if (this.get("shouldFixHeight") && !isEmpty$3(exHeight)) {
      return `${exHeight}px`;
    }
    return "auto";
  }
  bindExpandedClass(elem, expandedClassName) {
    const onExpand = () => {
      const expanded = this.styleExpanded;
      if (expanded) {
        elem.classList.add(expandedClassName);
      } else {
        elem.classList.remove(expandedClassName);
      }
    };
    bindValueMap$3(this, "expanded", onExpand);
    bindValueMap$3(this, "temporaryExpanded", onExpand);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", false);
    this.set("expandedHeight", null);
    this.set("completed", true);
  }
};
function computeExpandedFolderHeight$3(folder, containerElement) {
  let height = 0;
  disableTransitionTemporarily$3(containerElement, () => {
    folder.set("expandedHeight", null);
    folder.set("temporaryExpanded", true);
    forceReflow$3(containerElement);
    height = containerElement.clientHeight;
    folder.set("temporaryExpanded", null);
    forceReflow$3(containerElement);
  });
  return height;
}
function applyHeight$3(foldable, elem) {
  elem.style.height = foldable.styleHeight;
}
function bindFoldable$3(foldable, elem) {
  foldable.value("expanded").emitter.on("beforechange", () => {
    foldable.set("completed", false);
    if (isEmpty$3(foldable.get("expandedHeight"))) {
      const h = computeExpandedFolderHeight$3(foldable, elem);
      if (h > 0) {
        foldable.set("expandedHeight", h);
      }
    }
    foldable.set("shouldFixHeight", true);
    forceReflow$3(elem);
  });
  foldable.emitter.on("change", () => {
    applyHeight$3(foldable, elem);
  });
  applyHeight$3(foldable, elem);
  elem.addEventListener("transitionend", (ev) => {
    if (ev.propertyName !== "height") {
      return;
    }
    foldable.cleanUpTransition();
  });
}
let FolderApi$3 = class FolderApi4 extends ContainerBladeApi$3 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$3();
    this.controller.foldable.value("expanded").emitter.on("change", (ev) => {
      this.emitter_.emit("fold", new TpFoldEvent$3(this, ev.sender.rawValue));
    });
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(expanded) {
    this.controller.foldable.set("expanded", expanded);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(title) {
    this.controller.props.set("title", title);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    return this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
};
const bladeContainerClassName$3 = ClassName$3("cnt");
let FolderView$3 = class FolderView4 {
  constructor(doc, config) {
    var _a;
    this.className_ = ClassName$3(
      (_a = config.viewName) !== null && _a !== void 0 ? _a : "fld",
    );
    this.element = doc.createElement("div");
    this.element.classList.add(this.className_(), bladeContainerClassName$3());
    config.viewProps.bindClassModifiers(this.element);
    this.foldable_ = config.foldable;
    this.foldable_.bindExpandedClass(
      this.element,
      this.className_(void 0, "expanded"),
    );
    bindValueMap$3(
      this.foldable_,
      "completed",
      valueToClassName$3(this.element, this.className_(void 0, "cpl")),
    );
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(this.className_("b"));
    bindValueMap$3(config.props, "title", (title) => {
      if (isEmpty$3(title)) {
        this.element.classList.add(this.className_(void 0, "not"));
      } else {
        this.element.classList.remove(this.className_(void 0, "not"));
      }
    });
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(this.className_("i"));
    this.element.appendChild(indentElem);
    const titleElem = doc.createElement("div");
    titleElem.classList.add(this.className_("t"));
    bindValueToTextContent$3(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(this.className_("m"));
    this.buttonElement.appendChild(markElem);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(this.className_("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
let FolderController$3 = class FolderController4 extends ContainerBladeController$3 {
  constructor(doc, config) {
    var _a;
    const foldable = Foldable$3.create(
      (_a = config.expanded) !== null && _a !== void 0 ? _a : true,
    );
    const view = new FolderView$3(doc, {
      foldable,
      props: config.props,
      viewName: config.root ? "rot" : void 0,
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$3({
          blade: config.blade,
          element: view.containerElement,
          root: config.root,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onTitleClick_ = this.onTitleClick_.bind(this);
    this.props = config.props;
    this.foldable = foldable;
    bindFoldable$3(this.foldable, this.view.containerElement);
    this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    });
    this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    });
    this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(state) {
    return importBladeState$3(
      state,
      (s) => super.importState(s),
      (p) => ({
        expanded: p.required.boolean,
        title: p.optional.string,
      }),
      (result) => {
        this.foldable.set("expanded", result.expanded);
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$3(() => super.exportState(), {
      expanded: this.foldable.get("expanded"),
      title: this.props.get("title"),
    });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
};
createPlugin$3({
  id: "folder",
  type: "blade",
  accept(params) {
    const result = parseRecord$3(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("folder"),
      expanded: p.optional.boolean,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new FolderController$3(args.document, {
      blade: args.blade,
      expanded: args.params.expanded,
      props: ValueMap$3.fromObject({
        title: args.params.title,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (!(args.controller instanceof FolderController$3)) {
      return null;
    }
    return new FolderApi$3(args.controller, args.pool);
  },
});
const cn$n$3 = ClassName$3("");
function valueToModifier$3(elem, modifier) {
  return valueToClassName$3(elem, cn$n$3(void 0, modifier));
}
let ViewProps$3 = class ViewProps4 extends ValueMap$3 {
  constructor(valueMap) {
    var _a;
    super(valueMap);
    this.onDisabledChange_ = this.onDisabledChange_.bind(this);
    this.onParentChange_ = this.onParentChange_.bind(this);
    this.onParentGlobalDisabledChange_ =
      this.onParentGlobalDisabledChange_.bind(this);
    [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue$3(
      createValue$3(this.getGlobalDisabled_()),
    );
    this.value("disabled").emitter.on("change", this.onDisabledChange_);
    this.value("parent").emitter.on("change", this.onParentChange_);
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
  }
  static create(opt_initialValue) {
    var _a, _b, _c;
    const initialValue =
      opt_initialValue !== null && opt_initialValue !== void 0
        ? opt_initialValue
        : {};
    return new ViewProps4(
      ValueMap$3.createCore({
        disabled:
          (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
        disposed: false,
        hidden:
          (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
        parent:
          (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null,
      }),
    );
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(elem) {
    bindValue$3(this.globalDisabled_, valueToModifier$3(elem, "disabled"));
    bindValueMap$3(this, "hidden", valueToModifier$3(elem, "hidden"));
  }
  bindDisabled(target) {
    bindValue$3(this.globalDisabled_, (disabled) => {
      target.disabled = disabled;
    });
  }
  bindTabIndex(elem) {
    bindValue$3(this.globalDisabled_, (disabled) => {
      elem.tabIndex = disabled ? -1 : 0;
    });
  }
  handleDispose(callback) {
    this.value("disposed").emitter.on("change", (disposed) => {
      if (disposed) {
        callback();
      }
    });
  }
  importState(state) {
    this.set("disabled", state.disabled);
    this.set("hidden", state.hidden);
  }
  exportState() {
    return {
      disabled: this.get("disabled"),
      hidden: this.get("hidden"),
    };
  }
  getGlobalDisabled_() {
    const parent = this.get("parent");
    const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
    return parentDisabled || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(ev) {
    var _a;
    const prevParent = ev.previousRawValue;
    prevParent === null || prevParent === void 0
      ? void 0
      : prevParent.globalDisabled.emitter.off(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    this.updateGlobalDisabled_();
  }
};
const cn$m$3 = ClassName$3("tbp");
let TabPageView$3 = class TabPageView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$m$3());
    config.viewProps.bindClassModifiers(this.element);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(cn$m$3("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
const cn$l$3 = ClassName$3("tbi");
let TabItemView$3 = class TabItemView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$l$3());
    config.viewProps.bindClassModifiers(this.element);
    bindValueMap$3(config.props, "selected", (selected) => {
      if (selected) {
        this.element.classList.add(cn$l$3(void 0, "sel"));
      } else {
        this.element.classList.remove(cn$l$3(void 0, "sel"));
      }
    });
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$l$3("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$l$3("t"));
    bindValueToTextContent$3(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
  }
};
let TabItemController$3 = class TabItemController4 {
  constructor(doc, config) {
    this.emitter = new Emitter$3();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new TabItemView$3(doc, {
      props: config.props,
      viewProps: config.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let TabPageController$3 = class TabPageController4 extends ContainerBladeController$3 {
  constructor(doc, config) {
    const view = new TabPageView$3(doc, {
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$3({
          blade: config.blade,
          element: view.containerElement,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onItemClick_ = this.onItemClick_.bind(this);
    this.ic_ = new TabItemController$3(doc, {
      props: config.itemProps,
      viewProps: ViewProps$3.create(),
    });
    this.ic_.emitter.on("click", this.onItemClick_);
    this.props = config.props;
    bindValueMap$3(this.props, "selected", (selected) => {
      this.itemController.props.set("selected", selected);
      this.viewProps.set("hidden", !selected);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(state) {
    return importBladeState$3(
      state,
      (s) => super.importState(s),
      (p) => ({
        selected: p.required.boolean,
        title: p.required.string,
      }),
      (result) => {
        this.ic_.props.set("selected", result.selected);
        this.ic_.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$3(() => super.exportState(), {
      selected: this.ic_.props.get("selected"),
      title: this.ic_.props.get("title"),
    });
  }
  onItemClick_() {
    this.props.set("selected", true);
  }
};
let TabApi$3 = class TabApi4 extends ContainerBladeApi$3 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$3();
    this.onSelect_ = this.onSelect_.bind(this);
    this.pool_ = pool;
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
    this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(params) {
    const doc = this.controller.view.element.ownerDocument;
    const pc = new TabPageController$3(doc, {
      blade: createBlade$3(),
      itemProps: ValueMap$3.fromObject({
        selected: false,
        title: params.title,
      }),
      props: ValueMap$3.fromObject({
        selected: false,
      }),
      viewProps: ViewProps$3.create(),
    });
    const papi = this.pool_.createApi(pc);
    return this.rackApi_.add(papi, params.index);
  }
  removePage(index) {
    this.rackApi_.remove(this.rackApi_.children[index]);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  onSelect_(ev) {
    this.emitter_.emit("select", new TpTabSelectEvent$3(this, ev.rawValue));
  }
};
let TabPageApi$3 = class TabPageApi4 extends ContainerBladeApi$3 {
  get title() {
    var _a;
    return (_a = this.controller.itemController.props.get("title")) !== null &&
      _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.itemController.props.set("title", title);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(selected) {
    this.controller.props.set("selected", selected);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
};
const INDEX_NOT_SELECTED$3 = -1;
let Tab$3 = class Tab4 {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
    this.empty = createValue$3(true);
    this.selectedIndex = createValue$3(INDEX_NOT_SELECTED$3);
    this.items_ = [];
  }
  add(item, opt_index) {
    const index =
      opt_index !== null && opt_index !== void 0
        ? opt_index
        : this.items_.length;
    this.items_.splice(index, 0, item);
    item.emitter.on("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    item.emitter.off("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = INDEX_NOT_SELECTED$3;
      this.empty.rawValue = true;
      return;
    }
    const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
    if (firstSelIndex < 0) {
      this.items_.forEach((s, i) => {
        s.rawValue = i === 0;
      });
      this.selectedIndex.rawValue = 0;
    } else {
      this.items_.forEach((s, i) => {
        s.rawValue = i === firstSelIndex;
      });
      this.selectedIndex.rawValue = firstSelIndex;
    }
    this.empty.rawValue = false;
  }
  onItemSelectedChange_(ev) {
    if (ev.rawValue) {
      const index = this.items_.findIndex((s) => s === ev.sender);
      this.items_.forEach((s, i) => {
        s.rawValue = i === index;
      });
      this.selectedIndex.rawValue = index;
    } else {
      this.keepSelection_();
    }
  }
};
const cn$k$3 = ClassName$3("tab");
let TabView$3 = class TabView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$k$3(), bladeContainerClassName$3());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$3(
      config.empty,
      valueToClassName$3(this.element, cn$k$3(void 0, "nop")),
    );
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$k$3("t"));
    this.element.appendChild(titleElem);
    this.itemsElement = titleElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(cn$k$3("i"));
    this.element.appendChild(indentElem);
    const contentsElem = doc.createElement("div");
    contentsElem.classList.add(cn$k$3("c"));
    this.element.appendChild(contentsElem);
    this.contentsElement = contentsElem;
  }
};
let TabController$3 = class TabController4 extends ContainerBladeController$3 {
  constructor(doc, config) {
    const tab = new Tab$3();
    const view = new TabView$3(doc, {
      empty: tab.empty,
      viewProps: config.viewProps,
    });
    super({
      blade: config.blade,
      rackController: new RackController$3({
        blade: config.blade,
        element: view.contentsElement,
        viewProps: config.viewProps,
      }),
      view,
    });
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    const rack = this.rackController.rack;
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.tab = tab;
  }
  add(pc, opt_index) {
    this.rackController.rack.add(pc, opt_index);
  }
  remove(index) {
    this.rackController.rack.remove(this.rackController.rack.children[index]);
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    insertElementAt$3(
      this.view.itemsElement,
      pc.itemController.view.element,
      ev.index,
    );
    pc.itemController.viewProps.set("parent", this.viewProps);
    this.tab.add(pc.props.value("selected"));
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    removeElement$3(pc.itemController.view.element);
    pc.itemController.viewProps.set("parent", null);
    this.tab.remove(pc.props.value("selected"));
  }
};
createPlugin$3({
  id: "tab",
  type: "blade",
  accept(params) {
    const result = parseRecord$3(params, (p) => ({
      pages: p.required.array(p.required.object({ title: p.required.string })),
      view: p.required.constant("tab"),
    }));
    if (!result || result.pages.length === 0) {
      return null;
    }
    return { params: result };
  },
  controller(args) {
    const c = new TabController$3(args.document, {
      blade: args.blade,
      viewProps: args.viewProps,
    });
    args.params.pages.forEach((p) => {
      const pc = new TabPageController$3(args.document, {
        blade: createBlade$3(),
        itemProps: ValueMap$3.fromObject({
          selected: false,
          title: p.title,
        }),
        props: ValueMap$3.fromObject({
          selected: false,
        }),
        viewProps: ViewProps$3.create(),
      });
      c.add(pc);
    });
    return c;
  },
  api(args) {
    if (args.controller instanceof TabController$3) {
      return new TabApi$3(args.controller, args.pool);
    }
    if (args.controller instanceof TabPageController$3) {
      return new TabPageApi$3(args.controller, args.pool);
    }
    return null;
  },
});
let ListInputBindingApi$3 = class ListInputBindingApi4 extends BindingApi$3 {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(options) {
    this.controller.valueController.props.set("options", options);
  }
};
let CompositeConstraint$3 = class CompositeConstraint4 {
  constructor(constraints) {
    this.constraints = constraints;
  }
  constrain(value) {
    return this.constraints.reduce((result, c) => {
      return c.constrain(result);
    }, value);
  }
};
function findConstraint$3(c, constraintClass) {
  if (c instanceof constraintClass) {
    return c;
  }
  if (c instanceof CompositeConstraint$3) {
    const result = c.constraints.reduce((tmpResult, sc) => {
      if (tmpResult) {
        return tmpResult;
      }
      return sc instanceof constraintClass ? sc : null;
    }, null);
    if (result) {
      return result;
    }
  }
  return null;
}
let ListConstraint$3 = class ListConstraint4 {
  constructor(options) {
    this.values = ValueMap$3.fromObject({
      options,
    });
  }
  constrain(value) {
    const opts = this.values.get("options");
    if (opts.length === 0) {
      return value;
    }
    const matched =
      opts.filter((item) => {
        return item.value === value;
      }).length > 0;
    return matched ? value : opts[0].value;
  }
};
function parseListOptions$3(value) {
  var _a;
  const p = MicroParsers$3;
  if (Array.isArray(value)) {
    return (_a = parseRecord$3({ items: value }, (p2) => ({
      items: p2.required.array(
        p2.required.object({
          text: p2.required.string,
          value: p2.required.raw,
        }),
      ),
    }))) === null || _a === void 0
      ? void 0
      : _a.items;
  }
  if (typeof value === "object") {
    return p.required.raw(value).value;
  }
  return void 0;
}
function normalizeListOptions$3(options) {
  if (Array.isArray(options)) {
    return options;
  }
  const items = [];
  Object.keys(options).forEach((text) => {
    items.push({ text, value: options[text] });
  });
  return items;
}
function createListConstraint$3(options) {
  return !isEmpty$3(options)
    ? new ListConstraint$3(normalizeListOptions$3(forceCast$3(options)))
    : null;
}
const cn$j$3 = ClassName$3("lst");
let ListView$3 = class ListView4 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$j$3());
    config.viewProps.bindClassModifiers(this.element);
    const selectElem = doc.createElement("select");
    selectElem.classList.add(cn$j$3("s"));
    config.viewProps.bindDisabled(selectElem);
    this.element.appendChild(selectElem);
    this.selectElement = selectElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(cn$j$3("m"));
    markElem.appendChild(createSvgIconElement$3(doc, "dropdown"));
    this.element.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value_ = config.value;
    bindValueMap$3(this.props_, "options", (opts) => {
      removeChildElements$3(this.selectElement);
      opts.forEach((item) => {
        const optionElem = doc.createElement("option");
        optionElem.textContent = item.text;
        this.selectElement.appendChild(optionElem);
      });
      this.update_();
    });
  }
  update_() {
    const values = this.props_.get("options").map((o) => o.value);
    this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
};
let ListController$3 = class ListController4 {
  constructor(doc, config) {
    this.onSelectChange_ = this.onSelectChange_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ListView$3(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const selectElem = forceCast$3(e.currentTarget);
    this.value.rawValue =
      this.props.get("options")[selectElem.selectedIndex].value;
  }
  importProps(state) {
    return importBladeState$3(
      state,
      null,
      (p) => ({
        options: p.required.custom(parseListOptions$3),
      }),
      (result) => {
        this.props.set("options", normalizeListOptions$3(result.options));
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$3(null, {
      options: this.props.get("options"),
    });
  }
};
const cn$i$3 = ClassName$3("pop");
let PopupView$3 = class PopupView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$i$3());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$3(
      config.shows,
      valueToClassName$3(this.element, cn$i$3(void 0, "v")),
    );
  }
};
let PopupController$3 = class PopupController4 {
  constructor(doc, config) {
    this.shows = createValue$3(false);
    this.viewProps = config.viewProps;
    this.view = new PopupView$3(doc, {
      shows: this.shows,
      viewProps: this.viewProps,
    });
  }
};
const cn$h$3 = ClassName$3("txt");
let TextView$3 = class TextView4 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$h$3());
    config.viewProps.bindClassModifiers(this.element);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$h$3("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onChange_);
    this.value_ = config.value;
    this.refresh();
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let TextController$3 = class TextController4 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new TextView$3(doc, {
      props: config.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$3(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$3(parsedValue)) {
      this.value.rawValue = parsedValue;
    }
    this.view.refresh();
  }
};
function boolToString$3(value) {
  return String(value);
}
function boolFromUnknown$3(value) {
  if (value === "false") {
    return false;
  }
  return !!value;
}
function BooleanFormatter$3(value) {
  return boolToString$3(value);
}
function composeParsers$3(parsers) {
  return (text) => {
    return parsers.reduce((result, parser) => {
      if (result !== null) {
        return result;
      }
      return parser(text);
    }, null);
  };
}
const innerFormatter$3 = createNumberFormatter$3(0);
function formatPercentage$3(value) {
  return innerFormatter$3(value) + "%";
}
function stringFromUnknown$3(value) {
  return String(value);
}
function formatString$3(value) {
  return value;
}
function connectValues$3({ primary, secondary, forward, backward }) {
  let changing = false;
  function preventFeedback(callback) {
    if (changing) {
      return;
    }
    changing = true;
    callback();
    changing = false;
  }
  primary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  secondary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      primary.setRawValue(
        backward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  preventFeedback(() => {
    secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), {
      forceEmit: false,
      last: true,
    });
  });
}
function getStepForKey$3(keyScale, keys) {
  const step = keyScale * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
  if (keys.upKey) {
    return +step;
  } else if (keys.downKey) {
    return -step;
  }
  return 0;
}
function getVerticalStepKeys$3(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowDown",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowUp",
  };
}
function getHorizontalStepKeys$3(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowLeft",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowRight",
  };
}
function isVerticalArrowKey$3(key2) {
  return key2 === "ArrowUp" || key2 === "ArrowDown";
}
function isArrowKey$3(key2) {
  return (
    isVerticalArrowKey$3(key2) || key2 === "ArrowLeft" || key2 === "ArrowRight"
  );
}
function computeOffset$1$3(ev, elem) {
  var _a, _b;
  const win = elem.ownerDocument.defaultView;
  const rect = elem.getBoundingClientRect();
  return {
    x:
      ev.pageX -
      (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) +
        rect.left),
    y:
      ev.pageY -
      (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) +
        rect.top),
  };
}
let PointerHandler$3 = class PointerHandler4 {
  constructor(element) {
    this.lastTouch_ = null;
    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onTouchEnd_ = this.onTouchEnd_.bind(this);
    this.onTouchMove_ = this.onTouchMove_.bind(this);
    this.onTouchStart_ = this.onTouchStart_.bind(this);
    this.elem_ = element;
    this.emitter = new Emitter$3();
    element.addEventListener("touchstart", this.onTouchStart_, {
      passive: false,
    });
    element.addEventListener("touchmove", this.onTouchMove_, {
      passive: true,
    });
    element.addEventListener("touchend", this.onTouchEnd_);
    element.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(offset) {
    const rect = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: rect.width,
        height: rect.height,
      },
      point: offset
        ? {
            x: offset.x,
            y: offset.y,
          }
        : null,
    };
  }
  onMouseDown_(ev) {
    var _a;
    ev.preventDefault();
    (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
    const doc = this.elem_.ownerDocument;
    doc.addEventListener("mousemove", this.onDocumentMouseMove_);
    doc.addEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$3(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseMove_(ev) {
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$3(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseUp_(ev) {
    const doc = this.elem_.ownerDocument;
    doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
    doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$3(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onTouchStart_(ev) {
    ev.preventDefault();
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchMove_(ev) {
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchEnd_(ev) {
    var _a;
    const touch =
      (_a = ev.targetTouches.item(0)) !== null && _a !== void 0
        ? _a
        : this.lastTouch_;
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
};
const cn$g$3 = ClassName$3("txt");
let NumberTextView$3 = class NumberTextView4 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$g$3(), cn$g$3(void 0, "num"));
    if (config.arrayPosition) {
      this.element.classList.add(cn$g$3(void 0, config.arrayPosition));
    }
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$g$3("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    this.onDraggingChange_ = this.onDraggingChange_.bind(this);
    this.dragging_ = config.dragging;
    this.dragging_.emitter.on("change", this.onDraggingChange_);
    this.element.classList.add(cn$g$3());
    this.inputElement.classList.add(cn$g$3("i"));
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$g$3("k"));
    this.element.appendChild(knobElem);
    this.knobElement = knobElem;
    const guideElem = doc.createElementNS(SVG_NS$3, "svg");
    guideElem.classList.add(cn$g$3("g"));
    this.knobElement.appendChild(guideElem);
    const bodyElem = doc.createElementNS(SVG_NS$3, "path");
    bodyElem.classList.add(cn$g$3("gb"));
    guideElem.appendChild(bodyElem);
    this.guideBodyElem_ = bodyElem;
    const headElem = doc.createElementNS(SVG_NS$3, "path");
    headElem.classList.add(cn$g$3("gh"));
    guideElem.appendChild(headElem);
    this.guideHeadElem_ = headElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(ClassName$3("tt")());
    this.knobElement.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.refresh();
  }
  onDraggingChange_(ev) {
    if (ev.rawValue === null) {
      this.element.classList.remove(cn$g$3(void 0, "drg"));
      return;
    }
    this.element.classList.add(cn$g$3(void 0, "drg"));
    const x = ev.rawValue / this.props_.get("pointerScale");
    const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
    const adx = constrainRange$3(-aox, -4, 4);
    this.guideHeadElem_.setAttributeNS(
      null,
      "d",
      [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(
        " ",
      ),
    );
    this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
    const formatter = this.props_.get("formatter");
    this.tooltipElem_.textContent = formatter(this.value.rawValue);
    this.tooltipElem_.style.left = `${x}px`;
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let NumberTextController$3 = class NumberTextController4 {
  constructor(doc, config) {
    var _a;
    this.originRawValue_ = 0;
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.sliderProps_ =
      (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.dragging_ = createValue$3(null);
    this.view = new NumberTextView$3(doc, {
      arrayPosition: config.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
    this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
    this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const ph = new PointerHandler$3(this.view.knobElement);
    ph.emitter.on("down", this.onPointerDown_);
    ph.emitter.on("move", this.onPointerMove_);
    ph.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(value) {
    var _a, _b;
    const min =
      (_a = this.sliderProps_) === null || _a === void 0
        ? void 0
        : _a.get("min");
    const max =
      (_b = this.sliderProps_) === null || _b === void 0
        ? void 0
        : _b.get("max");
    let v = value;
    if (min !== void 0) {
      v = Math.max(v, min);
    }
    if (max !== void 0) {
      v = Math.min(v, max);
    }
    return v;
  }
  onInputChange_(e) {
    const inputElem = forceCast$3(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$3(parsedValue)) {
      this.value.rawValue = this.constrainValue_(parsedValue);
    }
    this.view.refresh();
  }
  onInputKeyDown_(ev) {
    const step = getStepForKey$3(
      this.props.get("keyScale"),
      getVerticalStepKeys$3(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
      forceEmit: false,
      last: false,
    });
  }
  onInputKeyUp_(ev) {
    const step = getStepForKey$3(
      this.props.get("keyScale"),
      getVerticalStepKeys$3(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue;
    this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(data) {
    if (!data.point) {
      return null;
    }
    const dx = data.point.x - data.bounds.width / 2;
    return this.constrainValue_(
      this.originRawValue_ + dx * this.props.get("pointerScale"),
    );
  }
  onPointerMove_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: false,
      last: false,
    });
    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
  }
  onPointerUp_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: true,
      last: true,
    });
    this.dragging_.rawValue = null;
  }
};
const cn$f$3 = ClassName$3("sld");
let SliderView$3 = class SliderView4 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$f$3());
    config.viewProps.bindClassModifiers(this.element);
    const trackElem = doc.createElement("div");
    trackElem.classList.add(cn$f$3("t"));
    config.viewProps.bindTabIndex(trackElem);
    this.element.appendChild(trackElem);
    this.trackElement = trackElem;
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$f$3("k"));
    this.trackElement.appendChild(knobElem);
    this.knobElement = knobElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const p = constrainRange$3(
      mapRange$3(
        this.value.rawValue,
        this.props_.get("min"),
        this.props_.get("max"),
        0,
        100,
      ),
      0,
      100,
    );
    this.knobElement.style.width = `${p}%`;
  }
  onChange_() {
    this.update_();
  }
};
let SliderController$3 = class SliderController4 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.props = config.props;
    this.view = new SliderView$3(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$3(this.view.trackElement);
    this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
    this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    this.value.setRawValue(
      mapRange$3(
        constrainRange$3(d.point.x, 0, d.bounds.width),
        0,
        d.bounds.width,
        this.props.get("min"),
        this.props.get("max"),
      ),
      opts,
    );
  }
  onPointerDownOrMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$3(
      this.props.get("keyScale"),
      getHorizontalStepKeys$3(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue + step, {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$3(
      this.props.get("keyScale"),
      getHorizontalStepKeys$3(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$e$3 = ClassName$3("sldtxt");
let SliderTextView$3 = class SliderTextView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$e$3());
    const sliderElem = doc.createElement("div");
    sliderElem.classList.add(cn$e$3("s"));
    this.sliderView_ = config.sliderView;
    sliderElem.appendChild(this.sliderView_.element);
    this.element.appendChild(sliderElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$e$3("t"));
    this.textView_ = config.textView;
    textElem.appendChild(this.textView_.element);
    this.element.appendChild(textElem);
  }
};
let SliderTextController$3 = class SliderTextController4 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.sliderC_ = new SliderController$3(doc, {
      props: config.sliderProps,
      value: config.value,
      viewProps: this.viewProps,
    });
    this.textC_ = new NumberTextController$3(doc, {
      parser: config.parser,
      props: config.textProps,
      sliderProps: config.sliderProps,
      value: config.value,
      viewProps: config.viewProps,
    });
    this.view = new SliderTextView$3(doc, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view,
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(state) {
    return importBladeState$3(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        const sliderProps = this.sliderC_.props;
        sliderProps.set("max", result.max);
        sliderProps.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    const sliderProps = this.sliderC_.props;
    return exportBladeState$3(null, {
      max: sliderProps.get("max"),
      min: sliderProps.get("min"),
    });
  }
};
function createSliderTextProps$3(config) {
  return {
    sliderProps: new ValueMap$3({
      keyScale: config.keyScale,
      max: config.max,
      min: config.min,
    }),
    textProps: new ValueMap$3({
      formatter: createValue$3(config.formatter),
      keyScale: config.keyScale,
      pointerScale: createValue$3(config.pointerScale),
    }),
  };
}
const CSS_VAR_MAP$3 = {
  containerUnitSize: "cnt-usz",
};
function getCssVar$3(key2) {
  return `--${CSS_VAR_MAP$3[key2]}`;
}
function createPointDimensionParser$3(p) {
  return createNumberTextInputParamsParser$3(p);
}
function parsePointDimensionParams$3(value) {
  if (!isRecord$3(value)) {
    return void 0;
  }
  return parseRecord$3(value, createPointDimensionParser$3);
}
function createDimensionConstraint$1$1(params, initialValue) {
  if (!params) {
    return void 0;
  }
  const constraints = [];
  const cs = createStepConstraint$3(params, initialValue);
  if (cs) {
    constraints.push(cs);
  }
  const rs = createRangeConstraint$3(params);
  if (rs) {
    constraints.push(rs);
  }
  return new CompositeConstraint$3(constraints);
}
function parsePickerLayout$3(value) {
  if (value === "inline" || value === "popup") {
    return value;
  }
  return void 0;
}
function writePrimitive$3(target, value) {
  target.write(value);
}
const cn$d$3 = ClassName$3("ckb");
let CheckboxView$3 = class CheckboxView4 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$d$3());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("label");
    labelElem.classList.add(cn$d$3("l"));
    this.element.appendChild(labelElem);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$d$3("i"));
    inputElem.type = "checkbox";
    labelElem.appendChild(inputElem);
    this.inputElement = inputElem;
    config.viewProps.bindDisabled(this.inputElement);
    const wrapperElem = doc.createElement("div");
    wrapperElem.classList.add(cn$d$3("w"));
    labelElem.appendChild(wrapperElem);
    const markElem = createSvgIconElement$3(doc, "check");
    wrapperElem.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
};
let CheckboxController$3 = class CheckboxController4 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new CheckboxView$3(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$3(e.currentTarget);
    this.value.rawValue = inputElem.checked;
  }
};
function createConstraint$6$3(params) {
  const constraints = [];
  const lc = createListConstraint$3(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$3(constraints);
}
createPlugin$3({
  id: "input-bool",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$3(params, (p) => ({
      options: p.optional.custom(parseListOptions$3),
      readonly: p.optional.constant(false),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$3,
    constraint: (args) => createConstraint$6$3(args.params),
    writer: (_args) => writePrimitive$3,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$3(c, ListConstraint$3);
    if (lc) {
      return new ListController$3(doc, {
        props: new ValueMap$3({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new CheckboxController$3(doc, {
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "boolean") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$3) {
      return new ListInputBindingApi$3(args.controller);
    }
    return null;
  },
});
const cn$c$3 = ClassName$3("col");
let ColorView$3 = class ColorView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$c$3());
    config.foldable.bindExpandedClass(this.element, cn$c$3(void 0, "expanded"));
    bindValueMap$3(
      config.foldable,
      "completed",
      valueToClassName$3(this.element, cn$c$3(void 0, "cpl")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$c$3("h"));
    this.element.appendChild(headElem);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$c$3("s"));
    headElem.appendChild(swatchElem);
    this.swatchElement = swatchElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$c$3("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$c$3("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
function rgbToHslInt$3(r, g, b) {
  const rp = constrainRange$3(r / 255, 0, 1);
  const gp = constrainRange$3(g / 255, 0, 1);
  const bp = constrainRange$3(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const c = cmax - cmin;
  let h = 0;
  let s = 0;
  const l = (cmin + cmax) / 2;
  if (c !== 0) {
    s = c / (1 - Math.abs(cmax + cmin - 1));
    if (rp === cmax) {
      h = (gp - bp) / c;
    } else if (gp === cmax) {
      h = 2 + (bp - rp) / c;
    } else {
      h = 4 + (rp - gp) / c;
    }
    h = h / 6 + (h < 0 ? 1 : 0);
  }
  return [h * 360, s * 100, l * 100];
}
function hslToRgbInt$3(h, s, l) {
  const hp = ((h % 360) + 360) % 360;
  const sp = constrainRange$3(s / 100, 0, 1);
  const lp = constrainRange$3(l / 100, 0, 1);
  const c = (1 - Math.abs(2 * lp - 1)) * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = lp - c / 2;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function rgbToHsvInt$3(r, g, b) {
  const rp = constrainRange$3(r / 255, 0, 1);
  const gp = constrainRange$3(g / 255, 0, 1);
  const bp = constrainRange$3(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const d = cmax - cmin;
  let h;
  if (d === 0) {
    h = 0;
  } else if (cmax === rp) {
    h = 60 * (((((gp - bp) / d) % 6) + 6) % 6);
  } else if (cmax === gp) {
    h = 60 * ((bp - rp) / d + 2);
  } else {
    h = 60 * ((rp - gp) / d + 4);
  }
  const s = cmax === 0 ? 0 : d / cmax;
  const v = cmax;
  return [h, s * 100, v * 100];
}
function hsvToRgbInt$3(h, s, v) {
  const hp = loopRange$3(h, 360);
  const sp = constrainRange$3(s / 100, 0, 1);
  const vp = constrainRange$3(v / 100, 0, 1);
  const c = vp * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = vp - c;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function hslToHsvInt$3(h, s, l) {
  const sd = l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100);
  return [
    h,
    sd !== 0 ? (s * (100 - Math.abs(2 * l - 100))) / sd : 0,
    l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100),
  ];
}
function hsvToHslInt$3(h, s, v) {
  const sd = 100 - Math.abs((v * (200 - s)) / 100 - 100);
  return [h, sd !== 0 ? (s * v) / sd : 0, (v * (200 - s)) / (2 * 100)];
}
function removeAlphaComponent$3(comps) {
  return [comps[0], comps[1], comps[2]];
}
function appendAlphaComponent$3(comps, alpha) {
  return [comps[0], comps[1], comps[2], alpha];
}
const MODE_CONVERTER_MAP$3 = {
  hsl: {
    hsl: (h, s, l) => [h, s, l],
    hsv: hslToHsvInt$3,
    rgb: hslToRgbInt$3,
  },
  hsv: {
    hsl: hsvToHslInt$3,
    hsv: (h, s, v) => [h, s, v],
    rgb: hsvToRgbInt$3,
  },
  rgb: {
    hsl: rgbToHslInt$3,
    hsv: rgbToHsvInt$3,
    rgb: (r, g, b) => [r, g, b],
  },
};
function getColorMaxComponents$3(mode, type) {
  return [
    type === "float" ? 1 : mode === "rgb" ? 255 : 360,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
  ];
}
function loopHueRange$3(hue, max) {
  return hue === max ? max : loopRange$3(hue, max);
}
function constrainColorComponents$3(components, mode, type) {
  var _a;
  const ms = getColorMaxComponents$3(mode, type);
  return [
    mode === "rgb"
      ? constrainRange$3(components[0], 0, ms[0])
      : loopHueRange$3(components[0], ms[0]),
    constrainRange$3(components[1], 0, ms[1]),
    constrainRange$3(components[2], 0, ms[2]),
    constrainRange$3(
      (_a = components[3]) !== null && _a !== void 0 ? _a : 1,
      0,
      1,
    ),
  ];
}
function convertColorType$3(comps, mode, from, to) {
  const fms = getColorMaxComponents$3(mode, from);
  const tms = getColorMaxComponents$3(mode, to);
  return comps.map((c, index) => (c / fms[index]) * tms[index]);
}
function convertColor$3(components, from, to) {
  const intComps = convertColorType$3(components, from.mode, from.type, "int");
  const result = MODE_CONVERTER_MAP$3[from.mode][to.mode](...intComps);
  return convertColorType$3(result, to.mode, "int", to.type);
}
let IntColor$3 = class IntColor4 {
  static black() {
    return new IntColor4([0, 0, 0], "rgb");
  }
  constructor(comps, mode) {
    this.type = "int";
    this.mode = mode;
    this.comps_ = constrainColorComponents$3(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$3(
      convertColor$3(
        removeAlphaComponent$3(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const cn$b$3 = ClassName$3("colp");
let ColorPickerView$3 = class ColorPickerView4 {
  constructor(doc, config) {
    this.alphaViews_ = null;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$b$3());
    config.viewProps.bindClassModifiers(this.element);
    const hsvElem = doc.createElement("div");
    hsvElem.classList.add(cn$b$3("hsv"));
    const svElem = doc.createElement("div");
    svElem.classList.add(cn$b$3("sv"));
    this.svPaletteView_ = config.svPaletteView;
    svElem.appendChild(this.svPaletteView_.element);
    hsvElem.appendChild(svElem);
    const hElem = doc.createElement("div");
    hElem.classList.add(cn$b$3("h"));
    this.hPaletteView_ = config.hPaletteView;
    hElem.appendChild(this.hPaletteView_.element);
    hsvElem.appendChild(hElem);
    this.element.appendChild(hsvElem);
    const rgbElem = doc.createElement("div");
    rgbElem.classList.add(cn$b$3("rgb"));
    this.textsView_ = config.textsView;
    rgbElem.appendChild(this.textsView_.element);
    this.element.appendChild(rgbElem);
    if (config.alphaViews) {
      this.alphaViews_ = {
        palette: config.alphaViews.palette,
        text: config.alphaViews.text,
      };
      const aElem = doc.createElement("div");
      aElem.classList.add(cn$b$3("a"));
      const apElem = doc.createElement("div");
      apElem.classList.add(cn$b$3("ap"));
      apElem.appendChild(this.alphaViews_.palette.element);
      aElem.appendChild(apElem);
      const atElem = doc.createElement("div");
      atElem.classList.add(cn$b$3("at"));
      atElem.appendChild(this.alphaViews_.text.element);
      aElem.appendChild(atElem);
      this.element.appendChild(aElem);
    }
  }
  get allFocusableElements() {
    const elems = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textsView_.modeSelectElement,
      ...this.textsView_.inputViews.map((v) => v.inputElement),
    ];
    if (this.alphaViews_) {
      elems.push(
        this.alphaViews_.palette.element,
        this.alphaViews_.text.inputElement,
      );
    }
    return elems;
  }
};
function parseColorType$3(value) {
  return value === "int" ? "int" : value === "float" ? "float" : void 0;
}
function parseColorInputParams$3(params) {
  return parseRecord$3(params, (p) => ({
    color: p.optional.object({
      alpha: p.optional.boolean,
      type: p.optional.custom(parseColorType$3),
    }),
    expanded: p.optional.boolean,
    picker: p.optional.custom(parsePickerLayout$3),
    readonly: p.optional.constant(false),
  }));
}
function getKeyScaleForColor$3(forAlpha) {
  return forAlpha ? 0.1 : 1;
}
function extractColorType$3(params) {
  var _a;
  return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
}
let FloatColor$3 = class FloatColor4 {
  constructor(comps, mode) {
    this.type = "float";
    this.mode = mode;
    this.comps_ = constrainColorComponents$3(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$3(
      convertColor$3(
        removeAlphaComponent$3(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const TYPE_TO_CONSTRUCTOR_MAP$3 = {
  int: (comps, mode) => new IntColor$3(comps, mode),
  float: (comps, mode) => new FloatColor$3(comps, mode),
};
function createColor$3(comps, mode, type) {
  return TYPE_TO_CONSTRUCTOR_MAP$3[type](comps, mode);
}
function isFloatColor$3(c) {
  return c.type === "float";
}
function isIntColor$3(c) {
  return c.type === "int";
}
function convertFloatToInt$3(cf) {
  const comps = cf.getComponents();
  const ms = getColorMaxComponents$3(cf.mode, "int");
  return new IntColor$3(
    [
      Math.round(mapRange$3(comps[0], 0, 1, 0, ms[0])),
      Math.round(mapRange$3(comps[1], 0, 1, 0, ms[1])),
      Math.round(mapRange$3(comps[2], 0, 1, 0, ms[2])),
      comps[3],
    ],
    cf.mode,
  );
}
function convertIntToFloat$3(ci) {
  const comps = ci.getComponents();
  const ms = getColorMaxComponents$3(ci.mode, "int");
  return new FloatColor$3(
    [
      mapRange$3(comps[0], 0, ms[0], 0, 1),
      mapRange$3(comps[1], 0, ms[1], 0, 1),
      mapRange$3(comps[2], 0, ms[2], 0, 1),
      comps[3],
    ],
    ci.mode,
  );
}
function mapColorType$3(c, type) {
  if (c.type === type) {
    return c;
  }
  if (isIntColor$3(c) && type === "float") {
    return convertIntToFloat$3(c);
  }
  if (isFloatColor$3(c) && type === "int") {
    return convertFloatToInt$3(c);
  }
  throw TpError$3.shouldNeverHappen();
}
function equalsStringColorFormat$3(f1, f2) {
  return (
    f1.alpha === f2.alpha &&
    f1.mode === f2.mode &&
    f1.notation === f2.notation &&
    f1.type === f2.type
  );
}
function parseCssNumberOrPercentage$3(text, max) {
  const m = text.match(/^(.+)%$/);
  if (!m) {
    return Math.min(parseFloat(text), max);
  }
  return Math.min(parseFloat(m[1]) * 0.01 * max, max);
}
const ANGLE_TO_DEG_MAP$3 = {
  deg: (angle) => angle,
  grad: (angle) => (angle * 360) / 400,
  rad: (angle) => (angle * 360) / (2 * Math.PI),
  turn: (angle) => angle * 360,
};
function parseCssNumberOrAngle$3(text) {
  const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!m) {
    return parseFloat(text);
  }
  const angle = parseFloat(m[1]);
  const unit = m[2];
  return ANGLE_TO_DEG_MAP$3[unit](angle);
}
function parseFunctionalRgbColorComponents$3(text) {
  const m = text.match(
    /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$3(m[1], 255),
    parseCssNumberOrPercentage$3(m[2], 255),
    parseCssNumberOrPercentage$3(m[3], 255),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbColor$3(text) {
  const comps = parseFunctionalRgbColorComponents$3(text);
  return comps ? new IntColor$3(comps, "rgb") : null;
}
function parseFunctionalRgbaColorComponents$3(text) {
  const m = text.match(
    /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$3(m[1], 255),
    parseCssNumberOrPercentage$3(m[2], 255),
    parseCssNumberOrPercentage$3(m[3], 255),
    parseCssNumberOrPercentage$3(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbaColor$3(text) {
  const comps = parseFunctionalRgbaColorComponents$3(text);
  return comps ? new IntColor$3(comps, "rgb") : null;
}
function parseFunctionalHslColorComponents$3(text) {
  const m = text.match(
    /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$3(m[1]),
    parseCssNumberOrPercentage$3(m[2], 100),
    parseCssNumberOrPercentage$3(m[3], 100),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalHslColor$3(text) {
  const comps = parseFunctionalHslColorComponents$3(text);
  return comps ? new IntColor$3(comps, "hsl") : null;
}
function parseHslaColorComponents$3(text) {
  const m = text.match(
    /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$3(m[1]),
    parseCssNumberOrPercentage$3(m[2], 100),
    parseCssNumberOrPercentage$3(m[3], 100),
    parseCssNumberOrPercentage$3(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalHslaColor$3(text) {
  const comps = parseHslaColorComponents$3(text);
  return comps ? new IntColor$3(comps, "hsl") : null;
}
function parseHexRgbColorComponents$3(text) {
  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
    ];
  }
  return null;
}
function parseHexRgbColor$3(text) {
  const comps = parseHexRgbColorComponents$3(text);
  return comps ? new IntColor$3(comps, "rgb") : null;
}
function parseHexRgbaColorComponents$3(text) {
  const mRgb = text.match(
    /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/,
  );
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
      mapRange$3(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
      mapRange$3(parseInt(mRrggbb[4], 16), 0, 255, 0, 1),
    ];
  }
  return null;
}
function parseHexRgbaColor$3(text) {
  const comps = parseHexRgbaColorComponents$3(text);
  return comps ? new IntColor$3(comps, "rgb") : null;
}
function parseObjectRgbColorComponents$3(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function createObjectRgbColorParser$3(type) {
  return (text) => {
    const comps = parseObjectRgbColorComponents$3(text);
    return comps ? createColor$3(comps, "rgb", type) : null;
  };
}
function parseObjectRgbaColorComponents$3(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseFloat(m[1]),
    parseFloat(m[2]),
    parseFloat(m[3]),
    parseFloat(m[4]),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function createObjectRgbaColorParser$3(type) {
  return (text) => {
    const comps = parseObjectRgbaColorComponents$3(text);
    return comps ? createColor$3(comps, "rgb", type) : null;
  };
}
const PARSER_AND_RESULT$3 = [
  {
    parser: parseHexRgbColorComponents$3,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseHexRgbaColorComponents$3,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseFunctionalRgbColorComponents$3,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalRgbaColorComponents$3,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalHslColorComponents$3,
    result: {
      alpha: false,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseHslaColorComponents$3,
    result: {
      alpha: true,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseObjectRgbColorComponents$3,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "object",
    },
  },
  {
    parser: parseObjectRgbaColorComponents$3,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "object",
    },
  },
];
function detectStringColor$3(text) {
  return PARSER_AND_RESULT$3.reduce((prev, { parser, result: detection }) => {
    if (prev) {
      return prev;
    }
    return parser(text) ? detection : null;
  }, null);
}
function detectStringColorFormat$3(text, type = "int") {
  const r = detectStringColor$3(text);
  if (!r) {
    return null;
  }
  if (r.notation === "hex" && type !== "float") {
    return Object.assign(Object.assign({}, r), { type: "int" });
  }
  if (r.notation === "func") {
    return Object.assign(Object.assign({}, r), { type });
  }
  return null;
}
function createColorStringParser$3(type) {
  const parsers = [
    parseHexRgbColor$3,
    parseHexRgbaColor$3,
    parseFunctionalRgbColor$3,
    parseFunctionalRgbaColor$3,
    parseFunctionalHslColor$3,
    parseFunctionalHslaColor$3,
  ];
  if (type === "int") {
    parsers.push(
      createObjectRgbColorParser$3("int"),
      createObjectRgbaColorParser$3("int"),
    );
  }
  if (type === "float") {
    parsers.push(
      createObjectRgbColorParser$3("float"),
      createObjectRgbaColorParser$3("float"),
    );
  }
  const parser = composeParsers$3(parsers);
  return (text) => {
    const result = parser(text);
    return result ? mapColorType$3(result, type) : null;
  };
}
function readIntColorString$3(value) {
  const parser = createColorStringParser$3("int");
  if (typeof value !== "string") {
    return IntColor$3.black();
  }
  const result = parser(value);
  return result !== null && result !== void 0 ? result : IntColor$3.black();
}
function zerofill$3(comp) {
  const hex = constrainRange$3(Math.floor(comp), 0, 255).toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function colorToHexRgbString$3(value, prefix = "#") {
  const hexes = removeAlphaComponent$3(value.getComponents("rgb"))
    .map(zerofill$3)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToHexRgbaString$3(value, prefix = "#") {
  const rgbaComps = value.getComponents("rgb");
  const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
    .map(zerofill$3)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToFunctionalRgbString$3(value) {
  const formatter = createNumberFormatter$3(0);
  const ci = mapColorType$3(value, "int");
  const comps = removeAlphaComponent$3(ci.getComponents("rgb")).map((comp) =>
    formatter(comp),
  );
  return `rgb(${comps.join(", ")})`;
}
function colorToFunctionalRgbaString$3(value) {
  const aFormatter = createNumberFormatter$3(2);
  const rgbFormatter = createNumberFormatter$3(0);
  const ci = mapColorType$3(value, "int");
  const comps = ci.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return formatter(comp);
  });
  return `rgba(${comps.join(", ")})`;
}
function colorToFunctionalHslString$3(value) {
  const formatters = [
    createNumberFormatter$3(0),
    formatPercentage$3,
    formatPercentage$3,
  ];
  const ci = mapColorType$3(value, "int");
  const comps = removeAlphaComponent$3(ci.getComponents("hsl")).map(
    (comp, index) => formatters[index](comp),
  );
  return `hsl(${comps.join(", ")})`;
}
function colorToFunctionalHslaString$3(value) {
  const formatters = [
    createNumberFormatter$3(0),
    formatPercentage$3,
    formatPercentage$3,
    createNumberFormatter$3(2),
  ];
  const ci = mapColorType$3(value, "int");
  const comps = ci
    .getComponents("hsl")
    .map((comp, index) => formatters[index](comp));
  return `hsla(${comps.join(", ")})`;
}
function colorToObjectRgbString$3(value, type) {
  const formatter = createNumberFormatter$3(type === "float" ? 2 : 0);
  const names = ["r", "g", "b"];
  const cc = mapColorType$3(value, type);
  const comps = removeAlphaComponent$3(cc.getComponents("rgb")).map(
    (comp, index) => `${names[index]}: ${formatter(comp)}`,
  );
  return `{${comps.join(", ")}}`;
}
function createObjectRgbColorFormatter$3(type) {
  return (value) => colorToObjectRgbString$3(value, type);
}
function colorToObjectRgbaString$3(value, type) {
  const aFormatter = createNumberFormatter$3(2);
  const rgbFormatter = createNumberFormatter$3(type === "float" ? 2 : 0);
  const names = ["r", "g", "b", "a"];
  const cc = mapColorType$3(value, type);
  const comps = cc.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return `${names[index]}: ${formatter(comp)}`;
  });
  return `{${comps.join(", ")}}`;
}
function createObjectRgbaColorFormatter$3(type) {
  return (value) => colorToObjectRgbaString$3(value, type);
}
const FORMAT_AND_STRINGIFIERS$3 = [
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbString$3,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbaString$3,
  },
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbString$3,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbaString$3,
  },
  {
    format: {
      alpha: false,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslString$3,
  },
  {
    format: {
      alpha: true,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslaString$3,
  },
  ...["int", "float"].reduce((prev, type) => {
    return [
      ...prev,
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbColorFormatter$3(type),
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbaColorFormatter$3(type),
      },
    ];
  }, []),
];
function findColorStringifier$3(format) {
  return FORMAT_AND_STRINGIFIERS$3.reduce((prev, fas) => {
    if (prev) {
      return prev;
    }
    return equalsStringColorFormat$3(fas.format, format)
      ? fas.stringifier
      : null;
  }, null);
}
const cn$a$3 = ClassName$3("apl");
let APaletteView$3 = class APaletteView4 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$a$3());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const barElem = doc.createElement("div");
    barElem.classList.add(cn$a$3("b"));
    this.element.appendChild(barElem);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$a$3("c"));
    barElem.appendChild(colorElem);
    this.colorElem_ = colorElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$a$3("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    const previewElem = doc.createElement("div");
    previewElem.classList.add(cn$a$3("p"));
    this.markerElem_.appendChild(previewElem);
    this.previewElem_ = previewElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const rgbaComps = c.getComponents("rgb");
    const leftColor = new IntColor$3(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 0],
      "rgb",
    );
    const rightColor = new IntColor$3(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 255],
      "rgb",
    );
    const gradientComps = [
      "to right",
      colorToFunctionalRgbaString$3(leftColor),
      colorToFunctionalRgbaString$3(rightColor),
    ];
    this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
    this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString$3(c);
    const left = mapRange$3(rgbaComps[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let APaletteController$3 = class APaletteController4 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new APaletteView$3(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$3(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const alpha = d.point.x / d.bounds.width;
    const c = this.value.rawValue;
    const [h, s, v] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$3([h, s, v, alpha], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$3(
      getKeyScaleForColor$3(true),
      getHorizontalStepKeys$3(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$3([h, s, v, a + step], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$3(
      getKeyScaleForColor$3(true),
      getHorizontalStepKeys$3(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$9$3 = ClassName$3("coltxt");
function createModeSelectElement$3(doc) {
  const selectElem = doc.createElement("select");
  const items = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" },
    { text: "HEX", value: "hex" },
  ];
  selectElem.appendChild(
    items.reduce((frag, item) => {
      const optElem = doc.createElement("option");
      optElem.textContent = item.text;
      optElem.value = item.value;
      frag.appendChild(optElem);
      return frag;
    }, doc.createDocumentFragment()),
  );
  return selectElem;
}
let ColorTextsView$3 = class ColorTextsView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$9$3());
    config.viewProps.bindClassModifiers(this.element);
    const modeElem = doc.createElement("div");
    modeElem.classList.add(cn$9$3("m"));
    this.modeElem_ = createModeSelectElement$3(doc);
    this.modeElem_.classList.add(cn$9$3("ms"));
    modeElem.appendChild(this.modeSelectElement);
    config.viewProps.bindDisabled(this.modeElem_);
    const modeMarkerElem = doc.createElement("div");
    modeMarkerElem.classList.add(cn$9$3("mm"));
    modeMarkerElem.appendChild(createSvgIconElement$3(doc, "dropdown"));
    modeElem.appendChild(modeMarkerElem);
    this.element.appendChild(modeElem);
    const inputsElem = doc.createElement("div");
    inputsElem.classList.add(cn$9$3("w"));
    this.element.appendChild(inputsElem);
    this.inputsElem_ = inputsElem;
    this.inputViews_ = config.inputViews;
    this.applyInputViews_();
    bindValue$3(config.mode, (mode) => {
      this.modeElem_.value = mode;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(inputViews) {
    this.inputViews_ = inputViews;
    this.applyInputViews_();
  }
  applyInputViews_() {
    removeChildElements$3(this.inputsElem_);
    const doc = this.element.ownerDocument;
    this.inputViews_.forEach((v) => {
      const compElem = doc.createElement("div");
      compElem.classList.add(cn$9$3("c"));
      compElem.appendChild(v.element);
      this.inputsElem_.appendChild(compElem);
    });
  }
};
function createFormatter$2$3(type) {
  return createNumberFormatter$3(type === "float" ? 2 : 0);
}
function createConstraint$5$3(mode, type, index) {
  const max = getColorMaxComponents$3(mode, type)[index];
  return new DefiniteRangeConstraint$3({
    min: 0,
    max,
  });
}
function createComponentController$3(doc, config, index) {
  return new NumberTextController$3(doc, {
    arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
    parser: config.parser,
    props: ValueMap$3.fromObject({
      formatter: createFormatter$2$3(config.colorType),
      keyScale: getKeyScaleForColor$3(false),
      pointerScale: config.colorType === "float" ? 0.01 : 1,
    }),
    value: createValue$3(0, {
      constraint: createConstraint$5$3(
        config.colorMode,
        config.colorType,
        index,
      ),
    }),
    viewProps: config.viewProps,
  });
}
function createComponentControllers$3(doc, config) {
  const cc = {
    colorMode: config.colorMode,
    colorType: config.colorType,
    parser: parseNumber$3,
    viewProps: config.viewProps,
  };
  return [0, 1, 2].map((i) => {
    const c = createComponentController$3(doc, cc, i);
    connectValues$3({
      primary: config.value,
      secondary: c.value,
      forward(p) {
        const mc = mapColorType$3(p, config.colorType);
        return mc.getComponents(config.colorMode)[i];
      },
      backward(p, s) {
        const pickedMode = config.colorMode;
        const mc = mapColorType$3(p, config.colorType);
        const comps = mc.getComponents(pickedMode);
        comps[i] = s;
        const c2 = createColor$3(
          appendAlphaComponent$3(removeAlphaComponent$3(comps), comps[3]),
          pickedMode,
          config.colorType,
        );
        return mapColorType$3(c2, "int");
      },
    });
    return c;
  });
}
function createHexController$3(doc, config) {
  const c = new TextController$3(doc, {
    parser: createColorStringParser$3("int"),
    props: ValueMap$3.fromObject({
      formatter: colorToHexRgbString$3,
    }),
    value: createValue$3(IntColor$3.black()),
    viewProps: config.viewProps,
  });
  connectValues$3({
    primary: config.value,
    secondary: c.value,
    forward: (p) =>
      new IntColor$3(removeAlphaComponent$3(p.getComponents()), p.mode),
    backward: (p, s) =>
      new IntColor$3(
        appendAlphaComponent$3(
          removeAlphaComponent$3(s.getComponents(p.mode)),
          p.getComponents()[3],
        ),
        p.mode,
      ),
  });
  return [c];
}
function isColorMode$3(mode) {
  return mode !== "hex";
}
let ColorTextsController$3 = class ColorTextsController4 {
  constructor(doc, config) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
    this.colorType_ = config.colorType;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.colorMode = createValue$3(this.value.rawValue.mode);
    this.ccs_ = this.createComponentControllers_(doc);
    this.view = new ColorTextsView$3(doc, {
      mode: this.colorMode,
      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
      viewProps: this.viewProps,
    });
    this.view.modeSelectElement.addEventListener(
      "change",
      this.onModeSelectChange_,
    );
  }
  createComponentControllers_(doc) {
    const mode = this.colorMode.rawValue;
    if (isColorMode$3(mode)) {
      return createComponentControllers$3(doc, {
        colorMode: mode,
        colorType: this.colorType_,
        value: this.value,
        viewProps: this.viewProps,
      });
    }
    return createHexController$3(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
  onModeSelectChange_(ev) {
    const selectElem = ev.currentTarget;
    this.colorMode.rawValue = selectElem.value;
    this.ccs_ = this.createComponentControllers_(
      this.view.element.ownerDocument,
    );
    this.view.inputViews = this.ccs_.map((cc) => cc.view);
  }
};
const cn$8$3 = ClassName$3("hpl");
let HPaletteView$3 = class HPaletteView4 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$8$3());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$8$3("c"));
    this.element.appendChild(colorElem);
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$8$3("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const [h] = c.getComponents("hsv");
    this.markerElem_.style.backgroundColor = colorToFunctionalRgbString$3(
      new IntColor$3([h, 100, 100], "hsv"),
    );
    const left = mapRange$3(h, 0, 360, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let HPaletteController$3 = class HPaletteController4 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new HPaletteView$3(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$3(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const hue = mapRange$3(
      constrainRange$3(d.point.x, 0, d.bounds.width),
      0,
      d.bounds.width,
      0,
      360,
    );
    const c = this.value.rawValue;
    const [, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$3([hue, s, v, a], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$3(
      getKeyScaleForColor$3(false),
      getHorizontalStepKeys$3(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$3([h + step, s, v, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$3(
      getKeyScaleForColor$3(false),
      getHorizontalStepKeys$3(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$7$3 = ClassName$3("svp");
const CANVAS_RESOL$3 = 64;
let SvPaletteView$3 = class SvPaletteView4 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$7$3());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const canvasElem = doc.createElement("canvas");
    canvasElem.height = CANVAS_RESOL$3;
    canvasElem.width = CANVAS_RESOL$3;
    canvasElem.classList.add(cn$7$3("c"));
    this.element.appendChild(canvasElem);
    this.canvasElement = canvasElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$7$3("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const ctx = getCanvasContext$3(this.canvasElement);
    if (!ctx) {
      return;
    }
    const c = this.value.rawValue;
    const hsvComps = c.getComponents("hsv");
    const width = this.canvasElement.width;
    const height = this.canvasElement.height;
    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;
    for (let iy = 0; iy < height; iy++) {
      for (let ix = 0; ix < width; ix++) {
        const s = mapRange$3(ix, 0, width, 0, 100);
        const v = mapRange$3(iy, 0, height, 100, 0);
        const rgbComps = hsvToRgbInt$3(hsvComps[0], s, v);
        const i = (iy * width + ix) * 4;
        data[i] = rgbComps[0];
        data[i + 1] = rgbComps[1];
        data[i + 2] = rgbComps[2];
        data[i + 3] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    const left = mapRange$3(hsvComps[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${left}%`;
    const top = mapRange$3(hsvComps[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${top}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let SvPaletteController$3 = class SvPaletteController4 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SvPaletteView$3(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$3(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const saturation = mapRange$3(d.point.x, 0, d.bounds.width, 0, 100);
    const value = mapRange$3(d.point.y, 0, d.bounds.height, 100, 0);
    const [h, , , a] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(
      new IntColor$3([h, saturation, value, a], "hsv"),
      opts,
    );
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    if (isArrowKey$3(ev.key)) {
      ev.preventDefault();
    }
    const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
    const keyScale = getKeyScaleForColor$3(false);
    const ds = getStepForKey$3(keyScale, getHorizontalStepKeys$3(ev));
    const dv = getStepForKey$3(keyScale, getVerticalStepKeys$3(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(new IntColor$3([h, s + ds, v + dv, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const keyScale = getKeyScaleForColor$3(false);
    const ds = getStepForKey$3(keyScale, getHorizontalStepKeys$3(ev));
    const dv = getStepForKey$3(keyScale, getVerticalStepKeys$3(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let ColorPickerController$3 = class ColorPickerController4 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.hPaletteC_ = new HPaletteController$3(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.svPaletteC_ = new SvPaletteController$3(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.alphaIcs_ = config.supportsAlpha
      ? {
          palette: new APaletteController$3(doc, {
            value: this.value,
            viewProps: this.viewProps,
          }),
          text: new NumberTextController$3(doc, {
            parser: parseNumber$3,
            props: ValueMap$3.fromObject({
              pointerScale: 0.01,
              keyScale: 0.1,
              formatter: createNumberFormatter$3(2),
            }),
            value: createValue$3(0, {
              constraint: new DefiniteRangeConstraint$3({ min: 0, max: 1 }),
            }),
            viewProps: this.viewProps,
          }),
        }
      : null;
    if (this.alphaIcs_) {
      connectValues$3({
        primary: this.value,
        secondary: this.alphaIcs_.text.value,
        forward: (p) => p.getComponents()[3],
        backward: (p, s) => {
          const comps = p.getComponents();
          comps[3] = s;
          return new IntColor$3(comps, p.mode);
        },
      });
    }
    this.textsC_ = new ColorTextsController$3(doc, {
      colorType: config.colorType,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorPickerView$3(doc, {
      alphaViews: this.alphaIcs_
        ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view,
          }
        : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: config.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textsView: this.textsC_.view,
      viewProps: this.viewProps,
    });
  }
  get textsController() {
    return this.textsC_;
  }
};
const cn$6$3 = ClassName$3("colsw");
let ColorSwatchView$3 = class ColorSwatchView4 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$6$3());
    config.viewProps.bindClassModifiers(this.element);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$6$3("sw"));
    this.element.appendChild(swatchElem);
    this.swatchElem_ = swatchElem;
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$6$3("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    this.update_();
  }
  update_() {
    const value = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = colorToHexRgbaString$3(value);
  }
  onValueChange_() {
    this.update_();
  }
};
let ColorSwatchController$3 = class ColorSwatchController4 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ColorSwatchView$3(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
let ColorController$3 = class ColorController4 {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$3.create(config.expanded);
    this.swatchC_ = new ColorSwatchController$3(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    const buttonElem = this.swatchC_.view.buttonElement;
    buttonElem.addEventListener("blur", this.onButtonBlur_);
    buttonElem.addEventListener("click", this.onButtonClick_);
    this.textC_ = new TextController$3(doc, {
      parser: config.parser,
      props: ValueMap$3.fromObject({
        formatter: config.formatter,
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorView$3(doc, {
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout,
    });
    this.view.swatchElement.appendChild(this.swatchC_.view.element);
    this.view.textElement.appendChild(this.textC_.view.element);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$3(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const pickerC = new ColorPickerController$3(doc, {
      colorType: config.colorType,
      supportsAlpha: config.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps,
    });
    pickerC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = pickerC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(pickerC.view.element);
      connectValues$3({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$3(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$3(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$3(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.swatchC_.view.buttonElement &&
      !supportsTouch$3(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.swatchC_.view.buttonElement.focus();
      }
    }
  }
};
function colorToRgbNumber$3(value) {
  return removeAlphaComponent$3(value.getComponents("rgb")).reduce(
    (result, comp) => {
      return (result << 8) | (Math.floor(comp) & 255);
    },
    0,
  );
}
function colorToRgbaNumber$3(value) {
  return (
    value.getComponents("rgb").reduce((result, comp, index) => {
      const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
      return (result << 8) | hex;
    }, 0) >>> 0
  );
}
function numberToRgbColor$3(num) {
  return new IntColor$3(
    [(num >> 16) & 255, (num >> 8) & 255, num & 255],
    "rgb",
  );
}
function numberToRgbaColor$3(num) {
  return new IntColor$3(
    [
      (num >> 24) & 255,
      (num >> 16) & 255,
      (num >> 8) & 255,
      mapRange$3(num & 255, 0, 255, 0, 1),
    ],
    "rgb",
  );
}
function colorFromRgbNumber$3(value) {
  if (typeof value !== "number") {
    return IntColor$3.black();
  }
  return numberToRgbColor$3(value);
}
function colorFromRgbaNumber$3(value) {
  if (typeof value !== "number") {
    return IntColor$3.black();
  }
  return numberToRgbaColor$3(value);
}
function isRgbColorComponent$3(obj, key2) {
  if (typeof obj !== "object" || isEmpty$3(obj)) {
    return false;
  }
  return key2 in obj && typeof obj[key2] === "number";
}
function isRgbColorObject$3(obj) {
  return (
    isRgbColorComponent$3(obj, "r") &&
    isRgbColorComponent$3(obj, "g") &&
    isRgbColorComponent$3(obj, "b")
  );
}
function isRgbaColorObject$3(obj) {
  return isRgbColorObject$3(obj) && isRgbColorComponent$3(obj, "a");
}
function isColorObject$3(obj) {
  return isRgbColorObject$3(obj);
}
function equalsColor$3(v1, v2) {
  if (v1.mode !== v2.mode) {
    return false;
  }
  if (v1.type !== v2.type) {
    return false;
  }
  const comps1 = v1.getComponents();
  const comps2 = v2.getComponents();
  for (let i = 0; i < comps1.length; i++) {
    if (comps1[i] !== comps2[i]) {
      return false;
    }
  }
  return true;
}
function createColorComponentsFromRgbObject$3(obj) {
  return "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
}
function createColorStringWriter$3(format) {
  const stringify = findColorStringifier$3(format);
  return stringify
    ? (target, value) => {
        writePrimitive$3(target, stringify(value));
      }
    : null;
}
function createColorNumberWriter$3(supportsAlpha) {
  const colorToNumber = supportsAlpha
    ? colorToRgbaNumber$3
    : colorToRgbNumber$3;
  return (target, value) => {
    writePrimitive$3(target, colorToNumber(value));
  };
}
function writeRgbaColorObject$3(target, value, type) {
  const cc = mapColorType$3(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
  target.writeProperty("a", obj.a);
}
function writeRgbColorObject$3(target, value, type) {
  const cc = mapColorType$3(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
}
function createColorObjectWriter$3(supportsAlpha, type) {
  return (target, inValue) => {
    if (supportsAlpha) {
      writeRgbaColorObject$3(target, inValue, type);
    } else {
      writeRgbColorObject$3(target, inValue, type);
    }
  };
}
function shouldSupportAlpha$1$3(inputParams) {
  var _a;
  if (
    (_a =
      inputParams === null || inputParams === void 0
        ? void 0
        : inputParams.color) === null || _a === void 0
      ? void 0
      : _a.alpha
  ) {
    return true;
  }
  return false;
}
function createFormatter$1$3(supportsAlpha) {
  return supportsAlpha
    ? (v) => colorToHexRgbaString$3(v, "0x")
    : (v) => colorToHexRgbString$3(v, "0x");
}
function isForColor$3(params) {
  if ("color" in params) {
    return true;
  }
  if (params.view === "color") {
    return true;
  }
  return false;
}
createPlugin$3({
  id: "input-color-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    if (!isForColor$3(params)) {
      return null;
    }
    const result = parseColorInputParams$3(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            supportsAlpha: shouldSupportAlpha$1$3(params),
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => {
      return args.params.supportsAlpha
        ? colorFromRgbaNumber$3
        : colorFromRgbNumber$3;
    },
    equals: equalsColor$3,
    writer: (args) => {
      return createColorNumberWriter$3(args.params.supportsAlpha);
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$3(args.document, {
      colorType: "int",
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createFormatter$1$3(args.params.supportsAlpha),
      parser: createColorStringParser$3("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
function colorFromObject$3(value, type) {
  if (!isColorObject$3(value)) {
    return mapColorType$3(IntColor$3.black(), type);
  }
  if (type === "int") {
    const comps = createColorComponentsFromRgbObject$3(value);
    return new IntColor$3(comps, "rgb");
  }
  if (type === "float") {
    const comps = createColorComponentsFromRgbObject$3(value);
    return new FloatColor$3(comps, "rgb");
  }
  return mapColorType$3(IntColor$3.black(), "int");
}
function shouldSupportAlpha$4(initialValue) {
  return isRgbaColorObject$3(initialValue);
}
function createColorObjectBindingReader$3(type) {
  return (value) => {
    const c = colorFromObject$3(value, type);
    return mapColorType$3(c, "int");
  };
}
function createColorObjectFormatter$3(supportsAlpha, type) {
  return (value) => {
    if (supportsAlpha) {
      return colorToObjectRgbaString$3(value, type);
    }
    return colorToObjectRgbString$3(value, type);
  };
}
createPlugin$3({
  id: "input-color-object",
  type: "input",
  accept: (value, params) => {
    var _a;
    if (!isColorObject$3(value)) {
      return null;
    }
    const result = parseColorInputParams$3(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            colorType:
              (_a = extractColorType$3(params)) !== null && _a !== void 0
                ? _a
                : "int",
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => createColorObjectBindingReader$3(args.params.colorType),
    equals: equalsColor$3,
    writer: (args) =>
      createColorObjectWriter$3(
        shouldSupportAlpha$4(args.initialValue),
        args.params.colorType,
      ),
  },
  controller: (args) => {
    var _a, _b;
    const supportsAlpha = isRgbaColorObject$3(args.initialValue);
    return new ColorController$3(args.document, {
      colorType: args.params.colorType,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createColorObjectFormatter$3(
        supportsAlpha,
        args.params.colorType,
      ),
      parser: createColorStringParser$3("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
createPlugin$3({
  id: "input-color-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    if (params.view === "text") {
      return null;
    }
    const format = detectStringColorFormat$3(value, extractColorType$3(params));
    if (!format) {
      return null;
    }
    const stringifier = findColorStringifier$3(format);
    if (!stringifier) {
      return null;
    }
    const result = parseColorInputParams$3(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            format,
            stringifier,
          }),
        }
      : null;
  },
  binding: {
    reader: () => readIntColorString$3,
    equals: equalsColor$3,
    writer: (args) => {
      const writer = createColorStringWriter$3(args.params.format);
      if (!writer) {
        throw TpError$3.notBindable();
      }
      return writer;
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$3(args.document, {
      colorType: args.params.format.type,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: args.params.stringifier,
      parser: createColorStringParser$3("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.format.alpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let PointNdConstraint$3 = class PointNdConstraint4 {
  constructor(config) {
    this.components = config.components;
    this.asm_ = config.assembly;
  }
  constrain(value) {
    const comps = this.asm_.toComponents(value).map((comp, index) => {
      var _a, _b;
      return (_b =
        (_a = this.components[index]) === null || _a === void 0
          ? void 0
          : _a.constrain(comp)) !== null && _b !== void 0
        ? _b
        : comp;
    });
    return this.asm_.fromComponents(comps);
  }
};
const cn$5$3 = ClassName$3("pndtxt");
let PointNdTextView$3 = class PointNdTextView4 {
  constructor(doc, config) {
    this.textViews = config.textViews;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$5$3());
    this.textViews.forEach((v) => {
      const axisElem = doc.createElement("div");
      axisElem.classList.add(cn$5$3("a"));
      axisElem.appendChild(v.element);
      this.element.appendChild(axisElem);
    });
  }
};
function createAxisController$3(doc, config, index) {
  return new NumberTextController$3(doc, {
    arrayPosition:
      index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
    parser: config.parser,
    props: config.axes[index].textProps,
    value: createValue$3(0, {
      constraint: config.axes[index].constraint,
    }),
    viewProps: config.viewProps,
  });
}
let PointNdTextController$3 = class PointNdTextController4 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.acs_ = config.axes.map((_, index) =>
      createAxisController$3(doc, config, index),
    );
    this.acs_.forEach((c, index) => {
      connectValues$3({
        primary: this.value,
        secondary: c.value,
        forward: (p) => config.assembly.toComponents(p)[index],
        backward: (p, s) => {
          const comps = config.assembly.toComponents(p);
          comps[index] = s;
          return config.assembly.fromComponents(comps);
        },
      });
    });
    this.view = new PointNdTextView$3(doc, {
      textViews: this.acs_.map((ac) => ac.view),
    });
  }
  get textControllers() {
    return this.acs_;
  }
};
let SliderInputBindingApi$3 = class SliderInputBindingApi4 extends BindingApi$3 {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.sliderController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(max) {
    this.controller.valueController.sliderController.props.set("min", max);
  }
};
function createConstraint$4$3(params, initialValue) {
  const constraints = [];
  const sc = createStepConstraint$3(params, initialValue);
  if (sc) {
    constraints.push(sc);
  }
  const rc = createRangeConstraint$3(params);
  if (rc) {
    constraints.push(rc);
  }
  const lc = createListConstraint$3(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$3(constraints);
}
createPlugin$3({
  id: "input-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$3(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser$3(p)), {
        options: p.optional.custom(parseListOptions$3),
        readonly: p.optional.constant(false),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown$3,
    constraint: (args) => createConstraint$4$3(args.params, args.initialValue),
    writer: (_args) => writePrimitive$3,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$3(c, ListConstraint$3);
    if (lc) {
      return new ListController$3(args.document, {
        props: new ValueMap$3({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    const textPropsObj = createNumberTextPropsObject$3(
      args.params,
      value.rawValue,
    );
    const drc = c && findConstraint$3(c, DefiniteRangeConstraint$3);
    if (drc) {
      return new SliderTextController$3(
        args.document,
        Object.assign(
          Object.assign(
            {},
            createSliderTextProps$3(
              Object.assign(Object.assign({}, textPropsObj), {
                keyScale: createValue$3(textPropsObj.keyScale),
                max: drc.values.value("max"),
                min: drc.values.value("min"),
              }),
            ),
          ),
          { parser: parseNumber$3, value, viewProps: args.viewProps },
        ),
      );
    }
    return new NumberTextController$3(args.document, {
      parser: parseNumber$3,
      props: ValueMap$3.fromObject(textPropsObj),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "number") {
      return null;
    }
    if (args.controller.valueController instanceof SliderTextController$3) {
      return new SliderInputBindingApi$3(args.controller);
    }
    if (args.controller.valueController instanceof ListController$3) {
      return new ListInputBindingApi$3(args.controller);
    }
    return null;
  },
});
let Point2d$3 = class Point2d4 {
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(obj) {
    if (isEmpty$3(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    if (typeof x !== "number" || typeof y2 !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
    };
  }
};
const Point2dAssembly$3 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point2d$3(...comps),
};
const cn$4$3 = ClassName$3("p2d");
let Point2dView$3 = class Point2dView4 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$4$3());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$3(
      config.expanded,
      valueToClassName$3(this.element, cn$4$3(void 0, "expanded")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$4$3("h"));
    this.element.appendChild(headElem);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$4$3("b"));
    buttonElem.appendChild(createSvgIconElement$3(doc, "p2dpad"));
    config.viewProps.bindDisabled(buttonElem);
    headElem.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$4$3("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$4$3("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
const cn$3$3 = ClassName$3("p2dp");
let Point2dPickerView$3 = class Point2dPickerView4 {
  constructor(doc, config) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this);
    this.onPropsChange_ = this.onPropsChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onPropsChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$3$3());
    if (config.layout === "popup") {
      this.element.classList.add(cn$3$3(void 0, "p"));
    }
    config.viewProps.bindClassModifiers(this.element);
    const padElem = doc.createElement("div");
    padElem.classList.add(cn$3$3("p"));
    config.viewProps.bindTabIndex(padElem);
    this.element.appendChild(padElem);
    this.padElement = padElem;
    const svgElem = doc.createElementNS(SVG_NS$3, "svg");
    svgElem.classList.add(cn$3$3("g"));
    this.padElement.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const xAxisElem = doc.createElementNS(SVG_NS$3, "line");
    xAxisElem.classList.add(cn$3$3("ax"));
    xAxisElem.setAttributeNS(null, "x1", "0");
    xAxisElem.setAttributeNS(null, "y1", "50%");
    xAxisElem.setAttributeNS(null, "x2", "100%");
    xAxisElem.setAttributeNS(null, "y2", "50%");
    this.svgElem_.appendChild(xAxisElem);
    const yAxisElem = doc.createElementNS(SVG_NS$3, "line");
    yAxisElem.classList.add(cn$3$3("ax"));
    yAxisElem.setAttributeNS(null, "x1", "50%");
    yAxisElem.setAttributeNS(null, "y1", "0");
    yAxisElem.setAttributeNS(null, "x2", "50%");
    yAxisElem.setAttributeNS(null, "y2", "100%");
    this.svgElem_.appendChild(yAxisElem);
    const lineElem = doc.createElementNS(SVG_NS$3, "line");
    lineElem.classList.add(cn$3$3("l"));
    lineElem.setAttributeNS(null, "x1", "50%");
    lineElem.setAttributeNS(null, "y1", "50%");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$3$3("m"));
    this.padElement.appendChild(markerElem);
    this.markerElem_ = markerElem;
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [x, y2] = this.value.rawValue.getComponents();
    const max = this.props_.get("max");
    const px2 = mapRange$3(x, -max, +max, 0, 100);
    const py2 = mapRange$3(y2, -max, +max, 0, 100);
    const ipy = this.props_.get("invertsY") ? 100 - py2 : py2;
    this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
    this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
    this.markerElem_.style.left = `${px2}%`;
    this.markerElem_.style.top = `${ipy}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
};
function computeOffset$4(ev, keyScales, invertsY) {
  return [
    getStepForKey$3(keyScales[0], getHorizontalStepKeys$3(ev)),
    getStepForKey$3(keyScales[1], getVerticalStepKeys$3(ev)) *
      (invertsY ? 1 : -1),
  ];
}
let Point2dPickerController$3 = class Point2dPickerController4 {
  constructor(doc, config) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new Point2dPickerView$3(doc, {
      layout: config.layout,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$3(this.view.padElement);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
    this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const max = this.props.get("max");
    const px2 = mapRange$3(d.point.x, 0, d.bounds.width, -max, +max);
    const py2 = mapRange$3(
      this.props.get("invertsY") ? d.bounds.height - d.point.y : d.point.y,
      0,
      d.bounds.height,
      -max,
      +max,
    );
    this.value.setRawValue(new Point2d$3(px2, py2), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onPadKeyDown_(ev) {
    if (isArrowKey$3(ev.key)) {
      ev.preventDefault();
    }
    const [dx, dy] = computeOffset$4(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(
      new Point2d$3(this.value.rawValue.x + dx, this.value.rawValue.y + dy),
      {
        forceEmit: false,
        last: false,
      },
    );
  }
  onPadKeyUp_(ev) {
    const [dx, dy] = computeOffset$4(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let Point2dController$3 = class Point2dController4 {
  constructor(doc, config) {
    var _a, _b;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$3.create(config.expanded);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$3(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const padC = new Point2dPickerController$3(doc, {
      layout: config.pickerLayout,
      props: new ValueMap$3({
        invertsY: createValue$3(config.invertsY),
        max: createValue$3(config.max),
        xKeyScale: config.axes[0].textProps.value("keyScale"),
        yKeyScale: config.axes[1].textProps.value("keyScale"),
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    padC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = padC;
    this.textC_ = new PointNdTextController$3(doc, {
      assembly: Point2dAssembly$3,
      axes: config.axes,
      parser: config.parser,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new Point2dView$3(doc, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: config.pickerLayout,
      viewProps: this.viewProps,
    });
    this.view.textElement.appendChild(this.textC_.view.element);
    (_a = this.view.buttonElement) === null || _a === void 0
      ? void 0
      : _a.addEventListener("blur", this.onPadButtonBlur_);
    (_b = this.view.buttonElement) === null || _b === void 0
      ? void 0
      : _b.addEventListener("click", this.onPadButtonClick_);
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(this.pickerC_.view.element);
      connectValues$3({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$3(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$3(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$3(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.view.buttonElement &&
      !supportsTouch$3(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.view.buttonElement.focus();
      }
    }
  }
};
function point2dFromUnknown$3(value) {
  return Point2d$3.isObject(value)
    ? new Point2d$3(value.x, value.y)
    : new Point2d$3();
}
function writePoint2d$3(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
}
function createConstraint$3$3(params, initialValue) {
  return new PointNdConstraint$3({
    assembly: Point2dAssembly$3,
    components: [
      createDimensionConstraint$1$1(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$1$1(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
    ],
  });
}
function getSuitableMaxDimensionValue$3(params, rawValue) {
  var _a, _b;
  if (!isEmpty$3(params.min) || !isEmpty$3(params.max)) {
    return Math.max(
      Math.abs((_a = params.min) !== null && _a !== void 0 ? _a : 0),
      Math.abs((_b = params.max) !== null && _b !== void 0 ? _b : 0),
    );
  }
  const step = getSuitableKeyScale$3(params);
  return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
}
function getSuitableMax$3(params, initialValue) {
  var _a, _b;
  const xr = getSuitableMaxDimensionValue$3(
    deepMerge$3(params, (_a = params.x) !== null && _a !== void 0 ? _a : {}),
    initialValue.x,
  );
  const yr = getSuitableMaxDimensionValue$3(
    deepMerge$3(params, (_b = params.y) !== null && _b !== void 0 ? _b : {}),
    initialValue.y,
  );
  return Math.max(xr, yr);
}
function shouldInvertY$3(params) {
  if (!("y" in params)) {
    return false;
  }
  const yParams = params.y;
  if (!yParams) {
    return false;
  }
  return "inverted" in yParams ? !!yParams.inverted : false;
}
createPlugin$3({
  id: "input-point2d",
  type: "input",
  accept: (value, params) => {
    if (!Point2d$3.isObject(value)) {
      return null;
    }
    const result = parseRecord$3(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$3(p)), {
        expanded: p.optional.boolean,
        picker: p.optional.custom(parsePickerLayout$3),
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$3),
        y: p.optional.object(
          Object.assign(Object.assign({}, createPointDimensionParser$3(p)), {
            inverted: p.optional.boolean,
          }),
        ),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: () => point2dFromUnknown$3,
    constraint: (args) => createConstraint$3$3(args.params, args.initialValue),
    equals: Point2d$3.equals,
    writer: () => writePoint2d$3,
  },
  controller: (args) => {
    var _a, _b;
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y];
    return new Point2dController$3(doc, {
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a2;
        return createPointAxis$3({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$3(
            args.params,
            (_a2 = dParams[i]) !== null && _a2 !== void 0 ? _a2 : {},
          ),
        });
      }),
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      invertsY: shouldInvertY$3(args.params),
      max: getSuitableMax$3(args.params, value.rawValue),
      parser: parseNumber$3,
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point3d$3 = class Point3d4 {
  constructor(x = 0, y2 = 0, z = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(obj) {
    if (isEmpty$3(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
    };
  }
};
const Point3dAssembly$3 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point3d$3(...comps),
};
function point3dFromUnknown$3(value) {
  return Point3d$3.isObject(value)
    ? new Point3d$3(value.x, value.y, value.z)
    : new Point3d$3();
}
function writePoint3d$3(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
}
function createConstraint$2$3(params, initialValue) {
  return new PointNdConstraint$3({
    assembly: Point3dAssembly$3,
    components: [
      createDimensionConstraint$1$1(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$1$1(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$1$1(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
    ],
  });
}
createPlugin$3({
  id: "input-point3d",
  type: "input",
  accept: (value, params) => {
    if (!Point3d$3.isObject(value)) {
      return null;
    }
    const result = parseRecord$3(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$3(p)), {
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$3),
        y: p.optional.custom(parsePointDimensionParams$3),
        z: p.optional.custom(parsePointDimensionParams$3),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point3dFromUnknown$3,
    constraint: (args) => createConstraint$2$3(args.params, args.initialValue),
    equals: Point3d$3.equals,
    writer: (_args) => writePoint3d$3,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y, args.params.z];
    return new PointNdTextController$3(args.document, {
      assembly: Point3dAssembly$3,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$3({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$3(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$3,
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point4d$3 = class Point4d4 {
  constructor(x = 0, y2 = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
    this.w = w;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(obj) {
    if (isEmpty$3(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    const w = obj.w;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number" ||
      typeof w !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w,
    };
  }
};
const Point4dAssembly$3 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point4d$3(...comps),
};
function point4dFromUnknown$3(value) {
  return Point4d$3.isObject(value)
    ? new Point4d$3(value.x, value.y, value.z, value.w)
    : new Point4d$3();
}
function writePoint4d$3(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
  target.writeProperty("w", value.w);
}
function createConstraint$1$3(params, initialValue) {
  return new PointNdConstraint$3({
    assembly: Point4dAssembly$3,
    components: [
      createDimensionConstraint$1$1(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$1$1(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$1$1(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
      createDimensionConstraint$1$1(
        Object.assign(Object.assign({}, params), params.w),
        initialValue.w,
      ),
    ],
  });
}
createPlugin$3({
  id: "input-point4d",
  type: "input",
  accept: (value, params) => {
    if (!Point4d$3.isObject(value)) {
      return null;
    }
    const result = parseRecord$3(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$3(p)), {
        readonly: p.optional.constant(false),
        w: p.optional.custom(parsePointDimensionParams$3),
        x: p.optional.custom(parsePointDimensionParams$3),
        y: p.optional.custom(parsePointDimensionParams$3),
        z: p.optional.custom(parsePointDimensionParams$3),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point4dFromUnknown$3,
    constraint: (args) => createConstraint$1$3(args.params, args.initialValue),
    equals: Point4d$3.equals,
    writer: (_args) => writePoint4d$3,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [
      args.params.x,
      args.params.y,
      args.params.z,
      args.params.w,
    ];
    return new PointNdTextController$3(args.document, {
      assembly: Point4dAssembly$3,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$3({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$3(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$3,
      value,
      viewProps: args.viewProps,
    });
  },
});
function createConstraint$9(params) {
  const constraints = [];
  const lc = createListConstraint$3(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$3(constraints);
}
createPlugin$3({
  id: "input-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$3(params, (p) => ({
      readonly: p.optional.constant(false),
      options: p.optional.custom(parseListOptions$3),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$3,
    constraint: (args) => createConstraint$9(args.params),
    writer: (_args) => writePrimitive$3,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$3(c, ListConstraint$3);
    if (lc) {
      return new ListController$3(doc, {
        props: new ValueMap$3({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new TextController$3(doc, {
      parser: (v) => v,
      props: ValueMap$3.fromObject({
        formatter: formatString$3,
      }),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "string") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$3) {
      return new ListInputBindingApi$3(args.controller);
    }
    return null;
  },
});
const Constants$3 = {
  monitor: {
    defaultInterval: 200,
    defaultRows: 3,
  },
};
const cn$2$3 = ClassName$3("mll");
let MultiLogView$3 = class MultiLogView4 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$2$3());
    config.viewProps.bindClassModifiers(this.element);
    const textareaElem = doc.createElement("textarea");
    textareaElem.classList.add(cn$2$3("i"));
    textareaElem.style.height = `calc(var(${getCssVar$3("containerUnitSize")}) * ${config.rows})`;
    textareaElem.readOnly = true;
    config.viewProps.bindDisabled(textareaElem);
    this.element.appendChild(textareaElem);
    this.textareaElem_ = textareaElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const elem = this.textareaElem_;
    const shouldScroll =
      elem.scrollTop === elem.scrollHeight - elem.clientHeight;
    const lines = [];
    this.value.rawValue.forEach((value) => {
      if (value !== void 0) {
        lines.push(this.formatter_(value));
      }
    });
    elem.textContent = lines.join("\n");
    if (shouldScroll) {
      elem.scrollTop = elem.scrollHeight;
    }
  }
  onValueUpdate_() {
    this.update_();
  }
};
let MultiLogController$3 = class MultiLogController4 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new MultiLogView$3(doc, {
      formatter: config.formatter,
      rows: config.rows,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
const cn$1$3 = ClassName$3("sgl");
let SingleLogView$3 = class SingleLogView4 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$1$3());
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$1$3("i"));
    inputElem.readOnly = true;
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const values = this.value.rawValue;
    const lastValue = values[values.length - 1];
    this.inputElement.value =
      lastValue !== void 0 ? this.formatter_(lastValue) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
};
let SingleLogController$3 = class SingleLogController4 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SingleLogView$3(doc, {
      formatter: config.formatter,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
createPlugin$3({
  id: "monitor-bool",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$3(params, (p) => ({
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$3,
  },
  controller: (args) => {
    var _a;
    if (args.value.rawValue.length === 1) {
      return new SingleLogController$3(args.document, {
        formatter: BooleanFormatter$3,
        value: args.value,
        viewProps: args.viewProps,
      });
    }
    return new MultiLogController$3(args.document, {
      formatter: BooleanFormatter$3,
      rows:
        (_a = args.params.rows) !== null && _a !== void 0
          ? _a
          : Constants$3.monitor.defaultRows,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let GraphLogMonitorBindingApi$3 = class GraphLogMonitorBindingApi4 extends BindingApi$3 {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.props.set("min", min);
  }
};
const cn$t = ClassName$3("grl");
let GraphLogView$3 = class GraphLogView4 {
  constructor(doc, config) {
    this.onCursorChange_ = this.onCursorChange_.bind(this);
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$t());
    config.viewProps.bindClassModifiers(this.element);
    this.formatter_ = config.formatter;
    this.props_ = config.props;
    this.cursor_ = config.cursor;
    this.cursor_.emitter.on("change", this.onCursorChange_);
    const svgElem = doc.createElementNS(SVG_NS$3, "svg");
    svgElem.classList.add(cn$t("g"));
    svgElem.style.height = `calc(var(${getCssVar$3("containerUnitSize")}) * ${config.rows})`;
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const lineElem = doc.createElementNS(SVG_NS$3, "polyline");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(cn$t("t"), ClassName$3("tt")());
    this.element.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const bounds = this.svgElem_.getBoundingClientRect();
    const maxIndex = this.value.rawValue.length - 1;
    const min = this.props_.get("min");
    const max = this.props_.get("max");
    const points = [];
    this.value.rawValue.forEach((v, index) => {
      if (v === void 0) {
        return;
      }
      const x = mapRange$3(index, 0, maxIndex, 0, bounds.width);
      const y2 = mapRange$3(v, min, max, bounds.height, 0);
      points.push([x, y2].join(","));
    });
    this.lineElem_.setAttributeNS(null, "points", points.join(" "));
    const tooltipElem = this.tooltipElem_;
    const value = this.value.rawValue[this.cursor_.rawValue];
    if (value === void 0) {
      tooltipElem.classList.remove(cn$t("t", "a"));
      return;
    }
    const tx = mapRange$3(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
    const ty = mapRange$3(value, min, max, bounds.height, 0);
    tooltipElem.style.left = `${tx}px`;
    tooltipElem.style.top = `${ty}px`;
    tooltipElem.textContent = `${this.formatter_(value)}`;
    if (!tooltipElem.classList.contains(cn$t("t", "a"))) {
      tooltipElem.classList.add(cn$t("t", "a"), cn$t("t", "in"));
      forceReflow$3(tooltipElem);
      tooltipElem.classList.remove(cn$t("t", "in"));
    }
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
};
let GraphLogController$3 = class GraphLogController4 {
  constructor(doc, config) {
    this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.cursor_ = createValue$3(-1);
    this.view = new GraphLogView$3(doc, {
      cursor: this.cursor_,
      formatter: config.formatter,
      rows: config.rows,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    if (!supportsTouch$3(doc)) {
      this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
      this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    } else {
      const ph = new PointerHandler$3(this.view.element);
      ph.emitter.on("down", this.onGraphPointerDown_);
      ph.emitter.on("move", this.onGraphPointerMove_);
      ph.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(state) {
    return importBladeState$3(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        this.props.set("max", result.max);
        this.props.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$3(null, {
      max: this.props.get("max"),
      min: this.props.get("min"),
    });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(ev) {
    const bounds = this.view.element.getBoundingClientRect();
    this.cursor_.rawValue = Math.floor(
      mapRange$3(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length),
    );
  }
  onGraphPointerDown_(ev) {
    this.onGraphPointerMove_(ev);
  }
  onGraphPointerMove_(ev) {
    if (!ev.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(
      mapRange$3(
        ev.data.point.x,
        0,
        ev.data.bounds.width,
        0,
        this.value.rawValue.length,
      ),
    );
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
};
function createFormatter$5(params) {
  return !isEmpty$3(params.format) ? params.format : createNumberFormatter$3(2);
}
function createTextMonitor$3(args) {
  var _a;
  if (args.value.rawValue.length === 1) {
    return new SingleLogController$3(args.document, {
      formatter: createFormatter$5(args.params),
      value: args.value,
      viewProps: args.viewProps,
    });
  }
  return new MultiLogController$3(args.document, {
    formatter: createFormatter$5(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$3.monitor.defaultRows,
    value: args.value,
    viewProps: args.viewProps,
  });
}
function createGraphMonitor$3(args) {
  var _a, _b, _c;
  return new GraphLogController$3(args.document, {
    formatter: createFormatter$5(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$3.monitor.defaultRows,
    props: ValueMap$3.fromObject({
      max: (_b = args.params.max) !== null && _b !== void 0 ? _b : 100,
      min: (_c = args.params.min) !== null && _c !== void 0 ? _c : 0,
    }),
    value: args.value,
    viewProps: args.viewProps,
  });
}
function shouldShowGraph$3(params) {
  return params.view === "graph";
}
createPlugin$3({
  id: "monitor-number",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$3(params, (p) => ({
      format: p.optional.function,
      max: p.optional.number,
      min: p.optional.number,
      readonly: p.required.constant(true),
      rows: p.optional.number,
      view: p.optional.string,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    defaultBufferSize: (params) => (shouldShowGraph$3(params) ? 64 : 1),
    reader: (_args) => numberFromUnknown$3,
  },
  controller: (args) => {
    if (shouldShowGraph$3(args.params)) {
      return createGraphMonitor$3(args);
    }
    return createTextMonitor$3(args);
  },
  api: (args) => {
    if (args.controller.valueController instanceof GraphLogController$3) {
      return new GraphLogMonitorBindingApi$3(args.controller);
    }
    return null;
  },
});
createPlugin$3({
  id: "monitor-string",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$3(params, (p) => ({
      multiline: p.optional.boolean,
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$3,
  },
  controller: (args) => {
    var _a;
    const value = args.value;
    const multiline = value.rawValue.length > 1 || args.params.multiline;
    if (multiline) {
      return new MultiLogController$3(args.document, {
        formatter: formatString$3,
        rows:
          (_a = args.params.rows) !== null && _a !== void 0
            ? _a
            : Constants$3.monitor.defaultRows,
        value,
        viewProps: args.viewProps,
      });
    }
    return new SingleLogController$3(args.document, {
      formatter: formatString$3,
      value,
      viewProps: args.viewProps,
    });
  },
});
class Rotation {
  multiply(b) {
    return this.format(this.quat.multiply(b.quat));
  }
  premultiply(a) {
    return this.format(a.multiply(this));
  }
  slerp(b, t) {
    return this.format(this.quat.slerp(b.quat, t));
  }
}
function clamp(x, l, h) {
  return Math.min(Math.max(x, l), h);
}
function lofi(x, d) {
  return Math.floor(x / d) * d;
}
function mod(x, d) {
  return x - lofi(x, d);
}
function sanitizeAngle(angle) {
  return mod(angle + Math.PI, Math.PI * 2) - Math.PI;
}
class Euler2 extends Rotation {
  static fromQuaternion(quat, order, unit) {
    const m = quat.toMat3();
    const [i, j, k, sign2] =
      order === "XYZ"
        ? [0, 1, 2, 1]
        : order === "XZY"
          ? [0, 2, 1, -1]
          : order === "YXZ"
            ? [1, 0, 2, -1]
            : order === "YZX"
              ? [1, 2, 0, 1]
              : order === "ZXY"
                ? [2, 0, 1, 1]
                : [2, 1, 0, -1];
    const result = [0, 0, 0];
    const c = m[k + i * 3];
    result[j] = -sign2 * Math.asin(clamp(c, -1, 1));
    if (Math.abs(c) < 0.999999) {
      result[i] = sign2 * Math.atan2(m[k + j * 3], m[k * 4]);
      result[k] = sign2 * Math.atan2(m[j + i * 3], m[i * 4]);
    } else {
      result[i] = sign2 * Math.atan2(-m[j + k * 3], m[j * 4]);
    }
    if (Math.abs(result[i]) + Math.abs(result[k]) > Math.PI) {
      result[i] = sanitizeAngle(result[i] + Math.PI);
      result[j] = sanitizeAngle(Math.PI - result[j]);
      result[k] = sanitizeAngle(result[k] + Math.PI);
    }
    return new Euler2(...result, order).reunit(unit);
  }
  constructor(x, y2, z, order, unit) {
    super();
    this.x = x !== null && x !== void 0 ? x : 0;
    this.y = y2 !== null && y2 !== void 0 ? y2 : 0;
    this.z = z !== null && z !== void 0 ? z : 0;
    this.order = order !== null && order !== void 0 ? order : "XYZ";
    this.unit = unit !== null && unit !== void 0 ? unit : "rad";
  }
  get quat() {
    return Quaternion2.fromEuler(this);
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  toEuler(order, unit) {
    return this.reorder(order).reunit(unit);
  }
  format(r) {
    if (r instanceof Euler2) {
      return r.reorder(this.order);
    }
    return r.toEuler(this.order, this.unit);
  }
  reorder(order) {
    if (order === this.order) {
      return this;
    }
    return this.quat.toEuler(order, this.unit);
  }
  reunit(unit) {
    const prev2Rad = {
      deg: Math.PI / 180,
      rad: 1,
      turn: 2 * Math.PI,
    }[this.unit];
    const rad2Next = {
      deg: 180 / Math.PI,
      rad: 1,
      turn: 0.5 / Math.PI,
    }[unit];
    const prev2Next = prev2Rad * rad2Next;
    return new Euler2(
      prev2Next * this.x,
      prev2Next * this.y,
      prev2Next * this.z,
      this.order,
      unit,
    );
  }
}
class Quaternion2 extends Rotation {
  static fromAxisAngle(axis, angle) {
    const halfAngle = angle / 2;
    const sinHalfAngle = Math.sin(halfAngle);
    return new Quaternion2(
      axis.x * sinHalfAngle,
      axis.y * sinHalfAngle,
      axis.z * sinHalfAngle,
      Math.cos(halfAngle),
    );
  }
  static fromEuler(eulerr) {
    const euler = eulerr.reunit("rad");
    const [i, j, k, sign2] =
      euler.order === "XYZ"
        ? [0, 1, 2, 1]
        : euler.order === "XZY"
          ? [0, 2, 1, -1]
          : euler.order === "YXZ"
            ? [1, 0, 2, -1]
            : euler.order === "YZX"
              ? [1, 2, 0, 1]
              : euler.order === "ZXY"
                ? [2, 0, 1, 1]
                : [2, 1, 0, -1];
    const compo = euler.getComponents();
    const ti = 0.5 * compo[i];
    const tj = 0.5 * sign2 * compo[j];
    const tk = 0.5 * compo[k];
    const ci = Math.cos(ti);
    const cj = Math.cos(tj);
    const ck = Math.cos(tk);
    const si = Math.sin(ti);
    const sj = Math.sin(tj);
    const sk = Math.sin(tk);
    const result = [0, 0, 0, ck * cj * ci + sk * sj * si];
    result[i] = ck * cj * si - sk * sj * ci;
    result[j] = sign2 * (ck * sj * ci + sk * cj * si);
    result[k] = sk * cj * ci - ck * sj * si;
    return new Quaternion2(...result);
  }
  static lookRotation(look, up) {
    const { normal, tangent, binormal } = look.orthoNormalize(up);
    const m11 = binormal.x;
    const m12 = tangent.x;
    const m13 = normal.x;
    const m21 = binormal.y;
    const m22 = tangent.y;
    const m23 = normal.y;
    const m31 = binormal.z;
    const m32 = tangent.z;
    const m33 = normal.z;
    const trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      return new Quaternion2(
        (m32 - m23) * s,
        (m13 - m31) * s,
        (m21 - m12) * s,
        0.25 / s,
      );
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      return new Quaternion2(
        0.25 * s,
        (m12 + m21) / s,
        (m13 + m31) / s,
        (m32 - m23) / s,
      );
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      return new Quaternion2(
        (m12 + m21) / s,
        0.25 * s,
        (m23 + m32) / s,
        (m13 - m31) / s,
      );
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      return new Quaternion2(
        (m13 + m31) / s,
        (m23 + m32) / s,
        0.25 * s,
        (m21 - m12) / s,
      );
    }
  }
  constructor(x, y2, z, w) {
    super();
    this.x = x !== null && x !== void 0 ? x : 0;
    this.y = y2 !== null && y2 !== void 0 ? y2 : 0;
    this.z = z !== null && z !== void 0 ? z : 0;
    this.w = w !== null && w !== void 0 ? w : 1;
  }
  get quat() {
    return this;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  toEuler(order, unit) {
    return Euler2.fromQuaternion(this, order, unit);
  }
  get lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  get length() {
    return Math.sqrt(this.lengthSq);
  }
  get normalized() {
    const l = this.length;
    if (l === 0) {
      return new Quaternion2();
    }
    return new Quaternion2(this.x / l, this.y / l, this.z / l, this.w / l);
  }
  get negated() {
    return new Quaternion2(-this.x, -this.y, -this.z, -this.w);
  }
  get ban360s() {
    return this.w < 0 ? this.negated : this;
  }
  multiply(br) {
    const b = br.quat;
    return new Quaternion2(
      this.w * b.x + this.x * b.w + this.y * b.z - this.z * b.y,
      this.w * b.y - this.x * b.z + this.y * b.w + this.z * b.x,
      this.w * b.z + this.x * b.y - this.y * b.x + this.z * b.w,
      this.w * b.w - this.x * b.x - this.y * b.y - this.z * b.z,
    );
  }
  format(r) {
    return r.quat;
  }
  slerp(br, t) {
    let b = br.quat;
    if (t === 0) {
      return this;
    }
    if (t === 1) {
      return b;
    }
    const a = this.ban360s;
    b = b.ban360s;
    let cosHalfTheta = a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z;
    if (cosHalfTheta < 0) {
      b = b.negated;
      cosHalfTheta = -cosHalfTheta;
    }
    if (cosHalfTheta >= 1) {
      return a;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      return new Quaternion2(
        s * a.x + t * b.x,
        s * a.y + t * b.y,
        s * a.z + t * b.z,
        s * a.w + t * b.w,
      ).normalized;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
    const ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    return new Quaternion2(
      a.x * ratioA + b.x * ratioB,
      a.y * ratioA + b.y * ratioB,
      a.z * ratioA + b.z * ratioB,
      a.w * ratioA + b.w * ratioB,
    );
  }
  toMat3() {
    const { x, y: y2, z, w } = this;
    return [
      1 - 2 * y2 * y2 - 2 * z * z,
      2 * x * y2 + 2 * z * w,
      2 * x * z - 2 * y2 * w,
      2 * x * y2 - 2 * z * w,
      1 - 2 * x * x - 2 * z * z,
      2 * y2 * z + 2 * x * w,
      2 * x * z + 2 * y2 * w,
      2 * y2 * z - 2 * x * w,
      1 - 2 * x * x - 2 * y2 * y2,
    ];
  }
}
class PointProjector {
  constructor() {
    this.offset = [0, 0, -5];
    this.fov = 30;
    this.aspect = 1;
    this.viewport = [0, 0, 1, 1];
  }
  project(v) {
    const vcx = (this.viewport[0] + this.viewport[2]) * 0.5;
    const vcy = (this.viewport[1] + this.viewport[3]) * 0.5;
    const vw = this.viewport[2] - this.viewport[0];
    const vh = this.viewport[3] - this.viewport[1];
    const p = 1 / Math.tan((this.fov * Math.PI) / 360);
    const sz = -(v.z + this.offset[2]);
    const sx =
      vcx + (((v.x + this.offset[0]) / sz) * p * vw * 0.5) / this.aspect;
    const sy = vcy - ((v.y + this.offset[1]) / sz) * p * vh * 0.5;
    return [sx, sy];
  }
}
class SVGLineStrip {
  constructor(doc, vertices, projector) {
    this.element = doc.createElementNS(SVG_NS$3, "path");
    this.vertices = vertices;
    this.projector = projector;
  }
  /**
   * Make sure rotation is normalized!
   */
  setRotation(rotation) {
    let pathStr = "";
    this.vertices.forEach((vertex2, iVertex) => {
      const transformed = vertex2.applyQuaternion(rotation);
      const [sx, sy] = this.projector.project(transformed);
      const cmd = iVertex === 0 ? "M" : "L";
      pathStr += `${cmd}${sx} ${sy}`;
    });
    this.element.setAttributeNS(null, "d", pathStr);
    return this;
  }
}
class Vector32 {
  constructor(x, y2, z) {
    this.x = x !== null && x !== void 0 ? x : 0;
    this.y = y2 !== null && y2 !== void 0 ? y2 : 0;
    this.z = z !== null && z !== void 0 ? z : 0;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  get lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  get length() {
    return Math.sqrt(this.lengthSq);
  }
  get normalized() {
    const l = this.length;
    if (l === 0) {
      return new Vector32();
    }
    return new Vector32(this.x / l, this.y / l, this.z / l);
  }
  get negated() {
    return new Vector32(-this.x, -this.y, -this.z);
  }
  add(v) {
    return new Vector32(this.x + v.x, this.y + v.y, this.z + v.z);
  }
  sub(v) {
    return new Vector32(this.x - v.x, this.y - v.y, this.z - v.z);
  }
  scale(s) {
    return new Vector32(this.x * s, this.y * s, this.z * s);
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  cross(v) {
    return new Vector32(
      this.y * v.z - this.z * v.y,
      this.z * v.x - this.x * v.z,
      this.x * v.y - this.y * v.x,
    );
  }
  orthoNormalize(tangent) {
    const normal = this.normalized;
    tangent = tangent.normalized;
    let dotNT = normal.dot(tangent);
    if (dotNT === 1) {
      if (Math.abs(normal.y) > Math.abs(normal.z)) {
        tangent = new Vector32(0, 0, 1);
      } else {
        tangent = new Vector32(0, 1, 0);
      }
      dotNT = normal.dot(tangent);
    }
    tangent = tangent.sub(normal.scale(dotNT)).normalized;
    const binormal = tangent.cross(normal);
    return {
      normal,
      tangent,
      binormal,
    };
  }
  applyQuaternion(q) {
    const ix = q.w * this.x + q.y * this.z - q.z * this.y;
    const iy = q.w * this.y + q.z * this.x - q.x * this.z;
    const iz = q.w * this.z + q.x * this.y - q.y * this.x;
    const iw = -q.x * this.x - q.y * this.y - q.z * this.z;
    return new Vector32(
      ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y,
      iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z,
      iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x,
    );
  }
}
function createArcRotation(axis, front) {
  const b =
    front.z > 0 ? new Quaternion2(0, 0, 0, 1) : new Quaternion2(0, 0, 1, 0);
  if (Math.abs(axis.z) > 0.9999) {
    return b;
  }
  return Quaternion2.lookRotation(axis, front);
}
function createArcVerticesArray(
  thetaStart,
  thetaLength,
  segments,
  cosAxis,
  sinAxis,
  radius = 1,
) {
  const vertices = [];
  for (let i = 0; i < segments; i++) {
    const t = thetaStart + (thetaLength * i) / (segments - 1);
    const vector = new Vector32();
    vector[cosAxis] = radius * Math.cos(t);
    vector[sinAxis] = radius * Math.sin(t);
    vertices.push(vector);
  }
  return vertices;
}
const className$2$1 = ClassName$3("rotationgizmo");
const VEC3_ZERO = new Vector32(0, 0, 0);
const VEC3_XP$2 = new Vector32(1, 0, 0);
const VEC3_YP$2 = new Vector32(0, 1, 0);
const VEC3_ZP$2 = new Vector32(0, 0, 1);
const VEC3_ZN = new Vector32(0, 0, -1);
const VEC3_XP70 = new Vector32(0.7, 0, 0);
const VEC3_YP70 = new Vector32(0, 0.7, 0);
const VEC3_ZP70 = new Vector32(0, 0, 0.7);
const VEC3_XN70 = new Vector32(-0.7, 0, 0);
const VEC3_YN70 = new Vector32(0, -0.7, 0);
const VEC3_ZN70 = new Vector32(0, 0, -0.7);
const QUAT_IDENTITY$2 = new Quaternion2(0, 0, 0, 1);
function createLabel(doc, circleClass, labelText) {
  const label = doc.createElementNS(SVG_NS$3, "g");
  const circle = doc.createElementNS(SVG_NS$3, "circle");
  circle.classList.add(className$2$1(circleClass));
  circle.setAttributeNS(null, "cx", "0");
  circle.setAttributeNS(null, "cy", "0");
  circle.setAttributeNS(null, "r", "8");
  label.appendChild(circle);
  const text = doc.createElementNS(SVG_NS$3, "text");
  text.classList.add(className$2$1("labeltext"));
  text.setAttributeNS(null, "y", "4");
  text.setAttributeNS(null, "text-anchor", "middle");
  text.setAttributeNS(null, "font-size", "10");
  text.textContent = labelText;
  label.appendChild(text);
  return label;
}
class RotationInputGizmoView {
  get xArcBElement() {
    return this.xArcBC_.element;
  }
  get yArcBElement() {
    return this.yArcBC_.element;
  }
  get zArcBElement() {
    return this.zArcBC_.element;
  }
  get xArcFElement() {
    return this.xArcFC_.element;
  }
  get yArcFElement() {
    return this.yArcFC_.element;
  }
  get zArcFElement() {
    return this.zArcFC_.element;
  }
  get rArcElement() {
    return this.rArcC_.element;
  }
  constructor(doc, config) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.onModeChange_ = this.onModeChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(className$2$1());
    if (config.pickerLayout === "popup") {
      this.element.classList.add(className$2$1(void 0, "p"));
    }
    const padElem = doc.createElement("div");
    padElem.classList.add(className$2$1("p"));
    config.viewProps.bindTabIndex(padElem);
    this.element.appendChild(padElem);
    this.padElement = padElem;
    const svgElem = doc.createElementNS(SVG_NS$3, "svg");
    svgElem.classList.add(className$2$1("g"));
    this.padElement.appendChild(svgElem);
    this.svgElem_ = svgElem;
    this.projector_ = new PointProjector();
    this.projector_.viewport = [0, 0, 136, 136];
    const arcArray = createArcVerticesArray(0, Math.PI, 33, "x", "y");
    const arcArrayR = createArcVerticesArray(0, 2 * Math.PI, 65, "x", "y", 1.1);
    this.xArcB_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.xArcB_.element.classList.add(className$2$1("arcx"));
    this.svgElem_.appendChild(this.xArcB_.element);
    this.yArcB_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.yArcB_.element.classList.add(className$2$1("arcy"));
    this.svgElem_.appendChild(this.yArcB_.element);
    this.zArcB_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.zArcB_.element.classList.add(className$2$1("arcz"));
    this.svgElem_.appendChild(this.zArcB_.element);
    this.xArcBC_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.xArcBC_.element.classList.add(className$2$1("arcc"));
    this.svgElem_.appendChild(this.xArcBC_.element);
    this.yArcBC_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.yArcBC_.element.classList.add(className$2$1("arcc"));
    this.svgElem_.appendChild(this.yArcBC_.element);
    this.zArcBC_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.zArcBC_.element.classList.add(className$2$1("arcc"));
    this.svgElem_.appendChild(this.zArcBC_.element);
    const axesElem = doc.createElementNS(SVG_NS$3, "g");
    svgElem.classList.add(className$2$1("axes"));
    this.svgElem_.appendChild(axesElem);
    this.axesElem_ = axesElem;
    this.xAxis_ = new SVGLineStrip(
      doc,
      [VEC3_ZERO, VEC3_XP70],
      this.projector_,
    );
    this.xAxis_.element.classList.add(className$2$1("axisx"));
    this.axesElem_.appendChild(this.xAxis_.element);
    this.yAxis_ = new SVGLineStrip(
      doc,
      [VEC3_ZERO, VEC3_YP70],
      this.projector_,
    );
    this.yAxis_.element.classList.add(className$2$1("axisy"));
    this.axesElem_.appendChild(this.yAxis_.element);
    this.zAxis_ = new SVGLineStrip(
      doc,
      [VEC3_ZERO, VEC3_ZP70],
      this.projector_,
    );
    this.zAxis_.element.classList.add(className$2$1("axisz"));
    this.axesElem_.appendChild(this.zAxis_.element);
    this.xnAxis_ = new SVGLineStrip(
      doc,
      [VEC3_ZERO, VEC3_XN70],
      this.projector_,
    );
    this.xnAxis_.element.classList.add(className$2$1("axisn"));
    this.axesElem_.appendChild(this.xnAxis_.element);
    this.ynAxis_ = new SVGLineStrip(
      doc,
      [VEC3_ZERO, VEC3_YN70],
      this.projector_,
    );
    this.ynAxis_.element.classList.add(className$2$1("axisn"));
    this.axesElem_.appendChild(this.ynAxis_.element);
    this.znAxis_ = new SVGLineStrip(
      doc,
      [VEC3_ZERO, VEC3_ZN70],
      this.projector_,
    );
    this.znAxis_.element.classList.add(className$2$1("axisn"));
    this.axesElem_.appendChild(this.znAxis_.element);
    this.xArcF_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.xArcF_.element.classList.add(className$2$1("arcx"));
    this.svgElem_.appendChild(this.xArcF_.element);
    this.yArcF_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.yArcF_.element.classList.add(className$2$1("arcy"));
    this.svgElem_.appendChild(this.yArcF_.element);
    this.zArcF_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.zArcF_.element.classList.add(className$2$1("arcz"));
    this.svgElem_.appendChild(this.zArcF_.element);
    this.xArcFC_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.xArcFC_.element.classList.add(className$2$1("arcc"));
    this.svgElem_.appendChild(this.xArcFC_.element);
    this.yArcFC_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.yArcFC_.element.classList.add(className$2$1("arcc"));
    this.svgElem_.appendChild(this.yArcFC_.element);
    this.zArcFC_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.zArcFC_.element.classList.add(className$2$1("arcc"));
    this.svgElem_.appendChild(this.zArcFC_.element);
    this.rArc_ = new SVGLineStrip(doc, arcArrayR, this.projector_);
    this.rArc_.element.classList.add(className$2$1("arcr"));
    this.rArc_.setRotation(QUAT_IDENTITY$2);
    this.svgElem_.appendChild(this.rArc_.element);
    this.rArcC_ = new SVGLineStrip(doc, arcArrayR, this.projector_);
    this.rArcC_.element.classList.add(className$2$1("arcc"));
    this.rArcC_.setRotation(QUAT_IDENTITY$2);
    this.svgElem_.appendChild(this.rArcC_.element);
    const labelsElem = doc.createElementNS(SVG_NS$3, "g");
    svgElem.classList.add(className$2$1("labels"));
    this.svgElem_.appendChild(labelsElem);
    this.labelsElem_ = labelsElem;
    this.xLabel = createLabel(doc, "labelcirclex", "X");
    this.labelsElem_.appendChild(this.xLabel);
    this.yLabel = createLabel(doc, "labelcircley", "Y");
    this.labelsElem_.appendChild(this.yLabel);
    this.zLabel = createLabel(doc, "labelcirclez", "Z");
    this.labelsElem_.appendChild(this.zLabel);
    this.xnLabel = createLabel(doc, "labelcirclen", "-X");
    this.labelsElem_.appendChild(this.xnLabel);
    this.ynLabel = createLabel(doc, "labelcirclen", "-Y");
    this.labelsElem_.appendChild(this.ynLabel);
    this.znLabel = createLabel(doc, "labelcirclen", "-Z");
    this.labelsElem_.appendChild(this.znLabel);
    const onHoverXArc = () => {
      this.xArcB_.element.classList.add(className$2$1("arcx_hover"));
      this.xArcF_.element.classList.add(className$2$1("arcx_hover"));
    };
    const onLeaveXArc = () => {
      this.xArcB_.element.classList.remove(className$2$1("arcx_hover"));
      this.xArcF_.element.classList.remove(className$2$1("arcx_hover"));
    };
    this.xArcBC_.element.addEventListener("mouseenter", onHoverXArc);
    this.xArcBC_.element.addEventListener("mouseleave", onLeaveXArc);
    this.xArcFC_.element.addEventListener("mouseenter", onHoverXArc);
    this.xArcFC_.element.addEventListener("mouseleave", onLeaveXArc);
    const onHoverYArc = () => {
      this.yArcB_.element.classList.add(className$2$1("arcy_hover"));
      this.yArcF_.element.classList.add(className$2$1("arcy_hover"));
    };
    const onLeaveYArc = () => {
      this.yArcB_.element.classList.remove(className$2$1("arcy_hover"));
      this.yArcF_.element.classList.remove(className$2$1("arcy_hover"));
    };
    this.yArcBC_.element.addEventListener("mouseenter", onHoverYArc);
    this.yArcBC_.element.addEventListener("mouseleave", onLeaveYArc);
    this.yArcFC_.element.addEventListener("mouseenter", onHoverYArc);
    this.yArcFC_.element.addEventListener("mouseleave", onLeaveYArc);
    const onHoverZArc = () => {
      this.zArcB_.element.classList.add(className$2$1("arcz_hover"));
      this.zArcF_.element.classList.add(className$2$1("arcz_hover"));
    };
    const onLeaveZArc = () => {
      this.zArcB_.element.classList.remove(className$2$1("arcz_hover"));
      this.zArcF_.element.classList.remove(className$2$1("arcz_hover"));
    };
    this.zArcBC_.element.addEventListener("mouseenter", onHoverZArc);
    this.zArcBC_.element.addEventListener("mouseleave", onLeaveZArc);
    this.zArcFC_.element.addEventListener("mouseenter", onHoverZArc);
    this.zArcFC_.element.addEventListener("mouseleave", onLeaveZArc);
    const onHoverRArc = () => {
      this.rArc_.element.classList.add(className$2$1("arcr_hover"));
    };
    const onLeaveRArc = () => {
      this.rArc_.element.classList.remove(className$2$1("arcr_hover"));
    };
    this.rArcC_.element.addEventListener("mouseenter", onHoverRArc);
    this.rArcC_.element.addEventListener("mouseleave", onLeaveRArc);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    config.mode.emitter.on("change", this.onModeChange_);
    this.mode_ = config.mode;
    this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const q = this.value.rawValue.quat.normalized;
    this.xAxis_.setRotation(q);
    this.yAxis_.setRotation(q);
    this.zAxis_.setRotation(q);
    this.xnAxis_.setRotation(q);
    this.ynAxis_.setRotation(q);
    this.znAxis_.setRotation(q);
    const xp = VEC3_XP$2.applyQuaternion(q);
    const yp = VEC3_YP$2.applyQuaternion(q);
    const zp = VEC3_ZP$2.applyQuaternion(q);
    const xn = xp.negated;
    const yn = yp.negated;
    const zn = zp.negated;
    [
      { el: this.xAxis_.element, v: xp },
      { el: this.yAxis_.element, v: yp },
      { el: this.zAxis_.element, v: zp },
      { el: this.xnAxis_.element, v: xn },
      { el: this.ynAxis_.element, v: yn },
      { el: this.znAxis_.element, v: zn },
    ]
      .map(({ el, v }) => {
        this.axesElem_.removeChild(el);
        return { el, v };
      })
      .sort((a, b) => a.v.z - b.v.z)
      .forEach(({ el }) => {
        this.axesElem_.appendChild(el);
      });
    this.xArcB_.setRotation(createArcRotation(xp, VEC3_ZN));
    this.yArcB_.setRotation(createArcRotation(yp, VEC3_ZN));
    this.zArcB_.setRotation(createArcRotation(zp, VEC3_ZN));
    this.xArcBC_.setRotation(createArcRotation(xp, VEC3_ZN));
    this.yArcBC_.setRotation(createArcRotation(yp, VEC3_ZN));
    this.zArcBC_.setRotation(createArcRotation(zp, VEC3_ZN));
    this.xArcF_.setRotation(createArcRotation(xp, VEC3_ZP$2));
    this.yArcF_.setRotation(createArcRotation(yp, VEC3_ZP$2));
    this.zArcF_.setRotation(createArcRotation(zp, VEC3_ZP$2));
    this.xArcFC_.setRotation(createArcRotation(xp, VEC3_ZP$2));
    this.yArcFC_.setRotation(createArcRotation(yp, VEC3_ZP$2));
    this.zArcFC_.setRotation(createArcRotation(zp, VEC3_ZP$2));
    [
      { el: this.xLabel, v: VEC3_XP70 },
      { el: this.yLabel, v: VEC3_YP70 },
      { el: this.zLabel, v: VEC3_ZP70 },
      { el: this.xnLabel, v: VEC3_XN70 },
      { el: this.ynLabel, v: VEC3_YN70 },
      { el: this.znLabel, v: VEC3_ZN70 },
    ].forEach(({ el, v }) => {
      const [x, y2] = this.projector_.project(v.applyQuaternion(q));
      el.setAttributeNS(null, "transform", `translate( ${x}, ${y2} )`);
    });
    [
      { el: this.xLabel, v: xp },
      { el: this.yLabel, v: yp },
      { el: this.zLabel, v: zp },
      { el: this.xnLabel, v: xn },
      { el: this.ynLabel, v: yn },
      { el: this.znLabel, v: zn },
    ]
      .map(({ el, v }) => {
        this.labelsElem_.removeChild(el);
        return { el, v };
      })
      .sort((a, b) => a.v.z - b.v.z)
      .forEach(({ el }) => {
        this.labelsElem_.appendChild(el);
      });
  }
  onValueChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
  onModeChange_() {
    const mode = this.mode_.rawValue;
    const x = mode === "angle-x" ? "add" : "remove";
    const y2 = mode === "angle-y" ? "add" : "remove";
    const z = mode === "angle-z" ? "add" : "remove";
    const r = mode === "angle-r" ? "add" : "remove";
    this.xArcB_.element.classList[x](className$2$1("arcx_active"));
    this.yArcB_.element.classList[y2](className$2$1("arcy_active"));
    this.zArcB_.element.classList[z](className$2$1("arcz_active"));
    this.xArcF_.element.classList[x](className$2$1("arcx_active"));
    this.yArcF_.element.classList[y2](className$2$1("arcy_active"));
    this.zArcF_.element.classList[z](className$2$1("arcz_active"));
    this.rArc_.element.classList[r](className$2$1("arcr_active"));
  }
}
function saturate$1(x) {
  return clamp(x, 0, 1);
}
function iikanjiEaseout(x) {
  if (x <= 0) {
    return 0;
  }
  if (x >= 1) {
    return 1;
  }
  const xt = 1 - x;
  const y2 = xt * (xt * (xt * (xt * (xt * (xt * (xt * -6 + 7))))));
  return saturate$1(1 - y2);
}
function linearstep(a, b, x) {
  return saturate$1((x - a) / (b - a));
}
const INV_SQRT2 = 1 / Math.sqrt(2);
const VEC3_XP$1 = new Vector32(1, 0, 0);
const VEC3_YP$1 = new Vector32(0, 1, 0);
const VEC3_ZP$1 = new Vector32(0, 0, 1);
const QUAT_IDENTITY$1 = new Quaternion2(0, 0, 0, 1);
const QUAT_TOP = new Quaternion2(INV_SQRT2, 0, 0, INV_SQRT2);
const QUAT_RIGHT = new Quaternion2(0, -INV_SQRT2, 0, INV_SQRT2);
const QUAT_BOTTOM = new Quaternion2(-INV_SQRT2, 0, 0, INV_SQRT2);
const QUAT_LEFT = new Quaternion2(0, INV_SQRT2, 0, INV_SQRT2);
const QUAT_BACK = new Quaternion2(0, 1, 0, 0);
class RotationInputGizmoController {
  constructor(doc, config) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.mode_ = createValue$3("free");
    this.view = new RotationInputGizmoView(doc, {
      value: this.value,
      mode: this.mode_,
      viewProps: this.viewProps,
      pickerLayout: config.pickerLayout,
    });
    this.ptHandler_ = new PointerHandler$3(this.view.padElement);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
    const ptHandlerXArcB = new PointerHandler$3(this.view.xArcBElement);
    ptHandlerXArcB.emitter.on("down", () =>
      this.changeModeIfNotAuto_("angle-x"),
    );
    ptHandlerXArcB.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
    const ptHandlerXArcF = new PointerHandler$3(this.view.xArcFElement);
    ptHandlerXArcF.emitter.on("down", () =>
      this.changeModeIfNotAuto_("angle-x"),
    );
    ptHandlerXArcF.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
    const ptHandlerYArcB = new PointerHandler$3(this.view.yArcBElement);
    ptHandlerYArcB.emitter.on("down", () =>
      this.changeModeIfNotAuto_("angle-y"),
    );
    ptHandlerYArcB.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
    const ptHandlerYArcF = new PointerHandler$3(this.view.yArcFElement);
    ptHandlerYArcF.emitter.on("down", () =>
      this.changeModeIfNotAuto_("angle-y"),
    );
    ptHandlerYArcF.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
    const ptHandlerZArcB = new PointerHandler$3(this.view.zArcBElement);
    ptHandlerZArcB.emitter.on("down", () =>
      this.changeModeIfNotAuto_("angle-z"),
    );
    ptHandlerZArcB.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
    const ptHandlerZArcF = new PointerHandler$3(this.view.zArcFElement);
    ptHandlerZArcF.emitter.on("down", () =>
      this.changeModeIfNotAuto_("angle-z"),
    );
    ptHandlerZArcF.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
    const ptHandlerRArc = new PointerHandler$3(this.view.rArcElement);
    ptHandlerRArc.emitter.on("down", () =>
      this.changeModeIfNotAuto_("angle-r"),
    );
    ptHandlerRArc.emitter.on("up", () => this.changeModeIfNotAuto_("free"));
    [
      { el: this.view.xLabel, q: QUAT_RIGHT },
      { el: this.view.yLabel, q: QUAT_TOP },
      { el: this.view.zLabel, q: QUAT_IDENTITY$1 },
      { el: this.view.xnLabel, q: QUAT_LEFT },
      { el: this.view.ynLabel, q: QUAT_BOTTOM },
      { el: this.view.znLabel, q: QUAT_BACK },
    ].forEach(({ el, q }) => {
      const ptHandler = new PointerHandler$3(el);
      ptHandler.emitter.on("down", () => this.autoRotate_(q));
    });
    this.px_ = null;
    this.py_ = null;
    this.angleState_ = null;
  }
  handlePointerEvent_(d) {
    if (!d.point) {
      return;
    }
    const mode = this.mode_.rawValue;
    const x = d.point.x;
    const y2 = d.point.y;
    if (mode === "auto");
    else if (mode === "free") {
      if (this.px_ != null && this.py_ != null) {
        const dx = x - this.px_;
        const dy = y2 - this.py_;
        const l = Math.sqrt(dx * dx + dy * dy);
        if (l === 0) {
          return;
        }
        const axis = new Vector32(dy / l, dx / l, 0);
        const quat = Quaternion2.fromAxisAngle(axis, l / 68);
        this.value.rawValue = this.value.rawValue.premultiply(quat);
      }
      this.px_ = x;
      this.py_ = y2;
    } else if (mode === "angle-r") {
      const cx = d.bounds.width / 2;
      const cy = d.bounds.height / 2;
      const angle = Math.atan2(y2 - cy, x - cx);
      if (this.angleState_ == null) {
        const axis = new Vector32(0, 0, 1);
        this.angleState_ = {
          initialRotation: this.value.rawValue,
          initialAngle: angle,
          axis,
          reverseAngle: true,
        };
      } else {
        const { initialRotation, initialAngle, axis } = this.angleState_;
        const angleDiff = -sanitizeAngle(angle - initialAngle);
        const quat = Quaternion2.fromAxisAngle(axis, angleDiff);
        this.value.rawValue = initialRotation.premultiply(quat);
      }
    } else {
      const cx = d.bounds.width / 2;
      const cy = d.bounds.height / 2;
      const angle = Math.atan2(y2 - cy, x - cx);
      if (this.angleState_ == null) {
        const axis =
          mode === "angle-x"
            ? VEC3_XP$1
            : mode === "angle-y"
              ? VEC3_YP$1
              : VEC3_ZP$1;
        const reverseAngle =
          axis.applyQuaternion(this.value.rawValue.quat).z > 0;
        this.angleState_ = {
          initialRotation: this.value.rawValue,
          initialAngle: angle,
          axis,
          reverseAngle,
        };
      } else {
        const { initialRotation, initialAngle, axis, reverseAngle } =
          this.angleState_;
        let angleDiff = sanitizeAngle(angle - initialAngle);
        angleDiff = reverseAngle ? -angleDiff : angleDiff;
        const quat = Quaternion2.fromAxisAngle(axis, angleDiff);
        this.value.rawValue = initialRotation.multiply(quat);
      }
    }
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data);
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data);
  }
  onPointerUp_() {
    this.px_ = null;
    this.py_ = null;
    this.angleState_ = null;
  }
  onPadKeyDown_(ev) {
    if (isArrowKey$3(ev.key)) {
      ev.preventDefault();
    }
    const x = getStepForKey$3(1, getHorizontalStepKeys$3(ev));
    const y2 = getStepForKey$3(1, getVerticalStepKeys$3(ev));
    if (x !== 0 || y2 !== 0) {
      const axis = new Vector32(-y2, x, 0);
      const quat = Quaternion2.fromAxisAngle(axis, Math.PI / 16);
      this.value.rawValue = this.value.rawValue.premultiply(quat);
    }
  }
  changeModeIfNotAuto_(mode) {
    if (this.mode_.rawValue !== "auto") {
      this.mode_.rawValue = mode;
    }
  }
  autoRotate_(to) {
    this.mode_.rawValue = "auto";
    const from = this.value.rawValue;
    const beginTime = Date.now();
    const update2 = () => {
      const now2 = Date.now();
      const t = iikanjiEaseout(linearstep(0, 300, now2 - beginTime));
      this.value.rawValue = from.slerp(to, t);
      if (t === 1) {
        this.mode_.rawValue = "free";
        return;
      }
      requestAnimationFrame(update2);
    };
    requestAnimationFrame(update2);
  }
}
const className$1$1 = ClassName$3("rotationswatch");
const VEC3_XP = new Vector32(1, 0, 0);
const VEC3_YP = new Vector32(0, 1, 0);
const VEC3_ZP = new Vector32(0, 0, 1);
const QUAT_IDENTITY = new Quaternion2(0, 0, 0, 1);
class RotationInputSwatchView {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.element = doc.createElement("div");
    this.element.classList.add(className$1$1());
    config.viewProps.bindClassModifiers(this.element);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(className$1$1("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const svgElem = doc.createElementNS(SVG_NS$3, "svg");
    svgElem.classList.add(className$1$1("g"));
    buttonElem.appendChild(svgElem);
    this.svgElem_ = svgElem;
    this.projector_ = new PointProjector();
    this.projector_.viewport = [0, 0, 20, 20];
    const arcArray = createArcVerticesArray(0, Math.PI, 33, "x", "y");
    const arcArrayR = createArcVerticesArray(0, 2 * Math.PI, 65, "x", "y");
    this.rArc_ = new SVGLineStrip(doc, arcArrayR, this.projector_);
    this.rArc_.element.classList.add(className$1$1("arcr"));
    svgElem.appendChild(this.rArc_.element);
    this.rArc_.setRotation(QUAT_IDENTITY);
    this.xArc_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.xArc_.element.classList.add(className$1$1("arc"));
    svgElem.appendChild(this.xArc_.element);
    this.yArc_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.yArc_.element.classList.add(className$1$1("arc"));
    svgElem.appendChild(this.yArc_.element);
    this.zArc_ = new SVGLineStrip(doc, arcArray, this.projector_);
    this.zArc_.element.classList.add(className$1$1("arc"));
    svgElem.appendChild(this.zArc_.element);
    this.update_();
  }
  update_() {
    const q = this.value.rawValue.quat.normalized;
    const xp = VEC3_XP.applyQuaternion(q);
    const yp = VEC3_YP.applyQuaternion(q);
    const zp = VEC3_ZP.applyQuaternion(q);
    this.xArc_.setRotation(createArcRotation(xp, VEC3_ZP));
    this.yArc_.setRotation(createArcRotation(yp, VEC3_ZP));
    this.zArc_.setRotation(createArcRotation(zp, VEC3_ZP));
  }
  onValueChange_() {
    this.update_();
  }
}
class RotationInputSwatchController {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new RotationInputSwatchView(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
}
const className$3 = ClassName$3("rotation");
class RotationInputView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(className$3());
    config.foldable.bindExpandedClass(
      this.element,
      className$3(void 0, "expanded"),
    );
    bindValueMap$3(
      config.foldable,
      "completed",
      valueToClassName$3(this.element, className$3(void 0, "cpl")),
    );
    if (config.rotationMode === "quaternion") {
      this.element.classList.add(className$3("quat"));
    }
    const headElem = doc.createElement("div");
    headElem.classList.add(className$3("h"));
    this.element.appendChild(headElem);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(className$3("s"));
    headElem.appendChild(swatchElem);
    this.swatchElement = swatchElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(className$3("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(className$3("g"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
}
class RotationInputController {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$3.create(config.expanded);
    this.swatchC_ = new RotationInputSwatchController(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    const buttonElem = this.swatchC_.view.buttonElement;
    buttonElem.addEventListener("blur", this.onButtonBlur_);
    buttonElem.addEventListener("click", this.onButtonClick_);
    this.textC_ = new PointNdTextController$3(doc, {
      assembly: config.assembly,
      axes: config.axes,
      parser: config.parser,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new RotationInputView(doc, {
      rotationMode: config.rotationMode,
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout,
    });
    this.view.swatchElement.appendChild(this.swatchC_.view.element);
    this.view.textElement.appendChild(this.textC_.view.element);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$3(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const gizmoC = new RotationInputGizmoController(doc, {
      value: this.value,
      viewProps: this.viewProps,
      pickerLayout: config.pickerLayout,
    });
    gizmoC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.gizmoC_ = gizmoC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(gizmoC.view.element);
      connectValues$3({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.gizmoC_.view.element);
      bindFoldable$3(this.foldable_, this.view.pickerElement);
    }
  }
  onButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$3(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.gizmoC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$3(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.swatchC_.view.buttonElement &&
      !supportsTouch$3(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.swatchC_.view.buttonElement.focus();
      }
    }
  }
}
function createAxisEuler(digits, constraint) {
  const step = Math.pow(0.1, digits);
  return {
    baseStep: step,
    constraint,
    textProps: ValueMap$3.fromObject({
      formatter: createNumberFormatter$3(digits),
      keyScale: step,
      pointerScale: step,
    }),
  };
}
function createDimensionConstraint$3(params) {
  if (!params) {
    return void 0;
  }
  const constraints = [];
  if (!isEmpty$3(params.step)) {
    constraints.push(new StepConstraint$3(params.step));
  }
  if (!isEmpty$3(params.max) || !isEmpty$3(params.min)) {
    constraints.push(
      new RangeConstraint$3({
        max: params.max,
        min: params.min,
      }),
    );
  }
  return new CompositeConstraint$3(constraints);
}
function createEulerAssembly(order, unit) {
  return {
    toComponents: (r) => r.getComponents(),
    fromComponents: (c) => new Euler2(c[0], c[1], c[2], order, unit),
  };
}
function parseEuler(exValue, order, unit) {
  if (
    typeof (exValue === null || exValue === void 0 ? void 0 : exValue.x) ===
      "number" &&
    typeof (exValue === null || exValue === void 0 ? void 0 : exValue.y) ===
      "number" &&
    typeof (exValue === null || exValue === void 0 ? void 0 : exValue.z) ===
      "number"
  ) {
    return new Euler2(exValue.x, exValue.y, exValue.z, order, unit);
  } else {
    return new Euler2(0, 0, 0, order, unit);
  }
}
function parseEulerOrder(value) {
  switch (value) {
    case "XYZ":
    case "XZY":
    case "YXZ":
    case "YZX":
    case "ZXY":
    case "ZYX":
      return value;
    default:
      return void 0;
  }
}
function parseEulerUnit(value) {
  switch (value) {
    case "rad":
    case "deg":
    case "turn":
      return value;
    default:
      return void 0;
  }
}
createPlugin$3({
  id: "rotation",
  type: "input",
  accept(exValue, params) {
    var _a, _b;
    const result = parseRecord$3(params, (p) => ({
      view: p.required.constant("rotation"),
      label: p.optional.string,
      picker: p.optional.custom(parsePickerLayout$3),
      expanded: p.optional.boolean,
      rotationMode: p.required.constant("euler"),
      x: p.optional.custom(parsePointDimensionParams$3),
      y: p.optional.custom(parsePointDimensionParams$3),
      z: p.optional.custom(parsePointDimensionParams$3),
      order: p.optional.custom(parseEulerOrder),
      unit: p.optional.custom(parseEulerUnit),
    }));
    return result
      ? {
          initialValue: parseEuler(
            exValue,
            (_a = result.order) !== null && _a !== void 0 ? _a : "XYZ",
            (_b = result.unit) !== null && _b !== void 0 ? _b : "rad",
          ),
          params: result,
        }
      : null;
  },
  binding: {
    reader({ params }) {
      return (exValue) => {
        var _a, _b;
        return parseEuler(
          exValue,
          (_a = params.order) !== null && _a !== void 0 ? _a : "XYZ",
          (_b = params.unit) !== null && _b !== void 0 ? _b : "rad",
        );
      };
    },
    constraint({ params }) {
      var _a, _b;
      return new PointNdConstraint$3({
        assembly: createEulerAssembly(
          (_a = params.order) !== null && _a !== void 0 ? _a : "XYZ",
          (_b = params.unit) !== null && _b !== void 0 ? _b : "rad",
        ),
        components: [
          createDimensionConstraint$3("x" in params ? params.x : void 0),
          createDimensionConstraint$3("y" in params ? params.y : void 0),
          createDimensionConstraint$3("z" in params ? params.z : void 0),
        ],
      });
    },
    writer(_args) {
      return (target, inValue) => {
        target.writeProperty("x", inValue.x);
        target.writeProperty("y", inValue.y);
        target.writeProperty("z", inValue.z);
      };
    },
  },
  controller({ document: document2, value, constraint, params, viewProps }) {
    var _a, _b;
    if (!(constraint instanceof PointNdConstraint$3)) {
      throw TpError$3.shouldNeverHappen();
    }
    const expanded = "expanded" in params ? params.expanded : void 0;
    const picker = "picker" in params ? params.picker : void 0;
    const unit = (_a = params.unit) !== null && _a !== void 0 ? _a : "rad";
    const digits = {
      rad: 2,
      deg: 0,
      turn: 2,
    }[unit];
    return new RotationInputController(document2, {
      axes: [
        createAxisEuler(digits, constraint.components[0]),
        createAxisEuler(digits, constraint.components[1]),
        createAxisEuler(digits, constraint.components[2]),
      ],
      assembly: createEulerAssembly(
        (_b = params.order) !== null && _b !== void 0 ? _b : "XYZ",
        unit,
      ),
      rotationMode: "euler",
      expanded: expanded !== null && expanded !== void 0 ? expanded : false,
      parser: parseNumber$3,
      pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
      value,
      viewProps,
    });
  },
});
const QuaternionAssembly = {
  toComponents: (r) => [r.x, r.y, r.z, r.w],
  fromComponents: (c) => new Quaternion2(c[0], c[1], c[2], c[3]),
};
function createAxisQuaternion(constraint) {
  return {
    baseStep: 0.01,
    constraint,
    textProps: ValueMap$3.fromObject({
      formatter: (value) => {
        if (Math.abs(value) < 0.995) {
          return value.toFixed(2).replace("0.", ".");
        } else {
          return value.toFixed(1);
        }
      },
      keyScale: 0.01,
      pointerScale: 0.01,
    }),
  };
}
function parseQuaternion(exValue) {
  if (
    typeof (exValue === null || exValue === void 0 ? void 0 : exValue.x) ===
      "number" &&
    typeof (exValue === null || exValue === void 0 ? void 0 : exValue.y) ===
      "number" &&
    typeof (exValue === null || exValue === void 0 ? void 0 : exValue.z) ===
      "number" &&
    typeof (exValue === null || exValue === void 0 ? void 0 : exValue.w) ===
      "number"
  ) {
    return new Quaternion2(exValue.x, exValue.y, exValue.z, exValue.w);
  } else {
    return new Quaternion2(0, 0, 0, 1);
  }
}
createPlugin$3({
  id: "rotation",
  type: "input",
  accept(exValue, params) {
    const result = parseRecord$3(params, (p) => ({
      view: p.required.constant("rotation"),
      label: p.optional.string,
      picker: p.optional.custom(parsePickerLayout$3),
      expanded: p.optional.boolean,
      rotationMode: p.optional.constant("quaternion"),
      x: p.optional.custom(parsePointDimensionParams$3),
      y: p.optional.custom(parsePointDimensionParams$3),
      z: p.optional.custom(parsePointDimensionParams$3),
      w: p.optional.custom(parsePointDimensionParams$3),
    }));
    return result
      ? {
          initialValue: parseQuaternion(exValue),
          params: result,
        }
      : null;
  },
  binding: {
    reader(_args) {
      return (exValue) => {
        return parseQuaternion(exValue);
      };
    },
    constraint({ params }) {
      return new PointNdConstraint$3({
        assembly: QuaternionAssembly,
        components: [
          createDimensionConstraint$3("x" in params ? params.x : void 0),
          createDimensionConstraint$3("y" in params ? params.y : void 0),
          createDimensionConstraint$3("z" in params ? params.z : void 0),
          createDimensionConstraint$3("w" in params ? params.w : void 0),
        ],
      });
    },
    writer(_args) {
      return (target, inValue) => {
        target.writeProperty("x", inValue.x);
        target.writeProperty("y", inValue.y);
        target.writeProperty("z", inValue.z);
        target.writeProperty("w", inValue.w);
      };
    },
  },
  controller({ document: document2, value, constraint, params, viewProps }) {
    if (!(constraint instanceof PointNdConstraint$3)) {
      throw TpError$3.shouldNeverHappen();
    }
    const expanded = "expanded" in params ? params.expanded : void 0;
    const picker = "picker" in params ? params.picker : void 0;
    return new RotationInputController(document2, {
      axes: [
        createAxisQuaternion(constraint.components[0]),
        createAxisQuaternion(constraint.components[1]),
        createAxisQuaternion(constraint.components[2]),
        createAxisQuaternion(constraint.components[3]),
      ],
      assembly: QuaternionAssembly,
      rotationMode: "quaternion",
      expanded: expanded !== null && expanded !== void 0 ? expanded : false,
      parser: parseNumber$3,
      pickerLayout: picker !== null && picker !== void 0 ? picker : "popup",
      value,
      viewProps,
    });
  },
});
function forceCast$2(v) {
  return v;
}
function isEmpty$2(value) {
  return value === null || value === void 0;
}
function isObject$1$2(value) {
  return value !== null && typeof value === "object";
}
function isRecord$2(value) {
  return value !== null && typeof value === "object";
}
function deepEqualsArray$2(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (let i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
function deepMerge$2(r1, r2) {
  const keys = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(r1), ...Object.keys(r2)]),
  );
  return keys.reduce((result, key2) => {
    const v1 = r1[key2];
    const v2 = r2[key2];
    return isRecord$2(v1) && isRecord$2(v2)
      ? Object.assign(Object.assign({}, result), {
          [key2]: deepMerge$2(v1, v2),
        })
      : Object.assign(Object.assign({}, result), {
          [key2]: key2 in r2 ? v2 : v1,
        });
  }, {});
}
function isBinding$2(value) {
  if (!isObject$1$2(value)) {
    return false;
  }
  return "target" in value;
}
const CREATE_MESSAGE_MAP$2 = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (context) => `Invalid parameters for '${context.name}'`,
  nomatchingcontroller: (context) =>
    `No matching controller for '${context.key}'`,
  nomatchingview: (context) =>
    `No matching view for '${JSON.stringify(context.params)}'`,
  notbindable: () => `Value is not bindable`,
  notcompatible: (context) => `Not compatible with  plugin '${context.id}'`,
  propertynotfound: (context) => `Property '${context.name}' not found`,
  shouldneverhappen: () => "This error should never happen",
};
let TpError$2 = class TpError5 {
  static alreadyDisposed() {
    return new TpError5({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new TpError5({
      type: "notbindable",
    });
  }
  static notCompatible(bundleId, id) {
    return new TpError5({
      type: "notcompatible",
      context: {
        id: `${bundleId}.${id}`,
      },
    });
  }
  static propertyNotFound(name) {
    return new TpError5({
      type: "propertynotfound",
      context: {
        name,
      },
    });
  }
  static shouldNeverHappen() {
    return new TpError5({ type: "shouldneverhappen" });
  }
  constructor(config) {
    var _a;
    this.message =
      (_a = CREATE_MESSAGE_MAP$2[config.type](forceCast$2(config.context))) !==
        null && _a !== void 0
        ? _a
        : "Unexpected error";
    this.name = this.constructor.name;
    this.stack = new Error(this.message).stack;
    this.type = config.type;
  }
  toString() {
    return this.message;
  }
};
let BindingTarget$2 = class BindingTarget5 {
  constructor(obj, key2) {
    this.obj_ = obj;
    this.key = key2;
  }
  static isBindable(obj) {
    if (obj === null) {
      return false;
    }
    if (typeof obj !== "object" && typeof obj !== "function") {
      return false;
    }
    return true;
  }
  read() {
    return this.obj_[this.key];
  }
  write(value) {
    this.obj_[this.key] = value;
  }
  writeProperty(name, value) {
    const valueObj = this.read();
    if (!BindingTarget5.isBindable(valueObj)) {
      throw TpError$2.notBindable();
    }
    if (!(name in valueObj)) {
      throw TpError$2.propertyNotFound(name);
    }
    valueObj[name] = value;
  }
};
let Emitter$2 = class Emitter5 {
  constructor() {
    this.observers_ = {};
  }
  on(eventName, handler, opt_options) {
    var _a;
    let observers = this.observers_[eventName];
    if (!observers) {
      observers = this.observers_[eventName] = [];
    }
    observers.push({
      handler,
      key:
        (_a =
          opt_options === null || opt_options === void 0
            ? void 0
            : opt_options.key) !== null && _a !== void 0
          ? _a
          : handler,
    });
    return this;
  }
  off(eventName, key2) {
    const observers = this.observers_[eventName];
    if (observers) {
      this.observers_[eventName] = observers.filter((observer) => {
        return observer.key !== key2;
      });
    }
    return this;
  }
  emit(eventName, event) {
    const observers = this.observers_[eventName];
    if (!observers) {
      return;
    }
    observers.forEach((observer) => {
      observer.handler(event);
    });
  }
};
let ComplexValue$2 = class ComplexValue5 {
  constructor(initialValue, config) {
    var _a;
    this.constraint_ =
      config === null || config === void 0 ? void 0 : config.constraint;
    this.equals_ =
      (_a = config === null || config === void 0 ? void 0 : config.equals) !==
        null && _a !== void 0
        ? _a
        : (v1, v2) => v1 === v2;
    this.emitter = new Emitter$2();
    this.rawValue_ = initialValue;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(rawValue) {
    this.setRawValue(rawValue, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(rawValue, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const constrainedValue = this.constraint_
      ? this.constraint_.constrain(rawValue)
      : rawValue;
    const prevValue = this.rawValue_;
    const changed = !this.equals_(prevValue, constrainedValue);
    if (!changed && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.rawValue_ = constrainedValue;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: constrainedValue,
      sender: this,
    });
  }
};
let PrimitiveValue$2 = class PrimitiveValue5 {
  constructor(initialValue) {
    this.emitter = new Emitter$2();
    this.value_ = initialValue;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(value) {
    this.setRawValue(value, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(value, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const prevValue = this.value_;
    if (prevValue === value && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.value_ = value;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: this.value_,
      sender: this,
    });
  }
};
let ReadonlyPrimitiveValue$2 = class ReadonlyPrimitiveValue5 {
  constructor(value) {
    this.emitter = new Emitter$2();
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value_ = value;
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit(
      "beforechange",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
  onValueChange_(ev) {
    this.emitter.emit(
      "change",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
};
function createValue$2(initialValue, config) {
  const constraint =
    config === null || config === void 0 ? void 0 : config.constraint;
  const equals2 = config === null || config === void 0 ? void 0 : config.equals;
  if (!constraint && !equals2) {
    return new PrimitiveValue$2(initialValue);
  }
  return new ComplexValue$2(initialValue, config);
}
function createReadonlyValue$2(value) {
  return [
    new ReadonlyPrimitiveValue$2(value),
    (rawValue, options) => {
      value.setRawValue(rawValue, options);
    },
  ];
}
let ValueMap$2 = class ValueMap5 {
  constructor(valueMap) {
    this.emitter = new Emitter$2();
    this.valMap_ = valueMap;
    for (const key2 in this.valMap_) {
      const v = this.valMap_[key2];
      v.emitter.on("change", () => {
        this.emitter.emit("change", {
          key: key2,
          sender: this,
        });
      });
    }
  }
  static createCore(initialValue) {
    const keys = Object.keys(initialValue);
    return keys.reduce((o, key2) => {
      return Object.assign(o, {
        [key2]: createValue$2(initialValue[key2]),
      });
    }, {});
  }
  static fromObject(initialValue) {
    const core = this.createCore(initialValue);
    return new ValueMap5(core);
  }
  get(key2) {
    return this.valMap_[key2].rawValue;
  }
  set(key2, value) {
    this.valMap_[key2].rawValue = value;
  }
  value(key2) {
    return this.valMap_[key2];
  }
};
let DefiniteRangeConstraint$2 = class DefiniteRangeConstraint5 {
  constructor(config) {
    this.values = ValueMap$2.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    return Math.min(Math.max(value, min), max);
  }
};
let RangeConstraint$2 = class RangeConstraint5 {
  constructor(config) {
    this.values = ValueMap$2.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    let result = value;
    if (!isEmpty$2(min)) {
      result = Math.max(result, min);
    }
    if (!isEmpty$2(max)) {
      result = Math.min(result, max);
    }
    return result;
  }
};
let StepConstraint$2 = class StepConstraint5 {
  constructor(step, origin = 0) {
    this.step = step;
    this.origin = origin;
  }
  constrain(value) {
    const o = this.origin % this.step;
    const r = Math.round((value - o) / this.step);
    return o + r * this.step;
  }
};
let NumberLiteralNode$2 = class NumberLiteralNode5 {
  constructor(text) {
    this.text = text;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
};
const BINARY_OPERATION_MAP$2 = {
  "**": (v1, v2) => Math.pow(v1, v2),
  "*": (v1, v2) => v1 * v2,
  "/": (v1, v2) => v1 / v2,
  "%": (v1, v2) => v1 % v2,
  "+": (v1, v2) => v1 + v2,
  "-": (v1, v2) => v1 - v2,
  "<<": (v1, v2) => v1 << v2,
  ">>": (v1, v2) => v1 >> v2,
  ">>>": (v1, v2) => v1 >>> v2,
  "&": (v1, v2) => v1 & v2,
  "^": (v1, v2) => v1 ^ v2,
  "|": (v1, v2) => v1 | v2,
};
let BinaryOperationNode$2 = class BinaryOperationNode5 {
  constructor(operator, left, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  evaluate() {
    const op = BINARY_OPERATION_MAP$2[this.operator];
    if (!op) {
      throw new Error(`unexpected binary operator: '${this.operator}`);
    }
    return op(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")",
    ].join(" ");
  }
};
const UNARY_OPERATION_MAP$2 = {
  "+": (v) => v,
  "-": (v) => -v,
  "~": (v) => ~v,
};
let UnaryOperationNode$2 = class UnaryOperationNode5 {
  constructor(operator, expr) {
    this.operator = operator;
    this.expression = expr;
  }
  evaluate() {
    const op = UNARY_OPERATION_MAP$2[this.operator];
    if (!op) {
      throw new Error(`unexpected unary operator: '${this.operator}`);
    }
    return op(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
};
function combineReader$2(parsers) {
  return (text, cursor) => {
    for (let i = 0; i < parsers.length; i++) {
      const result = parsers[i](text, cursor);
      if (result !== "") {
        return result;
      }
    }
    return "";
  };
}
function readWhitespace$2(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^\s+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readNonZeroDigit$2(text, cursor) {
  const ch = text.substr(cursor, 1);
  return ch.match(/^[1-9]$/) ? ch : "";
}
function readDecimalDigits$2(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readSignedInteger$2(text, cursor) {
  const ds = readDecimalDigits$2(text, cursor);
  if (ds !== "") {
    return ds;
  }
  const sign2 = text.substr(cursor, 1);
  cursor += 1;
  if (sign2 !== "-" && sign2 !== "+") {
    return "";
  }
  const sds = readDecimalDigits$2(text, cursor);
  if (sds === "") {
    return "";
  }
  return sign2 + sds;
}
function readExponentPart$2(text, cursor) {
  const e = text.substr(cursor, 1);
  cursor += 1;
  if (e.toLowerCase() !== "e") {
    return "";
  }
  const si = readSignedInteger$2(text, cursor);
  if (si === "") {
    return "";
  }
  return e + si;
}
function readDecimalIntegerLiteral$2(text, cursor) {
  const ch = text.substr(cursor, 1);
  if (ch === "0") {
    return ch;
  }
  const nzd = readNonZeroDigit$2(text, cursor);
  cursor += nzd.length;
  if (nzd === "") {
    return "";
  }
  return nzd + readDecimalDigits$2(text, cursor);
}
function readDecimalLiteral1$2(text, cursor) {
  const dil = readDecimalIntegerLiteral$2(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$2(text, cursor);
  cursor += dds.length;
  return dil + dot2 + dds + readExponentPart$2(text, cursor);
}
function readDecimalLiteral2$2(text, cursor) {
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$2(text, cursor);
  cursor += dds.length;
  if (dds === "") {
    return "";
  }
  return dot2 + dds + readExponentPart$2(text, cursor);
}
function readDecimalLiteral3$2(text, cursor) {
  const dil = readDecimalIntegerLiteral$2(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  return dil + readExponentPart$2(text, cursor);
}
const readDecimalLiteral$2 = combineReader$2([
  readDecimalLiteral1$2,
  readDecimalLiteral2$2,
  readDecimalLiteral3$2,
]);
function parseBinaryDigits$2(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[01]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readBinaryIntegerLiteral$2(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0b") {
    return "";
  }
  const bds = parseBinaryDigits$2(text, cursor);
  if (bds === "") {
    return "";
  }
  return prefix + bds;
}
function readOctalDigits$2(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-7]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readOctalIntegerLiteral$2(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0o") {
    return "";
  }
  const ods = readOctalDigits$2(text, cursor);
  if (ods === "") {
    return "";
  }
  return prefix + ods;
}
function readHexDigits$2(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9a-f]+/i);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readHexIntegerLiteral$2(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0x") {
    return "";
  }
  const hds = readHexDigits$2(text, cursor);
  if (hds === "") {
    return "";
  }
  return prefix + hds;
}
const readNonDecimalIntegerLiteral$2 = combineReader$2([
  readBinaryIntegerLiteral$2,
  readOctalIntegerLiteral$2,
  readHexIntegerLiteral$2,
]);
const readNumericLiteral$2 = combineReader$2([
  readNonDecimalIntegerLiteral$2,
  readDecimalLiteral$2,
]);
function parseLiteral$2(text, cursor) {
  const num = readNumericLiteral$2(text, cursor);
  cursor += num.length;
  if (num === "") {
    return null;
  }
  return {
    evaluable: new NumberLiteralNode$2(num),
    cursor,
  };
}
function parseParenthesizedExpression$2(text, cursor) {
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "(") {
    return null;
  }
  const expr = parseExpression$2(text, cursor);
  if (!expr) {
    return null;
  }
  cursor = expr.cursor;
  cursor += readWhitespace$2(text, cursor).length;
  const cl = text.substr(cursor, 1);
  cursor += cl.length;
  if (cl !== ")") {
    return null;
  }
  return {
    evaluable: expr.evaluable,
    cursor,
  };
}
function parsePrimaryExpression$2(text, cursor) {
  var _a;
  return (_a = parseLiteral$2(text, cursor)) !== null && _a !== void 0
    ? _a
    : parseParenthesizedExpression$2(text, cursor);
}
function parseUnaryExpression$2(text, cursor) {
  const expr = parsePrimaryExpression$2(text, cursor);
  if (expr) {
    return expr;
  }
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "+" && op !== "-" && op !== "~") {
    return null;
  }
  const num = parseUnaryExpression$2(text, cursor);
  if (!num) {
    return null;
  }
  cursor = num.cursor;
  return {
    cursor,
    evaluable: new UnaryOperationNode$2(op, num.evaluable),
  };
}
function readBinaryOperator$2(ops, text, cursor) {
  cursor += readWhitespace$2(text, cursor).length;
  const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
  if (!op) {
    return null;
  }
  cursor += op.length;
  cursor += readWhitespace$2(text, cursor).length;
  return {
    cursor,
    operator: op,
  };
}
function createBinaryOperationExpressionParser$2(exprParser, ops) {
  return (text, cursor) => {
    const firstExpr = exprParser(text, cursor);
    if (!firstExpr) {
      return null;
    }
    cursor = firstExpr.cursor;
    let expr = firstExpr.evaluable;
    for (;;) {
      const op = readBinaryOperator$2(ops, text, cursor);
      if (!op) {
        break;
      }
      cursor = op.cursor;
      const nextExpr = exprParser(text, cursor);
      if (!nextExpr) {
        return null;
      }
      cursor = nextExpr.cursor;
      expr = new BinaryOperationNode$2(op.operator, expr, nextExpr.evaluable);
    }
    return expr
      ? {
          cursor,
          evaluable: expr,
        }
      : null;
  };
}
const parseBinaryOperationExpression$2 = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"],
].reduce((parser, ops) => {
  return createBinaryOperationExpressionParser$2(parser, ops);
}, parseUnaryExpression$2);
function parseExpression$2(text, cursor) {
  cursor += readWhitespace$2(text, cursor).length;
  return parseBinaryOperationExpression$2(text, cursor);
}
function parseEcmaNumberExpression$2(text) {
  const expr = parseExpression$2(text, 0);
  if (!expr) {
    return null;
  }
  const cursor = expr.cursor + readWhitespace$2(text, expr.cursor).length;
  if (cursor !== text.length) {
    return null;
  }
  return expr.evaluable;
}
function parseNumber$2(text) {
  var _a;
  const r = parseEcmaNumberExpression$2(text);
  return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null &&
    _a !== void 0
    ? _a
    : null;
}
function numberFromUnknown$2(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const pv = parseNumber$2(value);
    if (!isEmpty$2(pv)) {
      return pv;
    }
  }
  return 0;
}
function createNumberFormatter$2(digits) {
  return (value) => {
    return value.toFixed(Math.max(Math.min(digits, 20), 0));
  };
}
function mapRange$2(value, start1, end1, start2, end2) {
  const p = (value - start1) / (end1 - start1);
  return start2 + p * (end2 - start2);
}
function getDecimalDigits$2(value) {
  const text = String(value.toFixed(10));
  const frac = text.split(".")[1];
  return frac.replace(/0+$/, "").length;
}
function constrainRange$2(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function loopRange$2(value, max) {
  return ((value % max) + max) % max;
}
function getSuitableDecimalDigits$2(params, rawValue) {
  return !isEmpty$2(params.step)
    ? getDecimalDigits$2(params.step)
    : Math.max(getDecimalDigits$2(rawValue), 2);
}
function getSuitableKeyScale$2(params) {
  var _a;
  return (_a = params.step) !== null && _a !== void 0 ? _a : 1;
}
function getSuitablePointerScale$2(params, rawValue) {
  var _a;
  const base2 = Math.abs(
    (_a = params.step) !== null && _a !== void 0 ? _a : rawValue,
  );
  return base2 === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base2)) - 1);
}
function createStepConstraint$2(params, initialValue) {
  if (!isEmpty$2(params.step)) {
    return new StepConstraint$2(params.step, initialValue);
  }
  return null;
}
function createRangeConstraint$2(params) {
  if (!isEmpty$2(params.max) && !isEmpty$2(params.min)) {
    return new DefiniteRangeConstraint$2({
      max: params.max,
      min: params.min,
    });
  }
  if (!isEmpty$2(params.max) || !isEmpty$2(params.min)) {
    return new RangeConstraint$2({
      max: params.max,
      min: params.min,
    });
  }
  return null;
}
function createNumberTextPropsObject$2(params, initialValue) {
  var _a, _b, _c;
  return {
    formatter:
      (_a = params.format) !== null && _a !== void 0
        ? _a
        : createNumberFormatter$2(
            getSuitableDecimalDigits$2(params, initialValue),
          ),
    keyScale:
      (_b = params.keyScale) !== null && _b !== void 0
        ? _b
        : getSuitableKeyScale$2(params),
    pointerScale:
      (_c = params.pointerScale) !== null && _c !== void 0
        ? _c
        : getSuitablePointerScale$2(params, initialValue),
  };
}
function createNumberTextInputParamsParser$2(p) {
  return {
    format: p.optional.function,
    keyScale: p.optional.number,
    max: p.optional.number,
    min: p.optional.number,
    pointerScale: p.optional.number,
    step: p.optional.number,
  };
}
function createPointAxis$2(config) {
  return {
    constraint: config.constraint,
    textProps: ValueMap$2.fromObject(
      createNumberTextPropsObject$2(config.params, config.initialValue),
    ),
  };
}
let BladeApi$2 = class BladeApi5 {
  constructor(controller) {
    this.controller = controller;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller.viewProps.set("disabled", disabled);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(hidden) {
    this.controller.viewProps.set("hidden", hidden);
  }
  dispose() {
    this.controller.viewProps.set("disposed", true);
  }
  importState(state) {
    return this.controller.importState(state);
  }
  exportState() {
    return this.controller.exportState();
  }
};
let TpEvent$2 = class TpEvent5 {
  constructor(target) {
    this.target = target;
  }
};
let TpChangeEvent$2 = class TpChangeEvent5 extends TpEvent$2 {
  constructor(target, value, last) {
    super(target);
    this.value = value;
    this.last = last !== null && last !== void 0 ? last : true;
  }
};
let TpFoldEvent$2 = class TpFoldEvent5 extends TpEvent$2 {
  constructor(target, expanded) {
    super(target);
    this.expanded = expanded;
  }
};
let TpTabSelectEvent$2 = class TpTabSelectEvent5 extends TpEvent$2 {
  constructor(target, index) {
    super(target);
    this.index = index;
  }
};
class TpMouseEvent extends TpEvent$2 {
  constructor(target, nativeEvent) {
    super(target);
    this.native = nativeEvent;
  }
}
let BindingApi$2 = class BindingApi5 extends BladeApi$2 {
  constructor(controller) {
    super(controller);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.emitter_ = new Emitter$2();
    this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(tag) {
    this.controller.tag = tag;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(
      eventName,
      (ev) => {
        bh(ev);
      },
      {
        key: handler,
      },
    );
    return this;
  }
  off(eventName, handler) {
    this.emitter_.off(eventName, handler);
    return this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(ev) {
    const value = this.controller.value;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$2(
        this,
        forceCast$2(value.binding.target.read()),
        ev.options.last,
      ),
    );
  }
};
function parseObject$2(value, keyToParserMap) {
  const keys = Object.keys(keyToParserMap);
  const result = keys.reduce((tmp2, key2) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const parser = keyToParserMap[key2];
    const result2 = parser(value[key2]);
    return result2.succeeded
      ? Object.assign(Object.assign({}, tmp2), { [key2]: result2.value })
      : void 0;
  }, {});
  return forceCast$2(result);
}
function parseArray$2(value, parseItem) {
  return value.reduce((tmp2, item) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const result = parseItem(item);
    if (!result.succeeded || result.value === void 0) {
      return void 0;
    }
    return [...tmp2, result.value];
  }, []);
}
function isObject$3(value) {
  if (value === null) {
    return false;
  }
  return typeof value === "object";
}
function createMicroParserBuilder$2(parse) {
  return (optional) => (v) => {
    if (!optional && v === void 0) {
      return {
        succeeded: false,
        value: void 0,
      };
    }
    if (optional && v === void 0) {
      return {
        succeeded: true,
        value: void 0,
      };
    }
    const result = parse(v);
    return result !== void 0
      ? {
          succeeded: true,
          value: result,
        }
      : {
          succeeded: false,
          value: void 0,
        };
  };
}
function createMicroParserBuilders$2(optional) {
  return {
    custom: (parse) => createMicroParserBuilder$2(parse)(optional),
    boolean: createMicroParserBuilder$2((v) =>
      typeof v === "boolean" ? v : void 0,
    )(optional),
    number: createMicroParserBuilder$2((v) =>
      typeof v === "number" ? v : void 0,
    )(optional),
    string: createMicroParserBuilder$2((v) =>
      typeof v === "string" ? v : void 0,
    )(optional),
    function: createMicroParserBuilder$2((v) =>
      typeof v === "function" ? v : void 0,
    )(optional),
    constant: (value) =>
      createMicroParserBuilder$2((v) => (v === value ? value : void 0))(
        optional,
      ),
    raw: createMicroParserBuilder$2((v) => v)(optional),
    object: (keyToParserMap) =>
      createMicroParserBuilder$2((v) => {
        if (!isObject$3(v)) {
          return void 0;
        }
        return parseObject$2(v, keyToParserMap);
      })(optional),
    array: (itemParser) =>
      createMicroParserBuilder$2((v) => {
        if (!Array.isArray(v)) {
          return void 0;
        }
        return parseArray$2(v, itemParser);
      })(optional),
  };
}
const MicroParsers$2 = {
  optional: createMicroParserBuilders$2(true),
  required: createMicroParserBuilders$2(false),
};
function parseRecord$2(value, keyToParserMap) {
  const map = keyToParserMap(MicroParsers$2);
  const result = MicroParsers$2.required.object(map)(value);
  return result.succeeded ? result.value : void 0;
}
function importBladeState$2(state, superImport, parser, callback) {
  if (superImport && !superImport(state)) {
    return false;
  }
  const result = parseRecord$2(state, parser);
  return result ? callback(result) : false;
}
function exportBladeState$2(superExport, thisState) {
  var _a;
  return deepMerge$2(
    (_a =
      superExport === null || superExport === void 0
        ? void 0
        : superExport()) !== null && _a !== void 0
      ? _a
      : {},
    thisState,
  );
}
function isValueBladeController$2(bc) {
  return "value" in bc;
}
function isBindingValue$2(v) {
  if (!isObject$1$2(v) || !("binding" in v)) {
    return false;
  }
  const b = v.binding;
  return isBinding$2(b);
}
const SVG_NS$2 = "http://www.w3.org/2000/svg";
function forceReflow$2(element) {
  element.offsetHeight;
}
function disableTransitionTemporarily$2(element, callback) {
  const t = element.style.transition;
  element.style.transition = "none";
  callback();
  element.style.transition = t;
}
function supportsTouch$2(doc) {
  return doc.ontouchstart !== void 0;
}
function getCanvasContext$2(canvasElement) {
  const win = canvasElement.ownerDocument.defaultView;
  if (!win) {
    return null;
  }
  const isBrowser = "document" in win;
  return isBrowser
    ? canvasElement.getContext("2d", {
        willReadFrequently: true,
      })
    : null;
}
const ICON_ID_TO_INNER_HTML_MAP$2 = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad:
    '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function createSvgIconElement$2(document2, iconId) {
  const elem = document2.createElementNS(SVG_NS$2, "svg");
  elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP$2[iconId];
  return elem;
}
function insertElementAt$2(parentElement, element, index) {
  parentElement.insertBefore(element, parentElement.children[index]);
}
function removeElement$2(element) {
  if (element.parentElement) {
    element.parentElement.removeChild(element);
  }
}
function removeChildElements$2(element) {
  while (element.children.length > 0) {
    element.removeChild(element.children[0]);
  }
}
function removeChildNodes$2(element) {
  while (element.childNodes.length > 0) {
    element.removeChild(element.childNodes[0]);
  }
}
function findNextTarget$2(ev) {
  if (ev.relatedTarget) {
    return forceCast$2(ev.relatedTarget);
  }
  if ("explicitOriginalTarget" in ev) {
    return ev.explicitOriginalTarget;
  }
  return null;
}
function bindValue$2(value, applyValue) {
  value.emitter.on("change", (ev) => {
    applyValue(ev.rawValue);
  });
  applyValue(value.rawValue);
}
function bindValueMap$2(valueMap, key2, applyValue) {
  bindValue$2(valueMap.value(key2), applyValue);
}
const PREFIX$2 = "tp";
function ClassName$2(viewName) {
  const fn = (opt_elementName, opt_modifier) => {
    return [
      PREFIX$2,
      "-",
      viewName,
      "v",
      opt_elementName ? `_${opt_elementName}` : "",
      opt_modifier ? `-${opt_modifier}` : "",
    ].join("");
  };
  return fn;
}
const cn$q$2 = ClassName$2("lbl");
function createLabelNode$2(doc, label) {
  const frag = doc.createDocumentFragment();
  const lineNodes = label.split("\n").map((line) => {
    return doc.createTextNode(line);
  });
  lineNodes.forEach((lineNode, index) => {
    if (index > 0) {
      frag.appendChild(doc.createElement("br"));
    }
    frag.appendChild(lineNode);
  });
  return frag;
}
let LabelView$2 = class LabelView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$q$2());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("div");
    labelElem.classList.add(cn$q$2("l"));
    bindValueMap$2(config.props, "label", (value) => {
      if (isEmpty$2(value)) {
        this.element.classList.add(cn$q$2(void 0, "nol"));
      } else {
        this.element.classList.remove(cn$q$2(void 0, "nol"));
        removeChildNodes$2(labelElem);
        labelElem.appendChild(createLabelNode$2(doc, value));
      }
    });
    this.element.appendChild(labelElem);
    this.labelElement = labelElem;
    const valueElem = doc.createElement("div");
    valueElem.classList.add(cn$q$2("v"));
    this.element.appendChild(valueElem);
    this.valueElement = valueElem;
  }
};
let LabelController$2 = class LabelController5 {
  constructor(doc, config) {
    this.props = config.props;
    this.valueController = config.valueController;
    this.viewProps = config.valueController.viewProps;
    this.view = new LabelView$2(doc, {
      props: config.props,
      viewProps: this.viewProps,
    });
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(state) {
    return importBladeState$2(
      state,
      null,
      (p) => ({
        label: p.optional.string,
      }),
      (result) => {
        this.props.set("label", result.label);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$2(null, {
      label: this.props.get("label"),
    });
  }
};
function getAllBladePositions$2() {
  return ["veryfirst", "first", "last", "verylast"];
}
const cn$p$2 = ClassName$2("");
const POS_TO_CLASS_NAME_MAP$2 = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst",
};
let BladeController$2 = class BladeController5 {
  constructor(config) {
    this.parent_ = null;
    this.blade = config.blade;
    this.view = config.view;
    this.viewProps = config.viewProps;
    const elem = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      getAllBladePositions$2().forEach((pos) => {
        elem.classList.remove(cn$p$2(void 0, POS_TO_CLASS_NAME_MAP$2[pos]));
      });
      this.blade.get("positions").forEach((pos) => {
        elem.classList.add(cn$p$2(void 0, POS_TO_CLASS_NAME_MAP$2[pos]));
      });
    });
    this.viewProps.handleDispose(() => {
      removeElement$2(elem);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(parent) {
    this.parent_ = parent;
    this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(state) {
    return importBladeState$2(
      state,
      null,
      (p) => ({
        disabled: p.required.boolean,
        hidden: p.required.boolean,
      }),
      (result) => {
        this.viewProps.importState(result);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$2(
      null,
      Object.assign({}, this.viewProps.exportState()),
    );
  }
};
let ButtonApi$2 = class ButtonApi5 extends BladeApi$2 {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get title() {
    var _a;
    return (_a = this.controller.buttonController.props.get("title")) !==
      null && _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.buttonController.props.set("title", title);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller.buttonController.emitter;
    emitter.on(eventName, (ev) => {
      bh(new TpMouseEvent(this, ev.nativeEvent));
    });
    return this;
  }
  off(eventName, handler) {
    const emitter = this.controller.buttonController.emitter;
    emitter.off(eventName, handler);
    return this;
  }
};
function applyClass$2(elem, className2, active) {
  if (active) {
    elem.classList.add(className2);
  } else {
    elem.classList.remove(className2);
  }
}
function valueToClassName$2(elem, className2) {
  return (value) => {
    applyClass$2(elem, className2, value);
  };
}
function bindValueToTextContent$2(value, elem) {
  bindValue$2(value, (text) => {
    elem.textContent = text !== null && text !== void 0 ? text : "";
  });
}
const cn$o$2 = ClassName$2("btn");
let ButtonView$2 = class ButtonView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$o$2());
    config.viewProps.bindClassModifiers(this.element);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$o$2("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$o$2("t"));
    bindValueToTextContent$2(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
  }
};
let ButtonController$2 = class ButtonController5 {
  constructor(doc, config) {
    this.emitter = new Emitter$2();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new ButtonView$2(doc, {
      props: this.props,
      viewProps: this.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(state) {
    return importBladeState$2(
      state,
      null,
      (p) => ({
        title: p.optional.string,
      }),
      (result) => {
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$2(null, {
      title: this.props.get("title"),
    });
  }
  onClick_(ev) {
    this.emitter.emit("click", {
      nativeEvent: ev,
      sender: this,
    });
  }
};
let ButtonBladeController$2 = class ButtonBladeController5 extends BladeController$2 {
  constructor(doc, config) {
    const bc = new ButtonController$2(doc, {
      props: config.buttonProps,
      viewProps: config.viewProps,
    });
    const lc = new LabelController$2(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: config.viewProps,
    });
    this.buttonController = bc;
    this.labelController = lc;
  }
  importState(state) {
    return importBladeState$2(
      state,
      (s) =>
        super.importState(s) &&
        this.buttonController.importProps(s) &&
        this.labelController.importProps(s),
      () => ({}),
      () => true,
    );
  }
  exportState() {
    return exportBladeState$2(
      () => super.exportState(),
      Object.assign(
        Object.assign({}, this.buttonController.exportProps()),
        this.labelController.exportProps(),
      ),
    );
  }
};
let Semver$2 = class Semver5 {
  constructor(text) {
    const [core, prerelease] = text.split("-");
    const coreComps = core.split(".");
    this.major = parseInt(coreComps[0], 10);
    this.minor = parseInt(coreComps[1], 10);
    this.patch = parseInt(coreComps[2], 10);
    this.prerelease =
      prerelease !== null && prerelease !== void 0 ? prerelease : null;
  }
  toString() {
    const core = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
  }
};
const VERSION$2 = new Semver$2("2.0.3");
function createPlugin$2(plugin) {
  return Object.assign({ core: VERSION$2 }, plugin);
}
createPlugin$2({
  id: "button",
  type: "blade",
  accept(params) {
    const result = parseRecord$2(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("button"),
      label: p.optional.string,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new ButtonBladeController$2(args.document, {
      blade: args.blade,
      buttonProps: ValueMap$2.fromObject({
        title: args.params.title,
      }),
      labelProps: ValueMap$2.fromObject({
        label: args.params.label,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (args.controller instanceof ButtonBladeController$2) {
      return new ButtonApi$2(args.controller);
    }
    return null;
  },
});
function addButtonAsBlade$2(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "button" }),
  );
}
function addFolderAsBlade$2(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "folder" }),
  );
}
function addTabAsBlade$2(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "tab" }),
  );
}
function isRefreshable$2(value) {
  if (!isObject$1$2(value)) {
    return false;
  }
  return "refresh" in value && typeof value.refresh === "function";
}
function createBindingTarget$2(obj, key2) {
  if (!BindingTarget$2.isBindable(obj)) {
    throw TpError$2.notBindable();
  }
  return new BindingTarget$2(obj, key2);
}
let RackApi$2 = class RackApi5 {
  constructor(controller, pool) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.controller_ = controller;
    this.emitter_ = new Emitter$2();
    this.pool_ = pool;
    const rack = this.controller_.rack;
    rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((bc) => this.pool_.createApi(bc));
  }
  addBinding(object, key2, opt_params) {
    const params =
      opt_params !== null && opt_params !== void 0 ? opt_params : {};
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBinding(
      doc,
      createBindingTarget$2(object, key2),
      params,
    );
    const api = this.pool_.createBindingApi(bc);
    return this.add(api, params.index);
  }
  addFolder(params) {
    return addFolderAsBlade$2(this, params);
  }
  addButton(params) {
    return addButtonAsBlade$2(this, params);
  }
  addTab(params) {
    return addTabAsBlade$2(this, params);
  }
  add(api, opt_index) {
    const bc = api.controller;
    this.controller_.rack.add(bc, opt_index);
    return api;
  }
  remove(api) {
    this.controller_.rack.remove(api.controller);
  }
  addBlade(params) {
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBlade(doc, params);
    const api = this.pool_.createApi(bc);
    return this.add(api, params.index);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(
      eventName,
      (ev) => {
        bh(ev);
      },
      {
        key: handler,
      },
    );
    return this;
  }
  off(eventName, handler) {
    this.emitter_.off(eventName, handler);
    return this;
  }
  refresh() {
    this.children.forEach((c) => {
      if (isRefreshable$2(c)) {
        c.refresh();
      }
    });
  }
  onRackValueChange_(ev) {
    const bc = ev.bladeController;
    const api = this.pool_.createApi(bc);
    const binding = isBindingValue$2(bc.value) ? bc.value.binding : null;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$2(
        api,
        binding ? binding.target.read() : bc.value.rawValue,
        ev.options.last,
      ),
    );
  }
};
let ContainerBladeApi$2 = class ContainerBladeApi5 extends BladeApi$2 {
  constructor(controller, pool) {
    super(controller);
    this.rackApi_ = new RackApi$2(controller.rackController, pool);
  }
  refresh() {
    this.rackApi_.refresh();
  }
};
let ContainerBladeController$2 = class ContainerBladeController5 extends BladeController$2 {
  constructor(config) {
    super({
      blade: config.blade,
      view: config.view,
      viewProps: config.rackController.viewProps,
    });
    this.rackController = config.rackController;
  }
  importState(state) {
    return importBladeState$2(
      state,
      (s) => super.importState(s),
      (p) => ({
        children: p.required.array(p.required.raw),
      }),
      (result) => {
        return this.rackController.rack.children.every((c, index) => {
          return c.importState(result.children[index]);
        });
      },
    );
  }
  exportState() {
    return exportBladeState$2(() => super.exportState(), {
      children: this.rackController.rack.children.map((c) => c.exportState()),
    });
  }
};
function isContainerBladeController$2(bc) {
  return "rackController" in bc;
}
let NestedOrderedSet$2 = class NestedOrderedSet5 {
  constructor(extract) {
    this.emitter = new Emitter$2();
    this.items_ = [];
    this.cache_ = /* @__PURE__ */ new Set();
    this.onSubListAdd_ = this.onSubListAdd_.bind(this);
    this.onSubListRemove_ = this.onSubListRemove_.bind(this);
    this.extract_ = extract;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(callback) {
    for (const item of this.allItems()) {
      if (callback(item)) {
        return item;
      }
    }
    return null;
  }
  includes(item) {
    return this.cache_.has(item);
  }
  add(item, opt_index) {
    if (this.includes(item)) {
      throw TpError$2.shouldNeverHappen();
    }
    const index = opt_index !== void 0 ? opt_index : this.items_.length;
    this.items_.splice(index, 0, item);
    this.cache_.add(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.emitter.on("add", this.onSubListAdd_);
      subList.emitter.on("remove", this.onSubListRemove_);
      subList.allItems().forEach((i) => {
        this.cache_.add(i);
      });
    }
    this.emitter.emit("add", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    this.cache_.delete(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.allItems().forEach((i) => {
        this.cache_.delete(i);
      });
      subList.emitter.off("add", this.onSubListAdd_);
      subList.emitter.off("remove", this.onSubListRemove_);
    }
    this.emitter.emit("remove", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  onSubListAdd_(ev) {
    this.cache_.add(ev.item);
    this.emitter.emit("add", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
  onSubListRemove_(ev) {
    this.cache_.delete(ev.item);
    this.emitter.emit("remove", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
};
function findValueBladeController$2(bcs, v) {
  for (let i = 0; i < bcs.length; i++) {
    const bc = bcs[i];
    if (isValueBladeController$2(bc) && bc.value === v) {
      return bc;
    }
  }
  return null;
}
function findSubBladeControllerSet$2(bc) {
  return isContainerBladeController$2(bc)
    ? bc.rackController.rack["bcSet_"]
    : null;
}
let Rack$2 = class Rack5 {
  constructor(config) {
    var _a, _b;
    this.emitter = new Emitter$2();
    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
    this.onSetAdd_ = this.onSetAdd_.bind(this);
    this.onSetRemove_ = this.onSetRemove_.bind(this);
    this.onChildDispose_ = this.onChildDispose_.bind(this);
    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
    this.onChildValueChange_ = this.onChildValueChange_.bind(this);
    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
    this.onRackLayout_ = this.onRackLayout_.bind(this);
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
    (_b = this.blade_) === null || _b === void 0
      ? void 0
      : _b
          .value("positions")
          .emitter.on("change", this.onBladePositionsChange_);
    this.viewProps = config.viewProps;
    this.bcSet_ = new NestedOrderedSet$2(findSubBladeControllerSet$2);
    this.bcSet_.emitter.on("add", this.onSetAdd_);
    this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(bc, opt_index) {
    var _a;
    (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
    bc.parent = this;
    this.bcSet_.add(bc, opt_index);
  }
  remove(bc) {
    bc.parent = null;
    this.bcSet_.remove(bc);
  }
  find(finder) {
    return this.bcSet_.allItems().filter(finder);
  }
  onSetAdd_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("add", {
      bladeController: ev.item,
      index: ev.index,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
    bc.blade
      .value("positions")
      .emitter.on("change", this.onChildPositionsChange_);
    bc.viewProps.handleDispose(this.onChildDispose_);
    if (isValueBladeController$2(bc)) {
      bc.value.emitter.on("change", this.onChildValueChange_);
    } else if (isContainerBladeController$2(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.on("layout", this.onRackLayout_);
        emitter.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("remove", {
      bladeController: ev.item,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    if (isValueBladeController$2(bc)) {
      bc.value.emitter.off("change", this.onChildValueChange_);
    } else if (isContainerBladeController$2(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.off("layout", this.onRackLayout_);
        emitter.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const visibleItems = this.bcSet_.items.filter(
      (bc) => !bc.viewProps.get("hidden"),
    );
    const firstVisibleItem = visibleItems[0];
    const lastVisibleItem = visibleItems[visibleItems.length - 1];
    this.bcSet_.items.forEach((bc) => {
      const ps = [];
      if (bc === firstVisibleItem) {
        ps.push("first");
        if (
          !this.blade_ ||
          this.blade_.get("positions").includes("veryfirst")
        ) {
          ps.push("veryfirst");
        }
      }
      if (bc === lastVisibleItem) {
        ps.push("last");
        if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
          ps.push("verylast");
        }
      }
      bc.blade.set("positions", ps);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildViewPropsChange_(_ev) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildDispose_() {
    const disposedUcs = this.bcSet_.items.filter((bc) => {
      return bc.viewProps.get("disposed");
    });
    disposedUcs.forEach((bc) => {
      this.bcSet_.remove(bc);
    });
  }
  onChildValueChange_(ev) {
    const bc = findValueBladeController$2(
      this.find(isValueBladeController$2),
      ev.sender,
    );
    if (!bc) {
      throw TpError$2.alreadyDisposed();
    }
    this.emitter.emit("valuechange", {
      bladeController: bc,
      options: ev.options,
      sender: this,
    });
  }
  onRackLayout_(_) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onRackValueChange_(ev) {
    this.emitter.emit("valuechange", {
      bladeController: ev.bladeController,
      options: ev.options,
      sender: this,
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
};
let RackController$2 = class RackController5 {
  constructor(config) {
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    this.element = config.element;
    this.viewProps = config.viewProps;
    const rack = new Rack$2({
      blade: config.root ? void 0 : config.blade,
      viewProps: config.viewProps,
    });
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.rack = rack;
    this.viewProps.handleDispose(() => {
      for (let i = this.rack.children.length - 1; i >= 0; i--) {
        const bc = this.rack.children[i];
        bc.viewProps.set("disposed", true);
      }
    });
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    insertElementAt$2(this.element, ev.bladeController.view.element, ev.index);
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    removeElement$2(ev.bladeController.view.element);
  }
};
function createBlade$2() {
  return new ValueMap$2({
    positions: createValue$2([], {
      equals: deepEqualsArray$2,
    }),
  });
}
let Foldable$2 = class Foldable5 extends ValueMap$2 {
  constructor(valueMap) {
    super(valueMap);
  }
  static create(expanded) {
    const coreObj = {
      completed: true,
      expanded,
      expandedHeight: null,
      shouldFixHeight: false,
      temporaryExpanded: null,
    };
    const core = ValueMap$2.createCore(coreObj);
    return new Foldable5(core);
  }
  get styleExpanded() {
    var _a;
    return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0
      ? _a
      : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded) {
      return "0";
    }
    const exHeight = this.get("expandedHeight");
    if (this.get("shouldFixHeight") && !isEmpty$2(exHeight)) {
      return `${exHeight}px`;
    }
    return "auto";
  }
  bindExpandedClass(elem, expandedClassName) {
    const onExpand = () => {
      const expanded = this.styleExpanded;
      if (expanded) {
        elem.classList.add(expandedClassName);
      } else {
        elem.classList.remove(expandedClassName);
      }
    };
    bindValueMap$2(this, "expanded", onExpand);
    bindValueMap$2(this, "temporaryExpanded", onExpand);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", false);
    this.set("expandedHeight", null);
    this.set("completed", true);
  }
};
function computeExpandedFolderHeight$2(folder, containerElement) {
  let height = 0;
  disableTransitionTemporarily$2(containerElement, () => {
    folder.set("expandedHeight", null);
    folder.set("temporaryExpanded", true);
    forceReflow$2(containerElement);
    height = containerElement.clientHeight;
    folder.set("temporaryExpanded", null);
    forceReflow$2(containerElement);
  });
  return height;
}
function applyHeight$2(foldable, elem) {
  elem.style.height = foldable.styleHeight;
}
function bindFoldable$2(foldable, elem) {
  foldable.value("expanded").emitter.on("beforechange", () => {
    foldable.set("completed", false);
    if (isEmpty$2(foldable.get("expandedHeight"))) {
      const h = computeExpandedFolderHeight$2(foldable, elem);
      if (h > 0) {
        foldable.set("expandedHeight", h);
      }
    }
    foldable.set("shouldFixHeight", true);
    forceReflow$2(elem);
  });
  foldable.emitter.on("change", () => {
    applyHeight$2(foldable, elem);
  });
  applyHeight$2(foldable, elem);
  elem.addEventListener("transitionend", (ev) => {
    if (ev.propertyName !== "height") {
      return;
    }
    foldable.cleanUpTransition();
  });
}
let FolderApi$2 = class FolderApi5 extends ContainerBladeApi$2 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$2();
    this.controller.foldable.value("expanded").emitter.on("change", (ev) => {
      this.emitter_.emit("fold", new TpFoldEvent$2(this, ev.sender.rawValue));
    });
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(expanded) {
    this.controller.foldable.set("expanded", expanded);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(title) {
    this.controller.props.set("title", title);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    return this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(
      eventName,
      (ev) => {
        bh(ev);
      },
      {
        key: handler,
      },
    );
    return this;
  }
  off(eventName, handler) {
    this.emitter_.off(eventName, handler);
    return this;
  }
};
const bladeContainerClassName$2 = ClassName$2("cnt");
let FolderView$2 = class FolderView5 {
  constructor(doc, config) {
    var _a;
    this.className_ = ClassName$2(
      (_a = config.viewName) !== null && _a !== void 0 ? _a : "fld",
    );
    this.element = doc.createElement("div");
    this.element.classList.add(this.className_(), bladeContainerClassName$2());
    config.viewProps.bindClassModifiers(this.element);
    this.foldable_ = config.foldable;
    this.foldable_.bindExpandedClass(
      this.element,
      this.className_(void 0, "expanded"),
    );
    bindValueMap$2(
      this.foldable_,
      "completed",
      valueToClassName$2(this.element, this.className_(void 0, "cpl")),
    );
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(this.className_("b"));
    bindValueMap$2(config.props, "title", (title) => {
      if (isEmpty$2(title)) {
        this.element.classList.add(this.className_(void 0, "not"));
      } else {
        this.element.classList.remove(this.className_(void 0, "not"));
      }
    });
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(this.className_("i"));
    this.element.appendChild(indentElem);
    const titleElem = doc.createElement("div");
    titleElem.classList.add(this.className_("t"));
    bindValueToTextContent$2(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(this.className_("m"));
    this.buttonElement.appendChild(markElem);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(this.className_("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
let FolderController$2 = class FolderController5 extends ContainerBladeController$2 {
  constructor(doc, config) {
    var _a;
    const foldable = Foldable$2.create(
      (_a = config.expanded) !== null && _a !== void 0 ? _a : true,
    );
    const view = new FolderView$2(doc, {
      foldable,
      props: config.props,
      viewName: config.root ? "rot" : void 0,
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$2({
          blade: config.blade,
          element: view.containerElement,
          root: config.root,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onTitleClick_ = this.onTitleClick_.bind(this);
    this.props = config.props;
    this.foldable = foldable;
    bindFoldable$2(this.foldable, this.view.containerElement);
    this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    });
    this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    });
    this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(state) {
    return importBladeState$2(
      state,
      (s) => super.importState(s),
      (p) => ({
        expanded: p.required.boolean,
        title: p.optional.string,
      }),
      (result) => {
        this.foldable.set("expanded", result.expanded);
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$2(() => super.exportState(), {
      expanded: this.foldable.get("expanded"),
      title: this.props.get("title"),
    });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
};
createPlugin$2({
  id: "folder",
  type: "blade",
  accept(params) {
    const result = parseRecord$2(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("folder"),
      expanded: p.optional.boolean,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new FolderController$2(args.document, {
      blade: args.blade,
      expanded: args.params.expanded,
      props: ValueMap$2.fromObject({
        title: args.params.title,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (!(args.controller instanceof FolderController$2)) {
      return null;
    }
    return new FolderApi$2(args.controller, args.pool);
  },
});
const cn$n$2 = ClassName$2("");
function valueToModifier$2(elem, modifier) {
  return valueToClassName$2(elem, cn$n$2(void 0, modifier));
}
let ViewProps$2 = class ViewProps5 extends ValueMap$2 {
  constructor(valueMap) {
    var _a;
    super(valueMap);
    this.onDisabledChange_ = this.onDisabledChange_.bind(this);
    this.onParentChange_ = this.onParentChange_.bind(this);
    this.onParentGlobalDisabledChange_ =
      this.onParentGlobalDisabledChange_.bind(this);
    [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue$2(
      createValue$2(this.getGlobalDisabled_()),
    );
    this.value("disabled").emitter.on("change", this.onDisabledChange_);
    this.value("parent").emitter.on("change", this.onParentChange_);
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
  }
  static create(opt_initialValue) {
    var _a, _b, _c;
    const initialValue =
      opt_initialValue !== null && opt_initialValue !== void 0
        ? opt_initialValue
        : {};
    return new ViewProps5(
      ValueMap$2.createCore({
        disabled:
          (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
        disposed: false,
        hidden:
          (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
        parent:
          (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null,
      }),
    );
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(elem) {
    bindValue$2(this.globalDisabled_, valueToModifier$2(elem, "disabled"));
    bindValueMap$2(this, "hidden", valueToModifier$2(elem, "hidden"));
  }
  bindDisabled(target) {
    bindValue$2(this.globalDisabled_, (disabled) => {
      target.disabled = disabled;
    });
  }
  bindTabIndex(elem) {
    bindValue$2(this.globalDisabled_, (disabled) => {
      elem.tabIndex = disabled ? -1 : 0;
    });
  }
  handleDispose(callback) {
    this.value("disposed").emitter.on("change", (disposed) => {
      if (disposed) {
        callback();
      }
    });
  }
  importState(state) {
    this.set("disabled", state.disabled);
    this.set("hidden", state.hidden);
  }
  exportState() {
    return {
      disabled: this.get("disabled"),
      hidden: this.get("hidden"),
    };
  }
  getGlobalDisabled_() {
    const parent = this.get("parent");
    const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
    return parentDisabled || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(ev) {
    var _a;
    const prevParent = ev.previousRawValue;
    prevParent === null || prevParent === void 0
      ? void 0
      : prevParent.globalDisabled.emitter.off(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    this.updateGlobalDisabled_();
  }
};
const cn$m$2 = ClassName$2("tbp");
let TabPageView$2 = class TabPageView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$m$2());
    config.viewProps.bindClassModifiers(this.element);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(cn$m$2("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
const cn$l$2 = ClassName$2("tbi");
let TabItemView$2 = class TabItemView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$l$2());
    config.viewProps.bindClassModifiers(this.element);
    bindValueMap$2(config.props, "selected", (selected) => {
      if (selected) {
        this.element.classList.add(cn$l$2(void 0, "sel"));
      } else {
        this.element.classList.remove(cn$l$2(void 0, "sel"));
      }
    });
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$l$2("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$l$2("t"));
    bindValueToTextContent$2(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
  }
};
let TabItemController$2 = class TabItemController5 {
  constructor(doc, config) {
    this.emitter = new Emitter$2();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new TabItemView$2(doc, {
      props: config.props,
      viewProps: config.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let TabPageController$2 = class TabPageController5 extends ContainerBladeController$2 {
  constructor(doc, config) {
    const view = new TabPageView$2(doc, {
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$2({
          blade: config.blade,
          element: view.containerElement,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onItemClick_ = this.onItemClick_.bind(this);
    this.ic_ = new TabItemController$2(doc, {
      props: config.itemProps,
      viewProps: ViewProps$2.create(),
    });
    this.ic_.emitter.on("click", this.onItemClick_);
    this.props = config.props;
    bindValueMap$2(this.props, "selected", (selected) => {
      this.itemController.props.set("selected", selected);
      this.viewProps.set("hidden", !selected);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(state) {
    return importBladeState$2(
      state,
      (s) => super.importState(s),
      (p) => ({
        selected: p.required.boolean,
        title: p.required.string,
      }),
      (result) => {
        this.ic_.props.set("selected", result.selected);
        this.ic_.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$2(() => super.exportState(), {
      selected: this.ic_.props.get("selected"),
      title: this.ic_.props.get("title"),
    });
  }
  onItemClick_() {
    this.props.set("selected", true);
  }
};
let TabApi$2 = class TabApi5 extends ContainerBladeApi$2 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$2();
    this.onSelect_ = this.onSelect_.bind(this);
    this.pool_ = pool;
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
    this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(params) {
    const doc = this.controller.view.element.ownerDocument;
    const pc = new TabPageController$2(doc, {
      blade: createBlade$2(),
      itemProps: ValueMap$2.fromObject({
        selected: false,
        title: params.title,
      }),
      props: ValueMap$2.fromObject({
        selected: false,
      }),
      viewProps: ViewProps$2.create(),
    });
    const papi = this.pool_.createApi(pc);
    return this.rackApi_.add(papi, params.index);
  }
  removePage(index) {
    this.rackApi_.remove(this.rackApi_.children[index]);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(
      eventName,
      (ev) => {
        bh(ev);
      },
      {
        key: handler,
      },
    );
    return this;
  }
  off(eventName, handler) {
    this.emitter_.off(eventName, handler);
    return this;
  }
  onSelect_(ev) {
    this.emitter_.emit("select", new TpTabSelectEvent$2(this, ev.rawValue));
  }
};
let TabPageApi$2 = class TabPageApi5 extends ContainerBladeApi$2 {
  get title() {
    var _a;
    return (_a = this.controller.itemController.props.get("title")) !== null &&
      _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.itemController.props.set("title", title);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(selected) {
    this.controller.props.set("selected", selected);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
};
const INDEX_NOT_SELECTED$2 = -1;
let Tab$2 = class Tab5 {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
    this.empty = createValue$2(true);
    this.selectedIndex = createValue$2(INDEX_NOT_SELECTED$2);
    this.items_ = [];
  }
  add(item, opt_index) {
    const index =
      opt_index !== null && opt_index !== void 0
        ? opt_index
        : this.items_.length;
    this.items_.splice(index, 0, item);
    item.emitter.on("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    item.emitter.off("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = INDEX_NOT_SELECTED$2;
      this.empty.rawValue = true;
      return;
    }
    const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
    if (firstSelIndex < 0) {
      this.items_.forEach((s, i) => {
        s.rawValue = i === 0;
      });
      this.selectedIndex.rawValue = 0;
    } else {
      this.items_.forEach((s, i) => {
        s.rawValue = i === firstSelIndex;
      });
      this.selectedIndex.rawValue = firstSelIndex;
    }
    this.empty.rawValue = false;
  }
  onItemSelectedChange_(ev) {
    if (ev.rawValue) {
      const index = this.items_.findIndex((s) => s === ev.sender);
      this.items_.forEach((s, i) => {
        s.rawValue = i === index;
      });
      this.selectedIndex.rawValue = index;
    } else {
      this.keepSelection_();
    }
  }
};
const cn$k$2 = ClassName$2("tab");
let TabView$2 = class TabView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$k$2(), bladeContainerClassName$2());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$2(
      config.empty,
      valueToClassName$2(this.element, cn$k$2(void 0, "nop")),
    );
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$k$2("t"));
    this.element.appendChild(titleElem);
    this.itemsElement = titleElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(cn$k$2("i"));
    this.element.appendChild(indentElem);
    const contentsElem = doc.createElement("div");
    contentsElem.classList.add(cn$k$2("c"));
    this.element.appendChild(contentsElem);
    this.contentsElement = contentsElem;
  }
};
let TabController$2 = class TabController5 extends ContainerBladeController$2 {
  constructor(doc, config) {
    const tab = new Tab$2();
    const view = new TabView$2(doc, {
      empty: tab.empty,
      viewProps: config.viewProps,
    });
    super({
      blade: config.blade,
      rackController: new RackController$2({
        blade: config.blade,
        element: view.contentsElement,
        viewProps: config.viewProps,
      }),
      view,
    });
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    const rack = this.rackController.rack;
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.tab = tab;
  }
  add(pc, opt_index) {
    this.rackController.rack.add(pc, opt_index);
  }
  remove(index) {
    this.rackController.rack.remove(this.rackController.rack.children[index]);
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    insertElementAt$2(
      this.view.itemsElement,
      pc.itemController.view.element,
      ev.index,
    );
    pc.itemController.viewProps.set("parent", this.viewProps);
    this.tab.add(pc.props.value("selected"));
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    removeElement$2(pc.itemController.view.element);
    pc.itemController.viewProps.set("parent", null);
    this.tab.remove(pc.props.value("selected"));
  }
};
createPlugin$2({
  id: "tab",
  type: "blade",
  accept(params) {
    const result = parseRecord$2(params, (p) => ({
      pages: p.required.array(p.required.object({ title: p.required.string })),
      view: p.required.constant("tab"),
    }));
    if (!result || result.pages.length === 0) {
      return null;
    }
    return { params: result };
  },
  controller(args) {
    const c = new TabController$2(args.document, {
      blade: args.blade,
      viewProps: args.viewProps,
    });
    args.params.pages.forEach((p) => {
      const pc = new TabPageController$2(args.document, {
        blade: createBlade$2(),
        itemProps: ValueMap$2.fromObject({
          selected: false,
          title: p.title,
        }),
        props: ValueMap$2.fromObject({
          selected: false,
        }),
        viewProps: ViewProps$2.create(),
      });
      c.add(pc);
    });
    return c;
  },
  api(args) {
    if (args.controller instanceof TabController$2) {
      return new TabApi$2(args.controller, args.pool);
    }
    if (args.controller instanceof TabPageController$2) {
      return new TabPageApi$2(args.controller, args.pool);
    }
    return null;
  },
});
let ListInputBindingApi$2 = class ListInputBindingApi5 extends BindingApi$2 {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(options) {
    this.controller.valueController.props.set("options", options);
  }
};
let CompositeConstraint$2 = class CompositeConstraint5 {
  constructor(constraints) {
    this.constraints = constraints;
  }
  constrain(value) {
    return this.constraints.reduce((result, c) => {
      return c.constrain(result);
    }, value);
  }
};
function findConstraint$2(c, constraintClass) {
  if (c instanceof constraintClass) {
    return c;
  }
  if (c instanceof CompositeConstraint$2) {
    const result = c.constraints.reduce((tmpResult, sc) => {
      if (tmpResult) {
        return tmpResult;
      }
      return sc instanceof constraintClass ? sc : null;
    }, null);
    if (result) {
      return result;
    }
  }
  return null;
}
let ListConstraint$2 = class ListConstraint5 {
  constructor(options) {
    this.values = ValueMap$2.fromObject({
      options,
    });
  }
  constrain(value) {
    const opts = this.values.get("options");
    if (opts.length === 0) {
      return value;
    }
    const matched =
      opts.filter((item) => {
        return item.value === value;
      }).length > 0;
    return matched ? value : opts[0].value;
  }
};
function parseListOptions$2(value) {
  var _a;
  const p = MicroParsers$2;
  if (Array.isArray(value)) {
    return (_a = parseRecord$2({ items: value }, (p2) => ({
      items: p2.required.array(
        p2.required.object({
          text: p2.required.string,
          value: p2.required.raw,
        }),
      ),
    }))) === null || _a === void 0
      ? void 0
      : _a.items;
  }
  if (typeof value === "object") {
    return p.required.raw(value).value;
  }
  return void 0;
}
function normalizeListOptions$2(options) {
  if (Array.isArray(options)) {
    return options;
  }
  const items = [];
  Object.keys(options).forEach((text) => {
    items.push({ text, value: options[text] });
  });
  return items;
}
function createListConstraint$2(options) {
  return !isEmpty$2(options)
    ? new ListConstraint$2(normalizeListOptions$2(forceCast$2(options)))
    : null;
}
const cn$j$2 = ClassName$2("lst");
let ListView$2 = class ListView5 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$j$2());
    config.viewProps.bindClassModifiers(this.element);
    const selectElem = doc.createElement("select");
    selectElem.classList.add(cn$j$2("s"));
    config.viewProps.bindDisabled(selectElem);
    this.element.appendChild(selectElem);
    this.selectElement = selectElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(cn$j$2("m"));
    markElem.appendChild(createSvgIconElement$2(doc, "dropdown"));
    this.element.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value_ = config.value;
    bindValueMap$2(this.props_, "options", (opts) => {
      removeChildElements$2(this.selectElement);
      opts.forEach((item) => {
        const optionElem = doc.createElement("option");
        optionElem.textContent = item.text;
        this.selectElement.appendChild(optionElem);
      });
      this.update_();
    });
  }
  update_() {
    const values = this.props_.get("options").map((o) => o.value);
    this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
};
let ListController$2 = class ListController5 {
  constructor(doc, config) {
    this.onSelectChange_ = this.onSelectChange_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ListView$2(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const selectElem = forceCast$2(e.currentTarget);
    this.value.rawValue =
      this.props.get("options")[selectElem.selectedIndex].value;
  }
  importProps(state) {
    return importBladeState$2(
      state,
      null,
      (p) => ({
        options: p.required.custom(parseListOptions$2),
      }),
      (result) => {
        this.props.set("options", normalizeListOptions$2(result.options));
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$2(null, {
      options: this.props.get("options"),
    });
  }
};
const cn$i$2 = ClassName$2("pop");
let PopupView$2 = class PopupView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$i$2());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$2(
      config.shows,
      valueToClassName$2(this.element, cn$i$2(void 0, "v")),
    );
  }
};
let PopupController$2 = class PopupController5 {
  constructor(doc, config) {
    this.shows = createValue$2(false);
    this.viewProps = config.viewProps;
    this.view = new PopupView$2(doc, {
      shows: this.shows,
      viewProps: this.viewProps,
    });
  }
};
const cn$h$2 = ClassName$2("txt");
let TextView$2 = class TextView5 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$h$2());
    config.viewProps.bindClassModifiers(this.element);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$h$2("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onChange_);
    this.value_ = config.value;
    this.refresh();
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let TextController$2 = class TextController5 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new TextView$2(doc, {
      props: config.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$2(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$2(parsedValue)) {
      this.value.rawValue = parsedValue;
    }
    this.view.refresh();
  }
};
function boolToString$2(value) {
  return String(value);
}
function boolFromUnknown$2(value) {
  if (value === "false") {
    return false;
  }
  return !!value;
}
function BooleanFormatter$2(value) {
  return boolToString$2(value);
}
function composeParsers$2(parsers) {
  return (text) => {
    return parsers.reduce((result, parser) => {
      if (result !== null) {
        return result;
      }
      return parser(text);
    }, null);
  };
}
const innerFormatter$2 = createNumberFormatter$2(0);
function formatPercentage$2(value) {
  return innerFormatter$2(value) + "%";
}
function stringFromUnknown$2(value) {
  return String(value);
}
function formatString$2(value) {
  return value;
}
function connectValues$2({ primary, secondary, forward, backward }) {
  let changing = false;
  function preventFeedback(callback) {
    if (changing) {
      return;
    }
    changing = true;
    callback();
    changing = false;
  }
  primary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  secondary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      primary.setRawValue(
        backward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  preventFeedback(() => {
    secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), {
      forceEmit: false,
      last: true,
    });
  });
}
function getStepForKey$2(keyScale, keys) {
  const step = keyScale * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
  if (keys.upKey) {
    return +step;
  } else if (keys.downKey) {
    return -step;
  }
  return 0;
}
function getVerticalStepKeys$2(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowDown",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowUp",
  };
}
function getHorizontalStepKeys$2(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowLeft",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowRight",
  };
}
function isVerticalArrowKey$2(key2) {
  return key2 === "ArrowUp" || key2 === "ArrowDown";
}
function isArrowKey$2(key2) {
  return (
    isVerticalArrowKey$2(key2) || key2 === "ArrowLeft" || key2 === "ArrowRight"
  );
}
function computeOffset$1$2(ev, elem) {
  var _a, _b;
  const win = elem.ownerDocument.defaultView;
  const rect = elem.getBoundingClientRect();
  return {
    x:
      ev.pageX -
      (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) +
        rect.left),
    y:
      ev.pageY -
      (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) +
        rect.top),
  };
}
let PointerHandler$2 = class PointerHandler5 {
  constructor(element) {
    this.lastTouch_ = null;
    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onTouchEnd_ = this.onTouchEnd_.bind(this);
    this.onTouchMove_ = this.onTouchMove_.bind(this);
    this.onTouchStart_ = this.onTouchStart_.bind(this);
    this.elem_ = element;
    this.emitter = new Emitter$2();
    element.addEventListener("touchstart", this.onTouchStart_, {
      passive: false,
    });
    element.addEventListener("touchmove", this.onTouchMove_, {
      passive: true,
    });
    element.addEventListener("touchend", this.onTouchEnd_);
    element.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(offset) {
    const rect = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: rect.width,
        height: rect.height,
      },
      point: offset
        ? {
            x: offset.x,
            y: offset.y,
          }
        : null,
    };
  }
  onMouseDown_(ev) {
    var _a;
    ev.preventDefault();
    (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
    const doc = this.elem_.ownerDocument;
    doc.addEventListener("mousemove", this.onDocumentMouseMove_);
    doc.addEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$2(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseMove_(ev) {
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$2(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseUp_(ev) {
    const doc = this.elem_.ownerDocument;
    doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
    doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$2(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onTouchStart_(ev) {
    ev.preventDefault();
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchMove_(ev) {
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchEnd_(ev) {
    var _a;
    const touch =
      (_a = ev.targetTouches.item(0)) !== null && _a !== void 0
        ? _a
        : this.lastTouch_;
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
};
const cn$g$2 = ClassName$2("txt");
let NumberTextView$2 = class NumberTextView5 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$g$2(), cn$g$2(void 0, "num"));
    if (config.arrayPosition) {
      this.element.classList.add(cn$g$2(void 0, config.arrayPosition));
    }
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$g$2("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    this.onDraggingChange_ = this.onDraggingChange_.bind(this);
    this.dragging_ = config.dragging;
    this.dragging_.emitter.on("change", this.onDraggingChange_);
    this.element.classList.add(cn$g$2());
    this.inputElement.classList.add(cn$g$2("i"));
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$g$2("k"));
    this.element.appendChild(knobElem);
    this.knobElement = knobElem;
    const guideElem = doc.createElementNS(SVG_NS$2, "svg");
    guideElem.classList.add(cn$g$2("g"));
    this.knobElement.appendChild(guideElem);
    const bodyElem = doc.createElementNS(SVG_NS$2, "path");
    bodyElem.classList.add(cn$g$2("gb"));
    guideElem.appendChild(bodyElem);
    this.guideBodyElem_ = bodyElem;
    const headElem = doc.createElementNS(SVG_NS$2, "path");
    headElem.classList.add(cn$g$2("gh"));
    guideElem.appendChild(headElem);
    this.guideHeadElem_ = headElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(ClassName$2("tt")());
    this.knobElement.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.refresh();
  }
  onDraggingChange_(ev) {
    if (ev.rawValue === null) {
      this.element.classList.remove(cn$g$2(void 0, "drg"));
      return;
    }
    this.element.classList.add(cn$g$2(void 0, "drg"));
    const x = ev.rawValue / this.props_.get("pointerScale");
    const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
    const adx = constrainRange$2(-aox, -4, 4);
    this.guideHeadElem_.setAttributeNS(
      null,
      "d",
      [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(
        " ",
      ),
    );
    this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
    const formatter = this.props_.get("formatter");
    this.tooltipElem_.textContent = formatter(this.value.rawValue);
    this.tooltipElem_.style.left = `${x}px`;
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let NumberTextController$2 = class NumberTextController5 {
  constructor(doc, config) {
    var _a;
    this.originRawValue_ = 0;
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.sliderProps_ =
      (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.dragging_ = createValue$2(null);
    this.view = new NumberTextView$2(doc, {
      arrayPosition: config.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
    this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
    this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const ph = new PointerHandler$2(this.view.knobElement);
    ph.emitter.on("down", this.onPointerDown_);
    ph.emitter.on("move", this.onPointerMove_);
    ph.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(value) {
    var _a, _b;
    const min =
      (_a = this.sliderProps_) === null || _a === void 0
        ? void 0
        : _a.get("min");
    const max =
      (_b = this.sliderProps_) === null || _b === void 0
        ? void 0
        : _b.get("max");
    let v = value;
    if (min !== void 0) {
      v = Math.max(v, min);
    }
    if (max !== void 0) {
      v = Math.min(v, max);
    }
    return v;
  }
  onInputChange_(e) {
    const inputElem = forceCast$2(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$2(parsedValue)) {
      this.value.rawValue = this.constrainValue_(parsedValue);
    }
    this.view.refresh();
  }
  onInputKeyDown_(ev) {
    const step = getStepForKey$2(
      this.props.get("keyScale"),
      getVerticalStepKeys$2(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
      forceEmit: false,
      last: false,
    });
  }
  onInputKeyUp_(ev) {
    const step = getStepForKey$2(
      this.props.get("keyScale"),
      getVerticalStepKeys$2(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue;
    this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(data) {
    if (!data.point) {
      return null;
    }
    const dx = data.point.x - data.bounds.width / 2;
    return this.constrainValue_(
      this.originRawValue_ + dx * this.props.get("pointerScale"),
    );
  }
  onPointerMove_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: false,
      last: false,
    });
    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
  }
  onPointerUp_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: true,
      last: true,
    });
    this.dragging_.rawValue = null;
  }
};
const cn$f$2 = ClassName$2("sld");
let SliderView$2 = class SliderView5 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$f$2());
    config.viewProps.bindClassModifiers(this.element);
    const trackElem = doc.createElement("div");
    trackElem.classList.add(cn$f$2("t"));
    config.viewProps.bindTabIndex(trackElem);
    this.element.appendChild(trackElem);
    this.trackElement = trackElem;
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$f$2("k"));
    this.trackElement.appendChild(knobElem);
    this.knobElement = knobElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const p = constrainRange$2(
      mapRange$2(
        this.value.rawValue,
        this.props_.get("min"),
        this.props_.get("max"),
        0,
        100,
      ),
      0,
      100,
    );
    this.knobElement.style.width = `${p}%`;
  }
  onChange_() {
    this.update_();
  }
};
let SliderController$2 = class SliderController5 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.props = config.props;
    this.view = new SliderView$2(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$2(this.view.trackElement);
    this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
    this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    this.value.setRawValue(
      mapRange$2(
        constrainRange$2(d.point.x, 0, d.bounds.width),
        0,
        d.bounds.width,
        this.props.get("min"),
        this.props.get("max"),
      ),
      opts,
    );
  }
  onPointerDownOrMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$2(
      this.props.get("keyScale"),
      getHorizontalStepKeys$2(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue + step, {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$2(
      this.props.get("keyScale"),
      getHorizontalStepKeys$2(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$e$2 = ClassName$2("sldtxt");
let SliderTextView$2 = class SliderTextView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$e$2());
    const sliderElem = doc.createElement("div");
    sliderElem.classList.add(cn$e$2("s"));
    this.sliderView_ = config.sliderView;
    sliderElem.appendChild(this.sliderView_.element);
    this.element.appendChild(sliderElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$e$2("t"));
    this.textView_ = config.textView;
    textElem.appendChild(this.textView_.element);
    this.element.appendChild(textElem);
  }
};
let SliderTextController$2 = class SliderTextController5 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.sliderC_ = new SliderController$2(doc, {
      props: config.sliderProps,
      value: config.value,
      viewProps: this.viewProps,
    });
    this.textC_ = new NumberTextController$2(doc, {
      parser: config.parser,
      props: config.textProps,
      sliderProps: config.sliderProps,
      value: config.value,
      viewProps: config.viewProps,
    });
    this.view = new SliderTextView$2(doc, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view,
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(state) {
    return importBladeState$2(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        const sliderProps = this.sliderC_.props;
        sliderProps.set("max", result.max);
        sliderProps.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    const sliderProps = this.sliderC_.props;
    return exportBladeState$2(null, {
      max: sliderProps.get("max"),
      min: sliderProps.get("min"),
    });
  }
};
function createSliderTextProps$2(config) {
  return {
    sliderProps: new ValueMap$2({
      keyScale: config.keyScale,
      max: config.max,
      min: config.min,
    }),
    textProps: new ValueMap$2({
      formatter: createValue$2(config.formatter),
      keyScale: config.keyScale,
      pointerScale: createValue$2(config.pointerScale),
    }),
  };
}
const CSS_VAR_MAP$2 = {
  containerUnitSize: "cnt-usz",
};
function getCssVar$2(key2) {
  return `--${CSS_VAR_MAP$2[key2]}`;
}
function createPointDimensionParser$2(p) {
  return createNumberTextInputParamsParser$2(p);
}
function parsePointDimensionParams$2(value) {
  if (!isRecord$2(value)) {
    return void 0;
  }
  return parseRecord$2(value, createPointDimensionParser$2);
}
function createDimensionConstraint$2(params, initialValue) {
  if (!params) {
    return void 0;
  }
  const constraints = [];
  const cs = createStepConstraint$2(params, initialValue);
  if (cs) {
    constraints.push(cs);
  }
  const rs = createRangeConstraint$2(params);
  if (rs) {
    constraints.push(rs);
  }
  return new CompositeConstraint$2(constraints);
}
function parsePickerLayout$2(value) {
  if (value === "inline" || value === "popup") {
    return value;
  }
  return void 0;
}
function writePrimitive$2(target, value) {
  target.write(value);
}
const cn$d$2 = ClassName$2("ckb");
let CheckboxView$2 = class CheckboxView5 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$d$2());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("label");
    labelElem.classList.add(cn$d$2("l"));
    this.element.appendChild(labelElem);
    this.labelElement = labelElem;
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$d$2("i"));
    inputElem.type = "checkbox";
    this.labelElement.appendChild(inputElem);
    this.inputElement = inputElem;
    config.viewProps.bindDisabled(this.inputElement);
    const wrapperElem = doc.createElement("div");
    wrapperElem.classList.add(cn$d$2("w"));
    this.labelElement.appendChild(wrapperElem);
    const markElem = createSvgIconElement$2(doc, "check");
    wrapperElem.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
};
let CheckboxController$2 = class CheckboxController5 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.onLabelMouseDown_ = this.onLabelMouseDown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new CheckboxView$2(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
    this.view.labelElement.addEventListener(
      "mousedown",
      this.onLabelMouseDown_,
    );
  }
  onInputChange_(ev) {
    const inputElem = forceCast$2(ev.currentTarget);
    this.value.rawValue = inputElem.checked;
    ev.preventDefault();
    ev.stopPropagation();
  }
  onLabelMouseDown_(ev) {
    ev.preventDefault();
  }
};
function createConstraint$6$2(params) {
  const constraints = [];
  const lc = createListConstraint$2(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$2(constraints);
}
createPlugin$2({
  id: "input-bool",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$2(params, (p) => ({
      options: p.optional.custom(parseListOptions$2),
      readonly: p.optional.constant(false),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$2,
    constraint: (args) => createConstraint$6$2(args.params),
    writer: (_args) => writePrimitive$2,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$2(c, ListConstraint$2);
    if (lc) {
      return new ListController$2(doc, {
        props: new ValueMap$2({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new CheckboxController$2(doc, {
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "boolean") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$2) {
      return new ListInputBindingApi$2(args.controller);
    }
    return null;
  },
});
const cn$c$2 = ClassName$2("col");
let ColorView$2 = class ColorView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$c$2());
    config.foldable.bindExpandedClass(this.element, cn$c$2(void 0, "expanded"));
    bindValueMap$2(
      config.foldable,
      "completed",
      valueToClassName$2(this.element, cn$c$2(void 0, "cpl")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$c$2("h"));
    this.element.appendChild(headElem);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$c$2("s"));
    headElem.appendChild(swatchElem);
    this.swatchElement = swatchElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$c$2("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$c$2("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
function rgbToHslInt$2(r, g, b) {
  const rp = constrainRange$2(r / 255, 0, 1);
  const gp = constrainRange$2(g / 255, 0, 1);
  const bp = constrainRange$2(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const c = cmax - cmin;
  let h = 0;
  let s = 0;
  const l = (cmin + cmax) / 2;
  if (c !== 0) {
    s = c / (1 - Math.abs(cmax + cmin - 1));
    if (rp === cmax) {
      h = (gp - bp) / c;
    } else if (gp === cmax) {
      h = 2 + (bp - rp) / c;
    } else {
      h = 4 + (rp - gp) / c;
    }
    h = h / 6 + (h < 0 ? 1 : 0);
  }
  return [h * 360, s * 100, l * 100];
}
function hslToRgbInt$2(h, s, l) {
  const hp = ((h % 360) + 360) % 360;
  const sp = constrainRange$2(s / 100, 0, 1);
  const lp = constrainRange$2(l / 100, 0, 1);
  const c = (1 - Math.abs(2 * lp - 1)) * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = lp - c / 2;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function rgbToHsvInt$2(r, g, b) {
  const rp = constrainRange$2(r / 255, 0, 1);
  const gp = constrainRange$2(g / 255, 0, 1);
  const bp = constrainRange$2(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const d = cmax - cmin;
  let h;
  if (d === 0) {
    h = 0;
  } else if (cmax === rp) {
    h = 60 * (((((gp - bp) / d) % 6) + 6) % 6);
  } else if (cmax === gp) {
    h = 60 * ((bp - rp) / d + 2);
  } else {
    h = 60 * ((rp - gp) / d + 4);
  }
  const s = cmax === 0 ? 0 : d / cmax;
  const v = cmax;
  return [h, s * 100, v * 100];
}
function hsvToRgbInt$2(h, s, v) {
  const hp = loopRange$2(h, 360);
  const sp = constrainRange$2(s / 100, 0, 1);
  const vp = constrainRange$2(v / 100, 0, 1);
  const c = vp * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = vp - c;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function hslToHsvInt$2(h, s, l) {
  const sd = l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100);
  return [
    h,
    sd !== 0 ? (s * (100 - Math.abs(2 * l - 100))) / sd : 0,
    l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100),
  ];
}
function hsvToHslInt$2(h, s, v) {
  const sd = 100 - Math.abs((v * (200 - s)) / 100 - 100);
  return [h, sd !== 0 ? (s * v) / sd : 0, (v * (200 - s)) / (2 * 100)];
}
function removeAlphaComponent$2(comps) {
  return [comps[0], comps[1], comps[2]];
}
function appendAlphaComponent$2(comps, alpha) {
  return [comps[0], comps[1], comps[2], alpha];
}
const MODE_CONVERTER_MAP$2 = {
  hsl: {
    hsl: (h, s, l) => [h, s, l],
    hsv: hslToHsvInt$2,
    rgb: hslToRgbInt$2,
  },
  hsv: {
    hsl: hsvToHslInt$2,
    hsv: (h, s, v) => [h, s, v],
    rgb: hsvToRgbInt$2,
  },
  rgb: {
    hsl: rgbToHslInt$2,
    hsv: rgbToHsvInt$2,
    rgb: (r, g, b) => [r, g, b],
  },
};
function getColorMaxComponents$2(mode, type) {
  return [
    type === "float" ? 1 : mode === "rgb" ? 255 : 360,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
  ];
}
function loopHueRange$2(hue, max) {
  return hue === max ? max : loopRange$2(hue, max);
}
function constrainColorComponents$2(components, mode, type) {
  var _a;
  const ms = getColorMaxComponents$2(mode, type);
  return [
    mode === "rgb"
      ? constrainRange$2(components[0], 0, ms[0])
      : loopHueRange$2(components[0], ms[0]),
    constrainRange$2(components[1], 0, ms[1]),
    constrainRange$2(components[2], 0, ms[2]),
    constrainRange$2(
      (_a = components[3]) !== null && _a !== void 0 ? _a : 1,
      0,
      1,
    ),
  ];
}
function convertColorType$2(comps, mode, from, to) {
  const fms = getColorMaxComponents$2(mode, from);
  const tms = getColorMaxComponents$2(mode, to);
  return comps.map((c, index) => (c / fms[index]) * tms[index]);
}
function convertColor$2(components, from, to) {
  const intComps = convertColorType$2(components, from.mode, from.type, "int");
  const result = MODE_CONVERTER_MAP$2[from.mode][to.mode](...intComps);
  return convertColorType$2(result, to.mode, "int", to.type);
}
let IntColor$2 = class IntColor5 {
  static black() {
    return new IntColor5([0, 0, 0], "rgb");
  }
  constructor(comps, mode) {
    this.type = "int";
    this.mode = mode;
    this.comps_ = constrainColorComponents$2(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$2(
      convertColor$2(
        removeAlphaComponent$2(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const cn$b$2 = ClassName$2("colp");
let ColorPickerView$2 = class ColorPickerView5 {
  constructor(doc, config) {
    this.alphaViews_ = null;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$b$2());
    config.viewProps.bindClassModifiers(this.element);
    const hsvElem = doc.createElement("div");
    hsvElem.classList.add(cn$b$2("hsv"));
    const svElem = doc.createElement("div");
    svElem.classList.add(cn$b$2("sv"));
    this.svPaletteView_ = config.svPaletteView;
    svElem.appendChild(this.svPaletteView_.element);
    hsvElem.appendChild(svElem);
    const hElem = doc.createElement("div");
    hElem.classList.add(cn$b$2("h"));
    this.hPaletteView_ = config.hPaletteView;
    hElem.appendChild(this.hPaletteView_.element);
    hsvElem.appendChild(hElem);
    this.element.appendChild(hsvElem);
    const rgbElem = doc.createElement("div");
    rgbElem.classList.add(cn$b$2("rgb"));
    this.textsView_ = config.textsView;
    rgbElem.appendChild(this.textsView_.element);
    this.element.appendChild(rgbElem);
    if (config.alphaViews) {
      this.alphaViews_ = {
        palette: config.alphaViews.palette,
        text: config.alphaViews.text,
      };
      const aElem = doc.createElement("div");
      aElem.classList.add(cn$b$2("a"));
      const apElem = doc.createElement("div");
      apElem.classList.add(cn$b$2("ap"));
      apElem.appendChild(this.alphaViews_.palette.element);
      aElem.appendChild(apElem);
      const atElem = doc.createElement("div");
      atElem.classList.add(cn$b$2("at"));
      atElem.appendChild(this.alphaViews_.text.element);
      aElem.appendChild(atElem);
      this.element.appendChild(aElem);
    }
  }
  get allFocusableElements() {
    const elems = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textsView_.modeSelectElement,
      ...this.textsView_.inputViews.map((v) => v.inputElement),
    ];
    if (this.alphaViews_) {
      elems.push(
        this.alphaViews_.palette.element,
        this.alphaViews_.text.inputElement,
      );
    }
    return elems;
  }
};
function parseColorType$2(value) {
  return value === "int" ? "int" : value === "float" ? "float" : void 0;
}
function parseColorInputParams$2(params) {
  return parseRecord$2(params, (p) => ({
    color: p.optional.object({
      alpha: p.optional.boolean,
      type: p.optional.custom(parseColorType$2),
    }),
    expanded: p.optional.boolean,
    picker: p.optional.custom(parsePickerLayout$2),
    readonly: p.optional.constant(false),
  }));
}
function getKeyScaleForColor$2(forAlpha) {
  return forAlpha ? 0.1 : 1;
}
function extractColorType$2(params) {
  var _a;
  return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
}
let FloatColor$2 = class FloatColor5 {
  constructor(comps, mode) {
    this.type = "float";
    this.mode = mode;
    this.comps_ = constrainColorComponents$2(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$2(
      convertColor$2(
        removeAlphaComponent$2(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const TYPE_TO_CONSTRUCTOR_MAP$2 = {
  int: (comps, mode) => new IntColor$2(comps, mode),
  float: (comps, mode) => new FloatColor$2(comps, mode),
};
function createColor$2(comps, mode, type) {
  return TYPE_TO_CONSTRUCTOR_MAP$2[type](comps, mode);
}
function isFloatColor$2(c) {
  return c.type === "float";
}
function isIntColor$2(c) {
  return c.type === "int";
}
function convertFloatToInt$2(cf) {
  const comps = cf.getComponents();
  const ms = getColorMaxComponents$2(cf.mode, "int");
  return new IntColor$2(
    [
      Math.round(mapRange$2(comps[0], 0, 1, 0, ms[0])),
      Math.round(mapRange$2(comps[1], 0, 1, 0, ms[1])),
      Math.round(mapRange$2(comps[2], 0, 1, 0, ms[2])),
      comps[3],
    ],
    cf.mode,
  );
}
function convertIntToFloat$2(ci) {
  const comps = ci.getComponents();
  const ms = getColorMaxComponents$2(ci.mode, "int");
  return new FloatColor$2(
    [
      mapRange$2(comps[0], 0, ms[0], 0, 1),
      mapRange$2(comps[1], 0, ms[1], 0, 1),
      mapRange$2(comps[2], 0, ms[2], 0, 1),
      comps[3],
    ],
    ci.mode,
  );
}
function mapColorType$2(c, type) {
  if (c.type === type) {
    return c;
  }
  if (isIntColor$2(c) && type === "float") {
    return convertIntToFloat$2(c);
  }
  if (isFloatColor$2(c) && type === "int") {
    return convertFloatToInt$2(c);
  }
  throw TpError$2.shouldNeverHappen();
}
function equalsStringColorFormat$2(f1, f2) {
  return (
    f1.alpha === f2.alpha &&
    f1.mode === f2.mode &&
    f1.notation === f2.notation &&
    f1.type === f2.type
  );
}
function parseCssNumberOrPercentage$2(text, max) {
  const m = text.match(/^(.+)%$/);
  if (!m) {
    return Math.min(parseFloat(text), max);
  }
  return Math.min(parseFloat(m[1]) * 0.01 * max, max);
}
const ANGLE_TO_DEG_MAP$2 = {
  deg: (angle) => angle,
  grad: (angle) => (angle * 360) / 400,
  rad: (angle) => (angle * 360) / (2 * Math.PI),
  turn: (angle) => angle * 360,
};
function parseCssNumberOrAngle$2(text) {
  const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!m) {
    return parseFloat(text);
  }
  const angle = parseFloat(m[1]);
  const unit = m[2];
  return ANGLE_TO_DEG_MAP$2[unit](angle);
}
function parseFunctionalRgbColorComponents$2(text) {
  const m = text.match(
    /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$2(m[1], 255),
    parseCssNumberOrPercentage$2(m[2], 255),
    parseCssNumberOrPercentage$2(m[3], 255),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbColor$2(text) {
  const comps = parseFunctionalRgbColorComponents$2(text);
  return comps ? new IntColor$2(comps, "rgb") : null;
}
function parseFunctionalRgbaColorComponents$2(text) {
  const m = text.match(
    /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$2(m[1], 255),
    parseCssNumberOrPercentage$2(m[2], 255),
    parseCssNumberOrPercentage$2(m[3], 255),
    parseCssNumberOrPercentage$2(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbaColor$2(text) {
  const comps = parseFunctionalRgbaColorComponents$2(text);
  return comps ? new IntColor$2(comps, "rgb") : null;
}
function parseFunctionalHslColorComponents$2(text) {
  const m = text.match(
    /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$2(m[1]),
    parseCssNumberOrPercentage$2(m[2], 100),
    parseCssNumberOrPercentage$2(m[3], 100),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalHslColor$2(text) {
  const comps = parseFunctionalHslColorComponents$2(text);
  return comps ? new IntColor$2(comps, "hsl") : null;
}
function parseHslaColorComponents$2(text) {
  const m = text.match(
    /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$2(m[1]),
    parseCssNumberOrPercentage$2(m[2], 100),
    parseCssNumberOrPercentage$2(m[3], 100),
    parseCssNumberOrPercentage$2(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalHslaColor$2(text) {
  const comps = parseHslaColorComponents$2(text);
  return comps ? new IntColor$2(comps, "hsl") : null;
}
function parseHexRgbColorComponents$2(text) {
  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
    ];
  }
  return null;
}
function parseHexRgbColor$2(text) {
  const comps = parseHexRgbColorComponents$2(text);
  return comps ? new IntColor$2(comps, "rgb") : null;
}
function parseHexRgbaColorComponents$2(text) {
  const mRgb = text.match(
    /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/,
  );
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
      mapRange$2(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
      mapRange$2(parseInt(mRrggbb[4], 16), 0, 255, 0, 1),
    ];
  }
  return null;
}
function parseHexRgbaColor$2(text) {
  const comps = parseHexRgbaColorComponents$2(text);
  return comps ? new IntColor$2(comps, "rgb") : null;
}
function parseObjectRgbColorComponents$2(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function createObjectRgbColorParser$2(type) {
  return (text) => {
    const comps = parseObjectRgbColorComponents$2(text);
    return comps ? createColor$2(comps, "rgb", type) : null;
  };
}
function parseObjectRgbaColorComponents$2(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseFloat(m[1]),
    parseFloat(m[2]),
    parseFloat(m[3]),
    parseFloat(m[4]),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function createObjectRgbaColorParser$2(type) {
  return (text) => {
    const comps = parseObjectRgbaColorComponents$2(text);
    return comps ? createColor$2(comps, "rgb", type) : null;
  };
}
const PARSER_AND_RESULT$2 = [
  {
    parser: parseHexRgbColorComponents$2,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseHexRgbaColorComponents$2,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseFunctionalRgbColorComponents$2,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalRgbaColorComponents$2,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalHslColorComponents$2,
    result: {
      alpha: false,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseHslaColorComponents$2,
    result: {
      alpha: true,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseObjectRgbColorComponents$2,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "object",
    },
  },
  {
    parser: parseObjectRgbaColorComponents$2,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "object",
    },
  },
];
function detectStringColor$2(text) {
  return PARSER_AND_RESULT$2.reduce((prev, { parser, result: detection }) => {
    if (prev) {
      return prev;
    }
    return parser(text) ? detection : null;
  }, null);
}
function detectStringColorFormat$2(text, type = "int") {
  const r = detectStringColor$2(text);
  if (!r) {
    return null;
  }
  if (r.notation === "hex" && type !== "float") {
    return Object.assign(Object.assign({}, r), { type: "int" });
  }
  if (r.notation === "func") {
    return Object.assign(Object.assign({}, r), { type });
  }
  return null;
}
function createColorStringParser$2(type) {
  const parsers = [
    parseHexRgbColor$2,
    parseHexRgbaColor$2,
    parseFunctionalRgbColor$2,
    parseFunctionalRgbaColor$2,
    parseFunctionalHslColor$2,
    parseFunctionalHslaColor$2,
  ];
  if (type === "int") {
    parsers.push(
      createObjectRgbColorParser$2("int"),
      createObjectRgbaColorParser$2("int"),
    );
  }
  if (type === "float") {
    parsers.push(
      createObjectRgbColorParser$2("float"),
      createObjectRgbaColorParser$2("float"),
    );
  }
  const parser = composeParsers$2(parsers);
  return (text) => {
    const result = parser(text);
    return result ? mapColorType$2(result, type) : null;
  };
}
function readIntColorString$2(value) {
  const parser = createColorStringParser$2("int");
  if (typeof value !== "string") {
    return IntColor$2.black();
  }
  const result = parser(value);
  return result !== null && result !== void 0 ? result : IntColor$2.black();
}
function zerofill$2(comp) {
  const hex = constrainRange$2(Math.floor(comp), 0, 255).toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function colorToHexRgbString$2(value, prefix = "#") {
  const hexes = removeAlphaComponent$2(value.getComponents("rgb"))
    .map(zerofill$2)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToHexRgbaString$2(value, prefix = "#") {
  const rgbaComps = value.getComponents("rgb");
  const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
    .map(zerofill$2)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToFunctionalRgbString$2(value) {
  const formatter = createNumberFormatter$2(0);
  const ci = mapColorType$2(value, "int");
  const comps = removeAlphaComponent$2(ci.getComponents("rgb")).map((comp) =>
    formatter(comp),
  );
  return `rgb(${comps.join(", ")})`;
}
function colorToFunctionalRgbaString$2(value) {
  const aFormatter = createNumberFormatter$2(2);
  const rgbFormatter = createNumberFormatter$2(0);
  const ci = mapColorType$2(value, "int");
  const comps = ci.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return formatter(comp);
  });
  return `rgba(${comps.join(", ")})`;
}
function colorToFunctionalHslString$2(value) {
  const formatters = [
    createNumberFormatter$2(0),
    formatPercentage$2,
    formatPercentage$2,
  ];
  const ci = mapColorType$2(value, "int");
  const comps = removeAlphaComponent$2(ci.getComponents("hsl")).map(
    (comp, index) => formatters[index](comp),
  );
  return `hsl(${comps.join(", ")})`;
}
function colorToFunctionalHslaString$2(value) {
  const formatters = [
    createNumberFormatter$2(0),
    formatPercentage$2,
    formatPercentage$2,
    createNumberFormatter$2(2),
  ];
  const ci = mapColorType$2(value, "int");
  const comps = ci
    .getComponents("hsl")
    .map((comp, index) => formatters[index](comp));
  return `hsla(${comps.join(", ")})`;
}
function colorToObjectRgbString$2(value, type) {
  const formatter = createNumberFormatter$2(type === "float" ? 2 : 0);
  const names = ["r", "g", "b"];
  const cc = mapColorType$2(value, type);
  const comps = removeAlphaComponent$2(cc.getComponents("rgb")).map(
    (comp, index) => `${names[index]}: ${formatter(comp)}`,
  );
  return `{${comps.join(", ")}}`;
}
function createObjectRgbColorFormatter$2(type) {
  return (value) => colorToObjectRgbString$2(value, type);
}
function colorToObjectRgbaString$2(value, type) {
  const aFormatter = createNumberFormatter$2(2);
  const rgbFormatter = createNumberFormatter$2(type === "float" ? 2 : 0);
  const names = ["r", "g", "b", "a"];
  const cc = mapColorType$2(value, type);
  const comps = cc.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return `${names[index]}: ${formatter(comp)}`;
  });
  return `{${comps.join(", ")}}`;
}
function createObjectRgbaColorFormatter$2(type) {
  return (value) => colorToObjectRgbaString$2(value, type);
}
const FORMAT_AND_STRINGIFIERS$2 = [
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbString$2,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbaString$2,
  },
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbString$2,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbaString$2,
  },
  {
    format: {
      alpha: false,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslString$2,
  },
  {
    format: {
      alpha: true,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslaString$2,
  },
  ...["int", "float"].reduce((prev, type) => {
    return [
      ...prev,
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbColorFormatter$2(type),
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbaColorFormatter$2(type),
      },
    ];
  }, []),
];
function findColorStringifier$2(format) {
  return FORMAT_AND_STRINGIFIERS$2.reduce((prev, fas) => {
    if (prev) {
      return prev;
    }
    return equalsStringColorFormat$2(fas.format, format)
      ? fas.stringifier
      : null;
  }, null);
}
const cn$a$2 = ClassName$2("apl");
let APaletteView$2 = class APaletteView5 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$a$2());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const barElem = doc.createElement("div");
    barElem.classList.add(cn$a$2("b"));
    this.element.appendChild(barElem);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$a$2("c"));
    barElem.appendChild(colorElem);
    this.colorElem_ = colorElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$a$2("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    const previewElem = doc.createElement("div");
    previewElem.classList.add(cn$a$2("p"));
    this.markerElem_.appendChild(previewElem);
    this.previewElem_ = previewElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const rgbaComps = c.getComponents("rgb");
    const leftColor = new IntColor$2(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 0],
      "rgb",
    );
    const rightColor = new IntColor$2(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 255],
      "rgb",
    );
    const gradientComps = [
      "to right",
      colorToFunctionalRgbaString$2(leftColor),
      colorToFunctionalRgbaString$2(rightColor),
    ];
    this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
    this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString$2(c);
    const left = mapRange$2(rgbaComps[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let APaletteController$2 = class APaletteController5 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new APaletteView$2(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$2(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const alpha = d.point.x / d.bounds.width;
    const c = this.value.rawValue;
    const [h, s, v] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$2([h, s, v, alpha], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$2(
      getKeyScaleForColor$2(true),
      getHorizontalStepKeys$2(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$2([h, s, v, a + step], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$2(
      getKeyScaleForColor$2(true),
      getHorizontalStepKeys$2(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$9$2 = ClassName$2("coltxt");
function createModeSelectElement$2(doc) {
  const selectElem = doc.createElement("select");
  const items = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" },
    { text: "HEX", value: "hex" },
  ];
  selectElem.appendChild(
    items.reduce((frag, item) => {
      const optElem = doc.createElement("option");
      optElem.textContent = item.text;
      optElem.value = item.value;
      frag.appendChild(optElem);
      return frag;
    }, doc.createDocumentFragment()),
  );
  return selectElem;
}
let ColorTextsView$2 = class ColorTextsView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$9$2());
    config.viewProps.bindClassModifiers(this.element);
    const modeElem = doc.createElement("div");
    modeElem.classList.add(cn$9$2("m"));
    this.modeElem_ = createModeSelectElement$2(doc);
    this.modeElem_.classList.add(cn$9$2("ms"));
    modeElem.appendChild(this.modeSelectElement);
    config.viewProps.bindDisabled(this.modeElem_);
    const modeMarkerElem = doc.createElement("div");
    modeMarkerElem.classList.add(cn$9$2("mm"));
    modeMarkerElem.appendChild(createSvgIconElement$2(doc, "dropdown"));
    modeElem.appendChild(modeMarkerElem);
    this.element.appendChild(modeElem);
    const inputsElem = doc.createElement("div");
    inputsElem.classList.add(cn$9$2("w"));
    this.element.appendChild(inputsElem);
    this.inputsElem_ = inputsElem;
    this.inputViews_ = config.inputViews;
    this.applyInputViews_();
    bindValue$2(config.mode, (mode) => {
      this.modeElem_.value = mode;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(inputViews) {
    this.inputViews_ = inputViews;
    this.applyInputViews_();
  }
  applyInputViews_() {
    removeChildElements$2(this.inputsElem_);
    const doc = this.element.ownerDocument;
    this.inputViews_.forEach((v) => {
      const compElem = doc.createElement("div");
      compElem.classList.add(cn$9$2("c"));
      compElem.appendChild(v.element);
      this.inputsElem_.appendChild(compElem);
    });
  }
};
function createFormatter$2$2(type) {
  return createNumberFormatter$2(type === "float" ? 2 : 0);
}
function createConstraint$5$2(mode, type, index) {
  const max = getColorMaxComponents$2(mode, type)[index];
  return new DefiniteRangeConstraint$2({
    min: 0,
    max,
  });
}
function createComponentController$2(doc, config, index) {
  return new NumberTextController$2(doc, {
    arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
    parser: config.parser,
    props: ValueMap$2.fromObject({
      formatter: createFormatter$2$2(config.colorType),
      keyScale: getKeyScaleForColor$2(false),
      pointerScale: config.colorType === "float" ? 0.01 : 1,
    }),
    value: createValue$2(0, {
      constraint: createConstraint$5$2(
        config.colorMode,
        config.colorType,
        index,
      ),
    }),
    viewProps: config.viewProps,
  });
}
function createComponentControllers$2(doc, config) {
  const cc = {
    colorMode: config.colorMode,
    colorType: config.colorType,
    parser: parseNumber$2,
    viewProps: config.viewProps,
  };
  return [0, 1, 2].map((i) => {
    const c = createComponentController$2(doc, cc, i);
    connectValues$2({
      primary: config.value,
      secondary: c.value,
      forward(p) {
        const mc = mapColorType$2(p, config.colorType);
        return mc.getComponents(config.colorMode)[i];
      },
      backward(p, s) {
        const pickedMode = config.colorMode;
        const mc = mapColorType$2(p, config.colorType);
        const comps = mc.getComponents(pickedMode);
        comps[i] = s;
        const c2 = createColor$2(
          appendAlphaComponent$2(removeAlphaComponent$2(comps), comps[3]),
          pickedMode,
          config.colorType,
        );
        return mapColorType$2(c2, "int");
      },
    });
    return c;
  });
}
function createHexController$2(doc, config) {
  const c = new TextController$2(doc, {
    parser: createColorStringParser$2("int"),
    props: ValueMap$2.fromObject({
      formatter: colorToHexRgbString$2,
    }),
    value: createValue$2(IntColor$2.black()),
    viewProps: config.viewProps,
  });
  connectValues$2({
    primary: config.value,
    secondary: c.value,
    forward: (p) =>
      new IntColor$2(removeAlphaComponent$2(p.getComponents()), p.mode),
    backward: (p, s) =>
      new IntColor$2(
        appendAlphaComponent$2(
          removeAlphaComponent$2(s.getComponents(p.mode)),
          p.getComponents()[3],
        ),
        p.mode,
      ),
  });
  return [c];
}
function isColorMode$2(mode) {
  return mode !== "hex";
}
let ColorTextsController$2 = class ColorTextsController5 {
  constructor(doc, config) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
    this.colorType_ = config.colorType;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.colorMode = createValue$2(this.value.rawValue.mode);
    this.ccs_ = this.createComponentControllers_(doc);
    this.view = new ColorTextsView$2(doc, {
      mode: this.colorMode,
      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
      viewProps: this.viewProps,
    });
    this.view.modeSelectElement.addEventListener(
      "change",
      this.onModeSelectChange_,
    );
  }
  createComponentControllers_(doc) {
    const mode = this.colorMode.rawValue;
    if (isColorMode$2(mode)) {
      return createComponentControllers$2(doc, {
        colorMode: mode,
        colorType: this.colorType_,
        value: this.value,
        viewProps: this.viewProps,
      });
    }
    return createHexController$2(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
  onModeSelectChange_(ev) {
    const selectElem = ev.currentTarget;
    this.colorMode.rawValue = selectElem.value;
    this.ccs_ = this.createComponentControllers_(
      this.view.element.ownerDocument,
    );
    this.view.inputViews = this.ccs_.map((cc) => cc.view);
  }
};
const cn$8$2 = ClassName$2("hpl");
let HPaletteView$2 = class HPaletteView5 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$8$2());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$8$2("c"));
    this.element.appendChild(colorElem);
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$8$2("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const [h] = c.getComponents("hsv");
    this.markerElem_.style.backgroundColor = colorToFunctionalRgbString$2(
      new IntColor$2([h, 100, 100], "hsv"),
    );
    const left = mapRange$2(h, 0, 360, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let HPaletteController$2 = class HPaletteController5 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new HPaletteView$2(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$2(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const hue = mapRange$2(
      constrainRange$2(d.point.x, 0, d.bounds.width),
      0,
      d.bounds.width,
      0,
      360,
    );
    const c = this.value.rawValue;
    const [, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$2([hue, s, v, a], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$2(
      getKeyScaleForColor$2(false),
      getHorizontalStepKeys$2(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$2([h + step, s, v, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$2(
      getKeyScaleForColor$2(false),
      getHorizontalStepKeys$2(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$7$2 = ClassName$2("svp");
const CANVAS_RESOL$2 = 64;
let SvPaletteView$2 = class SvPaletteView5 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$7$2());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const canvasElem = doc.createElement("canvas");
    canvasElem.height = CANVAS_RESOL$2;
    canvasElem.width = CANVAS_RESOL$2;
    canvasElem.classList.add(cn$7$2("c"));
    this.element.appendChild(canvasElem);
    this.canvasElement = canvasElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$7$2("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const ctx = getCanvasContext$2(this.canvasElement);
    if (!ctx) {
      return;
    }
    const c = this.value.rawValue;
    const hsvComps = c.getComponents("hsv");
    const width = this.canvasElement.width;
    const height = this.canvasElement.height;
    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;
    for (let iy = 0; iy < height; iy++) {
      for (let ix = 0; ix < width; ix++) {
        const s = mapRange$2(ix, 0, width, 0, 100);
        const v = mapRange$2(iy, 0, height, 100, 0);
        const rgbComps = hsvToRgbInt$2(hsvComps[0], s, v);
        const i = (iy * width + ix) * 4;
        data[i] = rgbComps[0];
        data[i + 1] = rgbComps[1];
        data[i + 2] = rgbComps[2];
        data[i + 3] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    const left = mapRange$2(hsvComps[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${left}%`;
    const top = mapRange$2(hsvComps[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${top}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let SvPaletteController$2 = class SvPaletteController5 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SvPaletteView$2(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$2(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const saturation = mapRange$2(d.point.x, 0, d.bounds.width, 0, 100);
    const value = mapRange$2(d.point.y, 0, d.bounds.height, 100, 0);
    const [h, , , a] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(
      new IntColor$2([h, saturation, value, a], "hsv"),
      opts,
    );
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    if (isArrowKey$2(ev.key)) {
      ev.preventDefault();
    }
    const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
    const keyScale = getKeyScaleForColor$2(false);
    const ds = getStepForKey$2(keyScale, getHorizontalStepKeys$2(ev));
    const dv = getStepForKey$2(keyScale, getVerticalStepKeys$2(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(new IntColor$2([h, s + ds, v + dv, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const keyScale = getKeyScaleForColor$2(false);
    const ds = getStepForKey$2(keyScale, getHorizontalStepKeys$2(ev));
    const dv = getStepForKey$2(keyScale, getVerticalStepKeys$2(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let ColorPickerController$2 = class ColorPickerController5 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.hPaletteC_ = new HPaletteController$2(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.svPaletteC_ = new SvPaletteController$2(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.alphaIcs_ = config.supportsAlpha
      ? {
          palette: new APaletteController$2(doc, {
            value: this.value,
            viewProps: this.viewProps,
          }),
          text: new NumberTextController$2(doc, {
            parser: parseNumber$2,
            props: ValueMap$2.fromObject({
              pointerScale: 0.01,
              keyScale: 0.1,
              formatter: createNumberFormatter$2(2),
            }),
            value: createValue$2(0, {
              constraint: new DefiniteRangeConstraint$2({ min: 0, max: 1 }),
            }),
            viewProps: this.viewProps,
          }),
        }
      : null;
    if (this.alphaIcs_) {
      connectValues$2({
        primary: this.value,
        secondary: this.alphaIcs_.text.value,
        forward: (p) => p.getComponents()[3],
        backward: (p, s) => {
          const comps = p.getComponents();
          comps[3] = s;
          return new IntColor$2(comps, p.mode);
        },
      });
    }
    this.textsC_ = new ColorTextsController$2(doc, {
      colorType: config.colorType,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorPickerView$2(doc, {
      alphaViews: this.alphaIcs_
        ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view,
          }
        : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: config.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textsView: this.textsC_.view,
      viewProps: this.viewProps,
    });
  }
  get textsController() {
    return this.textsC_;
  }
};
const cn$6$2 = ClassName$2("colsw");
let ColorSwatchView$2 = class ColorSwatchView5 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$6$2());
    config.viewProps.bindClassModifiers(this.element);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$6$2("sw"));
    this.element.appendChild(swatchElem);
    this.swatchElem_ = swatchElem;
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$6$2("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    this.update_();
  }
  update_() {
    const value = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = colorToHexRgbaString$2(value);
  }
  onValueChange_() {
    this.update_();
  }
};
let ColorSwatchController$2 = class ColorSwatchController5 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ColorSwatchView$2(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
let ColorController$2 = class ColorController5 {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$2.create(config.expanded);
    this.swatchC_ = new ColorSwatchController$2(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    const buttonElem = this.swatchC_.view.buttonElement;
    buttonElem.addEventListener("blur", this.onButtonBlur_);
    buttonElem.addEventListener("click", this.onButtonClick_);
    this.textC_ = new TextController$2(doc, {
      parser: config.parser,
      props: ValueMap$2.fromObject({
        formatter: config.formatter,
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorView$2(doc, {
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout,
    });
    this.view.swatchElement.appendChild(this.swatchC_.view.element);
    this.view.textElement.appendChild(this.textC_.view.element);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$2(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const pickerC = new ColorPickerController$2(doc, {
      colorType: config.colorType,
      supportsAlpha: config.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps,
    });
    pickerC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = pickerC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(pickerC.view.element);
      connectValues$2({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$2(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$2(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$2(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.swatchC_.view.buttonElement &&
      !supportsTouch$2(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.swatchC_.view.buttonElement.focus();
      }
    }
  }
};
function colorToRgbNumber$2(value) {
  return removeAlphaComponent$2(value.getComponents("rgb")).reduce(
    (result, comp) => {
      return (result << 8) | (Math.floor(comp) & 255);
    },
    0,
  );
}
function colorToRgbaNumber$2(value) {
  return (
    value.getComponents("rgb").reduce((result, comp, index) => {
      const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
      return (result << 8) | hex;
    }, 0) >>> 0
  );
}
function numberToRgbColor$2(num) {
  return new IntColor$2(
    [(num >> 16) & 255, (num >> 8) & 255, num & 255],
    "rgb",
  );
}
function numberToRgbaColor$2(num) {
  return new IntColor$2(
    [
      (num >> 24) & 255,
      (num >> 16) & 255,
      (num >> 8) & 255,
      mapRange$2(num & 255, 0, 255, 0, 1),
    ],
    "rgb",
  );
}
function colorFromRgbNumber$2(value) {
  if (typeof value !== "number") {
    return IntColor$2.black();
  }
  return numberToRgbColor$2(value);
}
function colorFromRgbaNumber$2(value) {
  if (typeof value !== "number") {
    return IntColor$2.black();
  }
  return numberToRgbaColor$2(value);
}
function isRgbColorComponent$2(obj, key2) {
  if (typeof obj !== "object" || isEmpty$2(obj)) {
    return false;
  }
  return key2 in obj && typeof obj[key2] === "number";
}
function isRgbColorObject$2(obj) {
  return (
    isRgbColorComponent$2(obj, "r") &&
    isRgbColorComponent$2(obj, "g") &&
    isRgbColorComponent$2(obj, "b")
  );
}
function isRgbaColorObject$2(obj) {
  return isRgbColorObject$2(obj) && isRgbColorComponent$2(obj, "a");
}
function isColorObject$2(obj) {
  return isRgbColorObject$2(obj);
}
function equalsColor$2(v1, v2) {
  if (v1.mode !== v2.mode) {
    return false;
  }
  if (v1.type !== v2.type) {
    return false;
  }
  const comps1 = v1.getComponents();
  const comps2 = v2.getComponents();
  for (let i = 0; i < comps1.length; i++) {
    if (comps1[i] !== comps2[i]) {
      return false;
    }
  }
  return true;
}
function createColorComponentsFromRgbObject$2(obj) {
  return "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
}
function createColorStringWriter$2(format) {
  const stringify = findColorStringifier$2(format);
  return stringify
    ? (target, value) => {
        writePrimitive$2(target, stringify(value));
      }
    : null;
}
function createColorNumberWriter$2(supportsAlpha) {
  const colorToNumber = supportsAlpha
    ? colorToRgbaNumber$2
    : colorToRgbNumber$2;
  return (target, value) => {
    writePrimitive$2(target, colorToNumber(value));
  };
}
function writeRgbaColorObject$2(target, value, type) {
  const cc = mapColorType$2(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
  target.writeProperty("a", obj.a);
}
function writeRgbColorObject$2(target, value, type) {
  const cc = mapColorType$2(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
}
function createColorObjectWriter$2(supportsAlpha, type) {
  return (target, inValue) => {
    if (supportsAlpha) {
      writeRgbaColorObject$2(target, inValue, type);
    } else {
      writeRgbColorObject$2(target, inValue, type);
    }
  };
}
function shouldSupportAlpha$1$2(inputParams) {
  var _a;
  if (
    (_a =
      inputParams === null || inputParams === void 0
        ? void 0
        : inputParams.color) === null || _a === void 0
      ? void 0
      : _a.alpha
  ) {
    return true;
  }
  return false;
}
function createFormatter$1$2(supportsAlpha) {
  return supportsAlpha
    ? (v) => colorToHexRgbaString$2(v, "0x")
    : (v) => colorToHexRgbString$2(v, "0x");
}
function isForColor$2(params) {
  if ("color" in params) {
    return true;
  }
  if (params.view === "color") {
    return true;
  }
  return false;
}
createPlugin$2({
  id: "input-color-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    if (!isForColor$2(params)) {
      return null;
    }
    const result = parseColorInputParams$2(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            supportsAlpha: shouldSupportAlpha$1$2(params),
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => {
      return args.params.supportsAlpha
        ? colorFromRgbaNumber$2
        : colorFromRgbNumber$2;
    },
    equals: equalsColor$2,
    writer: (args) => {
      return createColorNumberWriter$2(args.params.supportsAlpha);
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$2(args.document, {
      colorType: "int",
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createFormatter$1$2(args.params.supportsAlpha),
      parser: createColorStringParser$2("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
function colorFromObject$2(value, type) {
  if (!isColorObject$2(value)) {
    return mapColorType$2(IntColor$2.black(), type);
  }
  if (type === "int") {
    const comps = createColorComponentsFromRgbObject$2(value);
    return new IntColor$2(comps, "rgb");
  }
  if (type === "float") {
    const comps = createColorComponentsFromRgbObject$2(value);
    return new FloatColor$2(comps, "rgb");
  }
  return mapColorType$2(IntColor$2.black(), "int");
}
function shouldSupportAlpha$3(initialValue) {
  return isRgbaColorObject$2(initialValue);
}
function createColorObjectBindingReader$2(type) {
  return (value) => {
    const c = colorFromObject$2(value, type);
    return mapColorType$2(c, "int");
  };
}
function createColorObjectFormatter$2(supportsAlpha, type) {
  return (value) => {
    if (supportsAlpha) {
      return colorToObjectRgbaString$2(value, type);
    }
    return colorToObjectRgbString$2(value, type);
  };
}
createPlugin$2({
  id: "input-color-object",
  type: "input",
  accept: (value, params) => {
    var _a;
    if (!isColorObject$2(value)) {
      return null;
    }
    const result = parseColorInputParams$2(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            colorType:
              (_a = extractColorType$2(params)) !== null && _a !== void 0
                ? _a
                : "int",
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => createColorObjectBindingReader$2(args.params.colorType),
    equals: equalsColor$2,
    writer: (args) =>
      createColorObjectWriter$2(
        shouldSupportAlpha$3(args.initialValue),
        args.params.colorType,
      ),
  },
  controller: (args) => {
    var _a, _b;
    const supportsAlpha = isRgbaColorObject$2(args.initialValue);
    return new ColorController$2(args.document, {
      colorType: args.params.colorType,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createColorObjectFormatter$2(
        supportsAlpha,
        args.params.colorType,
      ),
      parser: createColorStringParser$2("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
createPlugin$2({
  id: "input-color-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    if (params.view === "text") {
      return null;
    }
    const format = detectStringColorFormat$2(value, extractColorType$2(params));
    if (!format) {
      return null;
    }
    const stringifier = findColorStringifier$2(format);
    if (!stringifier) {
      return null;
    }
    const result = parseColorInputParams$2(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            format,
            stringifier,
          }),
        }
      : null;
  },
  binding: {
    reader: () => readIntColorString$2,
    equals: equalsColor$2,
    writer: (args) => {
      const writer = createColorStringWriter$2(args.params.format);
      if (!writer) {
        throw TpError$2.notBindable();
      }
      return writer;
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$2(args.document, {
      colorType: args.params.format.type,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: args.params.stringifier,
      parser: createColorStringParser$2("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.format.alpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let PointNdConstraint$2 = class PointNdConstraint5 {
  constructor(config) {
    this.components = config.components;
    this.asm_ = config.assembly;
  }
  constrain(value) {
    const comps = this.asm_.toComponents(value).map((comp, index) => {
      var _a, _b;
      return (_b =
        (_a = this.components[index]) === null || _a === void 0
          ? void 0
          : _a.constrain(comp)) !== null && _b !== void 0
        ? _b
        : comp;
    });
    return this.asm_.fromComponents(comps);
  }
};
const cn$5$2 = ClassName$2("pndtxt");
let PointNdTextView$2 = class PointNdTextView5 {
  constructor(doc, config) {
    this.textViews = config.textViews;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$5$2());
    this.textViews.forEach((v) => {
      const axisElem = doc.createElement("div");
      axisElem.classList.add(cn$5$2("a"));
      axisElem.appendChild(v.element);
      this.element.appendChild(axisElem);
    });
  }
};
function createAxisController$2(doc, config, index) {
  return new NumberTextController$2(doc, {
    arrayPosition:
      index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
    parser: config.parser,
    props: config.axes[index].textProps,
    value: createValue$2(0, {
      constraint: config.axes[index].constraint,
    }),
    viewProps: config.viewProps,
  });
}
let PointNdTextController$2 = class PointNdTextController5 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.acs_ = config.axes.map((_, index) =>
      createAxisController$2(doc, config, index),
    );
    this.acs_.forEach((c, index) => {
      connectValues$2({
        primary: this.value,
        secondary: c.value,
        forward: (p) => config.assembly.toComponents(p)[index],
        backward: (p, s) => {
          const comps = config.assembly.toComponents(p);
          comps[index] = s;
          return config.assembly.fromComponents(comps);
        },
      });
    });
    this.view = new PointNdTextView$2(doc, {
      textViews: this.acs_.map((ac) => ac.view),
    });
  }
  get textControllers() {
    return this.acs_;
  }
};
let SliderInputBindingApi$2 = class SliderInputBindingApi5 extends BindingApi$2 {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.sliderController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(max) {
    this.controller.valueController.sliderController.props.set("min", max);
  }
};
function createConstraint$4$2(params, initialValue) {
  const constraints = [];
  const sc = createStepConstraint$2(params, initialValue);
  if (sc) {
    constraints.push(sc);
  }
  const rc = createRangeConstraint$2(params);
  if (rc) {
    constraints.push(rc);
  }
  const lc = createListConstraint$2(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$2(constraints);
}
createPlugin$2({
  id: "input-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$2(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser$2(p)), {
        options: p.optional.custom(parseListOptions$2),
        readonly: p.optional.constant(false),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown$2,
    constraint: (args) => createConstraint$4$2(args.params, args.initialValue),
    writer: (_args) => writePrimitive$2,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$2(c, ListConstraint$2);
    if (lc) {
      return new ListController$2(args.document, {
        props: new ValueMap$2({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    const textPropsObj = createNumberTextPropsObject$2(
      args.params,
      value.rawValue,
    );
    const drc = c && findConstraint$2(c, DefiniteRangeConstraint$2);
    if (drc) {
      return new SliderTextController$2(
        args.document,
        Object.assign(
          Object.assign(
            {},
            createSliderTextProps$2(
              Object.assign(Object.assign({}, textPropsObj), {
                keyScale: createValue$2(textPropsObj.keyScale),
                max: drc.values.value("max"),
                min: drc.values.value("min"),
              }),
            ),
          ),
          { parser: parseNumber$2, value, viewProps: args.viewProps },
        ),
      );
    }
    return new NumberTextController$2(args.document, {
      parser: parseNumber$2,
      props: ValueMap$2.fromObject(textPropsObj),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "number") {
      return null;
    }
    if (args.controller.valueController instanceof SliderTextController$2) {
      return new SliderInputBindingApi$2(args.controller);
    }
    if (args.controller.valueController instanceof ListController$2) {
      return new ListInputBindingApi$2(args.controller);
    }
    return null;
  },
});
let Point2d$2 = class Point2d5 {
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(obj) {
    if (isEmpty$2(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    if (typeof x !== "number" || typeof y2 !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
    };
  }
};
const Point2dAssembly$2 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point2d$2(...comps),
};
const cn$4$2 = ClassName$2("p2d");
let Point2dView$2 = class Point2dView5 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$4$2());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$2(
      config.expanded,
      valueToClassName$2(this.element, cn$4$2(void 0, "expanded")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$4$2("h"));
    this.element.appendChild(headElem);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$4$2("b"));
    buttonElem.appendChild(createSvgIconElement$2(doc, "p2dpad"));
    config.viewProps.bindDisabled(buttonElem);
    headElem.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$4$2("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$4$2("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
const cn$3$2 = ClassName$2("p2dp");
let Point2dPickerView$2 = class Point2dPickerView5 {
  constructor(doc, config) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this);
    this.onPropsChange_ = this.onPropsChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onPropsChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$3$2());
    if (config.layout === "popup") {
      this.element.classList.add(cn$3$2(void 0, "p"));
    }
    config.viewProps.bindClassModifiers(this.element);
    const padElem = doc.createElement("div");
    padElem.classList.add(cn$3$2("p"));
    config.viewProps.bindTabIndex(padElem);
    this.element.appendChild(padElem);
    this.padElement = padElem;
    const svgElem = doc.createElementNS(SVG_NS$2, "svg");
    svgElem.classList.add(cn$3$2("g"));
    this.padElement.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const xAxisElem = doc.createElementNS(SVG_NS$2, "line");
    xAxisElem.classList.add(cn$3$2("ax"));
    xAxisElem.setAttributeNS(null, "x1", "0");
    xAxisElem.setAttributeNS(null, "y1", "50%");
    xAxisElem.setAttributeNS(null, "x2", "100%");
    xAxisElem.setAttributeNS(null, "y2", "50%");
    this.svgElem_.appendChild(xAxisElem);
    const yAxisElem = doc.createElementNS(SVG_NS$2, "line");
    yAxisElem.classList.add(cn$3$2("ax"));
    yAxisElem.setAttributeNS(null, "x1", "50%");
    yAxisElem.setAttributeNS(null, "y1", "0");
    yAxisElem.setAttributeNS(null, "x2", "50%");
    yAxisElem.setAttributeNS(null, "y2", "100%");
    this.svgElem_.appendChild(yAxisElem);
    const lineElem = doc.createElementNS(SVG_NS$2, "line");
    lineElem.classList.add(cn$3$2("l"));
    lineElem.setAttributeNS(null, "x1", "50%");
    lineElem.setAttributeNS(null, "y1", "50%");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$3$2("m"));
    this.padElement.appendChild(markerElem);
    this.markerElem_ = markerElem;
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [x, y2] = this.value.rawValue.getComponents();
    const max = this.props_.get("max");
    const px2 = mapRange$2(x, -max, +max, 0, 100);
    const py2 = mapRange$2(y2, -max, +max, 0, 100);
    const ipy = this.props_.get("invertsY") ? 100 - py2 : py2;
    this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
    this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
    this.markerElem_.style.left = `${px2}%`;
    this.markerElem_.style.top = `${ipy}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
};
function computeOffset$3(ev, keyScales, invertsY) {
  return [
    getStepForKey$2(keyScales[0], getHorizontalStepKeys$2(ev)),
    getStepForKey$2(keyScales[1], getVerticalStepKeys$2(ev)) *
      (invertsY ? 1 : -1),
  ];
}
let Point2dPickerController$2 = class Point2dPickerController5 {
  constructor(doc, config) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new Point2dPickerView$2(doc, {
      layout: config.layout,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$2(this.view.padElement);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
    this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const max = this.props.get("max");
    const px2 = mapRange$2(d.point.x, 0, d.bounds.width, -max, +max);
    const py2 = mapRange$2(
      this.props.get("invertsY") ? d.bounds.height - d.point.y : d.point.y,
      0,
      d.bounds.height,
      -max,
      +max,
    );
    this.value.setRawValue(new Point2d$2(px2, py2), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onPadKeyDown_(ev) {
    if (isArrowKey$2(ev.key)) {
      ev.preventDefault();
    }
    const [dx, dy] = computeOffset$3(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(
      new Point2d$2(this.value.rawValue.x + dx, this.value.rawValue.y + dy),
      {
        forceEmit: false,
        last: false,
      },
    );
  }
  onPadKeyUp_(ev) {
    const [dx, dy] = computeOffset$3(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let Point2dController$2 = class Point2dController5 {
  constructor(doc, config) {
    var _a, _b;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$2.create(config.expanded);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$2(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const padC = new Point2dPickerController$2(doc, {
      layout: config.pickerLayout,
      props: new ValueMap$2({
        invertsY: createValue$2(config.invertsY),
        max: createValue$2(config.max),
        xKeyScale: config.axes[0].textProps.value("keyScale"),
        yKeyScale: config.axes[1].textProps.value("keyScale"),
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    padC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = padC;
    this.textC_ = new PointNdTextController$2(doc, {
      assembly: Point2dAssembly$2,
      axes: config.axes,
      parser: config.parser,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new Point2dView$2(doc, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: config.pickerLayout,
      viewProps: this.viewProps,
    });
    this.view.textElement.appendChild(this.textC_.view.element);
    (_a = this.view.buttonElement) === null || _a === void 0
      ? void 0
      : _a.addEventListener("blur", this.onPadButtonBlur_);
    (_b = this.view.buttonElement) === null || _b === void 0
      ? void 0
      : _b.addEventListener("click", this.onPadButtonClick_);
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(this.pickerC_.view.element);
      connectValues$2({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$2(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$2(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$2(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.view.buttonElement &&
      !supportsTouch$2(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.view.buttonElement.focus();
      }
    }
  }
};
function point2dFromUnknown$2(value) {
  return Point2d$2.isObject(value)
    ? new Point2d$2(value.x, value.y)
    : new Point2d$2();
}
function writePoint2d$2(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
}
function createConstraint$3$2(params, initialValue) {
  return new PointNdConstraint$2({
    assembly: Point2dAssembly$2,
    components: [
      createDimensionConstraint$2(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$2(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
    ],
  });
}
function getSuitableMaxDimensionValue$2(params, rawValue) {
  var _a, _b;
  if (!isEmpty$2(params.min) || !isEmpty$2(params.max)) {
    return Math.max(
      Math.abs((_a = params.min) !== null && _a !== void 0 ? _a : 0),
      Math.abs((_b = params.max) !== null && _b !== void 0 ? _b : 0),
    );
  }
  const step = getSuitableKeyScale$2(params);
  return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
}
function getSuitableMax$2(params, initialValue) {
  var _a, _b;
  const xr = getSuitableMaxDimensionValue$2(
    deepMerge$2(params, (_a = params.x) !== null && _a !== void 0 ? _a : {}),
    initialValue.x,
  );
  const yr = getSuitableMaxDimensionValue$2(
    deepMerge$2(params, (_b = params.y) !== null && _b !== void 0 ? _b : {}),
    initialValue.y,
  );
  return Math.max(xr, yr);
}
function shouldInvertY$2(params) {
  if (!("y" in params)) {
    return false;
  }
  const yParams = params.y;
  if (!yParams) {
    return false;
  }
  return "inverted" in yParams ? !!yParams.inverted : false;
}
createPlugin$2({
  id: "input-point2d",
  type: "input",
  accept: (value, params) => {
    if (!Point2d$2.isObject(value)) {
      return null;
    }
    const result = parseRecord$2(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$2(p)), {
        expanded: p.optional.boolean,
        picker: p.optional.custom(parsePickerLayout$2),
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$2),
        y: p.optional.object(
          Object.assign(Object.assign({}, createPointDimensionParser$2(p)), {
            inverted: p.optional.boolean,
          }),
        ),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: () => point2dFromUnknown$2,
    constraint: (args) => createConstraint$3$2(args.params, args.initialValue),
    equals: Point2d$2.equals,
    writer: () => writePoint2d$2,
  },
  controller: (args) => {
    var _a, _b;
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y];
    return new Point2dController$2(doc, {
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a2;
        return createPointAxis$2({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$2(
            args.params,
            (_a2 = dParams[i]) !== null && _a2 !== void 0 ? _a2 : {},
          ),
        });
      }),
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      invertsY: shouldInvertY$2(args.params),
      max: getSuitableMax$2(args.params, value.rawValue),
      parser: parseNumber$2,
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point3d$2 = class Point3d5 {
  constructor(x = 0, y2 = 0, z = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(obj) {
    if (isEmpty$2(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
    };
  }
};
const Point3dAssembly$2 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point3d$2(...comps),
};
function point3dFromUnknown$2(value) {
  return Point3d$2.isObject(value)
    ? new Point3d$2(value.x, value.y, value.z)
    : new Point3d$2();
}
function writePoint3d$2(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
}
function createConstraint$2$2(params, initialValue) {
  return new PointNdConstraint$2({
    assembly: Point3dAssembly$2,
    components: [
      createDimensionConstraint$2(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$2(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$2(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
    ],
  });
}
createPlugin$2({
  id: "input-point3d",
  type: "input",
  accept: (value, params) => {
    if (!Point3d$2.isObject(value)) {
      return null;
    }
    const result = parseRecord$2(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$2(p)), {
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$2),
        y: p.optional.custom(parsePointDimensionParams$2),
        z: p.optional.custom(parsePointDimensionParams$2),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point3dFromUnknown$2,
    constraint: (args) => createConstraint$2$2(args.params, args.initialValue),
    equals: Point3d$2.equals,
    writer: (_args) => writePoint3d$2,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y, args.params.z];
    return new PointNdTextController$2(args.document, {
      assembly: Point3dAssembly$2,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$2({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$2(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$2,
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point4d$2 = class Point4d5 {
  constructor(x = 0, y2 = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
    this.w = w;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(obj) {
    if (isEmpty$2(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    const w = obj.w;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number" ||
      typeof w !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w,
    };
  }
};
const Point4dAssembly$2 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point4d$2(...comps),
};
function point4dFromUnknown$2(value) {
  return Point4d$2.isObject(value)
    ? new Point4d$2(value.x, value.y, value.z, value.w)
    : new Point4d$2();
}
function writePoint4d$2(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
  target.writeProperty("w", value.w);
}
function createConstraint$1$2(params, initialValue) {
  return new PointNdConstraint$2({
    assembly: Point4dAssembly$2,
    components: [
      createDimensionConstraint$2(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$2(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$2(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
      createDimensionConstraint$2(
        Object.assign(Object.assign({}, params), params.w),
        initialValue.w,
      ),
    ],
  });
}
createPlugin$2({
  id: "input-point4d",
  type: "input",
  accept: (value, params) => {
    if (!Point4d$2.isObject(value)) {
      return null;
    }
    const result = parseRecord$2(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$2(p)), {
        readonly: p.optional.constant(false),
        w: p.optional.custom(parsePointDimensionParams$2),
        x: p.optional.custom(parsePointDimensionParams$2),
        y: p.optional.custom(parsePointDimensionParams$2),
        z: p.optional.custom(parsePointDimensionParams$2),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point4dFromUnknown$2,
    constraint: (args) => createConstraint$1$2(args.params, args.initialValue),
    equals: Point4d$2.equals,
    writer: (_args) => writePoint4d$2,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [
      args.params.x,
      args.params.y,
      args.params.z,
      args.params.w,
    ];
    return new PointNdTextController$2(args.document, {
      assembly: Point4dAssembly$2,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$2({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$2(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$2,
      value,
      viewProps: args.viewProps,
    });
  },
});
function createConstraint$8(params) {
  const constraints = [];
  const lc = createListConstraint$2(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$2(constraints);
}
createPlugin$2({
  id: "input-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$2(params, (p) => ({
      readonly: p.optional.constant(false),
      options: p.optional.custom(parseListOptions$2),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$2,
    constraint: (args) => createConstraint$8(args.params),
    writer: (_args) => writePrimitive$2,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$2(c, ListConstraint$2);
    if (lc) {
      return new ListController$2(doc, {
        props: new ValueMap$2({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new TextController$2(doc, {
      parser: (v) => v,
      props: ValueMap$2.fromObject({
        formatter: formatString$2,
      }),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "string") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$2) {
      return new ListInputBindingApi$2(args.controller);
    }
    return null;
  },
});
const Constants$2 = {
  monitor: {
    defaultInterval: 200,
    defaultRows: 3,
  },
};
const cn$2$2 = ClassName$2("mll");
let MultiLogView$2 = class MultiLogView5 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$2$2());
    config.viewProps.bindClassModifiers(this.element);
    const textareaElem = doc.createElement("textarea");
    textareaElem.classList.add(cn$2$2("i"));
    textareaElem.style.height = `calc(var(${getCssVar$2("containerUnitSize")}) * ${config.rows})`;
    textareaElem.readOnly = true;
    config.viewProps.bindDisabled(textareaElem);
    this.element.appendChild(textareaElem);
    this.textareaElem_ = textareaElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const elem = this.textareaElem_;
    const shouldScroll =
      elem.scrollTop === elem.scrollHeight - elem.clientHeight;
    const lines = [];
    this.value.rawValue.forEach((value) => {
      if (value !== void 0) {
        lines.push(this.formatter_(value));
      }
    });
    elem.textContent = lines.join("\n");
    if (shouldScroll) {
      elem.scrollTop = elem.scrollHeight;
    }
  }
  onValueUpdate_() {
    this.update_();
  }
};
let MultiLogController$2 = class MultiLogController5 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new MultiLogView$2(doc, {
      formatter: config.formatter,
      rows: config.rows,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
const cn$1$2 = ClassName$2("sgl");
let SingleLogView$2 = class SingleLogView5 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$1$2());
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$1$2("i"));
    inputElem.readOnly = true;
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const values = this.value.rawValue;
    const lastValue = values[values.length - 1];
    this.inputElement.value =
      lastValue !== void 0 ? this.formatter_(lastValue) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
};
let SingleLogController$2 = class SingleLogController5 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SingleLogView$2(doc, {
      formatter: config.formatter,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
createPlugin$2({
  id: "monitor-bool",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$2(params, (p) => ({
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$2,
  },
  controller: (args) => {
    var _a;
    if (args.value.rawValue.length === 1) {
      return new SingleLogController$2(args.document, {
        formatter: BooleanFormatter$2,
        value: args.value,
        viewProps: args.viewProps,
      });
    }
    return new MultiLogController$2(args.document, {
      formatter: BooleanFormatter$2,
      rows:
        (_a = args.params.rows) !== null && _a !== void 0
          ? _a
          : Constants$2.monitor.defaultRows,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let GraphLogMonitorBindingApi$2 = class GraphLogMonitorBindingApi5 extends BindingApi$2 {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.props.set("min", min);
  }
};
const cn$s = ClassName$2("grl");
let GraphLogView$2 = class GraphLogView5 {
  constructor(doc, config) {
    this.onCursorChange_ = this.onCursorChange_.bind(this);
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$s());
    config.viewProps.bindClassModifiers(this.element);
    this.formatter_ = config.formatter;
    this.props_ = config.props;
    this.cursor_ = config.cursor;
    this.cursor_.emitter.on("change", this.onCursorChange_);
    const svgElem = doc.createElementNS(SVG_NS$2, "svg");
    svgElem.classList.add(cn$s("g"));
    svgElem.style.height = `calc(var(${getCssVar$2("containerUnitSize")}) * ${config.rows})`;
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const lineElem = doc.createElementNS(SVG_NS$2, "polyline");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(cn$s("t"), ClassName$2("tt")());
    this.element.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const { clientWidth: w, clientHeight: h } = this.element;
    const maxIndex = this.value.rawValue.length - 1;
    const min = this.props_.get("min");
    const max = this.props_.get("max");
    const points = [];
    this.value.rawValue.forEach((v, index) => {
      if (v === void 0) {
        return;
      }
      const x = mapRange$2(index, 0, maxIndex, 0, w);
      const y2 = mapRange$2(v, min, max, h, 0);
      points.push([x, y2].join(","));
    });
    this.lineElem_.setAttributeNS(null, "points", points.join(" "));
    const tooltipElem = this.tooltipElem_;
    const value = this.value.rawValue[this.cursor_.rawValue];
    if (value === void 0) {
      tooltipElem.classList.remove(cn$s("t", "a"));
      return;
    }
    const tx = mapRange$2(this.cursor_.rawValue, 0, maxIndex, 0, w);
    const ty = mapRange$2(value, min, max, h, 0);
    tooltipElem.style.left = `${tx}px`;
    tooltipElem.style.top = `${ty}px`;
    tooltipElem.textContent = `${this.formatter_(value)}`;
    if (!tooltipElem.classList.contains(cn$s("t", "a"))) {
      tooltipElem.classList.add(cn$s("t", "a"), cn$s("t", "in"));
      forceReflow$2(tooltipElem);
      tooltipElem.classList.remove(cn$s("t", "in"));
    }
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
};
let GraphLogController$2 = class GraphLogController5 {
  constructor(doc, config) {
    this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.cursor_ = createValue$2(-1);
    this.view = new GraphLogView$2(doc, {
      cursor: this.cursor_,
      formatter: config.formatter,
      rows: config.rows,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    if (!supportsTouch$2(doc)) {
      this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
      this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    } else {
      const ph = new PointerHandler$2(this.view.element);
      ph.emitter.on("down", this.onGraphPointerDown_);
      ph.emitter.on("move", this.onGraphPointerMove_);
      ph.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(state) {
    return importBladeState$2(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        this.props.set("max", result.max);
        this.props.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$2(null, {
      max: this.props.get("max"),
      min: this.props.get("min"),
    });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(ev) {
    const { clientWidth: w } = this.view.element;
    this.cursor_.rawValue = Math.floor(
      mapRange$2(ev.offsetX, 0, w, 0, this.value.rawValue.length),
    );
  }
  onGraphPointerDown_(ev) {
    this.onGraphPointerMove_(ev);
  }
  onGraphPointerMove_(ev) {
    if (!ev.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(
      mapRange$2(
        ev.data.point.x,
        0,
        ev.data.bounds.width,
        0,
        this.value.rawValue.length,
      ),
    );
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
};
function createFormatter$4(params) {
  return !isEmpty$2(params.format) ? params.format : createNumberFormatter$2(2);
}
function createTextMonitor$2(args) {
  var _a;
  if (args.value.rawValue.length === 1) {
    return new SingleLogController$2(args.document, {
      formatter: createFormatter$4(args.params),
      value: args.value,
      viewProps: args.viewProps,
    });
  }
  return new MultiLogController$2(args.document, {
    formatter: createFormatter$4(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$2.monitor.defaultRows,
    value: args.value,
    viewProps: args.viewProps,
  });
}
function createGraphMonitor$2(args) {
  var _a, _b, _c;
  return new GraphLogController$2(args.document, {
    formatter: createFormatter$4(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$2.monitor.defaultRows,
    props: ValueMap$2.fromObject({
      max: (_b = args.params.max) !== null && _b !== void 0 ? _b : 100,
      min: (_c = args.params.min) !== null && _c !== void 0 ? _c : 0,
    }),
    value: args.value,
    viewProps: args.viewProps,
  });
}
function shouldShowGraph$2(params) {
  return params.view === "graph";
}
createPlugin$2({
  id: "monitor-number",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$2(params, (p) => ({
      format: p.optional.function,
      max: p.optional.number,
      min: p.optional.number,
      readonly: p.required.constant(true),
      rows: p.optional.number,
      view: p.optional.string,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    defaultBufferSize: (params) => (shouldShowGraph$2(params) ? 64 : 1),
    reader: (_args) => numberFromUnknown$2,
  },
  controller: (args) => {
    if (shouldShowGraph$2(args.params)) {
      return createGraphMonitor$2(args);
    }
    return createTextMonitor$2(args);
  },
  api: (args) => {
    if (args.controller.valueController instanceof GraphLogController$2) {
      return new GraphLogMonitorBindingApi$2(args.controller);
    }
    return null;
  },
});
createPlugin$2({
  id: "monitor-string",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$2(params, (p) => ({
      multiline: p.optional.boolean,
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$2,
  },
  controller: (args) => {
    var _a;
    const value = args.value;
    const multiline = value.rawValue.length > 1 || args.params.multiline;
    if (multiline) {
      return new MultiLogController$2(args.document, {
        formatter: formatString$2,
        rows:
          (_a = args.params.rows) !== null && _a !== void 0
            ? _a
            : Constants$2.monitor.defaultRows,
        value,
        viewProps: args.viewProps,
      });
    }
    return new SingleLogController$2(args.document, {
      formatter: formatString$2,
      value,
      viewProps: args.viewProps,
    });
  },
});
const className$2 = ClassName$2("txtr");
class TextAreaView {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(className$2());
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("textarea");
    inputElem.rows = config.rows;
    inputElem.cols = 22;
    inputElem.placeholder = config.placeholder;
    inputElem.classList.add(className$2("i"));
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onChange_);
    this.value_ = config.value;
    this.refresh();
  }
  refresh() {
    this.inputElement.value = this.value_.rawValue;
  }
  onChange_() {
    this.refresh();
  }
}
class TextAreaController {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.rows = config.rows;
    this.placeholder = config.placeholder;
    this.view = new TextAreaView(doc, {
      value: this.value,
      viewProps: this.viewProps,
      rows: this.rows,
      placeholder: this.placeholder,
    });
    this.view.inputElement.addEventListener("keyup", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$2(e.currentTarget);
    const value = inputElem.value;
    this.value.rawValue = value;
    this.view.refresh();
  }
}
createPlugin$2({
  id: "input-template",
  type: "input",
  accept(exValue, params) {
    if (typeof exValue !== "string") {
      return null;
    }
    const result = parseRecord$2(params, (p) => ({
      // `view` option may be useful to provide a custom control for primitive values
      view: p.required.constant("textarea"),
      rows: p.optional.number,
      placeholder: p.optional.string,
    }));
    if (!result) {
      return null;
    }
    return {
      initialValue: exValue,
      params: result,
    };
  },
  binding: {
    reader(_args) {
      return (exValue) => {
        return typeof exValue === "string" ? exValue : "";
      };
    },
    writer(_args) {
      return (target, inValue) => {
        target.write(inValue);
      };
    },
  },
  controller(args) {
    var _a, _b;
    return new TextAreaController(args.document, {
      value: args.value,
      rows: (_a = args.params.rows) !== null && _a !== void 0 ? _a : 3,
      placeholder:
        (_b = args.params.placeholder) !== null && _b !== void 0
          ? _b
          : "Enter text here",
      viewProps: args.viewProps,
    });
  },
});
function forceCast$1(v) {
  return v;
}
function isEmpty$1(value) {
  return value === null || value === void 0;
}
function isObject$1$1(value) {
  return value !== null && typeof value === "object";
}
function isRecord$1(value) {
  return value !== null && typeof value === "object";
}
function deepEqualsArray$1(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (let i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
function deepMerge$1(r1, r2) {
  const keys = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(r1), ...Object.keys(r2)]),
  );
  return keys.reduce((result, key2) => {
    const v1 = r1[key2];
    const v2 = r2[key2];
    return isRecord$1(v1) && isRecord$1(v2)
      ? Object.assign(Object.assign({}, result), {
          [key2]: deepMerge$1(v1, v2),
        })
      : Object.assign(Object.assign({}, result), {
          [key2]: key2 in r2 ? v2 : v1,
        });
  }, {});
}
function isBinding$1(value) {
  if (!isObject$1$1(value)) {
    return false;
  }
  return "target" in value;
}
const CREATE_MESSAGE_MAP$1 = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (context) => `Invalid parameters for '${context.name}'`,
  nomatchingcontroller: (context) =>
    `No matching controller for '${context.key}'`,
  nomatchingview: (context) =>
    `No matching view for '${JSON.stringify(context.params)}'`,
  notbindable: () => `Value is not bindable`,
  notcompatible: (context) => `Not compatible with  plugin '${context.id}'`,
  propertynotfound: (context) => `Property '${context.name}' not found`,
  shouldneverhappen: () => "This error should never happen",
};
let TpError$1 = class TpError6 {
  static alreadyDisposed() {
    return new TpError6({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new TpError6({
      type: "notbindable",
    });
  }
  static notCompatible(bundleId, id) {
    return new TpError6({
      type: "notcompatible",
      context: {
        id: `${bundleId}.${id}`,
      },
    });
  }
  static propertyNotFound(name) {
    return new TpError6({
      type: "propertynotfound",
      context: {
        name,
      },
    });
  }
  static shouldNeverHappen() {
    return new TpError6({ type: "shouldneverhappen" });
  }
  constructor(config) {
    var _a;
    this.message =
      (_a = CREATE_MESSAGE_MAP$1[config.type](forceCast$1(config.context))) !==
        null && _a !== void 0
        ? _a
        : "Unexpected error";
    this.name = this.constructor.name;
    this.stack = new Error(this.message).stack;
    this.type = config.type;
  }
  toString() {
    return this.message;
  }
};
let BindingTarget$1 = class BindingTarget6 {
  constructor(obj, key2) {
    this.obj_ = obj;
    this.key = key2;
  }
  static isBindable(obj) {
    if (obj === null) {
      return false;
    }
    if (typeof obj !== "object" && typeof obj !== "function") {
      return false;
    }
    return true;
  }
  read() {
    return this.obj_[this.key];
  }
  write(value) {
    this.obj_[this.key] = value;
  }
  writeProperty(name, value) {
    const valueObj = this.read();
    if (!BindingTarget6.isBindable(valueObj)) {
      throw TpError$1.notBindable();
    }
    if (!(name in valueObj)) {
      throw TpError$1.propertyNotFound(name);
    }
    valueObj[name] = value;
  }
};
let Emitter$1 = class Emitter6 {
  constructor() {
    this.observers_ = {};
  }
  on(eventName, handler) {
    let observers = this.observers_[eventName];
    if (!observers) {
      observers = this.observers_[eventName] = [];
    }
    observers.push({
      handler,
    });
    return this;
  }
  off(eventName, handler) {
    const observers = this.observers_[eventName];
    if (observers) {
      this.observers_[eventName] = observers.filter((observer) => {
        return observer.handler !== handler;
      });
    }
    return this;
  }
  emit(eventName, event) {
    const observers = this.observers_[eventName];
    if (!observers) {
      return;
    }
    observers.forEach((observer) => {
      observer.handler(event);
    });
  }
};
let ComplexValue$1 = class ComplexValue6 {
  constructor(initialValue, config) {
    var _a;
    this.constraint_ =
      config === null || config === void 0 ? void 0 : config.constraint;
    this.equals_ =
      (_a = config === null || config === void 0 ? void 0 : config.equals) !==
        null && _a !== void 0
        ? _a
        : (v1, v2) => v1 === v2;
    this.emitter = new Emitter$1();
    this.rawValue_ = initialValue;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(rawValue) {
    this.setRawValue(rawValue, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(rawValue, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const constrainedValue = this.constraint_
      ? this.constraint_.constrain(rawValue)
      : rawValue;
    const prevValue = this.rawValue_;
    const changed = !this.equals_(prevValue, constrainedValue);
    if (!changed && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.rawValue_ = constrainedValue;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: constrainedValue,
      sender: this,
    });
  }
};
let PrimitiveValue$1 = class PrimitiveValue6 {
  constructor(initialValue) {
    this.emitter = new Emitter$1();
    this.value_ = initialValue;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(value) {
    this.setRawValue(value, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(value, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const prevValue = this.value_;
    if (prevValue === value && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.value_ = value;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: this.value_,
      sender: this,
    });
  }
};
let ReadonlyPrimitiveValue$1 = class ReadonlyPrimitiveValue6 {
  constructor(value) {
    this.emitter = new Emitter$1();
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value_ = value;
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit(
      "beforechange",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
  onValueChange_(ev) {
    this.emitter.emit(
      "change",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
};
function createValue$1(initialValue, config) {
  const constraint =
    config === null || config === void 0 ? void 0 : config.constraint;
  const equals2 = config === null || config === void 0 ? void 0 : config.equals;
  if (!constraint && !equals2) {
    return new PrimitiveValue$1(initialValue);
  }
  return new ComplexValue$1(initialValue, config);
}
function createReadonlyValue$1(value) {
  return [
    new ReadonlyPrimitiveValue$1(value),
    (rawValue, options) => {
      value.setRawValue(rawValue, options);
    },
  ];
}
let ValueMap$1 = class ValueMap6 {
  constructor(valueMap) {
    this.emitter = new Emitter$1();
    this.valMap_ = valueMap;
    for (const key2 in this.valMap_) {
      const v = this.valMap_[key2];
      v.emitter.on("change", () => {
        this.emitter.emit("change", {
          key: key2,
          sender: this,
        });
      });
    }
  }
  static createCore(initialValue) {
    const keys = Object.keys(initialValue);
    return keys.reduce((o, key2) => {
      return Object.assign(o, {
        [key2]: createValue$1(initialValue[key2]),
      });
    }, {});
  }
  static fromObject(initialValue) {
    const core = this.createCore(initialValue);
    return new ValueMap6(core);
  }
  get(key2) {
    return this.valMap_[key2].rawValue;
  }
  set(key2, value) {
    this.valMap_[key2].rawValue = value;
  }
  value(key2) {
    return this.valMap_[key2];
  }
};
let DefiniteRangeConstraint$1 = class DefiniteRangeConstraint6 {
  constructor(config) {
    this.values = ValueMap$1.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    return Math.min(Math.max(value, min), max);
  }
};
let RangeConstraint$1 = class RangeConstraint6 {
  constructor(config) {
    this.values = ValueMap$1.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    let result = value;
    if (!isEmpty$1(min)) {
      result = Math.max(result, min);
    }
    if (!isEmpty$1(max)) {
      result = Math.min(result, max);
    }
    return result;
  }
};
let StepConstraint$1 = class StepConstraint6 {
  constructor(step, origin = 0) {
    this.step = step;
    this.origin = origin;
  }
  constrain(value) {
    const o = this.origin % this.step;
    const r = Math.round((value - o) / this.step);
    return o + r * this.step;
  }
};
let NumberLiteralNode$1 = class NumberLiteralNode6 {
  constructor(text) {
    this.text = text;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
};
const BINARY_OPERATION_MAP$1 = {
  "**": (v1, v2) => Math.pow(v1, v2),
  "*": (v1, v2) => v1 * v2,
  "/": (v1, v2) => v1 / v2,
  "%": (v1, v2) => v1 % v2,
  "+": (v1, v2) => v1 + v2,
  "-": (v1, v2) => v1 - v2,
  "<<": (v1, v2) => v1 << v2,
  ">>": (v1, v2) => v1 >> v2,
  ">>>": (v1, v2) => v1 >>> v2,
  "&": (v1, v2) => v1 & v2,
  "^": (v1, v2) => v1 ^ v2,
  "|": (v1, v2) => v1 | v2,
};
let BinaryOperationNode$1 = class BinaryOperationNode6 {
  constructor(operator, left, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  evaluate() {
    const op = BINARY_OPERATION_MAP$1[this.operator];
    if (!op) {
      throw new Error(`unexpected binary operator: '${this.operator}`);
    }
    return op(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")",
    ].join(" ");
  }
};
const UNARY_OPERATION_MAP$1 = {
  "+": (v) => v,
  "-": (v) => -v,
  "~": (v) => ~v,
};
let UnaryOperationNode$1 = class UnaryOperationNode6 {
  constructor(operator, expr) {
    this.operator = operator;
    this.expression = expr;
  }
  evaluate() {
    const op = UNARY_OPERATION_MAP$1[this.operator];
    if (!op) {
      throw new Error(`unexpected unary operator: '${this.operator}`);
    }
    return op(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
};
function combineReader$1(parsers) {
  return (text, cursor) => {
    for (let i = 0; i < parsers.length; i++) {
      const result = parsers[i](text, cursor);
      if (result !== "") {
        return result;
      }
    }
    return "";
  };
}
function readWhitespace$1(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^\s+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readNonZeroDigit$1(text, cursor) {
  const ch = text.substr(cursor, 1);
  return ch.match(/^[1-9]$/) ? ch : "";
}
function readDecimalDigits$1(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readSignedInteger$1(text, cursor) {
  const ds = readDecimalDigits$1(text, cursor);
  if (ds !== "") {
    return ds;
  }
  const sign2 = text.substr(cursor, 1);
  cursor += 1;
  if (sign2 !== "-" && sign2 !== "+") {
    return "";
  }
  const sds = readDecimalDigits$1(text, cursor);
  if (sds === "") {
    return "";
  }
  return sign2 + sds;
}
function readExponentPart$1(text, cursor) {
  const e = text.substr(cursor, 1);
  cursor += 1;
  if (e.toLowerCase() !== "e") {
    return "";
  }
  const si = readSignedInteger$1(text, cursor);
  if (si === "") {
    return "";
  }
  return e + si;
}
function readDecimalIntegerLiteral$1(text, cursor) {
  const ch = text.substr(cursor, 1);
  if (ch === "0") {
    return ch;
  }
  const nzd = readNonZeroDigit$1(text, cursor);
  cursor += nzd.length;
  if (nzd === "") {
    return "";
  }
  return nzd + readDecimalDigits$1(text, cursor);
}
function readDecimalLiteral1$1(text, cursor) {
  const dil = readDecimalIntegerLiteral$1(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$1(text, cursor);
  cursor += dds.length;
  return dil + dot2 + dds + readExponentPart$1(text, cursor);
}
function readDecimalLiteral2$1(text, cursor) {
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits$1(text, cursor);
  cursor += dds.length;
  if (dds === "") {
    return "";
  }
  return dot2 + dds + readExponentPart$1(text, cursor);
}
function readDecimalLiteral3$1(text, cursor) {
  const dil = readDecimalIntegerLiteral$1(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  return dil + readExponentPart$1(text, cursor);
}
const readDecimalLiteral$1 = combineReader$1([
  readDecimalLiteral1$1,
  readDecimalLiteral2$1,
  readDecimalLiteral3$1,
]);
function parseBinaryDigits$1(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[01]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readBinaryIntegerLiteral$1(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0b") {
    return "";
  }
  const bds = parseBinaryDigits$1(text, cursor);
  if (bds === "") {
    return "";
  }
  return prefix + bds;
}
function readOctalDigits$1(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-7]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readOctalIntegerLiteral$1(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0o") {
    return "";
  }
  const ods = readOctalDigits$1(text, cursor);
  if (ods === "") {
    return "";
  }
  return prefix + ods;
}
function readHexDigits$1(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9a-f]+/i);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readHexIntegerLiteral$1(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0x") {
    return "";
  }
  const hds = readHexDigits$1(text, cursor);
  if (hds === "") {
    return "";
  }
  return prefix + hds;
}
const readNonDecimalIntegerLiteral$1 = combineReader$1([
  readBinaryIntegerLiteral$1,
  readOctalIntegerLiteral$1,
  readHexIntegerLiteral$1,
]);
const readNumericLiteral$1 = combineReader$1([
  readNonDecimalIntegerLiteral$1,
  readDecimalLiteral$1,
]);
function parseLiteral$1(text, cursor) {
  const num = readNumericLiteral$1(text, cursor);
  cursor += num.length;
  if (num === "") {
    return null;
  }
  return {
    evaluable: new NumberLiteralNode$1(num),
    cursor,
  };
}
function parseParenthesizedExpression$1(text, cursor) {
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "(") {
    return null;
  }
  const expr = parseExpression$1(text, cursor);
  if (!expr) {
    return null;
  }
  cursor = expr.cursor;
  cursor += readWhitespace$1(text, cursor).length;
  const cl = text.substr(cursor, 1);
  cursor += cl.length;
  if (cl !== ")") {
    return null;
  }
  return {
    evaluable: expr.evaluable,
    cursor,
  };
}
function parsePrimaryExpression$1(text, cursor) {
  var _a;
  return (_a = parseLiteral$1(text, cursor)) !== null && _a !== void 0
    ? _a
    : parseParenthesizedExpression$1(text, cursor);
}
function parseUnaryExpression$1(text, cursor) {
  const expr = parsePrimaryExpression$1(text, cursor);
  if (expr) {
    return expr;
  }
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "+" && op !== "-" && op !== "~") {
    return null;
  }
  const num = parseUnaryExpression$1(text, cursor);
  if (!num) {
    return null;
  }
  cursor = num.cursor;
  return {
    cursor,
    evaluable: new UnaryOperationNode$1(op, num.evaluable),
  };
}
function readBinaryOperator$1(ops, text, cursor) {
  cursor += readWhitespace$1(text, cursor).length;
  const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
  if (!op) {
    return null;
  }
  cursor += op.length;
  cursor += readWhitespace$1(text, cursor).length;
  return {
    cursor,
    operator: op,
  };
}
function createBinaryOperationExpressionParser$1(exprParser, ops) {
  return (text, cursor) => {
    const firstExpr = exprParser(text, cursor);
    if (!firstExpr) {
      return null;
    }
    cursor = firstExpr.cursor;
    let expr = firstExpr.evaluable;
    for (;;) {
      const op = readBinaryOperator$1(ops, text, cursor);
      if (!op) {
        break;
      }
      cursor = op.cursor;
      const nextExpr = exprParser(text, cursor);
      if (!nextExpr) {
        return null;
      }
      cursor = nextExpr.cursor;
      expr = new BinaryOperationNode$1(op.operator, expr, nextExpr.evaluable);
    }
    return expr
      ? {
          cursor,
          evaluable: expr,
        }
      : null;
  };
}
const parseBinaryOperationExpression$1 = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"],
].reduce((parser, ops) => {
  return createBinaryOperationExpressionParser$1(parser, ops);
}, parseUnaryExpression$1);
function parseExpression$1(text, cursor) {
  cursor += readWhitespace$1(text, cursor).length;
  return parseBinaryOperationExpression$1(text, cursor);
}
function parseEcmaNumberExpression$1(text) {
  const expr = parseExpression$1(text, 0);
  if (!expr) {
    return null;
  }
  const cursor = expr.cursor + readWhitespace$1(text, expr.cursor).length;
  if (cursor !== text.length) {
    return null;
  }
  return expr.evaluable;
}
function parseNumber$1(text) {
  var _a;
  const r = parseEcmaNumberExpression$1(text);
  return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null &&
    _a !== void 0
    ? _a
    : null;
}
function numberFromUnknown$1(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const pv = parseNumber$1(value);
    if (!isEmpty$1(pv)) {
      return pv;
    }
  }
  return 0;
}
function createNumberFormatter$1(digits) {
  return (value) => {
    return value.toFixed(Math.max(Math.min(digits, 20), 0));
  };
}
function mapRange$1(value, start1, end1, start2, end2) {
  const p = (value - start1) / (end1 - start1);
  return start2 + p * (end2 - start2);
}
function getDecimalDigits$1(value) {
  const text = String(value.toFixed(10));
  const frac = text.split(".")[1];
  return frac.replace(/0+$/, "").length;
}
function constrainRange$1(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function loopRange$1(value, max) {
  return ((value % max) + max) % max;
}
function getSuitableDecimalDigits$1(params, rawValue) {
  return !isEmpty$1(params.step)
    ? getDecimalDigits$1(params.step)
    : Math.max(getDecimalDigits$1(rawValue), 2);
}
function getSuitableKeyScale$1(params) {
  var _a;
  return (_a = params.step) !== null && _a !== void 0 ? _a : 1;
}
function getSuitablePointerScale$1(params, rawValue) {
  var _a;
  const base2 = Math.abs(
    (_a = params.step) !== null && _a !== void 0 ? _a : rawValue,
  );
  return base2 === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base2)) - 1);
}
function createStepConstraint$1(params, initialValue) {
  if (!isEmpty$1(params.step)) {
    return new StepConstraint$1(params.step, initialValue);
  }
  return null;
}
function createRangeConstraint$1(params) {
  if (!isEmpty$1(params.max) && !isEmpty$1(params.min)) {
    return new DefiniteRangeConstraint$1({
      max: params.max,
      min: params.min,
    });
  }
  if (!isEmpty$1(params.max) || !isEmpty$1(params.min)) {
    return new RangeConstraint$1({
      max: params.max,
      min: params.min,
    });
  }
  return null;
}
function createNumberTextPropsObject$1(params, initialValue) {
  var _a, _b, _c;
  return {
    formatter:
      (_a = params.format) !== null && _a !== void 0
        ? _a
        : createNumberFormatter$1(
            getSuitableDecimalDigits$1(params, initialValue),
          ),
    keyScale:
      (_b = params.keyScale) !== null && _b !== void 0
        ? _b
        : getSuitableKeyScale$1(params),
    pointerScale:
      (_c = params.pointerScale) !== null && _c !== void 0
        ? _c
        : getSuitablePointerScale$1(params, initialValue),
  };
}
function createNumberTextInputParamsParser$1(p) {
  return {
    format: p.optional.function,
    keyScale: p.optional.number,
    max: p.optional.number,
    min: p.optional.number,
    pointerScale: p.optional.number,
    step: p.optional.number,
  };
}
function createPointAxis$1(config) {
  return {
    constraint: config.constraint,
    textProps: ValueMap$1.fromObject(
      createNumberTextPropsObject$1(config.params, config.initialValue),
    ),
  };
}
let BladeApi$1 = class BladeApi6 {
  constructor(controller) {
    this.controller = controller;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller.viewProps.set("disabled", disabled);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(hidden) {
    this.controller.viewProps.set("hidden", hidden);
  }
  dispose() {
    this.controller.viewProps.set("disposed", true);
  }
  importState(state) {
    return this.controller.importState(state);
  }
  exportState() {
    return this.controller.exportState();
  }
};
let TpEvent$1 = class TpEvent6 {
  constructor(target) {
    this.target = target;
  }
};
let TpChangeEvent$1 = class TpChangeEvent6 extends TpEvent$1 {
  constructor(target, value, last) {
    super(target);
    this.value = value;
    this.last = last !== null && last !== void 0 ? last : true;
  }
};
let TpFoldEvent$1 = class TpFoldEvent6 extends TpEvent$1 {
  constructor(target, expanded) {
    super(target);
    this.expanded = expanded;
  }
};
let TpTabSelectEvent$1 = class TpTabSelectEvent6 extends TpEvent$1 {
  constructor(target, index) {
    super(target);
    this.index = index;
  }
};
let BindingApi$1 = class BindingApi6 extends BladeApi$1 {
  constructor(controller) {
    super(controller);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.emitter_ = new Emitter$1();
    this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(tag) {
    this.controller.tag = tag;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(ev) {
    const value = this.controller.value;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$1(
        this,
        forceCast$1(value.binding.target.read()),
        ev.options.last,
      ),
    );
  }
};
function parseObject$1(value, keyToParserMap) {
  const keys = Object.keys(keyToParserMap);
  const result = keys.reduce((tmp2, key2) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const parser = keyToParserMap[key2];
    const result2 = parser(value[key2]);
    return result2.succeeded
      ? Object.assign(Object.assign({}, tmp2), { [key2]: result2.value })
      : void 0;
  }, {});
  return forceCast$1(result);
}
function parseArray$1(value, parseItem) {
  return value.reduce((tmp2, item) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const result = parseItem(item);
    if (!result.succeeded || result.value === void 0) {
      return void 0;
    }
    return [...tmp2, result.value];
  }, []);
}
function isObject$2(value) {
  if (value === null) {
    return false;
  }
  return typeof value === "object";
}
function createMicroParserBuilder$1(parse) {
  return (optional) => (v) => {
    if (!optional && v === void 0) {
      return {
        succeeded: false,
        value: void 0,
      };
    }
    if (optional && v === void 0) {
      return {
        succeeded: true,
        value: void 0,
      };
    }
    const result = parse(v);
    return result !== void 0
      ? {
          succeeded: true,
          value: result,
        }
      : {
          succeeded: false,
          value: void 0,
        };
  };
}
function createMicroParserBuilders$1(optional) {
  return {
    custom: (parse) => createMicroParserBuilder$1(parse)(optional),
    boolean: createMicroParserBuilder$1((v) =>
      typeof v === "boolean" ? v : void 0,
    )(optional),
    number: createMicroParserBuilder$1((v) =>
      typeof v === "number" ? v : void 0,
    )(optional),
    string: createMicroParserBuilder$1((v) =>
      typeof v === "string" ? v : void 0,
    )(optional),
    function: createMicroParserBuilder$1((v) =>
      typeof v === "function" ? v : void 0,
    )(optional),
    constant: (value) =>
      createMicroParserBuilder$1((v) => (v === value ? value : void 0))(
        optional,
      ),
    raw: createMicroParserBuilder$1((v) => v)(optional),
    object: (keyToParserMap) =>
      createMicroParserBuilder$1((v) => {
        if (!isObject$2(v)) {
          return void 0;
        }
        return parseObject$1(v, keyToParserMap);
      })(optional),
    array: (itemParser) =>
      createMicroParserBuilder$1((v) => {
        if (!Array.isArray(v)) {
          return void 0;
        }
        return parseArray$1(v, itemParser);
      })(optional),
  };
}
const MicroParsers$1 = {
  optional: createMicroParserBuilders$1(true),
  required: createMicroParserBuilders$1(false),
};
function parseRecord$1(value, keyToParserMap) {
  const map = keyToParserMap(MicroParsers$1);
  const result = MicroParsers$1.required.object(map)(value);
  return result.succeeded ? result.value : void 0;
}
function importBladeState$1(state, superImport, parser, callback) {
  if (superImport && !superImport(state)) {
    return false;
  }
  const result = parseRecord$1(state, parser);
  return result ? callback(result) : false;
}
function exportBladeState$1(superExport, thisState) {
  var _a;
  return deepMerge$1(
    (_a =
      superExport === null || superExport === void 0
        ? void 0
        : superExport()) !== null && _a !== void 0
      ? _a
      : {},
    thisState,
  );
}
function isValueBladeController$1(bc) {
  return "value" in bc;
}
function isBindingValue$1(v) {
  if (!isObject$1$1(v) || !("binding" in v)) {
    return false;
  }
  const b = v.binding;
  return isBinding$1(b);
}
const SVG_NS$1 = "http://www.w3.org/2000/svg";
function forceReflow$1(element) {
  element.offsetHeight;
}
function disableTransitionTemporarily$1(element, callback) {
  const t = element.style.transition;
  element.style.transition = "none";
  callback();
  element.style.transition = t;
}
function supportsTouch$1(doc) {
  return doc.ontouchstart !== void 0;
}
function getCanvasContext$1(canvasElement) {
  const win = canvasElement.ownerDocument.defaultView;
  if (!win) {
    return null;
  }
  const isBrowser = "document" in win;
  return isBrowser
    ? canvasElement.getContext("2d", {
        willReadFrequently: true,
      })
    : null;
}
const ICON_ID_TO_INNER_HTML_MAP$1 = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad:
    '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function createSvgIconElement$1(document2, iconId) {
  const elem = document2.createElementNS(SVG_NS$1, "svg");
  elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP$1[iconId];
  return elem;
}
function insertElementAt$1(parentElement, element, index) {
  parentElement.insertBefore(element, parentElement.children[index]);
}
function removeElement$1(element) {
  if (element.parentElement) {
    element.parentElement.removeChild(element);
  }
}
function removeChildElements$1(element) {
  while (element.children.length > 0) {
    element.removeChild(element.children[0]);
  }
}
function removeChildNodes$1(element) {
  while (element.childNodes.length > 0) {
    element.removeChild(element.childNodes[0]);
  }
}
function findNextTarget$1(ev) {
  if (ev.relatedTarget) {
    return forceCast$1(ev.relatedTarget);
  }
  if ("explicitOriginalTarget" in ev) {
    return ev.explicitOriginalTarget;
  }
  return null;
}
function bindValue$1(value, applyValue) {
  value.emitter.on("change", (ev) => {
    applyValue(ev.rawValue);
  });
  applyValue(value.rawValue);
}
function bindValueMap$1(valueMap, key2, applyValue) {
  bindValue$1(valueMap.value(key2), applyValue);
}
const PREFIX$1 = "tp";
function ClassName$1(viewName) {
  const fn = (opt_elementName, opt_modifier) => {
    return [
      PREFIX$1,
      "-",
      viewName,
      "v",
      opt_elementName ? `_${opt_elementName}` : "",
      opt_modifier ? `-${opt_modifier}` : "",
    ].join("");
  };
  return fn;
}
const cn$q$1 = ClassName$1("lbl");
function createLabelNode$1(doc, label) {
  const frag = doc.createDocumentFragment();
  const lineNodes = label.split("\n").map((line) => {
    return doc.createTextNode(line);
  });
  lineNodes.forEach((lineNode, index) => {
    if (index > 0) {
      frag.appendChild(doc.createElement("br"));
    }
    frag.appendChild(lineNode);
  });
  return frag;
}
let LabelView$1 = class LabelView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$q$1());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("div");
    labelElem.classList.add(cn$q$1("l"));
    bindValueMap$1(config.props, "label", (value) => {
      if (isEmpty$1(value)) {
        this.element.classList.add(cn$q$1(void 0, "nol"));
      } else {
        this.element.classList.remove(cn$q$1(void 0, "nol"));
        removeChildNodes$1(labelElem);
        labelElem.appendChild(createLabelNode$1(doc, value));
      }
    });
    this.element.appendChild(labelElem);
    this.labelElement = labelElem;
    const valueElem = doc.createElement("div");
    valueElem.classList.add(cn$q$1("v"));
    this.element.appendChild(valueElem);
    this.valueElement = valueElem;
  }
};
let LabelController$1 = class LabelController6 {
  constructor(doc, config) {
    this.props = config.props;
    this.valueController = config.valueController;
    this.viewProps = config.valueController.viewProps;
    this.view = new LabelView$1(doc, {
      props: config.props,
      viewProps: this.viewProps,
    });
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(state) {
    return importBladeState$1(
      state,
      null,
      (p) => ({
        label: p.optional.string,
      }),
      (result) => {
        this.props.set("label", result.label);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$1(null, {
      label: this.props.get("label"),
    });
  }
};
function getAllBladePositions$1() {
  return ["veryfirst", "first", "last", "verylast"];
}
const cn$p$1 = ClassName$1("");
const POS_TO_CLASS_NAME_MAP$1 = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst",
};
let BladeController$1 = class BladeController6 {
  constructor(config) {
    this.parent_ = null;
    this.blade = config.blade;
    this.view = config.view;
    this.viewProps = config.viewProps;
    const elem = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      getAllBladePositions$1().forEach((pos) => {
        elem.classList.remove(cn$p$1(void 0, POS_TO_CLASS_NAME_MAP$1[pos]));
      });
      this.blade.get("positions").forEach((pos) => {
        elem.classList.add(cn$p$1(void 0, POS_TO_CLASS_NAME_MAP$1[pos]));
      });
    });
    this.viewProps.handleDispose(() => {
      removeElement$1(elem);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(parent) {
    this.parent_ = parent;
    this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(state) {
    return importBladeState$1(
      state,
      null,
      (p) => ({
        disabled: p.required.boolean,
        hidden: p.required.boolean,
      }),
      (result) => {
        this.viewProps.importState(result);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$1(
      null,
      Object.assign({}, this.viewProps.exportState()),
    );
  }
};
let ButtonApi$1 = class ButtonApi6 extends BladeApi$1 {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get title() {
    var _a;
    return (_a = this.controller.buttonController.props.get("title")) !==
      null && _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.buttonController.props.set("title", title);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller.buttonController.emitter;
    emitter.on(eventName, () => {
      bh(new TpEvent$1(this));
    });
    return this;
  }
};
function applyClass$1(elem, className2, active) {
  if (active) {
    elem.classList.add(className2);
  } else {
    elem.classList.remove(className2);
  }
}
function valueToClassName$1(elem, className2) {
  return (value) => {
    applyClass$1(elem, className2, value);
  };
}
function bindValueToTextContent$1(value, elem) {
  bindValue$1(value, (text) => {
    elem.textContent = text !== null && text !== void 0 ? text : "";
  });
}
const cn$o$1 = ClassName$1("btn");
let ButtonView$1 = class ButtonView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$o$1());
    config.viewProps.bindClassModifiers(this.element);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$o$1("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$o$1("t"));
    bindValueToTextContent$1(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
  }
};
let ButtonController$1 = class ButtonController6 {
  constructor(doc, config) {
    this.emitter = new Emitter$1();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new ButtonView$1(doc, {
      props: this.props,
      viewProps: this.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(state) {
    return importBladeState$1(
      state,
      null,
      (p) => ({
        title: p.optional.string,
      }),
      (result) => {
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$1(null, {
      title: this.props.get("title"),
    });
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let ButtonBladeController$1 = class ButtonBladeController6 extends BladeController$1 {
  constructor(doc, config) {
    const bc = new ButtonController$1(doc, {
      props: config.buttonProps,
      viewProps: config.viewProps,
    });
    const lc = new LabelController$1(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: config.viewProps,
    });
    this.buttonController = bc;
    this.labelController = lc;
  }
  importState(state) {
    return importBladeState$1(
      state,
      (s) =>
        super.importState(s) &&
        this.buttonController.importProps(s) &&
        this.labelController.importProps(s),
      () => ({}),
      () => true,
    );
  }
  exportState() {
    return exportBladeState$1(
      () => super.exportState(),
      Object.assign(
        Object.assign({}, this.buttonController.exportProps()),
        this.labelController.exportProps(),
      ),
    );
  }
};
let Semver$1 = class Semver6 {
  constructor(text) {
    const [core, prerelease] = text.split("-");
    const coreComps = core.split(".");
    this.major = parseInt(coreComps[0], 10);
    this.minor = parseInt(coreComps[1], 10);
    this.patch = parseInt(coreComps[2], 10);
    this.prerelease =
      prerelease !== null && prerelease !== void 0 ? prerelease : null;
  }
  toString() {
    const core = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
  }
};
const VERSION$1 = new Semver$1("2.0.1");
function createPlugin$1(plugin) {
  return Object.assign({ core: VERSION$1 }, plugin);
}
createPlugin$1({
  id: "button",
  type: "blade",
  accept(params) {
    const result = parseRecord$1(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("button"),
      label: p.optional.string,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new ButtonBladeController$1(args.document, {
      blade: args.blade,
      buttonProps: ValueMap$1.fromObject({
        title: args.params.title,
      }),
      labelProps: ValueMap$1.fromObject({
        label: args.params.label,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (args.controller instanceof ButtonBladeController$1) {
      return new ButtonApi$1(args.controller);
    }
    return null;
  },
});
function addButtonAsBlade$1(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "button" }),
  );
}
function addFolderAsBlade$1(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "folder" }),
  );
}
function addTabAsBlade$1(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "tab" }),
  );
}
function isRefreshable$1(value) {
  if (!isObject$1$1(value)) {
    return false;
  }
  return "refresh" in value && typeof value.refresh === "function";
}
function createBindingTarget$1(obj, key2) {
  if (!BindingTarget$1.isBindable(obj)) {
    throw TpError$1.notBindable();
  }
  return new BindingTarget$1(obj, key2);
}
let RackApi$1 = class RackApi6 {
  constructor(controller, pool) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.controller_ = controller;
    this.emitter_ = new Emitter$1();
    this.pool_ = pool;
    const rack = this.controller_.rack;
    rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((bc) => this.pool_.createApi(bc));
  }
  addBinding(object, key2, opt_params) {
    const params =
      opt_params !== null && opt_params !== void 0 ? opt_params : {};
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBinding(
      doc,
      createBindingTarget$1(object, key2),
      params,
    );
    const api = this.pool_.createBindingApi(bc);
    return this.add(api, params.index);
  }
  addFolder(params) {
    return addFolderAsBlade$1(this, params);
  }
  addButton(params) {
    return addButtonAsBlade$1(this, params);
  }
  addTab(params) {
    return addTabAsBlade$1(this, params);
  }
  add(api, opt_index) {
    const bc = api.controller;
    this.controller_.rack.add(bc, opt_index);
    return api;
  }
  remove(api) {
    this.controller_.rack.remove(api.controller);
  }
  addBlade(params) {
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBlade(doc, params);
    const api = this.pool_.createApi(bc);
    return this.add(api, params.index);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.children.forEach((c) => {
      if (isRefreshable$1(c)) {
        c.refresh();
      }
    });
  }
  onRackValueChange_(ev) {
    const bc = ev.bladeController;
    const api = this.pool_.createApi(bc);
    const binding = isBindingValue$1(bc.value) ? bc.value.binding : null;
    this.emitter_.emit(
      "change",
      new TpChangeEvent$1(
        api,
        binding ? binding.target.read() : bc.value.rawValue,
        ev.options.last,
      ),
    );
  }
};
let ContainerBladeApi$1 = class ContainerBladeApi6 extends BladeApi$1 {
  constructor(controller, pool) {
    super(controller);
    this.rackApi_ = new RackApi$1(controller.rackController, pool);
  }
  refresh() {
    this.rackApi_.refresh();
  }
};
let ContainerBladeController$1 = class ContainerBladeController6 extends BladeController$1 {
  constructor(config) {
    super({
      blade: config.blade,
      view: config.view,
      viewProps: config.rackController.viewProps,
    });
    this.rackController = config.rackController;
  }
  importState(state) {
    return importBladeState$1(
      state,
      (s) => super.importState(s),
      (p) => ({
        children: p.required.array(p.required.raw),
      }),
      (result) => {
        return this.rackController.rack.children.every((c, index) => {
          return c.importState(result.children[index]);
        });
      },
    );
  }
  exportState() {
    return exportBladeState$1(() => super.exportState(), {
      children: this.rackController.rack.children.map((c) => c.exportState()),
    });
  }
};
function isContainerBladeController$1(bc) {
  return "rackController" in bc;
}
let NestedOrderedSet$1 = class NestedOrderedSet6 {
  constructor(extract) {
    this.emitter = new Emitter$1();
    this.items_ = [];
    this.cache_ = /* @__PURE__ */ new Set();
    this.onSubListAdd_ = this.onSubListAdd_.bind(this);
    this.onSubListRemove_ = this.onSubListRemove_.bind(this);
    this.extract_ = extract;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(callback) {
    for (const item of this.allItems()) {
      if (callback(item)) {
        return item;
      }
    }
    return null;
  }
  includes(item) {
    return this.cache_.has(item);
  }
  add(item, opt_index) {
    if (this.includes(item)) {
      throw TpError$1.shouldNeverHappen();
    }
    const index = opt_index !== void 0 ? opt_index : this.items_.length;
    this.items_.splice(index, 0, item);
    this.cache_.add(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.emitter.on("add", this.onSubListAdd_);
      subList.emitter.on("remove", this.onSubListRemove_);
      subList.allItems().forEach((i) => {
        this.cache_.add(i);
      });
    }
    this.emitter.emit("add", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    this.cache_.delete(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.allItems().forEach((i) => {
        this.cache_.delete(i);
      });
      subList.emitter.off("add", this.onSubListAdd_);
      subList.emitter.off("remove", this.onSubListRemove_);
    }
    this.emitter.emit("remove", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  onSubListAdd_(ev) {
    this.cache_.add(ev.item);
    this.emitter.emit("add", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
  onSubListRemove_(ev) {
    this.cache_.delete(ev.item);
    this.emitter.emit("remove", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
};
function findValueBladeController$1(bcs, v) {
  for (let i = 0; i < bcs.length; i++) {
    const bc = bcs[i];
    if (isValueBladeController$1(bc) && bc.value === v) {
      return bc;
    }
  }
  return null;
}
function findSubBladeControllerSet$1(bc) {
  return isContainerBladeController$1(bc)
    ? bc.rackController.rack["bcSet_"]
    : null;
}
let Rack$1 = class Rack6 {
  constructor(config) {
    var _a, _b;
    this.emitter = new Emitter$1();
    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
    this.onSetAdd_ = this.onSetAdd_.bind(this);
    this.onSetRemove_ = this.onSetRemove_.bind(this);
    this.onChildDispose_ = this.onChildDispose_.bind(this);
    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
    this.onChildValueChange_ = this.onChildValueChange_.bind(this);
    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
    this.onRackLayout_ = this.onRackLayout_.bind(this);
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
    (_b = this.blade_) === null || _b === void 0
      ? void 0
      : _b
          .value("positions")
          .emitter.on("change", this.onBladePositionsChange_);
    this.viewProps = config.viewProps;
    this.bcSet_ = new NestedOrderedSet$1(findSubBladeControllerSet$1);
    this.bcSet_.emitter.on("add", this.onSetAdd_);
    this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(bc, opt_index) {
    var _a;
    (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
    bc.parent = this;
    this.bcSet_.add(bc, opt_index);
  }
  remove(bc) {
    bc.parent = null;
    this.bcSet_.remove(bc);
  }
  find(finder) {
    return this.bcSet_.allItems().filter(finder);
  }
  onSetAdd_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("add", {
      bladeController: ev.item,
      index: ev.index,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
    bc.blade
      .value("positions")
      .emitter.on("change", this.onChildPositionsChange_);
    bc.viewProps.handleDispose(this.onChildDispose_);
    if (isValueBladeController$1(bc)) {
      bc.value.emitter.on("change", this.onChildValueChange_);
    } else if (isContainerBladeController$1(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.on("layout", this.onRackLayout_);
        emitter.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("remove", {
      bladeController: ev.item,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    if (isValueBladeController$1(bc)) {
      bc.value.emitter.off("change", this.onChildValueChange_);
    } else if (isContainerBladeController$1(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.off("layout", this.onRackLayout_);
        emitter.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const visibleItems = this.bcSet_.items.filter(
      (bc) => !bc.viewProps.get("hidden"),
    );
    const firstVisibleItem = visibleItems[0];
    const lastVisibleItem = visibleItems[visibleItems.length - 1];
    this.bcSet_.items.forEach((bc) => {
      const ps = [];
      if (bc === firstVisibleItem) {
        ps.push("first");
        if (
          !this.blade_ ||
          this.blade_.get("positions").includes("veryfirst")
        ) {
          ps.push("veryfirst");
        }
      }
      if (bc === lastVisibleItem) {
        ps.push("last");
        if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
          ps.push("verylast");
        }
      }
      bc.blade.set("positions", ps);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildViewPropsChange_(_ev) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildDispose_() {
    const disposedUcs = this.bcSet_.items.filter((bc) => {
      return bc.viewProps.get("disposed");
    });
    disposedUcs.forEach((bc) => {
      this.bcSet_.remove(bc);
    });
  }
  onChildValueChange_(ev) {
    const bc = findValueBladeController$1(
      this.find(isValueBladeController$1),
      ev.sender,
    );
    if (!bc) {
      throw TpError$1.alreadyDisposed();
    }
    this.emitter.emit("valuechange", {
      bladeController: bc,
      options: ev.options,
      sender: this,
    });
  }
  onRackLayout_(_) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onRackValueChange_(ev) {
    this.emitter.emit("valuechange", {
      bladeController: ev.bladeController,
      options: ev.options,
      sender: this,
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
};
let RackController$1 = class RackController6 {
  constructor(config) {
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    this.element = config.element;
    this.viewProps = config.viewProps;
    const rack = new Rack$1({
      blade: config.root ? void 0 : config.blade,
      viewProps: config.viewProps,
    });
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.rack = rack;
    this.viewProps.handleDispose(() => {
      for (let i = this.rack.children.length - 1; i >= 0; i--) {
        const bc = this.rack.children[i];
        bc.viewProps.set("disposed", true);
      }
    });
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    insertElementAt$1(this.element, ev.bladeController.view.element, ev.index);
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    removeElement$1(ev.bladeController.view.element);
  }
};
function createBlade$1() {
  return new ValueMap$1({
    positions: createValue$1([], {
      equals: deepEqualsArray$1,
    }),
  });
}
let Foldable$1 = class Foldable6 extends ValueMap$1 {
  constructor(valueMap) {
    super(valueMap);
  }
  static create(expanded) {
    const coreObj = {
      completed: true,
      expanded,
      expandedHeight: null,
      shouldFixHeight: false,
      temporaryExpanded: null,
    };
    const core = ValueMap$1.createCore(coreObj);
    return new Foldable6(core);
  }
  get styleExpanded() {
    var _a;
    return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0
      ? _a
      : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded) {
      return "0";
    }
    const exHeight = this.get("expandedHeight");
    if (this.get("shouldFixHeight") && !isEmpty$1(exHeight)) {
      return `${exHeight}px`;
    }
    return "auto";
  }
  bindExpandedClass(elem, expandedClassName) {
    const onExpand = () => {
      const expanded = this.styleExpanded;
      if (expanded) {
        elem.classList.add(expandedClassName);
      } else {
        elem.classList.remove(expandedClassName);
      }
    };
    bindValueMap$1(this, "expanded", onExpand);
    bindValueMap$1(this, "temporaryExpanded", onExpand);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", false);
    this.set("expandedHeight", null);
    this.set("completed", true);
  }
};
function computeExpandedFolderHeight$1(folder, containerElement) {
  let height = 0;
  disableTransitionTemporarily$1(containerElement, () => {
    folder.set("expandedHeight", null);
    folder.set("temporaryExpanded", true);
    forceReflow$1(containerElement);
    height = containerElement.clientHeight;
    folder.set("temporaryExpanded", null);
    forceReflow$1(containerElement);
  });
  return height;
}
function applyHeight$1(foldable, elem) {
  elem.style.height = foldable.styleHeight;
}
function bindFoldable$1(foldable, elem) {
  foldable.value("expanded").emitter.on("beforechange", () => {
    foldable.set("completed", false);
    if (isEmpty$1(foldable.get("expandedHeight"))) {
      const h = computeExpandedFolderHeight$1(foldable, elem);
      if (h > 0) {
        foldable.set("expandedHeight", h);
      }
    }
    foldable.set("shouldFixHeight", true);
    forceReflow$1(elem);
  });
  foldable.emitter.on("change", () => {
    applyHeight$1(foldable, elem);
  });
  applyHeight$1(foldable, elem);
  elem.addEventListener("transitionend", (ev) => {
    if (ev.propertyName !== "height") {
      return;
    }
    foldable.cleanUpTransition();
  });
}
let FolderApi$1 = class FolderApi6 extends ContainerBladeApi$1 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$1();
    this.controller.foldable.value("expanded").emitter.on("change", (ev) => {
      this.emitter_.emit("fold", new TpFoldEvent$1(this, ev.sender.rawValue));
    });
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(expanded) {
    this.controller.foldable.set("expanded", expanded);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(title) {
    this.controller.props.set("title", title);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    return this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
};
const bladeContainerClassName$1 = ClassName$1("cnt");
let FolderView$1 = class FolderView6 {
  constructor(doc, config) {
    var _a;
    this.className_ = ClassName$1(
      (_a = config.viewName) !== null && _a !== void 0 ? _a : "fld",
    );
    this.element = doc.createElement("div");
    this.element.classList.add(this.className_(), bladeContainerClassName$1());
    config.viewProps.bindClassModifiers(this.element);
    this.foldable_ = config.foldable;
    this.foldable_.bindExpandedClass(
      this.element,
      this.className_(void 0, "expanded"),
    );
    bindValueMap$1(
      this.foldable_,
      "completed",
      valueToClassName$1(this.element, this.className_(void 0, "cpl")),
    );
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(this.className_("b"));
    bindValueMap$1(config.props, "title", (title) => {
      if (isEmpty$1(title)) {
        this.element.classList.add(this.className_(void 0, "not"));
      } else {
        this.element.classList.remove(this.className_(void 0, "not"));
      }
    });
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(this.className_("i"));
    this.element.appendChild(indentElem);
    const titleElem = doc.createElement("div");
    titleElem.classList.add(this.className_("t"));
    bindValueToTextContent$1(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(this.className_("m"));
    this.buttonElement.appendChild(markElem);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(this.className_("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
let FolderController$1 = class FolderController6 extends ContainerBladeController$1 {
  constructor(doc, config) {
    var _a;
    const foldable = Foldable$1.create(
      (_a = config.expanded) !== null && _a !== void 0 ? _a : true,
    );
    const view = new FolderView$1(doc, {
      foldable,
      props: config.props,
      viewName: config.root ? "rot" : void 0,
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$1({
          blade: config.blade,
          element: view.containerElement,
          root: config.root,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onTitleClick_ = this.onTitleClick_.bind(this);
    this.props = config.props;
    this.foldable = foldable;
    bindFoldable$1(this.foldable, this.view.containerElement);
    this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    });
    this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    });
    this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(state) {
    return importBladeState$1(
      state,
      (s) => super.importState(s),
      (p) => ({
        expanded: p.required.boolean,
        title: p.optional.string,
      }),
      (result) => {
        this.foldable.set("expanded", result.expanded);
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$1(() => super.exportState(), {
      expanded: this.foldable.get("expanded"),
      title: this.props.get("title"),
    });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
};
createPlugin$1({
  id: "folder",
  type: "blade",
  accept(params) {
    const result = parseRecord$1(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("folder"),
      expanded: p.optional.boolean,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new FolderController$1(args.document, {
      blade: args.blade,
      expanded: args.params.expanded,
      props: ValueMap$1.fromObject({
        title: args.params.title,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (!(args.controller instanceof FolderController$1)) {
      return null;
    }
    return new FolderApi$1(args.controller, args.pool);
  },
});
const cn$n$1 = ClassName$1("");
function valueToModifier$1(elem, modifier) {
  return valueToClassName$1(elem, cn$n$1(void 0, modifier));
}
let ViewProps$1 = class ViewProps6 extends ValueMap$1 {
  constructor(valueMap) {
    var _a;
    super(valueMap);
    this.onDisabledChange_ = this.onDisabledChange_.bind(this);
    this.onParentChange_ = this.onParentChange_.bind(this);
    this.onParentGlobalDisabledChange_ =
      this.onParentGlobalDisabledChange_.bind(this);
    [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue$1(
      createValue$1(this.getGlobalDisabled_()),
    );
    this.value("disabled").emitter.on("change", this.onDisabledChange_);
    this.value("parent").emitter.on("change", this.onParentChange_);
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
  }
  static create(opt_initialValue) {
    var _a, _b, _c;
    const initialValue =
      opt_initialValue !== null && opt_initialValue !== void 0
        ? opt_initialValue
        : {};
    return new ViewProps6(
      ValueMap$1.createCore({
        disabled:
          (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
        disposed: false,
        hidden:
          (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
        parent:
          (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null,
      }),
    );
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(elem) {
    bindValue$1(this.globalDisabled_, valueToModifier$1(elem, "disabled"));
    bindValueMap$1(this, "hidden", valueToModifier$1(elem, "hidden"));
  }
  bindDisabled(target) {
    bindValue$1(this.globalDisabled_, (disabled) => {
      target.disabled = disabled;
    });
  }
  bindTabIndex(elem) {
    bindValue$1(this.globalDisabled_, (disabled) => {
      elem.tabIndex = disabled ? -1 : 0;
    });
  }
  handleDispose(callback) {
    this.value("disposed").emitter.on("change", (disposed) => {
      if (disposed) {
        callback();
      }
    });
  }
  importState(state) {
    this.set("disabled", state.disabled);
    this.set("hidden", state.hidden);
  }
  exportState() {
    return {
      disabled: this.get("disabled"),
      hidden: this.get("hidden"),
    };
  }
  getGlobalDisabled_() {
    const parent = this.get("parent");
    const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
    return parentDisabled || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(ev) {
    var _a;
    const prevParent = ev.previousRawValue;
    prevParent === null || prevParent === void 0
      ? void 0
      : prevParent.globalDisabled.emitter.off(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    this.updateGlobalDisabled_();
  }
};
const cn$m$1 = ClassName$1("tbp");
let TabPageView$1 = class TabPageView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$m$1());
    config.viewProps.bindClassModifiers(this.element);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(cn$m$1("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
};
const cn$l$1 = ClassName$1("tbi");
let TabItemView$1 = class TabItemView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$l$1());
    config.viewProps.bindClassModifiers(this.element);
    bindValueMap$1(config.props, "selected", (selected) => {
      if (selected) {
        this.element.classList.add(cn$l$1(void 0, "sel"));
      } else {
        this.element.classList.remove(cn$l$1(void 0, "sel"));
      }
    });
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$l$1("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$l$1("t"));
    bindValueToTextContent$1(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
  }
};
let TabItemController$1 = class TabItemController6 {
  constructor(doc, config) {
    this.emitter = new Emitter$1();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new TabItemView$1(doc, {
      props: config.props,
      viewProps: config.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
};
let TabPageController$1 = class TabPageController6 extends ContainerBladeController$1 {
  constructor(doc, config) {
    const view = new TabPageView$1(doc, {
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController$1({
          blade: config.blade,
          element: view.containerElement,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onItemClick_ = this.onItemClick_.bind(this);
    this.ic_ = new TabItemController$1(doc, {
      props: config.itemProps,
      viewProps: ViewProps$1.create(),
    });
    this.ic_.emitter.on("click", this.onItemClick_);
    this.props = config.props;
    bindValueMap$1(this.props, "selected", (selected) => {
      this.itemController.props.set("selected", selected);
      this.viewProps.set("hidden", !selected);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(state) {
    return importBladeState$1(
      state,
      (s) => super.importState(s),
      (p) => ({
        selected: p.required.boolean,
        title: p.required.string,
      }),
      (result) => {
        this.ic_.props.set("selected", result.selected);
        this.ic_.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState$1(() => super.exportState(), {
      selected: this.ic_.props.get("selected"),
      title: this.ic_.props.get("title"),
    });
  }
  onItemClick_() {
    this.props.set("selected", true);
  }
};
let TabApi$1 = class TabApi6 extends ContainerBladeApi$1 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter$1();
    this.onSelect_ = this.onSelect_.bind(this);
    this.pool_ = pool;
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
    this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(params) {
    const doc = this.controller.view.element.ownerDocument;
    const pc = new TabPageController$1(doc, {
      blade: createBlade$1(),
      itemProps: ValueMap$1.fromObject({
        selected: false,
        title: params.title,
      }),
      props: ValueMap$1.fromObject({
        selected: false,
      }),
      viewProps: ViewProps$1.create(),
    });
    const papi = this.pool_.createApi(pc);
    return this.rackApi_.add(papi, params.index);
  }
  removePage(index) {
    this.rackApi_.remove(this.rackApi_.children[index]);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  onSelect_(ev) {
    this.emitter_.emit("select", new TpTabSelectEvent$1(this, ev.rawValue));
  }
};
let TabPageApi$1 = class TabPageApi6 extends ContainerBladeApi$1 {
  get title() {
    var _a;
    return (_a = this.controller.itemController.props.get("title")) !== null &&
      _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.itemController.props.set("title", title);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(selected) {
    this.controller.props.set("selected", selected);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
};
const INDEX_NOT_SELECTED$1 = -1;
let Tab$1 = class Tab6 {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
    this.empty = createValue$1(true);
    this.selectedIndex = createValue$1(INDEX_NOT_SELECTED$1);
    this.items_ = [];
  }
  add(item, opt_index) {
    const index =
      opt_index !== null && opt_index !== void 0
        ? opt_index
        : this.items_.length;
    this.items_.splice(index, 0, item);
    item.emitter.on("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    item.emitter.off("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = INDEX_NOT_SELECTED$1;
      this.empty.rawValue = true;
      return;
    }
    const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
    if (firstSelIndex < 0) {
      this.items_.forEach((s, i) => {
        s.rawValue = i === 0;
      });
      this.selectedIndex.rawValue = 0;
    } else {
      this.items_.forEach((s, i) => {
        s.rawValue = i === firstSelIndex;
      });
      this.selectedIndex.rawValue = firstSelIndex;
    }
    this.empty.rawValue = false;
  }
  onItemSelectedChange_(ev) {
    if (ev.rawValue) {
      const index = this.items_.findIndex((s) => s === ev.sender);
      this.items_.forEach((s, i) => {
        s.rawValue = i === index;
      });
      this.selectedIndex.rawValue = index;
    } else {
      this.keepSelection_();
    }
  }
};
const cn$k$1 = ClassName$1("tab");
let TabView$1 = class TabView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$k$1(), bladeContainerClassName$1());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$1(
      config.empty,
      valueToClassName$1(this.element, cn$k$1(void 0, "nop")),
    );
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$k$1("t"));
    this.element.appendChild(titleElem);
    this.itemsElement = titleElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(cn$k$1("i"));
    this.element.appendChild(indentElem);
    const contentsElem = doc.createElement("div");
    contentsElem.classList.add(cn$k$1("c"));
    this.element.appendChild(contentsElem);
    this.contentsElement = contentsElem;
  }
};
let TabController$1 = class TabController6 extends ContainerBladeController$1 {
  constructor(doc, config) {
    const tab = new Tab$1();
    const view = new TabView$1(doc, {
      empty: tab.empty,
      viewProps: config.viewProps,
    });
    super({
      blade: config.blade,
      rackController: new RackController$1({
        blade: config.blade,
        element: view.contentsElement,
        viewProps: config.viewProps,
      }),
      view,
    });
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    const rack = this.rackController.rack;
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.tab = tab;
  }
  add(pc, opt_index) {
    this.rackController.rack.add(pc, opt_index);
  }
  remove(index) {
    this.rackController.rack.remove(this.rackController.rack.children[index]);
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    insertElementAt$1(
      this.view.itemsElement,
      pc.itemController.view.element,
      ev.index,
    );
    pc.itemController.viewProps.set("parent", this.viewProps);
    this.tab.add(pc.props.value("selected"));
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    removeElement$1(pc.itemController.view.element);
    pc.itemController.viewProps.set("parent", null);
    this.tab.remove(pc.props.value("selected"));
  }
};
createPlugin$1({
  id: "tab",
  type: "blade",
  accept(params) {
    const result = parseRecord$1(params, (p) => ({
      pages: p.required.array(p.required.object({ title: p.required.string })),
      view: p.required.constant("tab"),
    }));
    if (!result || result.pages.length === 0) {
      return null;
    }
    return { params: result };
  },
  controller(args) {
    const c = new TabController$1(args.document, {
      blade: args.blade,
      viewProps: args.viewProps,
    });
    args.params.pages.forEach((p) => {
      const pc = new TabPageController$1(args.document, {
        blade: createBlade$1(),
        itemProps: ValueMap$1.fromObject({
          selected: false,
          title: p.title,
        }),
        props: ValueMap$1.fromObject({
          selected: false,
        }),
        viewProps: ViewProps$1.create(),
      });
      c.add(pc);
    });
    return c;
  },
  api(args) {
    if (args.controller instanceof TabController$1) {
      return new TabApi$1(args.controller, args.pool);
    }
    if (args.controller instanceof TabPageController$1) {
      return new TabPageApi$1(args.controller, args.pool);
    }
    return null;
  },
});
let ListInputBindingApi$1 = class ListInputBindingApi6 extends BindingApi$1 {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(options) {
    this.controller.valueController.props.set("options", options);
  }
};
class ManualTicker2 {
  constructor() {
    this.disabled = false;
    this.emitter = new Emitter$1();
  }
  dispose() {}
  tick() {
    if (this.disabled) {
      return;
    }
    this.emitter.emit("tick", {
      sender: this,
    });
  }
}
class IntervalTicker2 {
  constructor(doc, interval) {
    this.disabled_ = false;
    this.timerId_ = null;
    this.onTick_ = this.onTick_.bind(this);
    this.doc_ = doc;
    this.emitter = new Emitter$1();
    this.interval_ = interval;
    this.setTimer_();
  }
  get disabled() {
    return this.disabled_;
  }
  set disabled(inactive) {
    this.disabled_ = inactive;
    if (this.disabled_) {
      this.clearTimer_();
    } else {
      this.setTimer_();
    }
  }
  dispose() {
    this.clearTimer_();
  }
  clearTimer_() {
    if (this.timerId_ === null) {
      return;
    }
    const win = this.doc_.defaultView;
    if (win) {
      win.clearInterval(this.timerId_);
    }
    this.timerId_ = null;
  }
  setTimer_() {
    this.clearTimer_();
    if (this.interval_ <= 0) {
      return;
    }
    const win = this.doc_.defaultView;
    if (win) {
      this.timerId_ = win.setInterval(this.onTick_, this.interval_);
    }
  }
  onTick_() {
    if (this.disabled_) {
      return;
    }
    this.emitter.emit("tick", {
      sender: this,
    });
  }
}
let CompositeConstraint$1 = class CompositeConstraint6 {
  constructor(constraints) {
    this.constraints = constraints;
  }
  constrain(value) {
    return this.constraints.reduce((result, c) => {
      return c.constrain(result);
    }, value);
  }
};
function findConstraint$1(c, constraintClass) {
  if (c instanceof constraintClass) {
    return c;
  }
  if (c instanceof CompositeConstraint$1) {
    const result = c.constraints.reduce((tmpResult, sc) => {
      if (tmpResult) {
        return tmpResult;
      }
      return sc instanceof constraintClass ? sc : null;
    }, null);
    if (result) {
      return result;
    }
  }
  return null;
}
let ListConstraint$1 = class ListConstraint6 {
  constructor(options) {
    this.values = ValueMap$1.fromObject({
      options,
    });
  }
  constrain(value) {
    const opts = this.values.get("options");
    if (opts.length === 0) {
      return value;
    }
    const matched =
      opts.filter((item) => {
        return item.value === value;
      }).length > 0;
    return matched ? value : opts[0].value;
  }
};
function parseListOptions$1(value) {
  var _a;
  const p = MicroParsers$1;
  if (Array.isArray(value)) {
    return (_a = parseRecord$1({ items: value }, (p2) => ({
      items: p2.required.array(
        p2.required.object({
          text: p2.required.string,
          value: p2.required.raw,
        }),
      ),
    }))) === null || _a === void 0
      ? void 0
      : _a.items;
  }
  if (typeof value === "object") {
    return p.required.raw(value).value;
  }
  return void 0;
}
function normalizeListOptions$1(options) {
  if (Array.isArray(options)) {
    return options;
  }
  const items = [];
  Object.keys(options).forEach((text) => {
    items.push({ text, value: options[text] });
  });
  return items;
}
function createListConstraint$1(options) {
  return !isEmpty$1(options)
    ? new ListConstraint$1(normalizeListOptions$1(forceCast$1(options)))
    : null;
}
const cn$j$1 = ClassName$1("lst");
let ListView$1 = class ListView6 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$j$1());
    config.viewProps.bindClassModifiers(this.element);
    const selectElem = doc.createElement("select");
    selectElem.classList.add(cn$j$1("s"));
    config.viewProps.bindDisabled(selectElem);
    this.element.appendChild(selectElem);
    this.selectElement = selectElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(cn$j$1("m"));
    markElem.appendChild(createSvgIconElement$1(doc, "dropdown"));
    this.element.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value_ = config.value;
    bindValueMap$1(this.props_, "options", (opts) => {
      removeChildElements$1(this.selectElement);
      opts.forEach((item) => {
        const optionElem = doc.createElement("option");
        optionElem.textContent = item.text;
        this.selectElement.appendChild(optionElem);
      });
      this.update_();
    });
  }
  update_() {
    const values = this.props_.get("options").map((o) => o.value);
    this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
};
let ListController$1 = class ListController6 {
  constructor(doc, config) {
    this.onSelectChange_ = this.onSelectChange_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ListView$1(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const selectElem = forceCast$1(e.currentTarget);
    this.value.rawValue =
      this.props.get("options")[selectElem.selectedIndex].value;
  }
  importProps(state) {
    return importBladeState$1(
      state,
      null,
      (p) => ({
        options: p.required.custom(parseListOptions$1),
      }),
      (result) => {
        this.props.set("options", normalizeListOptions$1(result.options));
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$1(null, {
      options: this.props.get("options"),
    });
  }
};
const cn$i$1 = ClassName$1("pop");
let PopupView$1 = class PopupView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$i$1());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$1(
      config.shows,
      valueToClassName$1(this.element, cn$i$1(void 0, "v")),
    );
  }
};
let PopupController$1 = class PopupController6 {
  constructor(doc, config) {
    this.shows = createValue$1(false);
    this.viewProps = config.viewProps;
    this.view = new PopupView$1(doc, {
      shows: this.shows,
      viewProps: this.viewProps,
    });
  }
};
const cn$h$1 = ClassName$1("txt");
let TextView$1 = class TextView6 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$h$1());
    config.viewProps.bindClassModifiers(this.element);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$h$1("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onChange_);
    this.value_ = config.value;
    this.refresh();
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let TextController$1 = class TextController6 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new TextView$1(doc, {
      props: config.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$1(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$1(parsedValue)) {
      this.value.rawValue = parsedValue;
    }
    this.view.refresh();
  }
};
function boolToString$1(value) {
  return String(value);
}
function boolFromUnknown$1(value) {
  if (value === "false") {
    return false;
  }
  return !!value;
}
function BooleanFormatter$1(value) {
  return boolToString$1(value);
}
function composeParsers$1(parsers) {
  return (text) => {
    return parsers.reduce((result, parser) => {
      if (result !== null) {
        return result;
      }
      return parser(text);
    }, null);
  };
}
const innerFormatter$1 = createNumberFormatter$1(0);
function formatPercentage$1(value) {
  return innerFormatter$1(value) + "%";
}
function stringFromUnknown$1(value) {
  return String(value);
}
function formatString$1(value) {
  return value;
}
function connectValues$1({ primary, secondary, forward, backward }) {
  let changing = false;
  function preventFeedback(callback) {
    if (changing) {
      return;
    }
    changing = true;
    callback();
    changing = false;
  }
  primary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  secondary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      primary.setRawValue(
        backward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  preventFeedback(() => {
    secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), {
      forceEmit: false,
      last: true,
    });
  });
}
function getStepForKey$1(keyScale, keys) {
  const step = keyScale * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
  if (keys.upKey) {
    return +step;
  } else if (keys.downKey) {
    return -step;
  }
  return 0;
}
function getVerticalStepKeys$1(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowDown",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowUp",
  };
}
function getHorizontalStepKeys$1(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowLeft",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowRight",
  };
}
function isVerticalArrowKey$1(key2) {
  return key2 === "ArrowUp" || key2 === "ArrowDown";
}
function isArrowKey$1(key2) {
  return (
    isVerticalArrowKey$1(key2) || key2 === "ArrowLeft" || key2 === "ArrowRight"
  );
}
function computeOffset$1$1(ev, elem) {
  var _a, _b;
  const win = elem.ownerDocument.defaultView;
  const rect = elem.getBoundingClientRect();
  return {
    x:
      ev.pageX -
      (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) +
        rect.left),
    y:
      ev.pageY -
      (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) +
        rect.top),
  };
}
let PointerHandler$1 = class PointerHandler6 {
  constructor(element) {
    this.lastTouch_ = null;
    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onTouchEnd_ = this.onTouchEnd_.bind(this);
    this.onTouchMove_ = this.onTouchMove_.bind(this);
    this.onTouchStart_ = this.onTouchStart_.bind(this);
    this.elem_ = element;
    this.emitter = new Emitter$1();
    element.addEventListener("touchstart", this.onTouchStart_, {
      passive: false,
    });
    element.addEventListener("touchmove", this.onTouchMove_, {
      passive: true,
    });
    element.addEventListener("touchend", this.onTouchEnd_);
    element.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(offset) {
    const rect = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: rect.width,
        height: rect.height,
      },
      point: offset
        ? {
            x: offset.x,
            y: offset.y,
          }
        : null,
    };
  }
  onMouseDown_(ev) {
    var _a;
    ev.preventDefault();
    (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
    const doc = this.elem_.ownerDocument;
    doc.addEventListener("mousemove", this.onDocumentMouseMove_);
    doc.addEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$1(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseMove_(ev) {
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$1(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseUp_(ev) {
    const doc = this.elem_.ownerDocument;
    doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
    doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1$1(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onTouchStart_(ev) {
    ev.preventDefault();
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchMove_(ev) {
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchEnd_(ev) {
    var _a;
    const touch =
      (_a = ev.targetTouches.item(0)) !== null && _a !== void 0
        ? _a
        : this.lastTouch_;
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
};
const cn$g$1 = ClassName$1("txt");
let NumberTextView$1 = class NumberTextView6 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$g$1(), cn$g$1(void 0, "num"));
    if (config.arrayPosition) {
      this.element.classList.add(cn$g$1(void 0, config.arrayPosition));
    }
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$g$1("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    this.onDraggingChange_ = this.onDraggingChange_.bind(this);
    this.dragging_ = config.dragging;
    this.dragging_.emitter.on("change", this.onDraggingChange_);
    this.element.classList.add(cn$g$1());
    this.inputElement.classList.add(cn$g$1("i"));
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$g$1("k"));
    this.element.appendChild(knobElem);
    this.knobElement = knobElem;
    const guideElem = doc.createElementNS(SVG_NS$1, "svg");
    guideElem.classList.add(cn$g$1("g"));
    this.knobElement.appendChild(guideElem);
    const bodyElem = doc.createElementNS(SVG_NS$1, "path");
    bodyElem.classList.add(cn$g$1("gb"));
    guideElem.appendChild(bodyElem);
    this.guideBodyElem_ = bodyElem;
    const headElem = doc.createElementNS(SVG_NS$1, "path");
    headElem.classList.add(cn$g$1("gh"));
    guideElem.appendChild(headElem);
    this.guideHeadElem_ = headElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(ClassName$1("tt")());
    this.knobElement.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.refresh();
  }
  onDraggingChange_(ev) {
    if (ev.rawValue === null) {
      this.element.classList.remove(cn$g$1(void 0, "drg"));
      return;
    }
    this.element.classList.add(cn$g$1(void 0, "drg"));
    const x = ev.rawValue / this.props_.get("pointerScale");
    const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
    const adx = constrainRange$1(-aox, -4, 4);
    this.guideHeadElem_.setAttributeNS(
      null,
      "d",
      [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(
        " ",
      ),
    );
    this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
    const formatter = this.props_.get("formatter");
    this.tooltipElem_.textContent = formatter(this.value.rawValue);
    this.tooltipElem_.style.left = `${x}px`;
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
};
let NumberTextController$1 = class NumberTextController6 {
  constructor(doc, config) {
    var _a;
    this.originRawValue_ = 0;
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.sliderProps_ =
      (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.dragging_ = createValue$1(null);
    this.view = new NumberTextView$1(doc, {
      arrayPosition: config.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
    this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
    this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const ph = new PointerHandler$1(this.view.knobElement);
    ph.emitter.on("down", this.onPointerDown_);
    ph.emitter.on("move", this.onPointerMove_);
    ph.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(value) {
    var _a, _b;
    const min =
      (_a = this.sliderProps_) === null || _a === void 0
        ? void 0
        : _a.get("min");
    const max =
      (_b = this.sliderProps_) === null || _b === void 0
        ? void 0
        : _b.get("max");
    let v = value;
    if (min !== void 0) {
      v = Math.max(v, min);
    }
    if (max !== void 0) {
      v = Math.min(v, max);
    }
    return v;
  }
  onInputChange_(e) {
    const inputElem = forceCast$1(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty$1(parsedValue)) {
      this.value.rawValue = this.constrainValue_(parsedValue);
    }
    this.view.refresh();
  }
  onInputKeyDown_(ev) {
    const step = getStepForKey$1(
      this.props.get("keyScale"),
      getVerticalStepKeys$1(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
      forceEmit: false,
      last: false,
    });
  }
  onInputKeyUp_(ev) {
    const step = getStepForKey$1(
      this.props.get("keyScale"),
      getVerticalStepKeys$1(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue;
    this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(data) {
    if (!data.point) {
      return null;
    }
    const dx = data.point.x - data.bounds.width / 2;
    return this.constrainValue_(
      this.originRawValue_ + dx * this.props.get("pointerScale"),
    );
  }
  onPointerMove_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: false,
      last: false,
    });
    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
  }
  onPointerUp_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: true,
      last: true,
    });
    this.dragging_.rawValue = null;
  }
};
const cn$f$1 = ClassName$1("sld");
let SliderView$1 = class SliderView6 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$f$1());
    config.viewProps.bindClassModifiers(this.element);
    const trackElem = doc.createElement("div");
    trackElem.classList.add(cn$f$1("t"));
    config.viewProps.bindTabIndex(trackElem);
    this.element.appendChild(trackElem);
    this.trackElement = trackElem;
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$f$1("k"));
    this.trackElement.appendChild(knobElem);
    this.knobElement = knobElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const p = constrainRange$1(
      mapRange$1(
        this.value.rawValue,
        this.props_.get("min"),
        this.props_.get("max"),
        0,
        100,
      ),
      0,
      100,
    );
    this.knobElement.style.width = `${p}%`;
  }
  onChange_() {
    this.update_();
  }
};
let SliderController$1 = class SliderController6 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.props = config.props;
    this.view = new SliderView$1(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$1(this.view.trackElement);
    this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
    this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    this.value.setRawValue(
      mapRange$1(
        constrainRange$1(d.point.x, 0, d.bounds.width),
        0,
        d.bounds.width,
        this.props.get("min"),
        this.props.get("max"),
      ),
      opts,
    );
  }
  onPointerDownOrMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$1(
      this.props.get("keyScale"),
      getHorizontalStepKeys$1(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue + step, {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$1(
      this.props.get("keyScale"),
      getHorizontalStepKeys$1(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$e$1 = ClassName$1("sldtxt");
let SliderTextView$1 = class SliderTextView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$e$1());
    const sliderElem = doc.createElement("div");
    sliderElem.classList.add(cn$e$1("s"));
    this.sliderView_ = config.sliderView;
    sliderElem.appendChild(this.sliderView_.element);
    this.element.appendChild(sliderElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$e$1("t"));
    this.textView_ = config.textView;
    textElem.appendChild(this.textView_.element);
    this.element.appendChild(textElem);
  }
};
let SliderTextController$1 = class SliderTextController6 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.sliderC_ = new SliderController$1(doc, {
      props: config.sliderProps,
      value: config.value,
      viewProps: this.viewProps,
    });
    this.textC_ = new NumberTextController$1(doc, {
      parser: config.parser,
      props: config.textProps,
      sliderProps: config.sliderProps,
      value: config.value,
      viewProps: config.viewProps,
    });
    this.view = new SliderTextView$1(doc, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view,
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(state) {
    return importBladeState$1(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        const sliderProps = this.sliderC_.props;
        sliderProps.set("max", result.max);
        sliderProps.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    const sliderProps = this.sliderC_.props;
    return exportBladeState$1(null, {
      max: sliderProps.get("max"),
      min: sliderProps.get("min"),
    });
  }
};
function createSliderTextProps$1(config) {
  return {
    sliderProps: new ValueMap$1({
      keyScale: config.keyScale,
      max: config.max,
      min: config.min,
    }),
    textProps: new ValueMap$1({
      formatter: createValue$1(config.formatter),
      keyScale: config.keyScale,
      pointerScale: createValue$1(config.pointerScale),
    }),
  };
}
const CSS_VAR_MAP$1 = {
  containerUnitSize: "cnt-usz",
};
function getCssVar$1(key2) {
  return `--${CSS_VAR_MAP$1[key2]}`;
}
function createPointDimensionParser$1(p) {
  return createNumberTextInputParamsParser$1(p);
}
function parsePointDimensionParams$1(value) {
  if (!isRecord$1(value)) {
    return void 0;
  }
  return parseRecord$1(value, createPointDimensionParser$1);
}
function createDimensionConstraint$1(params, initialValue) {
  if (!params) {
    return void 0;
  }
  const constraints = [];
  const cs = createStepConstraint$1(params, initialValue);
  if (cs) {
    constraints.push(cs);
  }
  const rs = createRangeConstraint$1(params);
  if (rs) {
    constraints.push(rs);
  }
  return new CompositeConstraint$1(constraints);
}
function parsePickerLayout$1(value) {
  if (value === "inline" || value === "popup") {
    return value;
  }
  return void 0;
}
function writePrimitive$1(target, value) {
  target.write(value);
}
const cn$d$1 = ClassName$1("ckb");
let CheckboxView$1 = class CheckboxView6 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$d$1());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("label");
    labelElem.classList.add(cn$d$1("l"));
    this.element.appendChild(labelElem);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$d$1("i"));
    inputElem.type = "checkbox";
    labelElem.appendChild(inputElem);
    this.inputElement = inputElem;
    config.viewProps.bindDisabled(this.inputElement);
    const wrapperElem = doc.createElement("div");
    wrapperElem.classList.add(cn$d$1("w"));
    labelElem.appendChild(wrapperElem);
    const markElem = createSvgIconElement$1(doc, "check");
    wrapperElem.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
};
let CheckboxController$1 = class CheckboxController6 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new CheckboxView$1(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast$1(e.currentTarget);
    this.value.rawValue = inputElem.checked;
  }
};
function createConstraint$6$1(params) {
  const constraints = [];
  const lc = createListConstraint$1(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$1(constraints);
}
createPlugin$1({
  id: "input-bool",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$1(params, (p) => ({
      options: p.optional.custom(parseListOptions$1),
      readonly: p.optional.constant(false),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$1,
    constraint: (args) => createConstraint$6$1(args.params),
    writer: (_args) => writePrimitive$1,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$1(c, ListConstraint$1);
    if (lc) {
      return new ListController$1(doc, {
        props: new ValueMap$1({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new CheckboxController$1(doc, {
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "boolean") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$1) {
      return new ListInputBindingApi$1(args.controller);
    }
    return null;
  },
});
const cn$c$1 = ClassName$1("col");
let ColorView$1 = class ColorView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$c$1());
    config.foldable.bindExpandedClass(this.element, cn$c$1(void 0, "expanded"));
    bindValueMap$1(
      config.foldable,
      "completed",
      valueToClassName$1(this.element, cn$c$1(void 0, "cpl")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$c$1("h"));
    this.element.appendChild(headElem);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$c$1("s"));
    headElem.appendChild(swatchElem);
    this.swatchElement = swatchElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$c$1("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$c$1("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
function rgbToHslInt$1(r, g, b) {
  const rp = constrainRange$1(r / 255, 0, 1);
  const gp = constrainRange$1(g / 255, 0, 1);
  const bp = constrainRange$1(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const c = cmax - cmin;
  let h = 0;
  let s = 0;
  const l = (cmin + cmax) / 2;
  if (c !== 0) {
    s = c / (1 - Math.abs(cmax + cmin - 1));
    if (rp === cmax) {
      h = (gp - bp) / c;
    } else if (gp === cmax) {
      h = 2 + (bp - rp) / c;
    } else {
      h = 4 + (rp - gp) / c;
    }
    h = h / 6 + (h < 0 ? 1 : 0);
  }
  return [h * 360, s * 100, l * 100];
}
function hslToRgbInt$1(h, s, l) {
  const hp = ((h % 360) + 360) % 360;
  const sp = constrainRange$1(s / 100, 0, 1);
  const lp = constrainRange$1(l / 100, 0, 1);
  const c = (1 - Math.abs(2 * lp - 1)) * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = lp - c / 2;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function rgbToHsvInt$1(r, g, b) {
  const rp = constrainRange$1(r / 255, 0, 1);
  const gp = constrainRange$1(g / 255, 0, 1);
  const bp = constrainRange$1(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const d = cmax - cmin;
  let h;
  if (d === 0) {
    h = 0;
  } else if (cmax === rp) {
    h = 60 * (((((gp - bp) / d) % 6) + 6) % 6);
  } else if (cmax === gp) {
    h = 60 * ((bp - rp) / d + 2);
  } else {
    h = 60 * ((rp - gp) / d + 4);
  }
  const s = cmax === 0 ? 0 : d / cmax;
  const v = cmax;
  return [h, s * 100, v * 100];
}
function hsvToRgbInt$1(h, s, v) {
  const hp = loopRange$1(h, 360);
  const sp = constrainRange$1(s / 100, 0, 1);
  const vp = constrainRange$1(v / 100, 0, 1);
  const c = vp * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = vp - c;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function hslToHsvInt$1(h, s, l) {
  const sd = l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100);
  return [
    h,
    sd !== 0 ? (s * (100 - Math.abs(2 * l - 100))) / sd : 0,
    l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100),
  ];
}
function hsvToHslInt$1(h, s, v) {
  const sd = 100 - Math.abs((v * (200 - s)) / 100 - 100);
  return [h, sd !== 0 ? (s * v) / sd : 0, (v * (200 - s)) / (2 * 100)];
}
function removeAlphaComponent$1(comps) {
  return [comps[0], comps[1], comps[2]];
}
function appendAlphaComponent$1(comps, alpha) {
  return [comps[0], comps[1], comps[2], alpha];
}
const MODE_CONVERTER_MAP$1 = {
  hsl: {
    hsl: (h, s, l) => [h, s, l],
    hsv: hslToHsvInt$1,
    rgb: hslToRgbInt$1,
  },
  hsv: {
    hsl: hsvToHslInt$1,
    hsv: (h, s, v) => [h, s, v],
    rgb: hsvToRgbInt$1,
  },
  rgb: {
    hsl: rgbToHslInt$1,
    hsv: rgbToHsvInt$1,
    rgb: (r, g, b) => [r, g, b],
  },
};
function getColorMaxComponents$1(mode, type) {
  return [
    type === "float" ? 1 : mode === "rgb" ? 255 : 360,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
  ];
}
function loopHueRange$1(hue, max) {
  return hue === max ? max : loopRange$1(hue, max);
}
function constrainColorComponents$1(components, mode, type) {
  var _a;
  const ms = getColorMaxComponents$1(mode, type);
  return [
    mode === "rgb"
      ? constrainRange$1(components[0], 0, ms[0])
      : loopHueRange$1(components[0], ms[0]),
    constrainRange$1(components[1], 0, ms[1]),
    constrainRange$1(components[2], 0, ms[2]),
    constrainRange$1(
      (_a = components[3]) !== null && _a !== void 0 ? _a : 1,
      0,
      1,
    ),
  ];
}
function convertColorType$1(comps, mode, from, to) {
  const fms = getColorMaxComponents$1(mode, from);
  const tms = getColorMaxComponents$1(mode, to);
  return comps.map((c, index) => (c / fms[index]) * tms[index]);
}
function convertColor$1(components, from, to) {
  const intComps = convertColorType$1(components, from.mode, from.type, "int");
  const result = MODE_CONVERTER_MAP$1[from.mode][to.mode](...intComps);
  return convertColorType$1(result, to.mode, "int", to.type);
}
let IntColor$1 = class IntColor6 {
  static black() {
    return new IntColor6([0, 0, 0], "rgb");
  }
  constructor(comps, mode) {
    this.type = "int";
    this.mode = mode;
    this.comps_ = constrainColorComponents$1(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$1(
      convertColor$1(
        removeAlphaComponent$1(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const cn$b$1 = ClassName$1("colp");
let ColorPickerView$1 = class ColorPickerView6 {
  constructor(doc, config) {
    this.alphaViews_ = null;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$b$1());
    config.viewProps.bindClassModifiers(this.element);
    const hsvElem = doc.createElement("div");
    hsvElem.classList.add(cn$b$1("hsv"));
    const svElem = doc.createElement("div");
    svElem.classList.add(cn$b$1("sv"));
    this.svPaletteView_ = config.svPaletteView;
    svElem.appendChild(this.svPaletteView_.element);
    hsvElem.appendChild(svElem);
    const hElem = doc.createElement("div");
    hElem.classList.add(cn$b$1("h"));
    this.hPaletteView_ = config.hPaletteView;
    hElem.appendChild(this.hPaletteView_.element);
    hsvElem.appendChild(hElem);
    this.element.appendChild(hsvElem);
    const rgbElem = doc.createElement("div");
    rgbElem.classList.add(cn$b$1("rgb"));
    this.textsView_ = config.textsView;
    rgbElem.appendChild(this.textsView_.element);
    this.element.appendChild(rgbElem);
    if (config.alphaViews) {
      this.alphaViews_ = {
        palette: config.alphaViews.palette,
        text: config.alphaViews.text,
      };
      const aElem = doc.createElement("div");
      aElem.classList.add(cn$b$1("a"));
      const apElem = doc.createElement("div");
      apElem.classList.add(cn$b$1("ap"));
      apElem.appendChild(this.alphaViews_.palette.element);
      aElem.appendChild(apElem);
      const atElem = doc.createElement("div");
      atElem.classList.add(cn$b$1("at"));
      atElem.appendChild(this.alphaViews_.text.element);
      aElem.appendChild(atElem);
      this.element.appendChild(aElem);
    }
  }
  get allFocusableElements() {
    const elems = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textsView_.modeSelectElement,
      ...this.textsView_.inputViews.map((v) => v.inputElement),
    ];
    if (this.alphaViews_) {
      elems.push(
        this.alphaViews_.palette.element,
        this.alphaViews_.text.inputElement,
      );
    }
    return elems;
  }
};
function parseColorType$1(value) {
  return value === "int" ? "int" : value === "float" ? "float" : void 0;
}
function parseColorInputParams$1(params) {
  return parseRecord$1(params, (p) => ({
    color: p.optional.object({
      alpha: p.optional.boolean,
      type: p.optional.custom(parseColorType$1),
    }),
    expanded: p.optional.boolean,
    picker: p.optional.custom(parsePickerLayout$1),
    readonly: p.optional.constant(false),
  }));
}
function getKeyScaleForColor$1(forAlpha) {
  return forAlpha ? 0.1 : 1;
}
function extractColorType$1(params) {
  var _a;
  return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
}
let FloatColor$1 = class FloatColor6 {
  constructor(comps, mode) {
    this.type = "float";
    this.mode = mode;
    this.comps_ = constrainColorComponents$1(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent$1(
      convertColor$1(
        removeAlphaComponent$1(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
};
const TYPE_TO_CONSTRUCTOR_MAP$1 = {
  int: (comps, mode) => new IntColor$1(comps, mode),
  float: (comps, mode) => new FloatColor$1(comps, mode),
};
function createColor$1(comps, mode, type) {
  return TYPE_TO_CONSTRUCTOR_MAP$1[type](comps, mode);
}
function isFloatColor$1(c) {
  return c.type === "float";
}
function isIntColor$1(c) {
  return c.type === "int";
}
function convertFloatToInt$1(cf) {
  const comps = cf.getComponents();
  const ms = getColorMaxComponents$1(cf.mode, "int");
  return new IntColor$1(
    [
      Math.round(mapRange$1(comps[0], 0, 1, 0, ms[0])),
      Math.round(mapRange$1(comps[1], 0, 1, 0, ms[1])),
      Math.round(mapRange$1(comps[2], 0, 1, 0, ms[2])),
      comps[3],
    ],
    cf.mode,
  );
}
function convertIntToFloat$1(ci) {
  const comps = ci.getComponents();
  const ms = getColorMaxComponents$1(ci.mode, "int");
  return new FloatColor$1(
    [
      mapRange$1(comps[0], 0, ms[0], 0, 1),
      mapRange$1(comps[1], 0, ms[1], 0, 1),
      mapRange$1(comps[2], 0, ms[2], 0, 1),
      comps[3],
    ],
    ci.mode,
  );
}
function mapColorType$1(c, type) {
  if (c.type === type) {
    return c;
  }
  if (isIntColor$1(c) && type === "float") {
    return convertIntToFloat$1(c);
  }
  if (isFloatColor$1(c) && type === "int") {
    return convertFloatToInt$1(c);
  }
  throw TpError$1.shouldNeverHappen();
}
function equalsStringColorFormat$1(f1, f2) {
  return (
    f1.alpha === f2.alpha &&
    f1.mode === f2.mode &&
    f1.notation === f2.notation &&
    f1.type === f2.type
  );
}
function parseCssNumberOrPercentage$1(text, max) {
  const m = text.match(/^(.+)%$/);
  if (!m) {
    return Math.min(parseFloat(text), max);
  }
  return Math.min(parseFloat(m[1]) * 0.01 * max, max);
}
const ANGLE_TO_DEG_MAP$1 = {
  deg: (angle) => angle,
  grad: (angle) => (angle * 360) / 400,
  rad: (angle) => (angle * 360) / (2 * Math.PI),
  turn: (angle) => angle * 360,
};
function parseCssNumberOrAngle$1(text) {
  const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!m) {
    return parseFloat(text);
  }
  const angle = parseFloat(m[1]);
  const unit = m[2];
  return ANGLE_TO_DEG_MAP$1[unit](angle);
}
function parseFunctionalRgbColorComponents$1(text) {
  const m = text.match(
    /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$1(m[1], 255),
    parseCssNumberOrPercentage$1(m[2], 255),
    parseCssNumberOrPercentage$1(m[3], 255),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbColor$1(text) {
  const comps = parseFunctionalRgbColorComponents$1(text);
  return comps ? new IntColor$1(comps, "rgb") : null;
}
function parseFunctionalRgbaColorComponents$1(text) {
  const m = text.match(
    /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage$1(m[1], 255),
    parseCssNumberOrPercentage$1(m[2], 255),
    parseCssNumberOrPercentage$1(m[3], 255),
    parseCssNumberOrPercentage$1(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbaColor$1(text) {
  const comps = parseFunctionalRgbaColorComponents$1(text);
  return comps ? new IntColor$1(comps, "rgb") : null;
}
function parseFunctionalHslColorComponents$1(text) {
  const m = text.match(
    /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$1(m[1]),
    parseCssNumberOrPercentage$1(m[2], 100),
    parseCssNumberOrPercentage$1(m[3], 100),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalHslColor$1(text) {
  const comps = parseFunctionalHslColorComponents$1(text);
  return comps ? new IntColor$1(comps, "hsl") : null;
}
function parseHslaColorComponents$1(text) {
  const m = text.match(
    /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle$1(m[1]),
    parseCssNumberOrPercentage$1(m[2], 100),
    parseCssNumberOrPercentage$1(m[3], 100),
    parseCssNumberOrPercentage$1(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalHslaColor$1(text) {
  const comps = parseHslaColorComponents$1(text);
  return comps ? new IntColor$1(comps, "hsl") : null;
}
function parseHexRgbColorComponents$1(text) {
  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
    ];
  }
  return null;
}
function parseHexRgbColor$1(text) {
  const comps = parseHexRgbColorComponents$1(text);
  return comps ? new IntColor$1(comps, "rgb") : null;
}
function parseHexRgbaColorComponents$1(text) {
  const mRgb = text.match(
    /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/,
  );
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
      mapRange$1(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
      mapRange$1(parseInt(mRrggbb[4], 16), 0, 255, 0, 1),
    ];
  }
  return null;
}
function parseHexRgbaColor$1(text) {
  const comps = parseHexRgbaColorComponents$1(text);
  return comps ? new IntColor$1(comps, "rgb") : null;
}
function parseObjectRgbColorComponents$1(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function createObjectRgbColorParser$1(type) {
  return (text) => {
    const comps = parseObjectRgbColorComponents$1(text);
    return comps ? createColor$1(comps, "rgb", type) : null;
  };
}
function parseObjectRgbaColorComponents$1(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseFloat(m[1]),
    parseFloat(m[2]),
    parseFloat(m[3]),
    parseFloat(m[4]),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function createObjectRgbaColorParser$1(type) {
  return (text) => {
    const comps = parseObjectRgbaColorComponents$1(text);
    return comps ? createColor$1(comps, "rgb", type) : null;
  };
}
const PARSER_AND_RESULT$1 = [
  {
    parser: parseHexRgbColorComponents$1,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseHexRgbaColorComponents$1,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseFunctionalRgbColorComponents$1,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalRgbaColorComponents$1,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalHslColorComponents$1,
    result: {
      alpha: false,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseHslaColorComponents$1,
    result: {
      alpha: true,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseObjectRgbColorComponents$1,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "object",
    },
  },
  {
    parser: parseObjectRgbaColorComponents$1,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "object",
    },
  },
];
function detectStringColor$1(text) {
  return PARSER_AND_RESULT$1.reduce((prev, { parser, result: detection }) => {
    if (prev) {
      return prev;
    }
    return parser(text) ? detection : null;
  }, null);
}
function detectStringColorFormat$1(text, type = "int") {
  const r = detectStringColor$1(text);
  if (!r) {
    return null;
  }
  if (r.notation === "hex" && type !== "float") {
    return Object.assign(Object.assign({}, r), { type: "int" });
  }
  if (r.notation === "func") {
    return Object.assign(Object.assign({}, r), { type });
  }
  return null;
}
function createColorStringParser$1(type) {
  const parsers = [
    parseHexRgbColor$1,
    parseHexRgbaColor$1,
    parseFunctionalRgbColor$1,
    parseFunctionalRgbaColor$1,
    parseFunctionalHslColor$1,
    parseFunctionalHslaColor$1,
  ];
  if (type === "int") {
    parsers.push(
      createObjectRgbColorParser$1("int"),
      createObjectRgbaColorParser$1("int"),
    );
  }
  if (type === "float") {
    parsers.push(
      createObjectRgbColorParser$1("float"),
      createObjectRgbaColorParser$1("float"),
    );
  }
  const parser = composeParsers$1(parsers);
  return (text) => {
    const result = parser(text);
    return result ? mapColorType$1(result, type) : null;
  };
}
function readIntColorString$1(value) {
  const parser = createColorStringParser$1("int");
  if (typeof value !== "string") {
    return IntColor$1.black();
  }
  const result = parser(value);
  return result !== null && result !== void 0 ? result : IntColor$1.black();
}
function zerofill$1(comp) {
  const hex = constrainRange$1(Math.floor(comp), 0, 255).toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function colorToHexRgbString$1(value, prefix = "#") {
  const hexes = removeAlphaComponent$1(value.getComponents("rgb"))
    .map(zerofill$1)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToHexRgbaString$1(value, prefix = "#") {
  const rgbaComps = value.getComponents("rgb");
  const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
    .map(zerofill$1)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToFunctionalRgbString$1(value) {
  const formatter = createNumberFormatter$1(0);
  const ci = mapColorType$1(value, "int");
  const comps = removeAlphaComponent$1(ci.getComponents("rgb")).map((comp) =>
    formatter(comp),
  );
  return `rgb(${comps.join(", ")})`;
}
function colorToFunctionalRgbaString$1(value) {
  const aFormatter = createNumberFormatter$1(2);
  const rgbFormatter = createNumberFormatter$1(0);
  const ci = mapColorType$1(value, "int");
  const comps = ci.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return formatter(comp);
  });
  return `rgba(${comps.join(", ")})`;
}
function colorToFunctionalHslString$1(value) {
  const formatters = [
    createNumberFormatter$1(0),
    formatPercentage$1,
    formatPercentage$1,
  ];
  const ci = mapColorType$1(value, "int");
  const comps = removeAlphaComponent$1(ci.getComponents("hsl")).map(
    (comp, index) => formatters[index](comp),
  );
  return `hsl(${comps.join(", ")})`;
}
function colorToFunctionalHslaString$1(value) {
  const formatters = [
    createNumberFormatter$1(0),
    formatPercentage$1,
    formatPercentage$1,
    createNumberFormatter$1(2),
  ];
  const ci = mapColorType$1(value, "int");
  const comps = ci
    .getComponents("hsl")
    .map((comp, index) => formatters[index](comp));
  return `hsla(${comps.join(", ")})`;
}
function colorToObjectRgbString$1(value, type) {
  const formatter = createNumberFormatter$1(type === "float" ? 2 : 0);
  const names = ["r", "g", "b"];
  const cc = mapColorType$1(value, type);
  const comps = removeAlphaComponent$1(cc.getComponents("rgb")).map(
    (comp, index) => `${names[index]}: ${formatter(comp)}`,
  );
  return `{${comps.join(", ")}}`;
}
function createObjectRgbColorFormatter$1(type) {
  return (value) => colorToObjectRgbString$1(value, type);
}
function colorToObjectRgbaString$1(value, type) {
  const aFormatter = createNumberFormatter$1(2);
  const rgbFormatter = createNumberFormatter$1(type === "float" ? 2 : 0);
  const names = ["r", "g", "b", "a"];
  const cc = mapColorType$1(value, type);
  const comps = cc.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return `${names[index]}: ${formatter(comp)}`;
  });
  return `{${comps.join(", ")}}`;
}
function createObjectRgbaColorFormatter$1(type) {
  return (value) => colorToObjectRgbaString$1(value, type);
}
const FORMAT_AND_STRINGIFIERS$1 = [
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbString$1,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbaString$1,
  },
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbString$1,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbaString$1,
  },
  {
    format: {
      alpha: false,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslString$1,
  },
  {
    format: {
      alpha: true,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslaString$1,
  },
  ...["int", "float"].reduce((prev, type) => {
    return [
      ...prev,
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbColorFormatter$1(type),
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbaColorFormatter$1(type),
      },
    ];
  }, []),
];
function findColorStringifier$1(format) {
  return FORMAT_AND_STRINGIFIERS$1.reduce((prev, fas) => {
    if (prev) {
      return prev;
    }
    return equalsStringColorFormat$1(fas.format, format)
      ? fas.stringifier
      : null;
  }, null);
}
const cn$a$1 = ClassName$1("apl");
let APaletteView$1 = class APaletteView6 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$a$1());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const barElem = doc.createElement("div");
    barElem.classList.add(cn$a$1("b"));
    this.element.appendChild(barElem);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$a$1("c"));
    barElem.appendChild(colorElem);
    this.colorElem_ = colorElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$a$1("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    const previewElem = doc.createElement("div");
    previewElem.classList.add(cn$a$1("p"));
    this.markerElem_.appendChild(previewElem);
    this.previewElem_ = previewElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const rgbaComps = c.getComponents("rgb");
    const leftColor = new IntColor$1(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 0],
      "rgb",
    );
    const rightColor = new IntColor$1(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 255],
      "rgb",
    );
    const gradientComps = [
      "to right",
      colorToFunctionalRgbaString$1(leftColor),
      colorToFunctionalRgbaString$1(rightColor),
    ];
    this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
    this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString$1(c);
    const left = mapRange$1(rgbaComps[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let APaletteController$1 = class APaletteController6 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new APaletteView$1(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$1(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const alpha = d.point.x / d.bounds.width;
    const c = this.value.rawValue;
    const [h, s, v] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$1([h, s, v, alpha], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$1(
      getKeyScaleForColor$1(true),
      getHorizontalStepKeys$1(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$1([h, s, v, a + step], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$1(
      getKeyScaleForColor$1(true),
      getHorizontalStepKeys$1(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$9$1 = ClassName$1("coltxt");
function createModeSelectElement$1(doc) {
  const selectElem = doc.createElement("select");
  const items = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" },
    { text: "HEX", value: "hex" },
  ];
  selectElem.appendChild(
    items.reduce((frag, item) => {
      const optElem = doc.createElement("option");
      optElem.textContent = item.text;
      optElem.value = item.value;
      frag.appendChild(optElem);
      return frag;
    }, doc.createDocumentFragment()),
  );
  return selectElem;
}
let ColorTextsView$1 = class ColorTextsView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$9$1());
    config.viewProps.bindClassModifiers(this.element);
    const modeElem = doc.createElement("div");
    modeElem.classList.add(cn$9$1("m"));
    this.modeElem_ = createModeSelectElement$1(doc);
    this.modeElem_.classList.add(cn$9$1("ms"));
    modeElem.appendChild(this.modeSelectElement);
    config.viewProps.bindDisabled(this.modeElem_);
    const modeMarkerElem = doc.createElement("div");
    modeMarkerElem.classList.add(cn$9$1("mm"));
    modeMarkerElem.appendChild(createSvgIconElement$1(doc, "dropdown"));
    modeElem.appendChild(modeMarkerElem);
    this.element.appendChild(modeElem);
    const inputsElem = doc.createElement("div");
    inputsElem.classList.add(cn$9$1("w"));
    this.element.appendChild(inputsElem);
    this.inputsElem_ = inputsElem;
    this.inputViews_ = config.inputViews;
    this.applyInputViews_();
    bindValue$1(config.mode, (mode) => {
      this.modeElem_.value = mode;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(inputViews) {
    this.inputViews_ = inputViews;
    this.applyInputViews_();
  }
  applyInputViews_() {
    removeChildElements$1(this.inputsElem_);
    const doc = this.element.ownerDocument;
    this.inputViews_.forEach((v) => {
      const compElem = doc.createElement("div");
      compElem.classList.add(cn$9$1("c"));
      compElem.appendChild(v.element);
      this.inputsElem_.appendChild(compElem);
    });
  }
};
function createFormatter$2$1(type) {
  return createNumberFormatter$1(type === "float" ? 2 : 0);
}
function createConstraint$5$1(mode, type, index) {
  const max = getColorMaxComponents$1(mode, type)[index];
  return new DefiniteRangeConstraint$1({
    min: 0,
    max,
  });
}
function createComponentController$1(doc, config, index) {
  return new NumberTextController$1(doc, {
    arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
    parser: config.parser,
    props: ValueMap$1.fromObject({
      formatter: createFormatter$2$1(config.colorType),
      keyScale: getKeyScaleForColor$1(false),
      pointerScale: config.colorType === "float" ? 0.01 : 1,
    }),
    value: createValue$1(0, {
      constraint: createConstraint$5$1(
        config.colorMode,
        config.colorType,
        index,
      ),
    }),
    viewProps: config.viewProps,
  });
}
function createComponentControllers$1(doc, config) {
  const cc = {
    colorMode: config.colorMode,
    colorType: config.colorType,
    parser: parseNumber$1,
    viewProps: config.viewProps,
  };
  return [0, 1, 2].map((i) => {
    const c = createComponentController$1(doc, cc, i);
    connectValues$1({
      primary: config.value,
      secondary: c.value,
      forward(p) {
        const mc = mapColorType$1(p, config.colorType);
        return mc.getComponents(config.colorMode)[i];
      },
      backward(p, s) {
        const pickedMode = config.colorMode;
        const mc = mapColorType$1(p, config.colorType);
        const comps = mc.getComponents(pickedMode);
        comps[i] = s;
        const c2 = createColor$1(
          appendAlphaComponent$1(removeAlphaComponent$1(comps), comps[3]),
          pickedMode,
          config.colorType,
        );
        return mapColorType$1(c2, "int");
      },
    });
    return c;
  });
}
function createHexController$1(doc, config) {
  const c = new TextController$1(doc, {
    parser: createColorStringParser$1("int"),
    props: ValueMap$1.fromObject({
      formatter: colorToHexRgbString$1,
    }),
    value: createValue$1(IntColor$1.black()),
    viewProps: config.viewProps,
  });
  connectValues$1({
    primary: config.value,
    secondary: c.value,
    forward: (p) =>
      new IntColor$1(removeAlphaComponent$1(p.getComponents()), p.mode),
    backward: (p, s) =>
      new IntColor$1(
        appendAlphaComponent$1(
          removeAlphaComponent$1(s.getComponents(p.mode)),
          p.getComponents()[3],
        ),
        p.mode,
      ),
  });
  return [c];
}
function isColorMode$1(mode) {
  return mode !== "hex";
}
let ColorTextsController$1 = class ColorTextsController6 {
  constructor(doc, config) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
    this.colorType_ = config.colorType;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.colorMode = createValue$1(this.value.rawValue.mode);
    this.ccs_ = this.createComponentControllers_(doc);
    this.view = new ColorTextsView$1(doc, {
      mode: this.colorMode,
      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
      viewProps: this.viewProps,
    });
    this.view.modeSelectElement.addEventListener(
      "change",
      this.onModeSelectChange_,
    );
  }
  createComponentControllers_(doc) {
    const mode = this.colorMode.rawValue;
    if (isColorMode$1(mode)) {
      return createComponentControllers$1(doc, {
        colorMode: mode,
        colorType: this.colorType_,
        value: this.value,
        viewProps: this.viewProps,
      });
    }
    return createHexController$1(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
  onModeSelectChange_(ev) {
    const selectElem = ev.currentTarget;
    this.colorMode.rawValue = selectElem.value;
    this.ccs_ = this.createComponentControllers_(
      this.view.element.ownerDocument,
    );
    this.view.inputViews = this.ccs_.map((cc) => cc.view);
  }
};
const cn$8$1 = ClassName$1("hpl");
let HPaletteView$1 = class HPaletteView6 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$8$1());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$8$1("c"));
    this.element.appendChild(colorElem);
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$8$1("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const [h] = c.getComponents("hsv");
    this.markerElem_.style.backgroundColor = colorToFunctionalRgbString$1(
      new IntColor$1([h, 100, 100], "hsv"),
    );
    const left = mapRange$1(h, 0, 360, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let HPaletteController$1 = class HPaletteController6 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new HPaletteView$1(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$1(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const hue = mapRange$1(
      constrainRange$1(d.point.x, 0, d.bounds.width),
      0,
      d.bounds.width,
      0,
      360,
    );
    const c = this.value.rawValue;
    const [, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$1([hue, s, v, a], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey$1(
      getKeyScaleForColor$1(false),
      getHorizontalStepKeys$1(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor$1([h + step, s, v, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey$1(
      getKeyScaleForColor$1(false),
      getHorizontalStepKeys$1(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
const cn$7$1 = ClassName$1("svp");
const CANVAS_RESOL$1 = 64;
let SvPaletteView$1 = class SvPaletteView6 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$7$1());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const canvasElem = doc.createElement("canvas");
    canvasElem.height = CANVAS_RESOL$1;
    canvasElem.width = CANVAS_RESOL$1;
    canvasElem.classList.add(cn$7$1("c"));
    this.element.appendChild(canvasElem);
    this.canvasElement = canvasElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$7$1("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const ctx = getCanvasContext$1(this.canvasElement);
    if (!ctx) {
      return;
    }
    const c = this.value.rawValue;
    const hsvComps = c.getComponents("hsv");
    const width = this.canvasElement.width;
    const height = this.canvasElement.height;
    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;
    for (let iy = 0; iy < height; iy++) {
      for (let ix = 0; ix < width; ix++) {
        const s = mapRange$1(ix, 0, width, 0, 100);
        const v = mapRange$1(iy, 0, height, 100, 0);
        const rgbComps = hsvToRgbInt$1(hsvComps[0], s, v);
        const i = (iy * width + ix) * 4;
        data[i] = rgbComps[0];
        data[i + 1] = rgbComps[1];
        data[i + 2] = rgbComps[2];
        data[i + 3] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    const left = mapRange$1(hsvComps[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${left}%`;
    const top = mapRange$1(hsvComps[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${top}%`;
  }
  onValueChange_() {
    this.update_();
  }
};
let SvPaletteController$1 = class SvPaletteController6 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SvPaletteView$1(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$1(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const saturation = mapRange$1(d.point.x, 0, d.bounds.width, 0, 100);
    const value = mapRange$1(d.point.y, 0, d.bounds.height, 100, 0);
    const [h, , , a] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(
      new IntColor$1([h, saturation, value, a], "hsv"),
      opts,
    );
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    if (isArrowKey$1(ev.key)) {
      ev.preventDefault();
    }
    const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
    const keyScale = getKeyScaleForColor$1(false);
    const ds = getStepForKey$1(keyScale, getHorizontalStepKeys$1(ev));
    const dv = getStepForKey$1(keyScale, getVerticalStepKeys$1(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(new IntColor$1([h, s + ds, v + dv, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const keyScale = getKeyScaleForColor$1(false);
    const ds = getStepForKey$1(keyScale, getHorizontalStepKeys$1(ev));
    const dv = getStepForKey$1(keyScale, getVerticalStepKeys$1(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let ColorPickerController$1 = class ColorPickerController6 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.hPaletteC_ = new HPaletteController$1(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.svPaletteC_ = new SvPaletteController$1(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.alphaIcs_ = config.supportsAlpha
      ? {
          palette: new APaletteController$1(doc, {
            value: this.value,
            viewProps: this.viewProps,
          }),
          text: new NumberTextController$1(doc, {
            parser: parseNumber$1,
            props: ValueMap$1.fromObject({
              pointerScale: 0.01,
              keyScale: 0.1,
              formatter: createNumberFormatter$1(2),
            }),
            value: createValue$1(0, {
              constraint: new DefiniteRangeConstraint$1({ min: 0, max: 1 }),
            }),
            viewProps: this.viewProps,
          }),
        }
      : null;
    if (this.alphaIcs_) {
      connectValues$1({
        primary: this.value,
        secondary: this.alphaIcs_.text.value,
        forward: (p) => p.getComponents()[3],
        backward: (p, s) => {
          const comps = p.getComponents();
          comps[3] = s;
          return new IntColor$1(comps, p.mode);
        },
      });
    }
    this.textsC_ = new ColorTextsController$1(doc, {
      colorType: config.colorType,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorPickerView$1(doc, {
      alphaViews: this.alphaIcs_
        ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view,
          }
        : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: config.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textsView: this.textsC_.view,
      viewProps: this.viewProps,
    });
  }
  get textsController() {
    return this.textsC_;
  }
};
const cn$6$1 = ClassName$1("colsw");
let ColorSwatchView$1 = class ColorSwatchView6 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$6$1());
    config.viewProps.bindClassModifiers(this.element);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$6$1("sw"));
    this.element.appendChild(swatchElem);
    this.swatchElem_ = swatchElem;
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$6$1("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    this.update_();
  }
  update_() {
    const value = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = colorToHexRgbaString$1(value);
  }
  onValueChange_() {
    this.update_();
  }
};
let ColorSwatchController$1 = class ColorSwatchController6 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ColorSwatchView$1(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
let ColorController$1 = class ColorController6 {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$1.create(config.expanded);
    this.swatchC_ = new ColorSwatchController$1(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    const buttonElem = this.swatchC_.view.buttonElement;
    buttonElem.addEventListener("blur", this.onButtonBlur_);
    buttonElem.addEventListener("click", this.onButtonClick_);
    this.textC_ = new TextController$1(doc, {
      parser: config.parser,
      props: ValueMap$1.fromObject({
        formatter: config.formatter,
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorView$1(doc, {
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout,
    });
    this.view.swatchElement.appendChild(this.swatchC_.view.element);
    this.view.textElement.appendChild(this.textC_.view.element);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$1(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const pickerC = new ColorPickerController$1(doc, {
      colorType: config.colorType,
      supportsAlpha: config.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps,
    });
    pickerC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = pickerC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(pickerC.view.element);
      connectValues$1({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$1(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$1(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$1(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.swatchC_.view.buttonElement &&
      !supportsTouch$1(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.swatchC_.view.buttonElement.focus();
      }
    }
  }
};
function colorToRgbNumber$1(value) {
  return removeAlphaComponent$1(value.getComponents("rgb")).reduce(
    (result, comp) => {
      return (result << 8) | (Math.floor(comp) & 255);
    },
    0,
  );
}
function colorToRgbaNumber$1(value) {
  return (
    value.getComponents("rgb").reduce((result, comp, index) => {
      const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
      return (result << 8) | hex;
    }, 0) >>> 0
  );
}
function numberToRgbColor$1(num) {
  return new IntColor$1(
    [(num >> 16) & 255, (num >> 8) & 255, num & 255],
    "rgb",
  );
}
function numberToRgbaColor$1(num) {
  return new IntColor$1(
    [
      (num >> 24) & 255,
      (num >> 16) & 255,
      (num >> 8) & 255,
      mapRange$1(num & 255, 0, 255, 0, 1),
    ],
    "rgb",
  );
}
function colorFromRgbNumber$1(value) {
  if (typeof value !== "number") {
    return IntColor$1.black();
  }
  return numberToRgbColor$1(value);
}
function colorFromRgbaNumber$1(value) {
  if (typeof value !== "number") {
    return IntColor$1.black();
  }
  return numberToRgbaColor$1(value);
}
function isRgbColorComponent$1(obj, key2) {
  if (typeof obj !== "object" || isEmpty$1(obj)) {
    return false;
  }
  return key2 in obj && typeof obj[key2] === "number";
}
function isRgbColorObject$1(obj) {
  return (
    isRgbColorComponent$1(obj, "r") &&
    isRgbColorComponent$1(obj, "g") &&
    isRgbColorComponent$1(obj, "b")
  );
}
function isRgbaColorObject$1(obj) {
  return isRgbColorObject$1(obj) && isRgbColorComponent$1(obj, "a");
}
function isColorObject$1(obj) {
  return isRgbColorObject$1(obj);
}
function equalsColor$1(v1, v2) {
  if (v1.mode !== v2.mode) {
    return false;
  }
  if (v1.type !== v2.type) {
    return false;
  }
  const comps1 = v1.getComponents();
  const comps2 = v2.getComponents();
  for (let i = 0; i < comps1.length; i++) {
    if (comps1[i] !== comps2[i]) {
      return false;
    }
  }
  return true;
}
function createColorComponentsFromRgbObject$1(obj) {
  return "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
}
function createColorStringWriter$1(format) {
  const stringify = findColorStringifier$1(format);
  return stringify
    ? (target, value) => {
        writePrimitive$1(target, stringify(value));
      }
    : null;
}
function createColorNumberWriter$1(supportsAlpha) {
  const colorToNumber = supportsAlpha
    ? colorToRgbaNumber$1
    : colorToRgbNumber$1;
  return (target, value) => {
    writePrimitive$1(target, colorToNumber(value));
  };
}
function writeRgbaColorObject$1(target, value, type) {
  const cc = mapColorType$1(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
  target.writeProperty("a", obj.a);
}
function writeRgbColorObject$1(target, value, type) {
  const cc = mapColorType$1(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
}
function createColorObjectWriter$1(supportsAlpha, type) {
  return (target, inValue) => {
    if (supportsAlpha) {
      writeRgbaColorObject$1(target, inValue, type);
    } else {
      writeRgbColorObject$1(target, inValue, type);
    }
  };
}
function shouldSupportAlpha$1$1(inputParams) {
  var _a;
  if (
    (_a =
      inputParams === null || inputParams === void 0
        ? void 0
        : inputParams.color) === null || _a === void 0
      ? void 0
      : _a.alpha
  ) {
    return true;
  }
  return false;
}
function createFormatter$1$1(supportsAlpha) {
  return supportsAlpha
    ? (v) => colorToHexRgbaString$1(v, "0x")
    : (v) => colorToHexRgbString$1(v, "0x");
}
function isForColor$1(params) {
  if ("color" in params) {
    return true;
  }
  if (params.view === "color") {
    return true;
  }
  return false;
}
createPlugin$1({
  id: "input-color-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    if (!isForColor$1(params)) {
      return null;
    }
    const result = parseColorInputParams$1(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            supportsAlpha: shouldSupportAlpha$1$1(params),
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => {
      return args.params.supportsAlpha
        ? colorFromRgbaNumber$1
        : colorFromRgbNumber$1;
    },
    equals: equalsColor$1,
    writer: (args) => {
      return createColorNumberWriter$1(args.params.supportsAlpha);
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$1(args.document, {
      colorType: "int",
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createFormatter$1$1(args.params.supportsAlpha),
      parser: createColorStringParser$1("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
function colorFromObject$1(value, type) {
  if (!isColorObject$1(value)) {
    return mapColorType$1(IntColor$1.black(), type);
  }
  if (type === "int") {
    const comps = createColorComponentsFromRgbObject$1(value);
    return new IntColor$1(comps, "rgb");
  }
  if (type === "float") {
    const comps = createColorComponentsFromRgbObject$1(value);
    return new FloatColor$1(comps, "rgb");
  }
  return mapColorType$1(IntColor$1.black(), "int");
}
function shouldSupportAlpha$2(initialValue) {
  return isRgbaColorObject$1(initialValue);
}
function createColorObjectBindingReader$1(type) {
  return (value) => {
    const c = colorFromObject$1(value, type);
    return mapColorType$1(c, "int");
  };
}
function createColorObjectFormatter$1(supportsAlpha, type) {
  return (value) => {
    if (supportsAlpha) {
      return colorToObjectRgbaString$1(value, type);
    }
    return colorToObjectRgbString$1(value, type);
  };
}
createPlugin$1({
  id: "input-color-object",
  type: "input",
  accept: (value, params) => {
    var _a;
    if (!isColorObject$1(value)) {
      return null;
    }
    const result = parseColorInputParams$1(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            colorType:
              (_a = extractColorType$1(params)) !== null && _a !== void 0
                ? _a
                : "int",
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => createColorObjectBindingReader$1(args.params.colorType),
    equals: equalsColor$1,
    writer: (args) =>
      createColorObjectWriter$1(
        shouldSupportAlpha$2(args.initialValue),
        args.params.colorType,
      ),
  },
  controller: (args) => {
    var _a, _b;
    const supportsAlpha = isRgbaColorObject$1(args.initialValue);
    return new ColorController$1(args.document, {
      colorType: args.params.colorType,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createColorObjectFormatter$1(
        supportsAlpha,
        args.params.colorType,
      ),
      parser: createColorStringParser$1("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
createPlugin$1({
  id: "input-color-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    if (params.view === "text") {
      return null;
    }
    const format = detectStringColorFormat$1(value, extractColorType$1(params));
    if (!format) {
      return null;
    }
    const stringifier = findColorStringifier$1(format);
    if (!stringifier) {
      return null;
    }
    const result = parseColorInputParams$1(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            format,
            stringifier,
          }),
        }
      : null;
  },
  binding: {
    reader: () => readIntColorString$1,
    equals: equalsColor$1,
    writer: (args) => {
      const writer = createColorStringWriter$1(args.params.format);
      if (!writer) {
        throw TpError$1.notBindable();
      }
      return writer;
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController$1(args.document, {
      colorType: args.params.format.type,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: args.params.stringifier,
      parser: createColorStringParser$1("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.format.alpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let PointNdConstraint$1 = class PointNdConstraint6 {
  constructor(config) {
    this.components = config.components;
    this.asm_ = config.assembly;
  }
  constrain(value) {
    const comps = this.asm_.toComponents(value).map((comp, index) => {
      var _a, _b;
      return (_b =
        (_a = this.components[index]) === null || _a === void 0
          ? void 0
          : _a.constrain(comp)) !== null && _b !== void 0
        ? _b
        : comp;
    });
    return this.asm_.fromComponents(comps);
  }
};
const cn$5$1 = ClassName$1("pndtxt");
let PointNdTextView$1 = class PointNdTextView6 {
  constructor(doc, config) {
    this.textViews = config.textViews;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$5$1());
    this.textViews.forEach((v) => {
      const axisElem = doc.createElement("div");
      axisElem.classList.add(cn$5$1("a"));
      axisElem.appendChild(v.element);
      this.element.appendChild(axisElem);
    });
  }
};
function createAxisController$1(doc, config, index) {
  return new NumberTextController$1(doc, {
    arrayPosition:
      index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
    parser: config.parser,
    props: config.axes[index].textProps,
    value: createValue$1(0, {
      constraint: config.axes[index].constraint,
    }),
    viewProps: config.viewProps,
  });
}
let PointNdTextController$1 = class PointNdTextController6 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.acs_ = config.axes.map((_, index) =>
      createAxisController$1(doc, config, index),
    );
    this.acs_.forEach((c, index) => {
      connectValues$1({
        primary: this.value,
        secondary: c.value,
        forward: (p) => config.assembly.toComponents(p)[index],
        backward: (p, s) => {
          const comps = config.assembly.toComponents(p);
          comps[index] = s;
          return config.assembly.fromComponents(comps);
        },
      });
    });
    this.view = new PointNdTextView$1(doc, {
      textViews: this.acs_.map((ac) => ac.view),
    });
  }
  get textControllers() {
    return this.acs_;
  }
};
let SliderInputBindingApi$1 = class SliderInputBindingApi6 extends BindingApi$1 {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.sliderController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(max) {
    this.controller.valueController.sliderController.props.set("min", max);
  }
};
function createConstraint$4$1(params, initialValue) {
  const constraints = [];
  const sc = createStepConstraint$1(params, initialValue);
  if (sc) {
    constraints.push(sc);
  }
  const rc = createRangeConstraint$1(params);
  if (rc) {
    constraints.push(rc);
  }
  const lc = createListConstraint$1(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$1(constraints);
}
createPlugin$1({
  id: "input-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$1(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser$1(p)), {
        options: p.optional.custom(parseListOptions$1),
        readonly: p.optional.constant(false),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown$1,
    constraint: (args) => createConstraint$4$1(args.params, args.initialValue),
    writer: (_args) => writePrimitive$1,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$1(c, ListConstraint$1);
    if (lc) {
      return new ListController$1(args.document, {
        props: new ValueMap$1({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    const textPropsObj = createNumberTextPropsObject$1(
      args.params,
      value.rawValue,
    );
    const drc = c && findConstraint$1(c, DefiniteRangeConstraint$1);
    if (drc) {
      return new SliderTextController$1(
        args.document,
        Object.assign(
          Object.assign(
            {},
            createSliderTextProps$1(
              Object.assign(Object.assign({}, textPropsObj), {
                keyScale: createValue$1(textPropsObj.keyScale),
                max: drc.values.value("max"),
                min: drc.values.value("min"),
              }),
            ),
          ),
          { parser: parseNumber$1, value, viewProps: args.viewProps },
        ),
      );
    }
    return new NumberTextController$1(args.document, {
      parser: parseNumber$1,
      props: ValueMap$1.fromObject(textPropsObj),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "number") {
      return null;
    }
    if (args.controller.valueController instanceof SliderTextController$1) {
      return new SliderInputBindingApi$1(args.controller);
    }
    if (args.controller.valueController instanceof ListController$1) {
      return new ListInputBindingApi$1(args.controller);
    }
    return null;
  },
});
let Point2d$1 = class Point2d6 {
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(obj) {
    if (isEmpty$1(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    if (typeof x !== "number" || typeof y2 !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
    };
  }
};
const Point2dAssembly$1 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point2d$1(...comps),
};
const cn$4$1 = ClassName$1("p2d");
let Point2dView$1 = class Point2dView6 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$4$1());
    config.viewProps.bindClassModifiers(this.element);
    bindValue$1(
      config.expanded,
      valueToClassName$1(this.element, cn$4$1(void 0, "expanded")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$4$1("h"));
    this.element.appendChild(headElem);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$4$1("b"));
    buttonElem.appendChild(createSvgIconElement$1(doc, "p2dpad"));
    config.viewProps.bindDisabled(buttonElem);
    headElem.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$4$1("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$4$1("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
};
const cn$3$1 = ClassName$1("p2dp");
let Point2dPickerView$1 = class Point2dPickerView6 {
  constructor(doc, config) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this);
    this.onPropsChange_ = this.onPropsChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onPropsChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$3$1());
    if (config.layout === "popup") {
      this.element.classList.add(cn$3$1(void 0, "p"));
    }
    config.viewProps.bindClassModifiers(this.element);
    const padElem = doc.createElement("div");
    padElem.classList.add(cn$3$1("p"));
    config.viewProps.bindTabIndex(padElem);
    this.element.appendChild(padElem);
    this.padElement = padElem;
    const svgElem = doc.createElementNS(SVG_NS$1, "svg");
    svgElem.classList.add(cn$3$1("g"));
    this.padElement.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const xAxisElem = doc.createElementNS(SVG_NS$1, "line");
    xAxisElem.classList.add(cn$3$1("ax"));
    xAxisElem.setAttributeNS(null, "x1", "0");
    xAxisElem.setAttributeNS(null, "y1", "50%");
    xAxisElem.setAttributeNS(null, "x2", "100%");
    xAxisElem.setAttributeNS(null, "y2", "50%");
    this.svgElem_.appendChild(xAxisElem);
    const yAxisElem = doc.createElementNS(SVG_NS$1, "line");
    yAxisElem.classList.add(cn$3$1("ax"));
    yAxisElem.setAttributeNS(null, "x1", "50%");
    yAxisElem.setAttributeNS(null, "y1", "0");
    yAxisElem.setAttributeNS(null, "x2", "50%");
    yAxisElem.setAttributeNS(null, "y2", "100%");
    this.svgElem_.appendChild(yAxisElem);
    const lineElem = doc.createElementNS(SVG_NS$1, "line");
    lineElem.classList.add(cn$3$1("l"));
    lineElem.setAttributeNS(null, "x1", "50%");
    lineElem.setAttributeNS(null, "y1", "50%");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$3$1("m"));
    this.padElement.appendChild(markerElem);
    this.markerElem_ = markerElem;
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [x, y2] = this.value.rawValue.getComponents();
    const max = this.props_.get("max");
    const px2 = mapRange$1(x, -max, +max, 0, 100);
    const py2 = mapRange$1(y2, -max, +max, 0, 100);
    const ipy = this.props_.get("invertsY") ? 100 - py2 : py2;
    this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
    this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
    this.markerElem_.style.left = `${px2}%`;
    this.markerElem_.style.top = `${ipy}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
};
function computeOffset$2(ev, keyScales, invertsY) {
  return [
    getStepForKey$1(keyScales[0], getHorizontalStepKeys$1(ev)),
    getStepForKey$1(keyScales[1], getVerticalStepKeys$1(ev)) *
      (invertsY ? 1 : -1),
  ];
}
let Point2dPickerController$1 = class Point2dPickerController6 {
  constructor(doc, config) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new Point2dPickerView$1(doc, {
      layout: config.layout,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler$1(this.view.padElement);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
    this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const max = this.props.get("max");
    const px2 = mapRange$1(d.point.x, 0, d.bounds.width, -max, +max);
    const py2 = mapRange$1(
      this.props.get("invertsY") ? d.bounds.height - d.point.y : d.point.y,
      0,
      d.bounds.height,
      -max,
      +max,
    );
    this.value.setRawValue(new Point2d$1(px2, py2), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onPadKeyDown_(ev) {
    if (isArrowKey$1(ev.key)) {
      ev.preventDefault();
    }
    const [dx, dy] = computeOffset$2(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(
      new Point2d$1(this.value.rawValue.x + dx, this.value.rawValue.y + dy),
      {
        forceEmit: false,
        last: false,
      },
    );
  }
  onPadKeyUp_(ev) {
    const [dx, dy] = computeOffset$2(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
};
let Point2dController$1 = class Point2dController6 {
  constructor(doc, config) {
    var _a, _b;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable$1.create(config.expanded);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController$1(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const padC = new Point2dPickerController$1(doc, {
      layout: config.pickerLayout,
      props: new ValueMap$1({
        invertsY: createValue$1(config.invertsY),
        max: createValue$1(config.max),
        xKeyScale: config.axes[0].textProps.value("keyScale"),
        yKeyScale: config.axes[1].textProps.value("keyScale"),
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    padC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = padC;
    this.textC_ = new PointNdTextController$1(doc, {
      assembly: Point2dAssembly$1,
      axes: config.axes,
      parser: config.parser,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new Point2dView$1(doc, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: config.pickerLayout,
      viewProps: this.viewProps,
    });
    this.view.textElement.appendChild(this.textC_.view.element);
    (_a = this.view.buttonElement) === null || _a === void 0
      ? void 0
      : _a.addEventListener("blur", this.onPadButtonBlur_);
    (_b = this.view.buttonElement) === null || _b === void 0
      ? void 0
      : _b.addEventListener("click", this.onPadButtonClick_);
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(this.pickerC_.view.element);
      connectValues$1({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable$1(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast$1(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget$1(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.view.buttonElement &&
      !supportsTouch$1(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.view.buttonElement.focus();
      }
    }
  }
};
function point2dFromUnknown$1(value) {
  return Point2d$1.isObject(value)
    ? new Point2d$1(value.x, value.y)
    : new Point2d$1();
}
function writePoint2d$1(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
}
function createConstraint$3$1(params, initialValue) {
  return new PointNdConstraint$1({
    assembly: Point2dAssembly$1,
    components: [
      createDimensionConstraint$1(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$1(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
    ],
  });
}
function getSuitableMaxDimensionValue$1(params, rawValue) {
  var _a, _b;
  if (!isEmpty$1(params.min) || !isEmpty$1(params.max)) {
    return Math.max(
      Math.abs((_a = params.min) !== null && _a !== void 0 ? _a : 0),
      Math.abs((_b = params.max) !== null && _b !== void 0 ? _b : 0),
    );
  }
  const step = getSuitableKeyScale$1(params);
  return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
}
function getSuitableMax$1(params, initialValue) {
  var _a, _b;
  const xr = getSuitableMaxDimensionValue$1(
    deepMerge$1(params, (_a = params.x) !== null && _a !== void 0 ? _a : {}),
    initialValue.x,
  );
  const yr = getSuitableMaxDimensionValue$1(
    deepMerge$1(params, (_b = params.y) !== null && _b !== void 0 ? _b : {}),
    initialValue.y,
  );
  return Math.max(xr, yr);
}
function shouldInvertY$1(params) {
  if (!("y" in params)) {
    return false;
  }
  const yParams = params.y;
  if (!yParams) {
    return false;
  }
  return "inverted" in yParams ? !!yParams.inverted : false;
}
createPlugin$1({
  id: "input-point2d",
  type: "input",
  accept: (value, params) => {
    if (!Point2d$1.isObject(value)) {
      return null;
    }
    const result = parseRecord$1(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$1(p)), {
        expanded: p.optional.boolean,
        picker: p.optional.custom(parsePickerLayout$1),
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$1),
        y: p.optional.object(
          Object.assign(Object.assign({}, createPointDimensionParser$1(p)), {
            inverted: p.optional.boolean,
          }),
        ),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: () => point2dFromUnknown$1,
    constraint: (args) => createConstraint$3$1(args.params, args.initialValue),
    equals: Point2d$1.equals,
    writer: () => writePoint2d$1,
  },
  controller: (args) => {
    var _a, _b;
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y];
    return new Point2dController$1(doc, {
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a2;
        return createPointAxis$1({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$1(
            args.params,
            (_a2 = dParams[i]) !== null && _a2 !== void 0 ? _a2 : {},
          ),
        });
      }),
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      invertsY: shouldInvertY$1(args.params),
      max: getSuitableMax$1(args.params, value.rawValue),
      parser: parseNumber$1,
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point3d$1 = class Point3d6 {
  constructor(x = 0, y2 = 0, z = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(obj) {
    if (isEmpty$1(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
    };
  }
};
const Point3dAssembly$1 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point3d$1(...comps),
};
function point3dFromUnknown$1(value) {
  return Point3d$1.isObject(value)
    ? new Point3d$1(value.x, value.y, value.z)
    : new Point3d$1();
}
function writePoint3d$1(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
}
function createConstraint$2$1(params, initialValue) {
  return new PointNdConstraint$1({
    assembly: Point3dAssembly$1,
    components: [
      createDimensionConstraint$1(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$1(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$1(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
    ],
  });
}
createPlugin$1({
  id: "input-point3d",
  type: "input",
  accept: (value, params) => {
    if (!Point3d$1.isObject(value)) {
      return null;
    }
    const result = parseRecord$1(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$1(p)), {
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams$1),
        y: p.optional.custom(parsePointDimensionParams$1),
        z: p.optional.custom(parsePointDimensionParams$1),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point3dFromUnknown$1,
    constraint: (args) => createConstraint$2$1(args.params, args.initialValue),
    equals: Point3d$1.equals,
    writer: (_args) => writePoint3d$1,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y, args.params.z];
    return new PointNdTextController$1(args.document, {
      assembly: Point3dAssembly$1,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$1({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$1(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$1,
      value,
      viewProps: args.viewProps,
    });
  },
});
let Point4d$1 = class Point4d6 {
  constructor(x = 0, y2 = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
    this.w = w;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(obj) {
    if (isEmpty$1(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    const w = obj.w;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number" ||
      typeof w !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w,
    };
  }
};
const Point4dAssembly$1 = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point4d$1(...comps),
};
function point4dFromUnknown$1(value) {
  return Point4d$1.isObject(value)
    ? new Point4d$1(value.x, value.y, value.z, value.w)
    : new Point4d$1();
}
function writePoint4d$1(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
  target.writeProperty("w", value.w);
}
function createConstraint$1$1(params, initialValue) {
  return new PointNdConstraint$1({
    assembly: Point4dAssembly$1,
    components: [
      createDimensionConstraint$1(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint$1(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint$1(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
      createDimensionConstraint$1(
        Object.assign(Object.assign({}, params), params.w),
        initialValue.w,
      ),
    ],
  });
}
createPlugin$1({
  id: "input-point4d",
  type: "input",
  accept: (value, params) => {
    if (!Point4d$1.isObject(value)) {
      return null;
    }
    const result = parseRecord$1(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser$1(p)), {
        readonly: p.optional.constant(false),
        w: p.optional.custom(parsePointDimensionParams$1),
        x: p.optional.custom(parsePointDimensionParams$1),
        y: p.optional.custom(parsePointDimensionParams$1),
        z: p.optional.custom(parsePointDimensionParams$1),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point4dFromUnknown$1,
    constraint: (args) => createConstraint$1$1(args.params, args.initialValue),
    equals: Point4d$1.equals,
    writer: (_args) => writePoint4d$1,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [
      args.params.x,
      args.params.y,
      args.params.z,
      args.params.w,
    ];
    return new PointNdTextController$1(args.document, {
      assembly: Point4dAssembly$1,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis$1({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge$1(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber$1,
      value,
      viewProps: args.viewProps,
    });
  },
});
function createConstraint$7(params) {
  const constraints = [];
  const lc = createListConstraint$1(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint$1(constraints);
}
createPlugin$1({
  id: "input-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$1(params, (p) => ({
      readonly: p.optional.constant(false),
      options: p.optional.custom(parseListOptions$1),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$1,
    constraint: (args) => createConstraint$7(args.params),
    writer: (_args) => writePrimitive$1,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint$1(c, ListConstraint$1);
    if (lc) {
      return new ListController$1(doc, {
        props: new ValueMap$1({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new TextController$1(doc, {
      parser: (v) => v,
      props: ValueMap$1.fromObject({
        formatter: formatString$1,
      }),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "string") {
      return null;
    }
    if (args.controller.valueController instanceof ListController$1) {
      return new ListInputBindingApi$1(args.controller);
    }
    return null;
  },
});
const Constants$1 = {
  monitor: {
    defaultInterval: 200,
    defaultRows: 3,
  },
};
const cn$2$1 = ClassName$1("mll");
let MultiLogView$1 = class MultiLogView6 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$2$1());
    config.viewProps.bindClassModifiers(this.element);
    const textareaElem = doc.createElement("textarea");
    textareaElem.classList.add(cn$2$1("i"));
    textareaElem.style.height = `calc(var(${getCssVar$1("containerUnitSize")}) * ${config.rows})`;
    textareaElem.readOnly = true;
    config.viewProps.bindDisabled(textareaElem);
    this.element.appendChild(textareaElem);
    this.textareaElem_ = textareaElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const elem = this.textareaElem_;
    const shouldScroll =
      elem.scrollTop === elem.scrollHeight - elem.clientHeight;
    const lines = [];
    this.value.rawValue.forEach((value) => {
      if (value !== void 0) {
        lines.push(this.formatter_(value));
      }
    });
    elem.textContent = lines.join("\n");
    if (shouldScroll) {
      elem.scrollTop = elem.scrollHeight;
    }
  }
  onValueUpdate_() {
    this.update_();
  }
};
let MultiLogController$1 = class MultiLogController6 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new MultiLogView$1(doc, {
      formatter: config.formatter,
      rows: config.rows,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
const cn$1$1 = ClassName$1("sgl");
let SingleLogView$1 = class SingleLogView6 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$1$1());
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$1$1("i"));
    inputElem.readOnly = true;
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const values = this.value.rawValue;
    const lastValue = values[values.length - 1];
    this.inputElement.value =
      lastValue !== void 0 ? this.formatter_(lastValue) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
};
let SingleLogController$1 = class SingleLogController6 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SingleLogView$1(doc, {
      formatter: config.formatter,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
};
createPlugin$1({
  id: "monitor-bool",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord$1(params, (p) => ({
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown$1,
  },
  controller: (args) => {
    var _a;
    if (args.value.rawValue.length === 1) {
      return new SingleLogController$1(args.document, {
        formatter: BooleanFormatter$1,
        value: args.value,
        viewProps: args.viewProps,
      });
    }
    return new MultiLogController$1(args.document, {
      formatter: BooleanFormatter$1,
      rows:
        (_a = args.params.rows) !== null && _a !== void 0
          ? _a
          : Constants$1.monitor.defaultRows,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let GraphLogMonitorBindingApi$1 = class GraphLogMonitorBindingApi6 extends BindingApi$1 {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.props.set("min", min);
  }
};
const cn$r = ClassName$1("grl");
let GraphLogView$1 = class GraphLogView6 {
  constructor(doc, config) {
    this.onCursorChange_ = this.onCursorChange_.bind(this);
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$r());
    config.viewProps.bindClassModifiers(this.element);
    this.formatter_ = config.formatter;
    this.props_ = config.props;
    this.cursor_ = config.cursor;
    this.cursor_.emitter.on("change", this.onCursorChange_);
    const svgElem = doc.createElementNS(SVG_NS$1, "svg");
    svgElem.classList.add(cn$r("g"));
    svgElem.style.height = `calc(var(${getCssVar$1("containerUnitSize")}) * ${config.rows})`;
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const lineElem = doc.createElementNS(SVG_NS$1, "polyline");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(cn$r("t"), ClassName$1("tt")());
    this.element.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const bounds = this.svgElem_.getBoundingClientRect();
    const maxIndex = this.value.rawValue.length - 1;
    const min = this.props_.get("min");
    const max = this.props_.get("max");
    const points = [];
    this.value.rawValue.forEach((v, index) => {
      if (v === void 0) {
        return;
      }
      const x = mapRange$1(index, 0, maxIndex, 0, bounds.width);
      const y2 = mapRange$1(v, min, max, bounds.height, 0);
      points.push([x, y2].join(","));
    });
    this.lineElem_.setAttributeNS(null, "points", points.join(" "));
    const tooltipElem = this.tooltipElem_;
    const value = this.value.rawValue[this.cursor_.rawValue];
    if (value === void 0) {
      tooltipElem.classList.remove(cn$r("t", "a"));
      return;
    }
    const tx = mapRange$1(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
    const ty = mapRange$1(value, min, max, bounds.height, 0);
    tooltipElem.style.left = `${tx}px`;
    tooltipElem.style.top = `${ty}px`;
    tooltipElem.textContent = `${this.formatter_(value)}`;
    if (!tooltipElem.classList.contains(cn$r("t", "a"))) {
      tooltipElem.classList.add(cn$r("t", "a"), cn$r("t", "in"));
      forceReflow$1(tooltipElem);
      tooltipElem.classList.remove(cn$r("t", "in"));
    }
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
};
let GraphLogController$1 = class GraphLogController6 {
  constructor(doc, config) {
    this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.cursor_ = createValue$1(-1);
    this.view = new GraphLogView$1(doc, {
      cursor: this.cursor_,
      formatter: config.formatter,
      rows: config.rows,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    if (!supportsTouch$1(doc)) {
      this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
      this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    } else {
      const ph = new PointerHandler$1(this.view.element);
      ph.emitter.on("down", this.onGraphPointerDown_);
      ph.emitter.on("move", this.onGraphPointerMove_);
      ph.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(state) {
    return importBladeState$1(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        this.props.set("max", result.max);
        this.props.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState$1(null, {
      max: this.props.get("max"),
      min: this.props.get("min"),
    });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(ev) {
    const bounds = this.view.element.getBoundingClientRect();
    this.cursor_.rawValue = Math.floor(
      mapRange$1(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length),
    );
  }
  onGraphPointerDown_(ev) {
    this.onGraphPointerMove_(ev);
  }
  onGraphPointerMove_(ev) {
    if (!ev.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(
      mapRange$1(
        ev.data.point.x,
        0,
        ev.data.bounds.width,
        0,
        this.value.rawValue.length,
      ),
    );
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
};
function createFormatter$3(params) {
  return !isEmpty$1(params.format) ? params.format : createNumberFormatter$1(2);
}
function createTextMonitor$1(args) {
  var _a;
  if (args.value.rawValue.length === 1) {
    return new SingleLogController$1(args.document, {
      formatter: createFormatter$3(args.params),
      value: args.value,
      viewProps: args.viewProps,
    });
  }
  return new MultiLogController$1(args.document, {
    formatter: createFormatter$3(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$1.monitor.defaultRows,
    value: args.value,
    viewProps: args.viewProps,
  });
}
function createGraphMonitor$1(args) {
  var _a, _b, _c;
  return new GraphLogController$1(args.document, {
    formatter: createFormatter$3(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants$1.monitor.defaultRows,
    props: ValueMap$1.fromObject({
      max: (_b = args.params.max) !== null && _b !== void 0 ? _b : 100,
      min: (_c = args.params.min) !== null && _c !== void 0 ? _c : 0,
    }),
    value: args.value,
    viewProps: args.viewProps,
  });
}
function shouldShowGraph$1(params) {
  return params.view === "graph";
}
createPlugin$1({
  id: "monitor-number",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord$1(params, (p) => ({
      format: p.optional.function,
      max: p.optional.number,
      min: p.optional.number,
      readonly: p.required.constant(true),
      rows: p.optional.number,
      view: p.optional.string,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    defaultBufferSize: (params) => (shouldShowGraph$1(params) ? 64 : 1),
    reader: (_args) => numberFromUnknown$1,
  },
  controller: (args) => {
    if (shouldShowGraph$1(args.params)) {
      return createGraphMonitor$1(args);
    }
    return createTextMonitor$1(args);
  },
  api: (args) => {
    if (args.controller.valueController instanceof GraphLogController$1) {
      return new GraphLogMonitorBindingApi$1(args.controller);
    }
    return null;
  },
});
createPlugin$1({
  id: "monitor-string",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord$1(params, (p) => ({
      multiline: p.optional.boolean,
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown$1,
  },
  controller: (args) => {
    var _a;
    const value = args.value;
    const multiline = value.rawValue.length > 1 || args.params.multiline;
    if (multiline) {
      return new MultiLogController$1(args.document, {
        formatter: formatString$1,
        rows:
          (_a = args.params.rows) !== null && _a !== void 0
            ? _a
            : Constants$1.monitor.defaultRows,
        value,
        viewProps: args.viewProps,
      });
    }
    return new SingleLogController$1(args.document, {
      formatter: formatString$1,
      value,
      viewProps: args.viewProps,
    });
  },
});
class ProfilerBladeApi extends BladeApi$1 {
  measureStart(name) {
    this.controller.valueController.measureStart(name);
  }
  measureEnd() {
    return this.controller.valueController.measureEnd();
  }
  measure(name, fn) {
    this.controller.valueController.measure(name, fn);
  }
  measureAsync(name, fn) {
    return this.controller.valueController.measureAsync(name, fn);
  }
  get measureHandler() {
    return this.controller.valueController.measureHandler;
  }
  set measureHandler(measureHandler) {
    this.controller.valueController.measureHandler = measureHandler;
  }
}
class ProfilerBladeController extends BladeController$1 {
  constructor(doc, config) {
    const bc = config.valueController;
    const lc = new LabelController$1(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: bc.viewProps,
    });
    this.valueController = bc;
    this.labelController = lc;
  }
}
class ProfilerBladeDefaultMeasureHandler {
  measureStart() {
    const begin = performance.now();
    return () => performance.now() - begin;
  }
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P
      ? value
      : new P(function (resolve) {
          resolve(value);
        });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done
        ? resolve(result.value)
        : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
class ConsecutiveCacheMap {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
    this.keySet = /* @__PURE__ */ new Set();
  }
  get(key2) {
    return this.map.get(key2);
  }
  getOrCreate(key2, create) {
    if (!this.keySet.has(key2)) {
      this.keySet.add(key2);
    }
    let value = this.map.get(key2);
    if (value == null) {
      value = create();
      this.map.set(key2, value);
    }
    return value;
  }
  set(key2, value) {
    if (!this.keySet.has(key2)) {
      this.keySet.add(key2);
    }
    this.map.set(key2, value);
  }
  resetUsedSet() {
    this.keySet.clear();
  }
  vaporize(onVaporize) {
    for (const [key2, value] of this.map.entries()) {
      if (!this.keySet.has(key2)) {
        this.map.delete(key2);
        onVaporize === null || onVaporize === void 0
          ? void 0
          : onVaporize([key2, value]);
      }
    }
  }
}
function arrayClear(array) {
  array.splice(0, array.length);
}
function arraySum(array) {
  let sum = 0;
  array.forEach((v) => (sum += v));
  return sum;
}
class HistoryMeanCalculator {
  constructor(length) {
    this.__recalcForEach = 0;
    this.__countUntilRecalc = 0;
    this.__history = [];
    this.__index = 0;
    this.__count = 0;
    this.__cache = 0;
    this.__length = length;
    this.__recalcForEach = length;
    for (let i = 0; i < length; i++) {
      this.__history[i] = 0;
    }
  }
  get mean() {
    const count = Math.min(this.__count, this.__length);
    return count === 0 ? 0 : this.__cache / count;
  }
  get recalcForEach() {
    return this.__recalcForEach;
  }
  set recalcForEach(value) {
    const delta = value - this.__recalcForEach;
    this.__recalcForEach = value;
    this.__countUntilRecalc = Math.max(0, this.__countUntilRecalc + delta);
  }
  reset() {
    this.__index = 0;
    this.__count = 0;
    this.__cache = 0;
    this.__countUntilRecalc = 0;
    for (let i = 0; i < this.__length; i++) {
      this.__history[i] = 0;
    }
  }
  push(value) {
    const prev = this.__history[this.__index];
    this.__history[this.__index] = value;
    this.__count++;
    this.__index = (this.__index + 1) % this.__length;
    if (this.__countUntilRecalc === 0) {
      this.recalc();
    } else {
      this.__countUntilRecalc--;
      this.__cache -= prev;
      this.__cache += value;
    }
  }
  recalc() {
    this.__countUntilRecalc = this.__recalcForEach;
    const sum = this.__history
      .slice(0, Math.min(this.__count, this.__length))
      .reduce((sum2, v) => sum2 + v, 0);
    this.__cache = sum;
  }
}
function binarySearch(array, elementOrCompare) {
  if (typeof elementOrCompare !== "function") {
    return binarySearch(array, (element) => element < elementOrCompare);
  }
  const compare = elementOrCompare;
  let start = 0;
  let end = array.length;
  while (start < end) {
    const center = (start + end) >> 1;
    const centerElement = array[center];
    const compareResult = compare(centerElement);
    if (compareResult) {
      start = center + 1;
    } else {
      end = center;
    }
  }
  return start;
}
class HistoryPercentileCalculator {
  constructor(length) {
    this.__history = [];
    this.__sorted = [];
    this.__index = 0;
    this.__length = length;
  }
  get median() {
    return this.percentile(50);
  }
  percentile(percentile) {
    if (this.__history.length === 0) {
      return 0;
    }
    return this.__sorted[
      Math.round(percentile * 0.01 * (this.__history.length - 1))
    ];
  }
  reset() {
    this.__index = 0;
    this.__history = [];
    this.__sorted = [];
  }
  push(value) {
    const prev = this.__history[this.__index];
    this.__history[this.__index] = value;
    this.__index = (this.__index + 1) % this.__length;
    if (this.__sorted.length === this.__length) {
      const prevIndex = binarySearch(this.__sorted, prev);
      this.__sorted.splice(prevIndex, 1);
    }
    const index = binarySearch(this.__sorted, value);
    this.__sorted.splice(index, 0, value);
  }
}
function dot(a, b) {
  let sum = 0;
  for (let i = 0; i < a.length; i++) {
    sum += a[i] * b[i];
  }
  return sum;
}
function saturate(x) {
  return Math.min(Math.max(x, 0), 1);
}
function rgbArrayToCssString(array) {
  const arrayPrepared = array.map((v) => saturate(v) * 256);
  return `rgb( ${arrayPrepared.join(", ")} )`;
}
function genTurboColormap(x) {
  const v4KRed = [0.13572138, 4.6153926, -42.66032258, 132.13108234];
  const v4KGreen = [0.09140261, 2.19418839, 4.84296658, -14.18503333];
  const v4KBlue = [0.1066733, 12.64194608, -60.58204836, 110.36276771];
  const v2KRed = [-152.94239396, 59.28637943];
  const v2KGreen = [4.27729857, 2.82956604];
  const v2KBlue = [-89.90310912, 27.34824973];
  x = saturate(x);
  const v4 = [1, x, x * x, x * x * x];
  const v2 = [v4[2], v4[3]].map((v) => v * v4[2]);
  const color = [
    dot(v4, v4KRed) + dot(v2, v2KRed),
    dot(v4, v4KGreen) + dot(v2, v2KGreen),
    dot(v4, v4KBlue) + dot(v2, v2KBlue),
  ];
  return rgbArrayToCssString(color);
}
const className$1 = ClassName$1("profiler");
class ProfilerView {
  constructor(doc, config) {
    this.targetDelta = config.targetDelta;
    this.deltaUnit = config.deltaUnit;
    this.fractionDigits = config.fractionDigits;
    this.calcMode = config.calcMode;
    this.element = doc.createElement("div");
    this.element.classList.add(className$1());
    config.viewProps.bindClassModifiers(this.element);
    this.svgRootElement_ = doc.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg",
    );
    this.svgRootElement_.classList.add(className$1("root"));
    this.element.appendChild(this.svgRootElement_);
    this.entryContainerElement_ = doc.createElementNS(
      "http://www.w3.org/2000/svg",
      "g",
    );
    this.entryContainerElement_.classList.add(className$1("container"));
    this.entryContainerElement_.setAttribute("transform", "translate( 1, 1 )");
    this.svgRootElement_.appendChild(this.entryContainerElement_);
    this.tooltipElement_ = doc.createElement("div");
    this.tooltipElement_.classList.add(className$1("tooltip"));
    this.tooltipElement_.style.display = "none";
    this.element.appendChild(this.tooltipElement_);
    this.tooltipInsideElement_ = doc.createElement("div");
    this.tooltipInsideElement_.classList.add(className$1("tooltipinside"));
    this.tooltipElement_.appendChild(this.tooltipInsideElement_);
    this.labelElement_ = doc.createElement("div");
    this.labelElement_.classList.add(className$1("label"));
    this.labelElement_.textContent = this.deltaToDisplayDelta_(0);
    this.element.appendChild(this.labelElement_);
    this.entryElementCacheMap_ = new ConsecutiveCacheMap();
    this.hoveringEntry_ = null;
  }
  update(rootEntry) {
    const rootEntryDelta = this.entryToDelta_(rootEntry);
    this.labelElement_.textContent = this.deltaToDisplayDelta_(rootEntryDelta);
    this.entryElementCacheMap_.resetUsedSet();
    const unit = 160 / Math.max(this.targetDelta, rootEntryDelta);
    let x = 0;
    for (const child of rootEntry.children) {
      const childElement = this.addEntry_(
        child,
        "",
        this.entryContainerElement_,
        unit,
      );
      childElement.setAttribute("transform", `translate( ${x}, ${0} )`);
      x += this.entryToDelta_(child) * unit;
    }
    this.entryElementCacheMap_.vaporize(([path, element]) => {
      element.remove();
      if (this.hoveringEntry_ === path) {
        this.hoveringEntry_ = null;
      }
    });
    this.updateTooltip_();
  }
  updateTooltip_() {
    const path = this.hoveringEntry_;
    if (path) {
      const element = this.entryElementCacheMap_.get(path);
      const dataDelta =
        element === null || element === void 0
          ? void 0
          : element.getAttribute("data-delta");
      const displayDelta = this.deltaToDisplayDelta_(
        parseFloat(
          dataDelta !== null && dataDelta !== void 0 ? dataDelta : "0.0",
        ),
      );
      const text = `${path}
${displayDelta}`;
      this.tooltipElement_.style.display = "block";
      this.tooltipInsideElement_.textContent = text;
    } else {
      this.tooltipElement_.style.display = "none";
    }
  }
  addEntry_(entry, parentPath, parent, unit) {
    const path = `${parentPath}/${entry.name}`;
    const g = this.entryElementCacheMap_.getOrCreate(path, () => {
      const newG = document.createElementNS("http://www.w3.org/2000/svg", "g");
      newG.classList.add(className$1("entry"));
      parent.appendChild(newG);
      this.entryElementCacheMap_.set(path, newG);
      const rect2 = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "rect",
      );
      rect2.classList.add(className$1("entryrect"));
      newG.appendChild(rect2);
      rect2.addEventListener("mouseenter", () => {
        this.hoveringEntry_ = path;
        this.updateTooltip_();
      });
      rect2.addEventListener("mouseleave", () => {
        this.hoveringEntry_ = null;
        this.updateTooltip_();
      });
      return newG;
    });
    const delta = this.entryToDelta_(entry);
    g.setAttribute("data-delta", `${delta}`);
    const rect = g.childNodes[0];
    rect.setAttribute("width", `${Math.max(0.01, delta * unit - 1)}px`);
    rect.setAttribute("height", `${9}px`);
    const turboX = 0.15 + 0.7 * saturate(delta / this.targetDelta);
    rect.setAttribute("fill", genTurboColormap(turboX));
    if (entry.children.length > 0) {
      let x = 0;
      entry.children.forEach((child) => {
        const childElement = this.addEntry_(child, path, g, unit);
        childElement.setAttribute("transform", `translate( ${x}, ${10} )`);
        x += this.entryToDelta_(child) * unit;
      });
    }
    return g;
  }
  entryToDelta_(entry) {
    if (this.calcMode === "frame") {
      return entry.delta;
    } else if (this.calcMode === "mean") {
      return entry.deltaMean;
    } else if (this.calcMode === "median") {
      return entry.deltaMedian;
    } else {
      throw new Error(
        'Unreachable! calcMode must be one of "frame", "mean", or "median"',
      );
    }
  }
  deltaToDisplayDelta_(delta) {
    return `${delta.toFixed(this.fractionDigits)} ${this.deltaUnit}`;
  }
}
class ProfilerController {
  constructor(doc, config) {
    this.targetDelta = config.targetDelta;
    this.bufferSize = config.bufferSize;
    this.onTick_ = this.onTick_.bind(this);
    this.ticker_ = config.ticker;
    this.ticker_.emitter.on("tick", this.onTick_);
    this.viewProps = config.viewProps;
    this.view = new ProfilerView(doc, {
      targetDelta: this.targetDelta,
      deltaUnit: config.deltaUnit,
      fractionDigits: config.fractionDigits,
      calcMode: config.calcMode,
      viewProps: this.viewProps,
    });
    this.viewProps.handleDispose(() => {
      this.ticker_.dispose();
    });
    this.measureHandler = config.measureHandler;
    this.rootCalcCacheStack_ = [this.createNewEntryCalcCache_()];
  }
  measureStart(name) {
    const parentCalcCache =
      this.rootCalcCacheStack_[this.rootCalcCacheStack_.length - 1];
    const calcCache = parentCalcCache.childrenCacheMap.getOrCreate(name, () =>
      this.createNewEntryCalcCache_(),
    );
    calcCache.childrenCacheMap.resetUsedSet();
    arrayClear(calcCache.childrenPromiseDelta);
    this.rootCalcCacheStack_.push(calcCache);
    calcCache.measureEnd = this.measureHandler.measureStart();
  }
  measureEnd() {
    return __awaiter(this, void 0, void 0, function* () {
      const calcCache =
        this.rootCalcCacheStack_[this.rootCalcCacheStack_.length - 1];
      const parentCalcCache =
        this.rootCalcCacheStack_[this.rootCalcCacheStack_.length - 2];
      const promiseDelta = Promise.resolve(calcCache.measureEnd());
      calcCache.measureEnd = null;
      parentCalcCache.childrenPromiseDelta.push(promiseDelta);
      this.rootCalcCacheStack_.pop();
      calcCache.childrenCacheMap.vaporize();
      const children = yield Promise.all(calcCache.childrenPromiseDelta);
      const sumChildrenDelta = arraySum(children);
      const selfDelta = (yield promiseDelta) - sumChildrenDelta;
      calcCache.meanCalc.push(selfDelta);
      calcCache.medianCalc.push(selfDelta);
      calcCache.latest = selfDelta;
    });
  }
  measure(name, fn) {
    this.measureStart(name);
    fn();
    this.measureEnd();
  }
  measureAsync(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
      this.measureStart(name);
      yield fn();
      this.measureEnd();
    });
  }
  renderEntry() {
    return this.renderEntryFromCalcCache_("", this.rootCalcCacheStack_[0]);
  }
  renderEntryFromCalcCache_(name, calcCache) {
    const children = [];
    for (const childName of calcCache.childrenCacheMap.keySet) {
      const child = calcCache.childrenCacheMap.get(childName);
      children.push(this.renderEntryFromCalcCache_(childName, child));
    }
    const selfDelta = calcCache.latest;
    const selfDeltaMean = calcCache.meanCalc.mean;
    const selfDeltaMedian = calcCache.medianCalc.median;
    const childrenDeltaSum = arraySum(children.map((child) => child.delta));
    const childrenDeltaMeanSum = arraySum(
      children.map((child) => child.deltaMean),
    );
    const childrenDeltaMedianSum = arraySum(
      children.map((child) => child.deltaMedian),
    );
    const delta = selfDelta + childrenDeltaSum;
    const deltaMean = selfDeltaMean + childrenDeltaMeanSum;
    const deltaMedian = selfDeltaMedian + childrenDeltaMedianSum;
    return {
      name,
      delta,
      deltaMean,
      deltaMedian,
      selfDelta,
      selfDeltaMean,
      selfDeltaMedian,
      children,
    };
  }
  onTick_() {
    this.view.update(this.renderEntry());
  }
  createNewEntryCalcCache_() {
    return {
      meanCalc: new HistoryMeanCalculator(this.bufferSize),
      medianCalc: new HistoryPercentileCalculator(this.bufferSize),
      latest: 0,
      measureEnd: null,
      childrenCacheMap: new ConsecutiveCacheMap(),
      childrenPromiseDelta: [],
    };
  }
}
function createTicker(document2, interval) {
  return interval === 0
    ? new ManualTicker2()
    : new IntervalTicker2(
        document2,
        interval !== null && interval !== void 0
          ? interval
          : Constants$1.monitor.defaultInterval,
      );
}
function parseCalcMode(value) {
  switch (value) {
    case "frame":
    case "mean":
    case "median":
      return value;
    default:
      return void 0;
  }
}
function parseMeasureHandler(value) {
  if (typeof value === "object" && value != null && "measureStart" in value) {
    return value;
  } else {
    if (typeof value === "object" && value != null && "measure" in value) {
      console.warn(
        "The API of `ProfilerBladeDefaultMeasureHandler` has been changed in v0.4.0! Please define `measureStart` instead of `measure`. Fallback to the default measure handler.",
      );
    }
    return void 0;
  }
}
createPlugin$1({
  id: "profiler",
  type: "blade",
  accept(params) {
    const result = parseRecord$1(params, (p) => ({
      view: p.required.constant("profiler"),
      targetDelta: p.optional.number,
      bufferSize: p.optional.number,
      deltaUnit: p.optional.string,
      fractionDigits: p.optional.number,
      calcMode: p.optional.custom(parseCalcMode),
      label: p.optional.string,
      interval: p.optional.number,
      measureHandler: p.optional.custom(parseMeasureHandler),
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    var _a, _b, _c, _d, _e, _f, _g;
    const interval =
      (_a = args.params.interval) !== null && _a !== void 0 ? _a : 500;
    const targetDelta =
      (_b = args.params.targetDelta) !== null && _b !== void 0 ? _b : 16.67;
    const bufferSize =
      (_c = args.params.bufferSize) !== null && _c !== void 0 ? _c : 30;
    const deltaUnit =
      (_d = args.params.deltaUnit) !== null && _d !== void 0 ? _d : "ms";
    const fractionDigits =
      (_e = args.params.fractionDigits) !== null && _e !== void 0 ? _e : 2;
    const calcMode =
      (_f = args.params.calcMode) !== null && _f !== void 0 ? _f : "mean";
    const measureHandler =
      (_g = args.params.measureHandler) !== null && _g !== void 0
        ? _g
        : new ProfilerBladeDefaultMeasureHandler();
    return new ProfilerBladeController(args.document, {
      blade: args.blade,
      labelProps: ValueMap$1.fromObject({
        label: args.params.label,
      }),
      valueController: new ProfilerController(args.document, {
        ticker: createTicker(args.document, interval),
        targetDelta,
        bufferSize,
        deltaUnit,
        fractionDigits,
        calcMode,
        viewProps: args.viewProps,
        measureHandler,
      }),
    });
  },
  api(args) {
    if (!(args.controller instanceof ProfilerBladeController)) {
      return null;
    }
    return new ProfilerBladeApi(args.controller);
  },
});
function forceCast(v) {
  return v;
}
function isEmpty(value) {
  return value === null || value === void 0;
}
function isObject$1(value) {
  return value !== null && typeof value === "object";
}
function isRecord(value) {
  return value !== null && typeof value === "object";
}
function deepEqualsArray(a1, a2) {
  if (a1.length !== a2.length) {
    return false;
  }
  for (let i = 0; i < a1.length; i++) {
    if (a1[i] !== a2[i]) {
      return false;
    }
  }
  return true;
}
function deepMerge(r1, r2) {
  const keys = Array.from(
    /* @__PURE__ */ new Set([...Object.keys(r1), ...Object.keys(r2)]),
  );
  return keys.reduce((result, key2) => {
    const v1 = r1[key2];
    const v2 = r2[key2];
    return isRecord(v1) && isRecord(v2)
      ? Object.assign(Object.assign({}, result), { [key2]: deepMerge(v1, v2) })
      : Object.assign(Object.assign({}, result), {
          [key2]: key2 in r2 ? v2 : v1,
        });
  }, {});
}
function isBinding(value) {
  if (!isObject$1(value)) {
    return false;
  }
  return "target" in value;
}
const CREATE_MESSAGE_MAP = {
  alreadydisposed: () => "View has been already disposed",
  invalidparams: (context) => `Invalid parameters for '${context.name}'`,
  nomatchingcontroller: (context) =>
    `No matching controller for '${context.key}'`,
  nomatchingview: (context) =>
    `No matching view for '${JSON.stringify(context.params)}'`,
  notbindable: () => `Value is not bindable`,
  notcompatible: (context) => `Not compatible with  plugin '${context.id}'`,
  propertynotfound: (context) => `Property '${context.name}' not found`,
  shouldneverhappen: () => "This error should never happen",
};
class TpError7 {
  static alreadyDisposed() {
    return new TpError7({ type: "alreadydisposed" });
  }
  static notBindable() {
    return new TpError7({
      type: "notbindable",
    });
  }
  static notCompatible(bundleId, id) {
    return new TpError7({
      type: "notcompatible",
      context: {
        id: `${bundleId}.${id}`,
      },
    });
  }
  static propertyNotFound(name) {
    return new TpError7({
      type: "propertynotfound",
      context: {
        name,
      },
    });
  }
  static shouldNeverHappen() {
    return new TpError7({ type: "shouldneverhappen" });
  }
  constructor(config) {
    var _a;
    this.message =
      (_a = CREATE_MESSAGE_MAP[config.type](forceCast(config.context))) !==
        null && _a !== void 0
        ? _a
        : "Unexpected error";
    this.name = this.constructor.name;
    this.stack = new Error(this.message).stack;
    this.type = config.type;
  }
  toString() {
    return this.message;
  }
}
class BindingTarget7 {
  constructor(obj, key2) {
    this.obj_ = obj;
    this.key = key2;
  }
  static isBindable(obj) {
    if (obj === null) {
      return false;
    }
    if (typeof obj !== "object" && typeof obj !== "function") {
      return false;
    }
    return true;
  }
  read() {
    return this.obj_[this.key];
  }
  write(value) {
    this.obj_[this.key] = value;
  }
  writeProperty(name, value) {
    const valueObj = this.read();
    if (!BindingTarget7.isBindable(valueObj)) {
      throw TpError7.notBindable();
    }
    if (!(name in valueObj)) {
      throw TpError7.propertyNotFound(name);
    }
    valueObj[name] = value;
  }
}
class Emitter7 {
  constructor() {
    this.observers_ = {};
  }
  on(eventName, handler) {
    let observers = this.observers_[eventName];
    if (!observers) {
      observers = this.observers_[eventName] = [];
    }
    observers.push({
      handler,
    });
    return this;
  }
  off(eventName, handler) {
    const observers = this.observers_[eventName];
    if (observers) {
      this.observers_[eventName] = observers.filter((observer) => {
        return observer.handler !== handler;
      });
    }
    return this;
  }
  emit(eventName, event) {
    const observers = this.observers_[eventName];
    if (!observers) {
      return;
    }
    observers.forEach((observer) => {
      observer.handler(event);
    });
  }
}
class ComplexValue7 {
  constructor(initialValue, config) {
    var _a;
    this.constraint_ =
      config === null || config === void 0 ? void 0 : config.constraint;
    this.equals_ =
      (_a = config === null || config === void 0 ? void 0 : config.equals) !==
        null && _a !== void 0
        ? _a
        : (v1, v2) => v1 === v2;
    this.emitter = new Emitter7();
    this.rawValue_ = initialValue;
  }
  get constraint() {
    return this.constraint_;
  }
  get rawValue() {
    return this.rawValue_;
  }
  set rawValue(rawValue) {
    this.setRawValue(rawValue, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(rawValue, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const constrainedValue = this.constraint_
      ? this.constraint_.constrain(rawValue)
      : rawValue;
    const prevValue = this.rawValue_;
    const changed = !this.equals_(prevValue, constrainedValue);
    if (!changed && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.rawValue_ = constrainedValue;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: constrainedValue,
      sender: this,
    });
  }
}
class PrimitiveValue7 {
  constructor(initialValue) {
    this.emitter = new Emitter7();
    this.value_ = initialValue;
  }
  get rawValue() {
    return this.value_;
  }
  set rawValue(value) {
    this.setRawValue(value, {
      forceEmit: false,
      last: true,
    });
  }
  setRawValue(value, options) {
    const opts =
      options !== null && options !== void 0
        ? options
        : {
            forceEmit: false,
            last: true,
          };
    const prevValue = this.value_;
    if (prevValue === value && !opts.forceEmit) {
      return;
    }
    this.emitter.emit("beforechange", {
      sender: this,
    });
    this.value_ = value;
    this.emitter.emit("change", {
      options: opts,
      previousRawValue: prevValue,
      rawValue: this.value_,
      sender: this,
    });
  }
}
class ReadonlyPrimitiveValue7 {
  constructor(value) {
    this.emitter = new Emitter7();
    this.onValueBeforeChange_ = this.onValueBeforeChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value_ = value;
    this.value_.emitter.on("beforechange", this.onValueBeforeChange_);
    this.value_.emitter.on("change", this.onValueChange_);
  }
  get rawValue() {
    return this.value_.rawValue;
  }
  onValueBeforeChange_(ev) {
    this.emitter.emit(
      "beforechange",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
  onValueChange_(ev) {
    this.emitter.emit(
      "change",
      Object.assign(Object.assign({}, ev), { sender: this }),
    );
  }
}
function createValue(initialValue, config) {
  const constraint =
    config === null || config === void 0 ? void 0 : config.constraint;
  const equals2 = config === null || config === void 0 ? void 0 : config.equals;
  if (!constraint && !equals2) {
    return new PrimitiveValue7(initialValue);
  }
  return new ComplexValue7(initialValue, config);
}
function createReadonlyValue(value) {
  return [
    new ReadonlyPrimitiveValue7(value),
    (rawValue, options) => {
      value.setRawValue(rawValue, options);
    },
  ];
}
class ValueMap7 {
  constructor(valueMap) {
    this.emitter = new Emitter7();
    this.valMap_ = valueMap;
    for (const key2 in this.valMap_) {
      const v = this.valMap_[key2];
      v.emitter.on("change", () => {
        this.emitter.emit("change", {
          key: key2,
          sender: this,
        });
      });
    }
  }
  static createCore(initialValue) {
    const keys = Object.keys(initialValue);
    return keys.reduce((o, key2) => {
      return Object.assign(o, {
        [key2]: createValue(initialValue[key2]),
      });
    }, {});
  }
  static fromObject(initialValue) {
    const core = this.createCore(initialValue);
    return new ValueMap7(core);
  }
  get(key2) {
    return this.valMap_[key2].rawValue;
  }
  set(key2, value) {
    this.valMap_[key2].rawValue = value;
  }
  value(key2) {
    return this.valMap_[key2];
  }
}
class DefiniteRangeConstraint7 {
  constructor(config) {
    this.values = ValueMap7.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    return Math.min(Math.max(value, min), max);
  }
}
class RangeConstraint7 {
  constructor(config) {
    this.values = ValueMap7.fromObject({
      max: config.max,
      min: config.min,
    });
  }
  constrain(value) {
    const max = this.values.get("max");
    const min = this.values.get("min");
    let result = value;
    if (!isEmpty(min)) {
      result = Math.max(result, min);
    }
    if (!isEmpty(max)) {
      result = Math.min(result, max);
    }
    return result;
  }
}
class StepConstraint7 {
  constructor(step, origin = 0) {
    this.step = step;
    this.origin = origin;
  }
  constrain(value) {
    const o = this.origin % this.step;
    const r = Math.round((value - o) / this.step);
    return o + r * this.step;
  }
}
class NumberLiteralNode7 {
  constructor(text) {
    this.text = text;
  }
  evaluate() {
    return Number(this.text);
  }
  toString() {
    return this.text;
  }
}
const BINARY_OPERATION_MAP = {
  "**": (v1, v2) => Math.pow(v1, v2),
  "*": (v1, v2) => v1 * v2,
  "/": (v1, v2) => v1 / v2,
  "%": (v1, v2) => v1 % v2,
  "+": (v1, v2) => v1 + v2,
  "-": (v1, v2) => v1 - v2,
  "<<": (v1, v2) => v1 << v2,
  ">>": (v1, v2) => v1 >> v2,
  ">>>": (v1, v2) => v1 >>> v2,
  "&": (v1, v2) => v1 & v2,
  "^": (v1, v2) => v1 ^ v2,
  "|": (v1, v2) => v1 | v2,
};
class BinaryOperationNode7 {
  constructor(operator, left, right) {
    this.left = left;
    this.operator = operator;
    this.right = right;
  }
  evaluate() {
    const op = BINARY_OPERATION_MAP[this.operator];
    if (!op) {
      throw new Error(`unexpected binary operator: '${this.operator}`);
    }
    return op(this.left.evaluate(), this.right.evaluate());
  }
  toString() {
    return [
      "b(",
      this.left.toString(),
      this.operator,
      this.right.toString(),
      ")",
    ].join(" ");
  }
}
const UNARY_OPERATION_MAP = {
  "+": (v) => v,
  "-": (v) => -v,
  "~": (v) => ~v,
};
class UnaryOperationNode7 {
  constructor(operator, expr) {
    this.operator = operator;
    this.expression = expr;
  }
  evaluate() {
    const op = UNARY_OPERATION_MAP[this.operator];
    if (!op) {
      throw new Error(`unexpected unary operator: '${this.operator}`);
    }
    return op(this.expression.evaluate());
  }
  toString() {
    return ["u(", this.operator, this.expression.toString(), ")"].join(" ");
  }
}
function combineReader(parsers) {
  return (text, cursor) => {
    for (let i = 0; i < parsers.length; i++) {
      const result = parsers[i](text, cursor);
      if (result !== "") {
        return result;
      }
    }
    return "";
  };
}
function readWhitespace(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^\s+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readNonZeroDigit(text, cursor) {
  const ch = text.substr(cursor, 1);
  return ch.match(/^[1-9]$/) ? ch : "";
}
function readDecimalDigits(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readSignedInteger(text, cursor) {
  const ds = readDecimalDigits(text, cursor);
  if (ds !== "") {
    return ds;
  }
  const sign2 = text.substr(cursor, 1);
  cursor += 1;
  if (sign2 !== "-" && sign2 !== "+") {
    return "";
  }
  const sds = readDecimalDigits(text, cursor);
  if (sds === "") {
    return "";
  }
  return sign2 + sds;
}
function readExponentPart(text, cursor) {
  const e = text.substr(cursor, 1);
  cursor += 1;
  if (e.toLowerCase() !== "e") {
    return "";
  }
  const si = readSignedInteger(text, cursor);
  if (si === "") {
    return "";
  }
  return e + si;
}
function readDecimalIntegerLiteral(text, cursor) {
  const ch = text.substr(cursor, 1);
  if (ch === "0") {
    return ch;
  }
  const nzd = readNonZeroDigit(text, cursor);
  cursor += nzd.length;
  if (nzd === "") {
    return "";
  }
  return nzd + readDecimalDigits(text, cursor);
}
function readDecimalLiteral1(text, cursor) {
  const dil = readDecimalIntegerLiteral(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits(text, cursor);
  cursor += dds.length;
  return dil + dot2 + dds + readExponentPart(text, cursor);
}
function readDecimalLiteral2(text, cursor) {
  const dot2 = text.substr(cursor, 1);
  cursor += dot2.length;
  if (dot2 !== ".") {
    return "";
  }
  const dds = readDecimalDigits(text, cursor);
  cursor += dds.length;
  if (dds === "") {
    return "";
  }
  return dot2 + dds + readExponentPart(text, cursor);
}
function readDecimalLiteral3(text, cursor) {
  const dil = readDecimalIntegerLiteral(text, cursor);
  cursor += dil.length;
  if (dil === "") {
    return "";
  }
  return dil + readExponentPart(text, cursor);
}
const readDecimalLiteral = combineReader([
  readDecimalLiteral1,
  readDecimalLiteral2,
  readDecimalLiteral3,
]);
function parseBinaryDigits(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[01]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readBinaryIntegerLiteral(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0b") {
    return "";
  }
  const bds = parseBinaryDigits(text, cursor);
  if (bds === "") {
    return "";
  }
  return prefix + bds;
}
function readOctalDigits(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-7]+/);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readOctalIntegerLiteral(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0o") {
    return "";
  }
  const ods = readOctalDigits(text, cursor);
  if (ods === "") {
    return "";
  }
  return prefix + ods;
}
function readHexDigits(text, cursor) {
  var _a;
  const m = text.substr(cursor).match(/^[0-9a-f]+/i);
  return (_a = m && m[0]) !== null && _a !== void 0 ? _a : "";
}
function readHexIntegerLiteral(text, cursor) {
  const prefix = text.substr(cursor, 2);
  cursor += prefix.length;
  if (prefix.toLowerCase() !== "0x") {
    return "";
  }
  const hds = readHexDigits(text, cursor);
  if (hds === "") {
    return "";
  }
  return prefix + hds;
}
const readNonDecimalIntegerLiteral = combineReader([
  readBinaryIntegerLiteral,
  readOctalIntegerLiteral,
  readHexIntegerLiteral,
]);
const readNumericLiteral = combineReader([
  readNonDecimalIntegerLiteral,
  readDecimalLiteral,
]);
function parseLiteral(text, cursor) {
  const num = readNumericLiteral(text, cursor);
  cursor += num.length;
  if (num === "") {
    return null;
  }
  return {
    evaluable: new NumberLiteralNode7(num),
    cursor,
  };
}
function parseParenthesizedExpression(text, cursor) {
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "(") {
    return null;
  }
  const expr = parseExpression(text, cursor);
  if (!expr) {
    return null;
  }
  cursor = expr.cursor;
  cursor += readWhitespace(text, cursor).length;
  const cl = text.substr(cursor, 1);
  cursor += cl.length;
  if (cl !== ")") {
    return null;
  }
  return {
    evaluable: expr.evaluable,
    cursor,
  };
}
function parsePrimaryExpression(text, cursor) {
  var _a;
  return (_a = parseLiteral(text, cursor)) !== null && _a !== void 0
    ? _a
    : parseParenthesizedExpression(text, cursor);
}
function parseUnaryExpression(text, cursor) {
  const expr = parsePrimaryExpression(text, cursor);
  if (expr) {
    return expr;
  }
  const op = text.substr(cursor, 1);
  cursor += op.length;
  if (op !== "+" && op !== "-" && op !== "~") {
    return null;
  }
  const num = parseUnaryExpression(text, cursor);
  if (!num) {
    return null;
  }
  cursor = num.cursor;
  return {
    cursor,
    evaluable: new UnaryOperationNode7(op, num.evaluable),
  };
}
function readBinaryOperator(ops, text, cursor) {
  cursor += readWhitespace(text, cursor).length;
  const op = ops.filter((op2) => text.startsWith(op2, cursor))[0];
  if (!op) {
    return null;
  }
  cursor += op.length;
  cursor += readWhitespace(text, cursor).length;
  return {
    cursor,
    operator: op,
  };
}
function createBinaryOperationExpressionParser(exprParser, ops) {
  return (text, cursor) => {
    const firstExpr = exprParser(text, cursor);
    if (!firstExpr) {
      return null;
    }
    cursor = firstExpr.cursor;
    let expr = firstExpr.evaluable;
    for (;;) {
      const op = readBinaryOperator(ops, text, cursor);
      if (!op) {
        break;
      }
      cursor = op.cursor;
      const nextExpr = exprParser(text, cursor);
      if (!nextExpr) {
        return null;
      }
      cursor = nextExpr.cursor;
      expr = new BinaryOperationNode7(op.operator, expr, nextExpr.evaluable);
    }
    return expr
      ? {
          cursor,
          evaluable: expr,
        }
      : null;
  };
}
const parseBinaryOperationExpression = [
  ["**"],
  ["*", "/", "%"],
  ["+", "-"],
  ["<<", ">>>", ">>"],
  ["&"],
  ["^"],
  ["|"],
].reduce((parser, ops) => {
  return createBinaryOperationExpressionParser(parser, ops);
}, parseUnaryExpression);
function parseExpression(text, cursor) {
  cursor += readWhitespace(text, cursor).length;
  return parseBinaryOperationExpression(text, cursor);
}
function parseEcmaNumberExpression(text) {
  const expr = parseExpression(text, 0);
  if (!expr) {
    return null;
  }
  const cursor = expr.cursor + readWhitespace(text, expr.cursor).length;
  if (cursor !== text.length) {
    return null;
  }
  return expr.evaluable;
}
function parseNumber(text) {
  var _a;
  const r = parseEcmaNumberExpression(text);
  return (_a = r === null || r === void 0 ? void 0 : r.evaluate()) !== null &&
    _a !== void 0
    ? _a
    : null;
}
function numberFromUnknown(value) {
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "string") {
    const pv = parseNumber(value);
    if (!isEmpty(pv)) {
      return pv;
    }
  }
  return 0;
}
function createNumberFormatter(digits) {
  return (value) => {
    return value.toFixed(Math.max(Math.min(digits, 20), 0));
  };
}
function mapRange(value, start1, end1, start2, end2) {
  const p = (value - start1) / (end1 - start1);
  return start2 + p * (end2 - start2);
}
function getDecimalDigits(value) {
  const text = String(value.toFixed(10));
  const frac = text.split(".")[1];
  return frac.replace(/0+$/, "").length;
}
function constrainRange(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function loopRange(value, max) {
  return ((value % max) + max) % max;
}
function getSuitableDecimalDigits(params, rawValue) {
  return !isEmpty(params.step)
    ? getDecimalDigits(params.step)
    : Math.max(getDecimalDigits(rawValue), 2);
}
function getSuitableKeyScale(params) {
  var _a;
  return (_a = params.step) !== null && _a !== void 0 ? _a : 1;
}
function getSuitablePointerScale(params, rawValue) {
  var _a;
  const base2 = Math.abs(
    (_a = params.step) !== null && _a !== void 0 ? _a : rawValue,
  );
  return base2 === 0 ? 0.1 : Math.pow(10, Math.floor(Math.log10(base2)) - 1);
}
function createStepConstraint(params, initialValue) {
  if (!isEmpty(params.step)) {
    return new StepConstraint7(params.step, initialValue);
  }
  return null;
}
function createRangeConstraint(params) {
  if (!isEmpty(params.max) && !isEmpty(params.min)) {
    return new DefiniteRangeConstraint7({
      max: params.max,
      min: params.min,
    });
  }
  if (!isEmpty(params.max) || !isEmpty(params.min)) {
    return new RangeConstraint7({
      max: params.max,
      min: params.min,
    });
  }
  return null;
}
function createNumberTextPropsObject(params, initialValue) {
  var _a, _b, _c;
  return {
    formatter:
      (_a = params.format) !== null && _a !== void 0
        ? _a
        : createNumberFormatter(getSuitableDecimalDigits(params, initialValue)),
    keyScale:
      (_b = params.keyScale) !== null && _b !== void 0
        ? _b
        : getSuitableKeyScale(params),
    pointerScale:
      (_c = params.pointerScale) !== null && _c !== void 0
        ? _c
        : getSuitablePointerScale(params, initialValue),
  };
}
function createNumberTextInputParamsParser(p) {
  return {
    format: p.optional.function,
    keyScale: p.optional.number,
    max: p.optional.number,
    min: p.optional.number,
    pointerScale: p.optional.number,
    step: p.optional.number,
  };
}
function createPointAxis(config) {
  return {
    constraint: config.constraint,
    textProps: ValueMap7.fromObject(
      createNumberTextPropsObject(config.params, config.initialValue),
    ),
  };
}
class BladeApi7 {
  constructor(controller) {
    this.controller = controller;
  }
  get element() {
    return this.controller.view.element;
  }
  get disabled() {
    return this.controller.viewProps.get("disabled");
  }
  set disabled(disabled) {
    this.controller.viewProps.set("disabled", disabled);
  }
  get hidden() {
    return this.controller.viewProps.get("hidden");
  }
  set hidden(hidden) {
    this.controller.viewProps.set("hidden", hidden);
  }
  dispose() {
    this.controller.viewProps.set("disposed", true);
  }
  importState(state) {
    return this.controller.importState(state);
  }
  exportState() {
    return this.controller.exportState();
  }
}
class TpEvent7 {
  constructor(target) {
    this.target = target;
  }
}
class TpChangeEvent7 extends TpEvent7 {
  constructor(target, value, last) {
    super(target);
    this.value = value;
    this.last = last !== null && last !== void 0 ? last : true;
  }
}
class TpFoldEvent7 extends TpEvent7 {
  constructor(target, expanded) {
    super(target);
    this.expanded = expanded;
  }
}
class TpTabSelectEvent7 extends TpEvent7 {
  constructor(target, index) {
    super(target);
    this.index = index;
  }
}
class BindingApi7 extends BladeApi7 {
  constructor(controller) {
    super(controller);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.emitter_ = new Emitter7();
    this.controller.value.emitter.on("change", this.onValueChange_);
  }
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get key() {
    return this.controller.value.binding.target.key;
  }
  get tag() {
    return this.controller.tag;
  }
  set tag(tag) {
    this.controller.tag = tag;
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.controller.value.fetch();
  }
  onValueChange_(ev) {
    const value = this.controller.value;
    this.emitter_.emit(
      "change",
      new TpChangeEvent7(
        this,
        forceCast(value.binding.target.read()),
        ev.options.last,
      ),
    );
  }
}
function parseObject(value, keyToParserMap) {
  const keys = Object.keys(keyToParserMap);
  const result = keys.reduce((tmp2, key2) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const parser = keyToParserMap[key2];
    const result2 = parser(value[key2]);
    return result2.succeeded
      ? Object.assign(Object.assign({}, tmp2), { [key2]: result2.value })
      : void 0;
  }, {});
  return forceCast(result);
}
function parseArray(value, parseItem) {
  return value.reduce((tmp2, item) => {
    if (tmp2 === void 0) {
      return void 0;
    }
    const result = parseItem(item);
    if (!result.succeeded || result.value === void 0) {
      return void 0;
    }
    return [...tmp2, result.value];
  }, []);
}
function isObject(value) {
  if (value === null) {
    return false;
  }
  return typeof value === "object";
}
function createMicroParserBuilder(parse) {
  return (optional) => (v) => {
    if (!optional && v === void 0) {
      return {
        succeeded: false,
        value: void 0,
      };
    }
    if (optional && v === void 0) {
      return {
        succeeded: true,
        value: void 0,
      };
    }
    const result = parse(v);
    return result !== void 0
      ? {
          succeeded: true,
          value: result,
        }
      : {
          succeeded: false,
          value: void 0,
        };
  };
}
function createMicroParserBuilders(optional) {
  return {
    custom: (parse) => createMicroParserBuilder(parse)(optional),
    boolean: createMicroParserBuilder((v) =>
      typeof v === "boolean" ? v : void 0,
    )(optional),
    number: createMicroParserBuilder((v) =>
      typeof v === "number" ? v : void 0,
    )(optional),
    string: createMicroParserBuilder((v) =>
      typeof v === "string" ? v : void 0,
    )(optional),
    function: createMicroParserBuilder((v) =>
      typeof v === "function" ? v : void 0,
    )(optional),
    constant: (value) =>
      createMicroParserBuilder((v) => (v === value ? value : void 0))(optional),
    raw: createMicroParserBuilder((v) => v)(optional),
    object: (keyToParserMap) =>
      createMicroParserBuilder((v) => {
        if (!isObject(v)) {
          return void 0;
        }
        return parseObject(v, keyToParserMap);
      })(optional),
    array: (itemParser) =>
      createMicroParserBuilder((v) => {
        if (!Array.isArray(v)) {
          return void 0;
        }
        return parseArray(v, itemParser);
      })(optional),
  };
}
const MicroParsers = {
  optional: createMicroParserBuilders(true),
  required: createMicroParserBuilders(false),
};
function parseRecord(value, keyToParserMap) {
  const map = keyToParserMap(MicroParsers);
  const result = MicroParsers.required.object(map)(value);
  return result.succeeded ? result.value : void 0;
}
function importBladeState(state, superImport, parser, callback) {
  if (superImport && !superImport(state)) {
    return false;
  }
  const result = parseRecord(state, parser);
  return result ? callback(result) : false;
}
function exportBladeState(superExport, thisState) {
  var _a;
  return deepMerge(
    (_a =
      superExport === null || superExport === void 0
        ? void 0
        : superExport()) !== null && _a !== void 0
      ? _a
      : {},
    thisState,
  );
}
function isValueBladeController(bc) {
  return "value" in bc;
}
function isBindingValue(v) {
  if (!isObject$1(v) || !("binding" in v)) {
    return false;
  }
  const b = v.binding;
  return isBinding(b);
}
const SVG_NS = "http://www.w3.org/2000/svg";
function forceReflow(element) {
  element.offsetHeight;
}
function disableTransitionTemporarily(element, callback) {
  const t = element.style.transition;
  element.style.transition = "none";
  callback();
  element.style.transition = t;
}
function supportsTouch(doc) {
  return doc.ontouchstart !== void 0;
}
function getCanvasContext(canvasElement) {
  const win = canvasElement.ownerDocument.defaultView;
  if (!win) {
    return null;
  }
  const isBrowser = "document" in win;
  return isBrowser
    ? canvasElement.getContext("2d", {
        willReadFrequently: true,
      })
    : null;
}
const ICON_ID_TO_INNER_HTML_MAP = {
  check: '<path d="M2 8l4 4l8 -8"/>',
  dropdown: '<path d="M5 7h6l-3 3 z"/>',
  p2dpad:
    '<path d="M8 4v8"/><path d="M4 8h8"/><circle cx="12" cy="12" r="1.2"/>',
};
function createSvgIconElement(document2, iconId) {
  const elem = document2.createElementNS(SVG_NS, "svg");
  elem.innerHTML = ICON_ID_TO_INNER_HTML_MAP[iconId];
  return elem;
}
function insertElementAt(parentElement, element, index) {
  parentElement.insertBefore(element, parentElement.children[index]);
}
function removeElement(element) {
  if (element.parentElement) {
    element.parentElement.removeChild(element);
  }
}
function removeChildElements(element) {
  while (element.children.length > 0) {
    element.removeChild(element.children[0]);
  }
}
function removeChildNodes(element) {
  while (element.childNodes.length > 0) {
    element.removeChild(element.childNodes[0]);
  }
}
function findNextTarget(ev) {
  if (ev.relatedTarget) {
    return forceCast(ev.relatedTarget);
  }
  if ("explicitOriginalTarget" in ev) {
    return ev.explicitOriginalTarget;
  }
  return null;
}
function bindValue(value, applyValue) {
  value.emitter.on("change", (ev) => {
    applyValue(ev.rawValue);
  });
  applyValue(value.rawValue);
}
function bindValueMap(valueMap, key2, applyValue) {
  bindValue(valueMap.value(key2), applyValue);
}
const PREFIX = "tp";
function ClassName(viewName) {
  const fn = (opt_elementName, opt_modifier) => {
    return [
      PREFIX,
      "-",
      viewName,
      "v",
      opt_elementName ? `_${opt_elementName}` : "",
      opt_modifier ? `-${opt_modifier}` : "",
    ].join("");
  };
  return fn;
}
const cn$q = ClassName("lbl");
function createLabelNode(doc, label) {
  const frag = doc.createDocumentFragment();
  const lineNodes = label.split("\n").map((line) => {
    return doc.createTextNode(line);
  });
  lineNodes.forEach((lineNode, index) => {
    if (index > 0) {
      frag.appendChild(doc.createElement("br"));
    }
    frag.appendChild(lineNode);
  });
  return frag;
}
class LabelView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$q());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("div");
    labelElem.classList.add(cn$q("l"));
    bindValueMap(config.props, "label", (value) => {
      if (isEmpty(value)) {
        this.element.classList.add(cn$q(void 0, "nol"));
      } else {
        this.element.classList.remove(cn$q(void 0, "nol"));
        removeChildNodes(labelElem);
        labelElem.appendChild(createLabelNode(doc, value));
      }
    });
    this.element.appendChild(labelElem);
    this.labelElement = labelElem;
    const valueElem = doc.createElement("div");
    valueElem.classList.add(cn$q("v"));
    this.element.appendChild(valueElem);
    this.valueElement = valueElem;
  }
}
class LabelController7 {
  constructor(doc, config) {
    this.props = config.props;
    this.valueController = config.valueController;
    this.viewProps = config.valueController.viewProps;
    this.view = new LabelView7(doc, {
      props: config.props,
      viewProps: this.viewProps,
    });
    this.view.valueElement.appendChild(this.valueController.view.element);
  }
  importProps(state) {
    return importBladeState(
      state,
      null,
      (p) => ({
        label: p.optional.string,
      }),
      (result) => {
        this.props.set("label", result.label);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState(null, {
      label: this.props.get("label"),
    });
  }
}
function getAllBladePositions() {
  return ["veryfirst", "first", "last", "verylast"];
}
const cn$p = ClassName("");
const POS_TO_CLASS_NAME_MAP = {
  veryfirst: "vfst",
  first: "fst",
  last: "lst",
  verylast: "vlst",
};
class BladeController7 {
  constructor(config) {
    this.parent_ = null;
    this.blade = config.blade;
    this.view = config.view;
    this.viewProps = config.viewProps;
    const elem = this.view.element;
    this.blade.value("positions").emitter.on("change", () => {
      getAllBladePositions().forEach((pos) => {
        elem.classList.remove(cn$p(void 0, POS_TO_CLASS_NAME_MAP[pos]));
      });
      this.blade.get("positions").forEach((pos) => {
        elem.classList.add(cn$p(void 0, POS_TO_CLASS_NAME_MAP[pos]));
      });
    });
    this.viewProps.handleDispose(() => {
      removeElement(elem);
    });
  }
  get parent() {
    return this.parent_;
  }
  set parent(parent) {
    this.parent_ = parent;
    this.viewProps.set("parent", this.parent_ ? this.parent_.viewProps : null);
  }
  importState(state) {
    return importBladeState(
      state,
      null,
      (p) => ({
        disabled: p.required.boolean,
        hidden: p.required.boolean,
      }),
      (result) => {
        this.viewProps.importState(result);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState(
      null,
      Object.assign({}, this.viewProps.exportState()),
    );
  }
}
class ButtonApi7 extends BladeApi7 {
  get label() {
    return this.controller.labelController.props.get("label");
  }
  set label(label) {
    this.controller.labelController.props.set("label", label);
  }
  get title() {
    var _a;
    return (_a = this.controller.buttonController.props.get("title")) !==
      null && _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.buttonController.props.set("title", title);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    const emitter = this.controller.buttonController.emitter;
    emitter.on(eventName, () => {
      bh(new TpEvent7(this));
    });
    return this;
  }
}
function applyClass(elem, className2, active) {
  if (active) {
    elem.classList.add(className2);
  } else {
    elem.classList.remove(className2);
  }
}
function valueToClassName(elem, className2) {
  return (value) => {
    applyClass(elem, className2, value);
  };
}
function bindValueToTextContent(value, elem) {
  bindValue(value, (text) => {
    elem.textContent = text !== null && text !== void 0 ? text : "";
  });
}
const cn$o = ClassName("btn");
class ButtonView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$o());
    config.viewProps.bindClassModifiers(this.element);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$o("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$o("t"));
    bindValueToTextContent(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
  }
}
class ButtonController7 {
  constructor(doc, config) {
    this.emitter = new Emitter7();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new ButtonView7(doc, {
      props: this.props,
      viewProps: this.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  importProps(state) {
    return importBladeState(
      state,
      null,
      (p) => ({
        title: p.optional.string,
      }),
      (result) => {
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState(null, {
      title: this.props.get("title"),
    });
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
}
class ButtonBladeController7 extends BladeController7 {
  constructor(doc, config) {
    const bc = new ButtonController7(doc, {
      props: config.buttonProps,
      viewProps: config.viewProps,
    });
    const lc = new LabelController7(doc, {
      blade: config.blade,
      props: config.labelProps,
      valueController: bc,
    });
    super({
      blade: config.blade,
      view: lc.view,
      viewProps: config.viewProps,
    });
    this.buttonController = bc;
    this.labelController = lc;
  }
  importState(state) {
    return importBladeState(
      state,
      (s) =>
        super.importState(s) &&
        this.buttonController.importProps(s) &&
        this.labelController.importProps(s),
      () => ({}),
      () => true,
    );
  }
  exportState() {
    return exportBladeState(
      () => super.exportState(),
      Object.assign(
        Object.assign({}, this.buttonController.exportProps()),
        this.labelController.exportProps(),
      ),
    );
  }
}
class Semver7 {
  constructor(text) {
    const [core, prerelease] = text.split("-");
    const coreComps = core.split(".");
    this.major = parseInt(coreComps[0], 10);
    this.minor = parseInt(coreComps[1], 10);
    this.patch = parseInt(coreComps[2], 10);
    this.prerelease =
      prerelease !== null && prerelease !== void 0 ? prerelease : null;
  }
  toString() {
    const core = [this.major, this.minor, this.patch].join(".");
    return this.prerelease !== null ? [core, this.prerelease].join("-") : core;
  }
}
const VERSION = new Semver7("2.0.1");
function createPlugin(plugin) {
  return Object.assign({ core: VERSION }, plugin);
}
createPlugin({
  id: "button",
  type: "blade",
  accept(params) {
    const result = parseRecord(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("button"),
      label: p.optional.string,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new ButtonBladeController7(args.document, {
      blade: args.blade,
      buttonProps: ValueMap7.fromObject({
        title: args.params.title,
      }),
      labelProps: ValueMap7.fromObject({
        label: args.params.label,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (args.controller instanceof ButtonBladeController7) {
      return new ButtonApi7(args.controller);
    }
    return null;
  },
});
function addButtonAsBlade(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "button" }),
  );
}
function addFolderAsBlade(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "folder" }),
  );
}
function addTabAsBlade(api, params) {
  return api.addBlade(
    Object.assign(Object.assign({}, params), { view: "tab" }),
  );
}
function isRefreshable(value) {
  if (!isObject$1(value)) {
    return false;
  }
  return "refresh" in value && typeof value.refresh === "function";
}
function createBindingTarget(obj, key2) {
  if (!BindingTarget7.isBindable(obj)) {
    throw TpError7.notBindable();
  }
  return new BindingTarget7(obj, key2);
}
class RackApi7 {
  constructor(controller, pool) {
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.controller_ = controller;
    this.emitter_ = new Emitter7();
    this.pool_ = pool;
    const rack = this.controller_.rack;
    rack.emitter.on("valuechange", this.onRackValueChange_);
  }
  get children() {
    return this.controller_.rack.children.map((bc) => this.pool_.createApi(bc));
  }
  addBinding(object, key2, opt_params) {
    const params =
      opt_params !== null && opt_params !== void 0 ? opt_params : {};
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBinding(
      doc,
      createBindingTarget(object, key2),
      params,
    );
    const api = this.pool_.createBindingApi(bc);
    return this.add(api, params.index);
  }
  addFolder(params) {
    return addFolderAsBlade(this, params);
  }
  addButton(params) {
    return addButtonAsBlade(this, params);
  }
  addTab(params) {
    return addTabAsBlade(this, params);
  }
  add(api, opt_index) {
    const bc = api.controller;
    this.controller_.rack.add(bc, opt_index);
    return api;
  }
  remove(api) {
    this.controller_.rack.remove(api.controller);
  }
  addBlade(params) {
    const doc = this.controller_.element.ownerDocument;
    const bc = this.pool_.createBlade(doc, params);
    const api = this.pool_.createApi(bc);
    return this.add(api, params.index);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  refresh() {
    this.children.forEach((c) => {
      if (isRefreshable(c)) {
        c.refresh();
      }
    });
  }
  onRackValueChange_(ev) {
    const bc = ev.bladeController;
    const api = this.pool_.createApi(bc);
    const binding = isBindingValue(bc.value) ? bc.value.binding : null;
    this.emitter_.emit(
      "change",
      new TpChangeEvent7(
        api,
        binding ? binding.target.read() : bc.value.rawValue,
        ev.options.last,
      ),
    );
  }
}
class ContainerBladeApi7 extends BladeApi7 {
  constructor(controller, pool) {
    super(controller);
    this.rackApi_ = new RackApi7(controller.rackController, pool);
  }
  refresh() {
    this.rackApi_.refresh();
  }
}
class ContainerBladeController7 extends BladeController7 {
  constructor(config) {
    super({
      blade: config.blade,
      view: config.view,
      viewProps: config.rackController.viewProps,
    });
    this.rackController = config.rackController;
  }
  importState(state) {
    return importBladeState(
      state,
      (s) => super.importState(s),
      (p) => ({
        children: p.required.array(p.required.raw),
      }),
      (result) => {
        return this.rackController.rack.children.every((c, index) => {
          return c.importState(result.children[index]);
        });
      },
    );
  }
  exportState() {
    return exportBladeState(() => super.exportState(), {
      children: this.rackController.rack.children.map((c) => c.exportState()),
    });
  }
}
function isContainerBladeController(bc) {
  return "rackController" in bc;
}
class NestedOrderedSet7 {
  constructor(extract) {
    this.emitter = new Emitter7();
    this.items_ = [];
    this.cache_ = /* @__PURE__ */ new Set();
    this.onSubListAdd_ = this.onSubListAdd_.bind(this);
    this.onSubListRemove_ = this.onSubListRemove_.bind(this);
    this.extract_ = extract;
  }
  get items() {
    return this.items_;
  }
  allItems() {
    return Array.from(this.cache_);
  }
  find(callback) {
    for (const item of this.allItems()) {
      if (callback(item)) {
        return item;
      }
    }
    return null;
  }
  includes(item) {
    return this.cache_.has(item);
  }
  add(item, opt_index) {
    if (this.includes(item)) {
      throw TpError7.shouldNeverHappen();
    }
    const index = opt_index !== void 0 ? opt_index : this.items_.length;
    this.items_.splice(index, 0, item);
    this.cache_.add(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.emitter.on("add", this.onSubListAdd_);
      subList.emitter.on("remove", this.onSubListRemove_);
      subList.allItems().forEach((i) => {
        this.cache_.add(i);
      });
    }
    this.emitter.emit("add", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    this.cache_.delete(item);
    const subList = this.extract_(item);
    if (subList) {
      subList.allItems().forEach((i) => {
        this.cache_.delete(i);
      });
      subList.emitter.off("add", this.onSubListAdd_);
      subList.emitter.off("remove", this.onSubListRemove_);
    }
    this.emitter.emit("remove", {
      index,
      item,
      root: this,
      target: this,
    });
  }
  onSubListAdd_(ev) {
    this.cache_.add(ev.item);
    this.emitter.emit("add", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
  onSubListRemove_(ev) {
    this.cache_.delete(ev.item);
    this.emitter.emit("remove", {
      index: ev.index,
      item: ev.item,
      root: this,
      target: ev.target,
    });
  }
}
function findValueBladeController(bcs, v) {
  for (let i = 0; i < bcs.length; i++) {
    const bc = bcs[i];
    if (isValueBladeController(bc) && bc.value === v) {
      return bc;
    }
  }
  return null;
}
function findSubBladeControllerSet(bc) {
  return isContainerBladeController(bc)
    ? bc.rackController.rack["bcSet_"]
    : null;
}
class Rack7 {
  constructor(config) {
    var _a, _b;
    this.emitter = new Emitter7();
    this.onBladePositionsChange_ = this.onBladePositionsChange_.bind(this);
    this.onSetAdd_ = this.onSetAdd_.bind(this);
    this.onSetRemove_ = this.onSetRemove_.bind(this);
    this.onChildDispose_ = this.onChildDispose_.bind(this);
    this.onChildPositionsChange_ = this.onChildPositionsChange_.bind(this);
    this.onChildValueChange_ = this.onChildValueChange_.bind(this);
    this.onChildViewPropsChange_ = this.onChildViewPropsChange_.bind(this);
    this.onRackLayout_ = this.onRackLayout_.bind(this);
    this.onRackValueChange_ = this.onRackValueChange_.bind(this);
    this.blade_ = (_a = config.blade) !== null && _a !== void 0 ? _a : null;
    (_b = this.blade_) === null || _b === void 0
      ? void 0
      : _b
          .value("positions")
          .emitter.on("change", this.onBladePositionsChange_);
    this.viewProps = config.viewProps;
    this.bcSet_ = new NestedOrderedSet7(findSubBladeControllerSet);
    this.bcSet_.emitter.on("add", this.onSetAdd_);
    this.bcSet_.emitter.on("remove", this.onSetRemove_);
  }
  get children() {
    return this.bcSet_.items;
  }
  add(bc, opt_index) {
    var _a;
    (_a = bc.parent) === null || _a === void 0 ? void 0 : _a.remove(bc);
    bc.parent = this;
    this.bcSet_.add(bc, opt_index);
  }
  remove(bc) {
    bc.parent = null;
    this.bcSet_.remove(bc);
  }
  find(finder) {
    return this.bcSet_.allItems().filter(finder);
  }
  onSetAdd_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("add", {
      bladeController: ev.item,
      index: ev.index,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    bc.viewProps.emitter.on("change", this.onChildViewPropsChange_);
    bc.blade
      .value("positions")
      .emitter.on("change", this.onChildPositionsChange_);
    bc.viewProps.handleDispose(this.onChildDispose_);
    if (isValueBladeController(bc)) {
      bc.value.emitter.on("change", this.onChildValueChange_);
    } else if (isContainerBladeController(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.on("layout", this.onRackLayout_);
        emitter.on("valuechange", this.onRackValueChange_);
      }
    }
  }
  onSetRemove_(ev) {
    this.updatePositions_();
    const root = ev.target === ev.root;
    this.emitter.emit("remove", {
      bladeController: ev.item,
      root,
      sender: this,
    });
    if (!root) {
      return;
    }
    const bc = ev.item;
    if (isValueBladeController(bc)) {
      bc.value.emitter.off("change", this.onChildValueChange_);
    } else if (isContainerBladeController(bc)) {
      const rack = bc.rackController.rack;
      if (rack) {
        const emitter = rack.emitter;
        emitter.off("layout", this.onRackLayout_);
        emitter.off("valuechange", this.onRackValueChange_);
      }
    }
  }
  updatePositions_() {
    const visibleItems = this.bcSet_.items.filter(
      (bc) => !bc.viewProps.get("hidden"),
    );
    const firstVisibleItem = visibleItems[0];
    const lastVisibleItem = visibleItems[visibleItems.length - 1];
    this.bcSet_.items.forEach((bc) => {
      const ps = [];
      if (bc === firstVisibleItem) {
        ps.push("first");
        if (
          !this.blade_ ||
          this.blade_.get("positions").includes("veryfirst")
        ) {
          ps.push("veryfirst");
        }
      }
      if (bc === lastVisibleItem) {
        ps.push("last");
        if (!this.blade_ || this.blade_.get("positions").includes("verylast")) {
          ps.push("verylast");
        }
      }
      bc.blade.set("positions", ps);
    });
  }
  onChildPositionsChange_() {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildViewPropsChange_(_ev) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onChildDispose_() {
    const disposedUcs = this.bcSet_.items.filter((bc) => {
      return bc.viewProps.get("disposed");
    });
    disposedUcs.forEach((bc) => {
      this.bcSet_.remove(bc);
    });
  }
  onChildValueChange_(ev) {
    const bc = findValueBladeController(
      this.find(isValueBladeController),
      ev.sender,
    );
    if (!bc) {
      throw TpError7.alreadyDisposed();
    }
    this.emitter.emit("valuechange", {
      bladeController: bc,
      options: ev.options,
      sender: this,
    });
  }
  onRackLayout_(_) {
    this.updatePositions_();
    this.emitter.emit("layout", {
      sender: this,
    });
  }
  onRackValueChange_(ev) {
    this.emitter.emit("valuechange", {
      bladeController: ev.bladeController,
      options: ev.options,
      sender: this,
    });
  }
  onBladePositionsChange_() {
    this.updatePositions_();
  }
}
class RackController7 {
  constructor(config) {
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    this.element = config.element;
    this.viewProps = config.viewProps;
    const rack = new Rack7({
      blade: config.root ? void 0 : config.blade,
      viewProps: config.viewProps,
    });
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.rack = rack;
    this.viewProps.handleDispose(() => {
      for (let i = this.rack.children.length - 1; i >= 0; i--) {
        const bc = this.rack.children[i];
        bc.viewProps.set("disposed", true);
      }
    });
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    insertElementAt(this.element, ev.bladeController.view.element, ev.index);
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    removeElement(ev.bladeController.view.element);
  }
}
function createBlade() {
  return new ValueMap7({
    positions: createValue([], {
      equals: deepEqualsArray,
    }),
  });
}
class Foldable7 extends ValueMap7 {
  constructor(valueMap) {
    super(valueMap);
  }
  static create(expanded) {
    const coreObj = {
      completed: true,
      expanded,
      expandedHeight: null,
      shouldFixHeight: false,
      temporaryExpanded: null,
    };
    const core = ValueMap7.createCore(coreObj);
    return new Foldable7(core);
  }
  get styleExpanded() {
    var _a;
    return (_a = this.get("temporaryExpanded")) !== null && _a !== void 0
      ? _a
      : this.get("expanded");
  }
  get styleHeight() {
    if (!this.styleExpanded) {
      return "0";
    }
    const exHeight = this.get("expandedHeight");
    if (this.get("shouldFixHeight") && !isEmpty(exHeight)) {
      return `${exHeight}px`;
    }
    return "auto";
  }
  bindExpandedClass(elem, expandedClassName) {
    const onExpand = () => {
      const expanded = this.styleExpanded;
      if (expanded) {
        elem.classList.add(expandedClassName);
      } else {
        elem.classList.remove(expandedClassName);
      }
    };
    bindValueMap(this, "expanded", onExpand);
    bindValueMap(this, "temporaryExpanded", onExpand);
  }
  cleanUpTransition() {
    this.set("shouldFixHeight", false);
    this.set("expandedHeight", null);
    this.set("completed", true);
  }
}
function computeExpandedFolderHeight(folder, containerElement) {
  let height = 0;
  disableTransitionTemporarily(containerElement, () => {
    folder.set("expandedHeight", null);
    folder.set("temporaryExpanded", true);
    forceReflow(containerElement);
    height = containerElement.clientHeight;
    folder.set("temporaryExpanded", null);
    forceReflow(containerElement);
  });
  return height;
}
function applyHeight(foldable, elem) {
  elem.style.height = foldable.styleHeight;
}
function bindFoldable(foldable, elem) {
  foldable.value("expanded").emitter.on("beforechange", () => {
    foldable.set("completed", false);
    if (isEmpty(foldable.get("expandedHeight"))) {
      const h = computeExpandedFolderHeight(foldable, elem);
      if (h > 0) {
        foldable.set("expandedHeight", h);
      }
    }
    foldable.set("shouldFixHeight", true);
    forceReflow(elem);
  });
  foldable.emitter.on("change", () => {
    applyHeight(foldable, elem);
  });
  applyHeight(foldable, elem);
  elem.addEventListener("transitionend", (ev) => {
    if (ev.propertyName !== "height") {
      return;
    }
    foldable.cleanUpTransition();
  });
}
class FolderApi7 extends ContainerBladeApi7 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter7();
    this.controller.foldable.value("expanded").emitter.on("change", (ev) => {
      this.emitter_.emit("fold", new TpFoldEvent7(this, ev.sender.rawValue));
    });
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
  }
  get expanded() {
    return this.controller.foldable.get("expanded");
  }
  set expanded(expanded) {
    this.controller.foldable.set("expanded", expanded);
  }
  get title() {
    return this.controller.props.get("title");
  }
  set title(title) {
    this.controller.props.set("title", title);
  }
  get children() {
    return this.rackApi_.children;
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    return this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
}
const bladeContainerClassName = ClassName("cnt");
class FolderView7 {
  constructor(doc, config) {
    var _a;
    this.className_ = ClassName(
      (_a = config.viewName) !== null && _a !== void 0 ? _a : "fld",
    );
    this.element = doc.createElement("div");
    this.element.classList.add(this.className_(), bladeContainerClassName());
    config.viewProps.bindClassModifiers(this.element);
    this.foldable_ = config.foldable;
    this.foldable_.bindExpandedClass(
      this.element,
      this.className_(void 0, "expanded"),
    );
    bindValueMap(
      this.foldable_,
      "completed",
      valueToClassName(this.element, this.className_(void 0, "cpl")),
    );
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(this.className_("b"));
    bindValueMap(config.props, "title", (title) => {
      if (isEmpty(title)) {
        this.element.classList.add(this.className_(void 0, "not"));
      } else {
        this.element.classList.remove(this.className_(void 0, "not"));
      }
    });
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(this.className_("i"));
    this.element.appendChild(indentElem);
    const titleElem = doc.createElement("div");
    titleElem.classList.add(this.className_("t"));
    bindValueToTextContent(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(this.className_("m"));
    this.buttonElement.appendChild(markElem);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(this.className_("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
}
class FolderController7 extends ContainerBladeController7 {
  constructor(doc, config) {
    var _a;
    const foldable = Foldable7.create(
      (_a = config.expanded) !== null && _a !== void 0 ? _a : true,
    );
    const view = new FolderView7(doc, {
      foldable,
      props: config.props,
      viewName: config.root ? "rot" : void 0,
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController7({
          blade: config.blade,
          element: view.containerElement,
          root: config.root,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onTitleClick_ = this.onTitleClick_.bind(this);
    this.props = config.props;
    this.foldable = foldable;
    bindFoldable(this.foldable, this.view.containerElement);
    this.rackController.rack.emitter.on("add", () => {
      this.foldable.cleanUpTransition();
    });
    this.rackController.rack.emitter.on("remove", () => {
      this.foldable.cleanUpTransition();
    });
    this.view.buttonElement.addEventListener("click", this.onTitleClick_);
  }
  get document() {
    return this.view.element.ownerDocument;
  }
  importState(state) {
    return importBladeState(
      state,
      (s) => super.importState(s),
      (p) => ({
        expanded: p.required.boolean,
        title: p.optional.string,
      }),
      (result) => {
        this.foldable.set("expanded", result.expanded);
        this.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState(() => super.exportState(), {
      expanded: this.foldable.get("expanded"),
      title: this.props.get("title"),
    });
  }
  onTitleClick_() {
    this.foldable.set("expanded", !this.foldable.get("expanded"));
  }
}
createPlugin({
  id: "folder",
  type: "blade",
  accept(params) {
    const result = parseRecord(params, (p) => ({
      title: p.required.string,
      view: p.required.constant("folder"),
      expanded: p.optional.boolean,
    }));
    return result ? { params: result } : null;
  },
  controller(args) {
    return new FolderController7(args.document, {
      blade: args.blade,
      expanded: args.params.expanded,
      props: ValueMap7.fromObject({
        title: args.params.title,
      }),
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (!(args.controller instanceof FolderController7)) {
      return null;
    }
    return new FolderApi7(args.controller, args.pool);
  },
});
const cn$n = ClassName("");
function valueToModifier(elem, modifier) {
  return valueToClassName(elem, cn$n(void 0, modifier));
}
class ViewProps7 extends ValueMap7 {
  constructor(valueMap) {
    var _a;
    super(valueMap);
    this.onDisabledChange_ = this.onDisabledChange_.bind(this);
    this.onParentChange_ = this.onParentChange_.bind(this);
    this.onParentGlobalDisabledChange_ =
      this.onParentGlobalDisabledChange_.bind(this);
    [this.globalDisabled_, this.setGlobalDisabled_] = createReadonlyValue(
      createValue(this.getGlobalDisabled_()),
    );
    this.value("disabled").emitter.on("change", this.onDisabledChange_);
    this.value("parent").emitter.on("change", this.onParentChange_);
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
  }
  static create(opt_initialValue) {
    var _a, _b, _c;
    const initialValue =
      opt_initialValue !== null && opt_initialValue !== void 0
        ? opt_initialValue
        : {};
    return new ViewProps7(
      ValueMap7.createCore({
        disabled:
          (_a = initialValue.disabled) !== null && _a !== void 0 ? _a : false,
        disposed: false,
        hidden:
          (_b = initialValue.hidden) !== null && _b !== void 0 ? _b : false,
        parent:
          (_c = initialValue.parent) !== null && _c !== void 0 ? _c : null,
      }),
    );
  }
  get globalDisabled() {
    return this.globalDisabled_;
  }
  bindClassModifiers(elem) {
    bindValue(this.globalDisabled_, valueToModifier(elem, "disabled"));
    bindValueMap(this, "hidden", valueToModifier(elem, "hidden"));
  }
  bindDisabled(target) {
    bindValue(this.globalDisabled_, (disabled) => {
      target.disabled = disabled;
    });
  }
  bindTabIndex(elem) {
    bindValue(this.globalDisabled_, (disabled) => {
      elem.tabIndex = disabled ? -1 : 0;
    });
  }
  handleDispose(callback) {
    this.value("disposed").emitter.on("change", (disposed) => {
      if (disposed) {
        callback();
      }
    });
  }
  importState(state) {
    this.set("disabled", state.disabled);
    this.set("hidden", state.hidden);
  }
  exportState() {
    return {
      disabled: this.get("disabled"),
      hidden: this.get("hidden"),
    };
  }
  getGlobalDisabled_() {
    const parent = this.get("parent");
    const parentDisabled = parent ? parent.globalDisabled.rawValue : false;
    return parentDisabled || this.get("disabled");
  }
  updateGlobalDisabled_() {
    this.setGlobalDisabled_(this.getGlobalDisabled_());
  }
  onDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentGlobalDisabledChange_() {
    this.updateGlobalDisabled_();
  }
  onParentChange_(ev) {
    var _a;
    const prevParent = ev.previousRawValue;
    prevParent === null || prevParent === void 0
      ? void 0
      : prevParent.globalDisabled.emitter.off(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    (_a = this.get("parent")) === null || _a === void 0
      ? void 0
      : _a.globalDisabled.emitter.on(
          "change",
          this.onParentGlobalDisabledChange_,
        );
    this.updateGlobalDisabled_();
  }
}
const cn$m = ClassName("tbp");
class TabPageView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$m());
    config.viewProps.bindClassModifiers(this.element);
    const containerElem = doc.createElement("div");
    containerElem.classList.add(cn$m("c"));
    this.element.appendChild(containerElem);
    this.containerElement = containerElem;
  }
}
const cn$l = ClassName("tbi");
class TabItemView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$l());
    config.viewProps.bindClassModifiers(this.element);
    bindValueMap(config.props, "selected", (selected) => {
      if (selected) {
        this.element.classList.add(cn$l(void 0, "sel"));
      } else {
        this.element.classList.remove(cn$l(void 0, "sel"));
      }
    });
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$l("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$l("t"));
    bindValueToTextContent(config.props.value("title"), titleElem);
    this.buttonElement.appendChild(titleElem);
    this.titleElement = titleElem;
  }
}
class TabItemController7 {
  constructor(doc, config) {
    this.emitter = new Emitter7();
    this.onClick_ = this.onClick_.bind(this);
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.view = new TabItemView7(doc, {
      props: config.props,
      viewProps: config.viewProps,
    });
    this.view.buttonElement.addEventListener("click", this.onClick_);
  }
  onClick_() {
    this.emitter.emit("click", {
      sender: this,
    });
  }
}
class TabPageController7 extends ContainerBladeController7 {
  constructor(doc, config) {
    const view = new TabPageView7(doc, {
      viewProps: config.viewProps,
    });
    super(
      Object.assign(Object.assign({}, config), {
        rackController: new RackController7({
          blade: config.blade,
          element: view.containerElement,
          viewProps: config.viewProps,
        }),
        view,
      }),
    );
    this.onItemClick_ = this.onItemClick_.bind(this);
    this.ic_ = new TabItemController7(doc, {
      props: config.itemProps,
      viewProps: ViewProps7.create(),
    });
    this.ic_.emitter.on("click", this.onItemClick_);
    this.props = config.props;
    bindValueMap(this.props, "selected", (selected) => {
      this.itemController.props.set("selected", selected);
      this.viewProps.set("hidden", !selected);
    });
  }
  get itemController() {
    return this.ic_;
  }
  importState(state) {
    return importBladeState(
      state,
      (s) => super.importState(s),
      (p) => ({
        selected: p.required.boolean,
        title: p.required.string,
      }),
      (result) => {
        this.ic_.props.set("selected", result.selected);
        this.ic_.props.set("title", result.title);
        return true;
      },
    );
  }
  exportState() {
    return exportBladeState(() => super.exportState(), {
      selected: this.ic_.props.get("selected"),
      title: this.ic_.props.get("title"),
    });
  }
  onItemClick_() {
    this.props.set("selected", true);
  }
}
class TabApi7 extends ContainerBladeApi7 {
  constructor(controller, pool) {
    super(controller, pool);
    this.emitter_ = new Emitter7();
    this.onSelect_ = this.onSelect_.bind(this);
    this.pool_ = pool;
    this.rackApi_.on("change", (ev) => {
      this.emitter_.emit("change", ev);
    });
    this.controller.tab.selectedIndex.emitter.on("change", this.onSelect_);
  }
  get pages() {
    return this.rackApi_.children;
  }
  addPage(params) {
    const doc = this.controller.view.element.ownerDocument;
    const pc = new TabPageController7(doc, {
      blade: createBlade(),
      itemProps: ValueMap7.fromObject({
        selected: false,
        title: params.title,
      }),
      props: ValueMap7.fromObject({
        selected: false,
      }),
      viewProps: ViewProps7.create(),
    });
    const papi = this.pool_.createApi(pc);
    return this.rackApi_.add(papi, params.index);
  }
  removePage(index) {
    this.rackApi_.remove(this.rackApi_.children[index]);
  }
  on(eventName, handler) {
    const bh = handler.bind(this);
    this.emitter_.on(eventName, (ev) => {
      bh(ev);
    });
    return this;
  }
  onSelect_(ev) {
    this.emitter_.emit("select", new TpTabSelectEvent7(this, ev.rawValue));
  }
}
class TabPageApi7 extends ContainerBladeApi7 {
  get title() {
    var _a;
    return (_a = this.controller.itemController.props.get("title")) !== null &&
      _a !== void 0
      ? _a
      : "";
  }
  set title(title) {
    this.controller.itemController.props.set("title", title);
  }
  get selected() {
    return this.controller.props.get("selected");
  }
  set selected(selected) {
    this.controller.props.set("selected", selected);
  }
  get children() {
    return this.rackApi_.children;
  }
  addButton(params) {
    return this.rackApi_.addButton(params);
  }
  addFolder(params) {
    return this.rackApi_.addFolder(params);
  }
  addTab(params) {
    return this.rackApi_.addTab(params);
  }
  add(api, opt_index) {
    this.rackApi_.add(api, opt_index);
  }
  remove(api) {
    this.rackApi_.remove(api);
  }
  addBinding(object, key2, opt_params) {
    return this.rackApi_.addBinding(object, key2, opt_params);
  }
  addBlade(params) {
    return this.rackApi_.addBlade(params);
  }
}
const INDEX_NOT_SELECTED = -1;
class Tab7 {
  constructor() {
    this.onItemSelectedChange_ = this.onItemSelectedChange_.bind(this);
    this.empty = createValue(true);
    this.selectedIndex = createValue(INDEX_NOT_SELECTED);
    this.items_ = [];
  }
  add(item, opt_index) {
    const index =
      opt_index !== null && opt_index !== void 0
        ? opt_index
        : this.items_.length;
    this.items_.splice(index, 0, item);
    item.emitter.on("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  remove(item) {
    const index = this.items_.indexOf(item);
    if (index < 0) {
      return;
    }
    this.items_.splice(index, 1);
    item.emitter.off("change", this.onItemSelectedChange_);
    this.keepSelection_();
  }
  keepSelection_() {
    if (this.items_.length === 0) {
      this.selectedIndex.rawValue = INDEX_NOT_SELECTED;
      this.empty.rawValue = true;
      return;
    }
    const firstSelIndex = this.items_.findIndex((s) => s.rawValue);
    if (firstSelIndex < 0) {
      this.items_.forEach((s, i) => {
        s.rawValue = i === 0;
      });
      this.selectedIndex.rawValue = 0;
    } else {
      this.items_.forEach((s, i) => {
        s.rawValue = i === firstSelIndex;
      });
      this.selectedIndex.rawValue = firstSelIndex;
    }
    this.empty.rawValue = false;
  }
  onItemSelectedChange_(ev) {
    if (ev.rawValue) {
      const index = this.items_.findIndex((s) => s === ev.sender);
      this.items_.forEach((s, i) => {
        s.rawValue = i === index;
      });
      this.selectedIndex.rawValue = index;
    } else {
      this.keepSelection_();
    }
  }
}
const cn$k = ClassName("tab");
class TabView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$k(), bladeContainerClassName());
    config.viewProps.bindClassModifiers(this.element);
    bindValue(
      config.empty,
      valueToClassName(this.element, cn$k(void 0, "nop")),
    );
    const titleElem = doc.createElement("div");
    titleElem.classList.add(cn$k("t"));
    this.element.appendChild(titleElem);
    this.itemsElement = titleElem;
    const indentElem = doc.createElement("div");
    indentElem.classList.add(cn$k("i"));
    this.element.appendChild(indentElem);
    const contentsElem = doc.createElement("div");
    contentsElem.classList.add(cn$k("c"));
    this.element.appendChild(contentsElem);
    this.contentsElement = contentsElem;
  }
}
class TabController7 extends ContainerBladeController7 {
  constructor(doc, config) {
    const tab = new Tab7();
    const view = new TabView7(doc, {
      empty: tab.empty,
      viewProps: config.viewProps,
    });
    super({
      blade: config.blade,
      rackController: new RackController7({
        blade: config.blade,
        element: view.contentsElement,
        viewProps: config.viewProps,
      }),
      view,
    });
    this.onRackAdd_ = this.onRackAdd_.bind(this);
    this.onRackRemove_ = this.onRackRemove_.bind(this);
    const rack = this.rackController.rack;
    rack.emitter.on("add", this.onRackAdd_);
    rack.emitter.on("remove", this.onRackRemove_);
    this.tab = tab;
  }
  add(pc, opt_index) {
    this.rackController.rack.add(pc, opt_index);
  }
  remove(index) {
    this.rackController.rack.remove(this.rackController.rack.children[index]);
  }
  onRackAdd_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    insertElementAt(
      this.view.itemsElement,
      pc.itemController.view.element,
      ev.index,
    );
    pc.itemController.viewProps.set("parent", this.viewProps);
    this.tab.add(pc.props.value("selected"));
  }
  onRackRemove_(ev) {
    if (!ev.root) {
      return;
    }
    const pc = ev.bladeController;
    removeElement(pc.itemController.view.element);
    pc.itemController.viewProps.set("parent", null);
    this.tab.remove(pc.props.value("selected"));
  }
}
createPlugin({
  id: "tab",
  type: "blade",
  accept(params) {
    const result = parseRecord(params, (p) => ({
      pages: p.required.array(p.required.object({ title: p.required.string })),
      view: p.required.constant("tab"),
    }));
    if (!result || result.pages.length === 0) {
      return null;
    }
    return { params: result };
  },
  controller(args) {
    const c = new TabController7(args.document, {
      blade: args.blade,
      viewProps: args.viewProps,
    });
    args.params.pages.forEach((p) => {
      const pc = new TabPageController7(args.document, {
        blade: createBlade(),
        itemProps: ValueMap7.fromObject({
          selected: false,
          title: p.title,
        }),
        props: ValueMap7.fromObject({
          selected: false,
        }),
        viewProps: ViewProps7.create(),
      });
      c.add(pc);
    });
    return c;
  },
  api(args) {
    if (args.controller instanceof TabController7) {
      return new TabApi7(args.controller, args.pool);
    }
    if (args.controller instanceof TabPageController7) {
      return new TabPageApi7(args.controller, args.pool);
    }
    return null;
  },
});
class ListInputBindingApi7 extends BindingApi7 {
  get options() {
    return this.controller.valueController.props.get("options");
  }
  set options(options) {
    this.controller.valueController.props.set("options", options);
  }
}
class CompositeConstraint7 {
  constructor(constraints) {
    this.constraints = constraints;
  }
  constrain(value) {
    return this.constraints.reduce((result, c) => {
      return c.constrain(result);
    }, value);
  }
}
function findConstraint(c, constraintClass) {
  if (c instanceof constraintClass) {
    return c;
  }
  if (c instanceof CompositeConstraint7) {
    const result = c.constraints.reduce((tmpResult, sc) => {
      if (tmpResult) {
        return tmpResult;
      }
      return sc instanceof constraintClass ? sc : null;
    }, null);
    if (result) {
      return result;
    }
  }
  return null;
}
class ListConstraint7 {
  constructor(options) {
    this.values = ValueMap7.fromObject({
      options,
    });
  }
  constrain(value) {
    const opts = this.values.get("options");
    if (opts.length === 0) {
      return value;
    }
    const matched =
      opts.filter((item) => {
        return item.value === value;
      }).length > 0;
    return matched ? value : opts[0].value;
  }
}
function parseListOptions(value) {
  var _a;
  const p = MicroParsers;
  if (Array.isArray(value)) {
    return (_a = parseRecord({ items: value }, (p2) => ({
      items: p2.required.array(
        p2.required.object({
          text: p2.required.string,
          value: p2.required.raw,
        }),
      ),
    }))) === null || _a === void 0
      ? void 0
      : _a.items;
  }
  if (typeof value === "object") {
    return p.required.raw(value).value;
  }
  return void 0;
}
function normalizeListOptions(options) {
  if (Array.isArray(options)) {
    return options;
  }
  const items = [];
  Object.keys(options).forEach((text) => {
    items.push({ text, value: options[text] });
  });
  return items;
}
function createListConstraint(options) {
  return !isEmpty(options)
    ? new ListConstraint7(normalizeListOptions(forceCast(options)))
    : null;
}
const cn$j = ClassName("lst");
class ListView7 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$j());
    config.viewProps.bindClassModifiers(this.element);
    const selectElem = doc.createElement("select");
    selectElem.classList.add(cn$j("s"));
    config.viewProps.bindDisabled(selectElem);
    this.element.appendChild(selectElem);
    this.selectElement = selectElem;
    const markElem = doc.createElement("div");
    markElem.classList.add(cn$j("m"));
    markElem.appendChild(createSvgIconElement(doc, "dropdown"));
    this.element.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value_ = config.value;
    bindValueMap(this.props_, "options", (opts) => {
      removeChildElements(this.selectElement);
      opts.forEach((item) => {
        const optionElem = doc.createElement("option");
        optionElem.textContent = item.text;
        this.selectElement.appendChild(optionElem);
      });
      this.update_();
    });
  }
  update_() {
    const values = this.props_.get("options").map((o) => o.value);
    this.selectElement.selectedIndex = values.indexOf(this.value_.rawValue);
  }
  onValueChange_() {
    this.update_();
  }
}
class ListController7 {
  constructor(doc, config) {
    this.onSelectChange_ = this.onSelectChange_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ListView7(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.selectElement.addEventListener("change", this.onSelectChange_);
  }
  onSelectChange_(e) {
    const selectElem = forceCast(e.currentTarget);
    this.value.rawValue =
      this.props.get("options")[selectElem.selectedIndex].value;
  }
  importProps(state) {
    return importBladeState(
      state,
      null,
      (p) => ({
        options: p.required.custom(parseListOptions),
      }),
      (result) => {
        this.props.set("options", normalizeListOptions(result.options));
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState(null, {
      options: this.props.get("options"),
    });
  }
}
const cn$i = ClassName("pop");
class PopupView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$i());
    config.viewProps.bindClassModifiers(this.element);
    bindValue(config.shows, valueToClassName(this.element, cn$i(void 0, "v")));
  }
}
class PopupController7 {
  constructor(doc, config) {
    this.shows = createValue(false);
    this.viewProps = config.viewProps;
    this.view = new PopupView7(doc, {
      shows: this.shows,
      viewProps: this.viewProps,
    });
  }
}
const cn$h = ClassName("txt");
class TextView7 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$h());
    config.viewProps.bindClassModifiers(this.element);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$h("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onChange_);
    this.value_ = config.value;
    this.refresh();
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value_.rawValue);
  }
  onChange_() {
    this.refresh();
  }
}
class TextController7 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new TextView7(doc, {
      props: config.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty(parsedValue)) {
      this.value.rawValue = parsedValue;
    }
    this.view.refresh();
  }
}
function boolToString(value) {
  return String(value);
}
function boolFromUnknown(value) {
  if (value === "false") {
    return false;
  }
  return !!value;
}
function BooleanFormatter(value) {
  return boolToString(value);
}
function composeParsers(parsers) {
  return (text) => {
    return parsers.reduce((result, parser) => {
      if (result !== null) {
        return result;
      }
      return parser(text);
    }, null);
  };
}
const innerFormatter = createNumberFormatter(0);
function formatPercentage(value) {
  return innerFormatter(value) + "%";
}
function stringFromUnknown(value) {
  return String(value);
}
function formatString(value) {
  return value;
}
function connectValues({ primary, secondary, forward, backward }) {
  let changing = false;
  function preventFeedback(callback) {
    if (changing) {
      return;
    }
    changing = true;
    callback();
    changing = false;
  }
  primary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  secondary.emitter.on("change", (ev) => {
    preventFeedback(() => {
      primary.setRawValue(
        backward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
    preventFeedback(() => {
      secondary.setRawValue(
        forward(primary.rawValue, secondary.rawValue),
        ev.options,
      );
    });
  });
  preventFeedback(() => {
    secondary.setRawValue(forward(primary.rawValue, secondary.rawValue), {
      forceEmit: false,
      last: true,
    });
  });
}
function getStepForKey(keyScale, keys) {
  const step = keyScale * (keys.altKey ? 0.1 : 1) * (keys.shiftKey ? 10 : 1);
  if (keys.upKey) {
    return +step;
  } else if (keys.downKey) {
    return -step;
  }
  return 0;
}
function getVerticalStepKeys(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowDown",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowUp",
  };
}
function getHorizontalStepKeys(ev) {
  return {
    altKey: ev.altKey,
    downKey: ev.key === "ArrowLeft",
    shiftKey: ev.shiftKey,
    upKey: ev.key === "ArrowRight",
  };
}
function isVerticalArrowKey(key2) {
  return key2 === "ArrowUp" || key2 === "ArrowDown";
}
function isArrowKey(key2) {
  return (
    isVerticalArrowKey(key2) || key2 === "ArrowLeft" || key2 === "ArrowRight"
  );
}
function computeOffset$1(ev, elem) {
  var _a, _b;
  const win = elem.ownerDocument.defaultView;
  const rect = elem.getBoundingClientRect();
  return {
    x:
      ev.pageX -
      (((_a = win && win.scrollX) !== null && _a !== void 0 ? _a : 0) +
        rect.left),
    y:
      ev.pageY -
      (((_b = win && win.scrollY) !== null && _b !== void 0 ? _b : 0) +
        rect.top),
  };
}
class PointerHandler7 {
  constructor(element) {
    this.lastTouch_ = null;
    this.onDocumentMouseMove_ = this.onDocumentMouseMove_.bind(this);
    this.onDocumentMouseUp_ = this.onDocumentMouseUp_.bind(this);
    this.onMouseDown_ = this.onMouseDown_.bind(this);
    this.onTouchEnd_ = this.onTouchEnd_.bind(this);
    this.onTouchMove_ = this.onTouchMove_.bind(this);
    this.onTouchStart_ = this.onTouchStart_.bind(this);
    this.elem_ = element;
    this.emitter = new Emitter7();
    element.addEventListener("touchstart", this.onTouchStart_, {
      passive: false,
    });
    element.addEventListener("touchmove", this.onTouchMove_, {
      passive: true,
    });
    element.addEventListener("touchend", this.onTouchEnd_);
    element.addEventListener("mousedown", this.onMouseDown_);
  }
  computePosition_(offset) {
    const rect = this.elem_.getBoundingClientRect();
    return {
      bounds: {
        width: rect.width,
        height: rect.height,
      },
      point: offset
        ? {
            x: offset.x,
            y: offset.y,
          }
        : null,
    };
  }
  onMouseDown_(ev) {
    var _a;
    ev.preventDefault();
    (_a = ev.currentTarget) === null || _a === void 0 ? void 0 : _a.focus();
    const doc = this.elem_.ownerDocument;
    doc.addEventListener("mousemove", this.onDocumentMouseMove_);
    doc.addEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseMove_(ev) {
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onDocumentMouseUp_(ev) {
    const doc = this.elem_.ownerDocument;
    doc.removeEventListener("mousemove", this.onDocumentMouseMove_);
    doc.removeEventListener("mouseup", this.onDocumentMouseUp_);
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(computeOffset$1(ev, this.elem_)),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
  onTouchStart_(ev) {
    ev.preventDefault();
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("down", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchMove_(ev) {
    const touch = ev.targetTouches.item(0);
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("move", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
    this.lastTouch_ = touch;
  }
  onTouchEnd_(ev) {
    var _a;
    const touch =
      (_a = ev.targetTouches.item(0)) !== null && _a !== void 0
        ? _a
        : this.lastTouch_;
    const rect = this.elem_.getBoundingClientRect();
    this.emitter.emit("up", {
      altKey: ev.altKey,
      data: this.computePosition_(
        touch
          ? {
              x: touch.clientX - rect.left,
              y: touch.clientY - rect.top,
            }
          : void 0,
      ),
      sender: this,
      shiftKey: ev.shiftKey,
    });
  }
}
const cn$g = ClassName("txt");
class NumberTextView7 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$g(), cn$g(void 0, "num"));
    if (config.arrayPosition) {
      this.element.classList.add(cn$g(void 0, config.arrayPosition));
    }
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$g("i"));
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    this.onDraggingChange_ = this.onDraggingChange_.bind(this);
    this.dragging_ = config.dragging;
    this.dragging_.emitter.on("change", this.onDraggingChange_);
    this.element.classList.add(cn$g());
    this.inputElement.classList.add(cn$g("i"));
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$g("k"));
    this.element.appendChild(knobElem);
    this.knobElement = knobElem;
    const guideElem = doc.createElementNS(SVG_NS, "svg");
    guideElem.classList.add(cn$g("g"));
    this.knobElement.appendChild(guideElem);
    const bodyElem = doc.createElementNS(SVG_NS, "path");
    bodyElem.classList.add(cn$g("gb"));
    guideElem.appendChild(bodyElem);
    this.guideBodyElem_ = bodyElem;
    const headElem = doc.createElementNS(SVG_NS, "path");
    headElem.classList.add(cn$g("gh"));
    guideElem.appendChild(headElem);
    this.guideHeadElem_ = headElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(ClassName("tt")());
    this.knobElement.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.refresh();
  }
  onDraggingChange_(ev) {
    if (ev.rawValue === null) {
      this.element.classList.remove(cn$g(void 0, "drg"));
      return;
    }
    this.element.classList.add(cn$g(void 0, "drg"));
    const x = ev.rawValue / this.props_.get("pointerScale");
    const aox = x + (x > 0 ? -1 : x < 0 ? 1 : 0);
    const adx = constrainRange(-aox, -4, 4);
    this.guideHeadElem_.setAttributeNS(
      null,
      "d",
      [`M ${aox + adx},0 L${aox},4 L${aox + adx},8`, `M ${x},-1 L${x},9`].join(
        " ",
      ),
    );
    this.guideBodyElem_.setAttributeNS(null, "d", `M 0,4 L${x},4`);
    const formatter = this.props_.get("formatter");
    this.tooltipElem_.textContent = formatter(this.value.rawValue);
    this.tooltipElem_.style.left = `${x}px`;
  }
  refresh() {
    const formatter = this.props_.get("formatter");
    this.inputElement.value = formatter(this.value.rawValue);
  }
  onChange_() {
    this.refresh();
  }
}
class NumberTextController7 {
  constructor(doc, config) {
    var _a;
    this.originRawValue_ = 0;
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.onInputKeyDown_ = this.onInputKeyDown_.bind(this);
    this.onInputKeyUp_ = this.onInputKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.parser_ = config.parser;
    this.props = config.props;
    this.sliderProps_ =
      (_a = config.sliderProps) !== null && _a !== void 0 ? _a : null;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.dragging_ = createValue(null);
    this.view = new NumberTextView7(doc, {
      arrayPosition: config.arrayPosition,
      dragging: this.dragging_,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
    this.view.inputElement.addEventListener("keydown", this.onInputKeyDown_);
    this.view.inputElement.addEventListener("keyup", this.onInputKeyUp_);
    const ph = new PointerHandler7(this.view.knobElement);
    ph.emitter.on("down", this.onPointerDown_);
    ph.emitter.on("move", this.onPointerMove_);
    ph.emitter.on("up", this.onPointerUp_);
  }
  constrainValue_(value) {
    var _a, _b;
    const min =
      (_a = this.sliderProps_) === null || _a === void 0
        ? void 0
        : _a.get("min");
    const max =
      (_b = this.sliderProps_) === null || _b === void 0
        ? void 0
        : _b.get("max");
    let v = value;
    if (min !== void 0) {
      v = Math.max(v, min);
    }
    if (max !== void 0) {
      v = Math.min(v, max);
    }
    return v;
  }
  onInputChange_(e) {
    const inputElem = forceCast(e.currentTarget);
    const value = inputElem.value;
    const parsedValue = this.parser_(value);
    if (!isEmpty(parsedValue)) {
      this.value.rawValue = this.constrainValue_(parsedValue);
    }
    this.view.refresh();
  }
  onInputKeyDown_(ev) {
    const step = getStepForKey(
      this.props.get("keyScale"),
      getVerticalStepKeys(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.constrainValue_(this.value.rawValue + step), {
      forceEmit: false,
      last: false,
    });
  }
  onInputKeyUp_(ev) {
    const step = getStepForKey(
      this.props.get("keyScale"),
      getVerticalStepKeys(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
  onPointerDown_() {
    this.originRawValue_ = this.value.rawValue;
    this.dragging_.rawValue = 0;
  }
  computeDraggingValue_(data) {
    if (!data.point) {
      return null;
    }
    const dx = data.point.x - data.bounds.width / 2;
    return this.constrainValue_(
      this.originRawValue_ + dx * this.props.get("pointerScale"),
    );
  }
  onPointerMove_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: false,
      last: false,
    });
    this.dragging_.rawValue = this.value.rawValue - this.originRawValue_;
  }
  onPointerUp_(ev) {
    const v = this.computeDraggingValue_(ev.data);
    if (v === null) {
      return;
    }
    this.value.setRawValue(v, {
      forceEmit: true,
      last: true,
    });
    this.dragging_.rawValue = null;
  }
}
const cn$f = ClassName("sld");
class SliderView7 {
  constructor(doc, config) {
    this.onChange_ = this.onChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$f());
    config.viewProps.bindClassModifiers(this.element);
    const trackElem = doc.createElement("div");
    trackElem.classList.add(cn$f("t"));
    config.viewProps.bindTabIndex(trackElem);
    this.element.appendChild(trackElem);
    this.trackElement = trackElem;
    const knobElem = doc.createElement("div");
    knobElem.classList.add(cn$f("k"));
    this.trackElement.appendChild(knobElem);
    this.knobElement = knobElem;
    config.value.emitter.on("change", this.onChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const p = constrainRange(
      mapRange(
        this.value.rawValue,
        this.props_.get("min"),
        this.props_.get("max"),
        0,
        100,
      ),
      0,
      100,
    );
    this.knobElement.style.width = `${p}%`;
  }
  onChange_() {
    this.update_();
  }
}
class SliderController7 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDownOrMove_ = this.onPointerDownOrMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.props = config.props;
    this.view = new SliderView7(doc, {
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler7(this.view.trackElement);
    this.ptHandler_.emitter.on("down", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("move", this.onPointerDownOrMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.trackElement.addEventListener("keydown", this.onKeyDown_);
    this.view.trackElement.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    this.value.setRawValue(
      mapRange(
        constrainRange(d.point.x, 0, d.bounds.width),
        0,
        d.bounds.width,
        this.props.get("min"),
        this.props.get("max"),
      ),
      opts,
    );
  }
  onPointerDownOrMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey(
      this.props.get("keyScale"),
      getHorizontalStepKeys(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue + step, {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey(
      this.props.get("keyScale"),
      getHorizontalStepKeys(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
}
const cn$e = ClassName("sldtxt");
class SliderTextView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$e());
    const sliderElem = doc.createElement("div");
    sliderElem.classList.add(cn$e("s"));
    this.sliderView_ = config.sliderView;
    sliderElem.appendChild(this.sliderView_.element);
    this.element.appendChild(sliderElem);
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$e("t"));
    this.textView_ = config.textView;
    textElem.appendChild(this.textView_.element);
    this.element.appendChild(textElem);
  }
}
class SliderTextController7 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.sliderC_ = new SliderController7(doc, {
      props: config.sliderProps,
      value: config.value,
      viewProps: this.viewProps,
    });
    this.textC_ = new NumberTextController7(doc, {
      parser: config.parser,
      props: config.textProps,
      sliderProps: config.sliderProps,
      value: config.value,
      viewProps: config.viewProps,
    });
    this.view = new SliderTextView7(doc, {
      sliderView: this.sliderC_.view,
      textView: this.textC_.view,
    });
  }
  get sliderController() {
    return this.sliderC_;
  }
  get textController() {
    return this.textC_;
  }
  importProps(state) {
    return importBladeState(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        const sliderProps = this.sliderC_.props;
        sliderProps.set("max", result.max);
        sliderProps.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    const sliderProps = this.sliderC_.props;
    return exportBladeState(null, {
      max: sliderProps.get("max"),
      min: sliderProps.get("min"),
    });
  }
}
function createSliderTextProps(config) {
  return {
    sliderProps: new ValueMap7({
      keyScale: config.keyScale,
      max: config.max,
      min: config.min,
    }),
    textProps: new ValueMap7({
      formatter: createValue(config.formatter),
      keyScale: config.keyScale,
      pointerScale: createValue(config.pointerScale),
    }),
  };
}
const CSS_VAR_MAP = {
  containerUnitSize: "cnt-usz",
};
function getCssVar(key2) {
  return `--${CSS_VAR_MAP[key2]}`;
}
function createPointDimensionParser(p) {
  return createNumberTextInputParamsParser(p);
}
function parsePointDimensionParams(value) {
  if (!isRecord(value)) {
    return void 0;
  }
  return parseRecord(value, createPointDimensionParser);
}
function createDimensionConstraint(params, initialValue) {
  if (!params) {
    return void 0;
  }
  const constraints = [];
  const cs = createStepConstraint(params, initialValue);
  if (cs) {
    constraints.push(cs);
  }
  const rs = createRangeConstraint(params);
  if (rs) {
    constraints.push(rs);
  }
  return new CompositeConstraint7(constraints);
}
function parsePickerLayout(value) {
  if (value === "inline" || value === "popup") {
    return value;
  }
  return void 0;
}
function writePrimitive(target, value) {
  target.write(value);
}
const cn$d = ClassName("ckb");
class CheckboxView7 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$d());
    config.viewProps.bindClassModifiers(this.element);
    const labelElem = doc.createElement("label");
    labelElem.classList.add(cn$d("l"));
    this.element.appendChild(labelElem);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$d("i"));
    inputElem.type = "checkbox";
    labelElem.appendChild(inputElem);
    this.inputElement = inputElem;
    config.viewProps.bindDisabled(this.inputElement);
    const wrapperElem = doc.createElement("div");
    wrapperElem.classList.add(cn$d("w"));
    labelElem.appendChild(wrapperElem);
    const markElem = createSvgIconElement(doc, "check");
    wrapperElem.appendChild(markElem);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    this.inputElement.checked = this.value.rawValue;
  }
  onValueChange_() {
    this.update_();
  }
}
class CheckboxController7 {
  constructor(doc, config) {
    this.onInputChange_ = this.onInputChange_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new CheckboxView7(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view.inputElement.addEventListener("change", this.onInputChange_);
  }
  onInputChange_(e) {
    const inputElem = forceCast(e.currentTarget);
    this.value.rawValue = inputElem.checked;
  }
}
function createConstraint$6(params) {
  const constraints = [];
  const lc = createListConstraint(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint7(constraints);
}
createPlugin({
  id: "input-bool",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      options: p.optional.custom(parseListOptions),
      readonly: p.optional.constant(false),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown,
    constraint: (args) => createConstraint$6(args.params),
    writer: (_args) => writePrimitive,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint(c, ListConstraint7);
    if (lc) {
      return new ListController7(doc, {
        props: new ValueMap7({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new CheckboxController7(doc, {
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "boolean") {
      return null;
    }
    if (args.controller.valueController instanceof ListController7) {
      return new ListInputBindingApi7(args.controller);
    }
    return null;
  },
});
const cn$c = ClassName("col");
class ColorView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$c());
    config.foldable.bindExpandedClass(this.element, cn$c(void 0, "expanded"));
    bindValueMap(
      config.foldable,
      "completed",
      valueToClassName(this.element, cn$c(void 0, "cpl")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$c("h"));
    this.element.appendChild(headElem);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$c("s"));
    headElem.appendChild(swatchElem);
    this.swatchElement = swatchElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$c("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$c("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
}
function rgbToHslInt(r, g, b) {
  const rp = constrainRange(r / 255, 0, 1);
  const gp = constrainRange(g / 255, 0, 1);
  const bp = constrainRange(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const c = cmax - cmin;
  let h = 0;
  let s = 0;
  const l = (cmin + cmax) / 2;
  if (c !== 0) {
    s = c / (1 - Math.abs(cmax + cmin - 1));
    if (rp === cmax) {
      h = (gp - bp) / c;
    } else if (gp === cmax) {
      h = 2 + (bp - rp) / c;
    } else {
      h = 4 + (rp - gp) / c;
    }
    h = h / 6 + (h < 0 ? 1 : 0);
  }
  return [h * 360, s * 100, l * 100];
}
function hslToRgbInt(h, s, l) {
  const hp = ((h % 360) + 360) % 360;
  const sp = constrainRange(s / 100, 0, 1);
  const lp = constrainRange(l / 100, 0, 1);
  const c = (1 - Math.abs(2 * lp - 1)) * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = lp - c / 2;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function rgbToHsvInt(r, g, b) {
  const rp = constrainRange(r / 255, 0, 1);
  const gp = constrainRange(g / 255, 0, 1);
  const bp = constrainRange(b / 255, 0, 1);
  const cmax = Math.max(rp, gp, bp);
  const cmin = Math.min(rp, gp, bp);
  const d = cmax - cmin;
  let h;
  if (d === 0) {
    h = 0;
  } else if (cmax === rp) {
    h = 60 * (((((gp - bp) / d) % 6) + 6) % 6);
  } else if (cmax === gp) {
    h = 60 * ((bp - rp) / d + 2);
  } else {
    h = 60 * ((rp - gp) / d + 4);
  }
  const s = cmax === 0 ? 0 : d / cmax;
  const v = cmax;
  return [h, s * 100, v * 100];
}
function hsvToRgbInt(h, s, v) {
  const hp = loopRange(h, 360);
  const sp = constrainRange(s / 100, 0, 1);
  const vp = constrainRange(v / 100, 0, 1);
  const c = vp * sp;
  const x = c * (1 - Math.abs(((hp / 60) % 2) - 1));
  const m = vp - c;
  let rp, gp, bp;
  if (hp >= 0 && hp < 60) {
    [rp, gp, bp] = [c, x, 0];
  } else if (hp >= 60 && hp < 120) {
    [rp, gp, bp] = [x, c, 0];
  } else if (hp >= 120 && hp < 180) {
    [rp, gp, bp] = [0, c, x];
  } else if (hp >= 180 && hp < 240) {
    [rp, gp, bp] = [0, x, c];
  } else if (hp >= 240 && hp < 300) {
    [rp, gp, bp] = [x, 0, c];
  } else {
    [rp, gp, bp] = [c, 0, x];
  }
  return [(rp + m) * 255, (gp + m) * 255, (bp + m) * 255];
}
function hslToHsvInt(h, s, l) {
  const sd = l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100);
  return [
    h,
    sd !== 0 ? (s * (100 - Math.abs(2 * l - 100))) / sd : 0,
    l + (s * (100 - Math.abs(2 * l - 100))) / (2 * 100),
  ];
}
function hsvToHslInt(h, s, v) {
  const sd = 100 - Math.abs((v * (200 - s)) / 100 - 100);
  return [h, sd !== 0 ? (s * v) / sd : 0, (v * (200 - s)) / (2 * 100)];
}
function removeAlphaComponent(comps) {
  return [comps[0], comps[1], comps[2]];
}
function appendAlphaComponent(comps, alpha) {
  return [comps[0], comps[1], comps[2], alpha];
}
const MODE_CONVERTER_MAP = {
  hsl: {
    hsl: (h, s, l) => [h, s, l],
    hsv: hslToHsvInt,
    rgb: hslToRgbInt,
  },
  hsv: {
    hsl: hsvToHslInt,
    hsv: (h, s, v) => [h, s, v],
    rgb: hsvToRgbInt,
  },
  rgb: {
    hsl: rgbToHslInt,
    hsv: rgbToHsvInt,
    rgb: (r, g, b) => [r, g, b],
  },
};
function getColorMaxComponents(mode, type) {
  return [
    type === "float" ? 1 : mode === "rgb" ? 255 : 360,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
    type === "float" ? 1 : mode === "rgb" ? 255 : 100,
  ];
}
function loopHueRange(hue, max) {
  return hue === max ? max : loopRange(hue, max);
}
function constrainColorComponents(components, mode, type) {
  var _a;
  const ms = getColorMaxComponents(mode, type);
  return [
    mode === "rgb"
      ? constrainRange(components[0], 0, ms[0])
      : loopHueRange(components[0], ms[0]),
    constrainRange(components[1], 0, ms[1]),
    constrainRange(components[2], 0, ms[2]),
    constrainRange(
      (_a = components[3]) !== null && _a !== void 0 ? _a : 1,
      0,
      1,
    ),
  ];
}
function convertColorType(comps, mode, from, to) {
  const fms = getColorMaxComponents(mode, from);
  const tms = getColorMaxComponents(mode, to);
  return comps.map((c, index) => (c / fms[index]) * tms[index]);
}
function convertColor(components, from, to) {
  const intComps = convertColorType(components, from.mode, from.type, "int");
  const result = MODE_CONVERTER_MAP[from.mode][to.mode](...intComps);
  return convertColorType(result, to.mode, "int", to.type);
}
class IntColor7 {
  static black() {
    return new IntColor7([0, 0, 0], "rgb");
  }
  constructor(comps, mode) {
    this.type = "int";
    this.mode = mode;
    this.comps_ = constrainColorComponents(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent(
      convertColor(
        removeAlphaComponent(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
}
const cn$b = ClassName("colp");
class ColorPickerView7 {
  constructor(doc, config) {
    this.alphaViews_ = null;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$b());
    config.viewProps.bindClassModifiers(this.element);
    const hsvElem = doc.createElement("div");
    hsvElem.classList.add(cn$b("hsv"));
    const svElem = doc.createElement("div");
    svElem.classList.add(cn$b("sv"));
    this.svPaletteView_ = config.svPaletteView;
    svElem.appendChild(this.svPaletteView_.element);
    hsvElem.appendChild(svElem);
    const hElem = doc.createElement("div");
    hElem.classList.add(cn$b("h"));
    this.hPaletteView_ = config.hPaletteView;
    hElem.appendChild(this.hPaletteView_.element);
    hsvElem.appendChild(hElem);
    this.element.appendChild(hsvElem);
    const rgbElem = doc.createElement("div");
    rgbElem.classList.add(cn$b("rgb"));
    this.textsView_ = config.textsView;
    rgbElem.appendChild(this.textsView_.element);
    this.element.appendChild(rgbElem);
    if (config.alphaViews) {
      this.alphaViews_ = {
        palette: config.alphaViews.palette,
        text: config.alphaViews.text,
      };
      const aElem = doc.createElement("div");
      aElem.classList.add(cn$b("a"));
      const apElem = doc.createElement("div");
      apElem.classList.add(cn$b("ap"));
      apElem.appendChild(this.alphaViews_.palette.element);
      aElem.appendChild(apElem);
      const atElem = doc.createElement("div");
      atElem.classList.add(cn$b("at"));
      atElem.appendChild(this.alphaViews_.text.element);
      aElem.appendChild(atElem);
      this.element.appendChild(aElem);
    }
  }
  get allFocusableElements() {
    const elems = [
      this.svPaletteView_.element,
      this.hPaletteView_.element,
      this.textsView_.modeSelectElement,
      ...this.textsView_.inputViews.map((v) => v.inputElement),
    ];
    if (this.alphaViews_) {
      elems.push(
        this.alphaViews_.palette.element,
        this.alphaViews_.text.inputElement,
      );
    }
    return elems;
  }
}
function parseColorType(value) {
  return value === "int" ? "int" : value === "float" ? "float" : void 0;
}
function parseColorInputParams(params) {
  return parseRecord(params, (p) => ({
    color: p.optional.object({
      alpha: p.optional.boolean,
      type: p.optional.custom(parseColorType),
    }),
    expanded: p.optional.boolean,
    picker: p.optional.custom(parsePickerLayout),
    readonly: p.optional.constant(false),
  }));
}
function getKeyScaleForColor(forAlpha) {
  return forAlpha ? 0.1 : 1;
}
function extractColorType(params) {
  var _a;
  return (_a = params.color) === null || _a === void 0 ? void 0 : _a.type;
}
class FloatColor7 {
  constructor(comps, mode) {
    this.type = "float";
    this.mode = mode;
    this.comps_ = constrainColorComponents(comps, mode, this.type);
  }
  getComponents(opt_mode) {
    return appendAlphaComponent(
      convertColor(
        removeAlphaComponent(this.comps_),
        { mode: this.mode, type: this.type },
        {
          mode: opt_mode !== null && opt_mode !== void 0 ? opt_mode : this.mode,
          type: this.type,
        },
      ),
      this.comps_[3],
    );
  }
  toRgbaObject() {
    const rgbComps = this.getComponents("rgb");
    return {
      r: rgbComps[0],
      g: rgbComps[1],
      b: rgbComps[2],
      a: rgbComps[3],
    };
  }
}
const TYPE_TO_CONSTRUCTOR_MAP = {
  int: (comps, mode) => new IntColor7(comps, mode),
  float: (comps, mode) => new FloatColor7(comps, mode),
};
function createColor(comps, mode, type) {
  return TYPE_TO_CONSTRUCTOR_MAP[type](comps, mode);
}
function isFloatColor(c) {
  return c.type === "float";
}
function isIntColor(c) {
  return c.type === "int";
}
function convertFloatToInt(cf) {
  const comps = cf.getComponents();
  const ms = getColorMaxComponents(cf.mode, "int");
  return new IntColor7(
    [
      Math.round(mapRange(comps[0], 0, 1, 0, ms[0])),
      Math.round(mapRange(comps[1], 0, 1, 0, ms[1])),
      Math.round(mapRange(comps[2], 0, 1, 0, ms[2])),
      comps[3],
    ],
    cf.mode,
  );
}
function convertIntToFloat(ci) {
  const comps = ci.getComponents();
  const ms = getColorMaxComponents(ci.mode, "int");
  return new FloatColor7(
    [
      mapRange(comps[0], 0, ms[0], 0, 1),
      mapRange(comps[1], 0, ms[1], 0, 1),
      mapRange(comps[2], 0, ms[2], 0, 1),
      comps[3],
    ],
    ci.mode,
  );
}
function mapColorType(c, type) {
  if (c.type === type) {
    return c;
  }
  if (isIntColor(c) && type === "float") {
    return convertIntToFloat(c);
  }
  if (isFloatColor(c) && type === "int") {
    return convertFloatToInt(c);
  }
  throw TpError7.shouldNeverHappen();
}
function equalsStringColorFormat(f1, f2) {
  return (
    f1.alpha === f2.alpha &&
    f1.mode === f2.mode &&
    f1.notation === f2.notation &&
    f1.type === f2.type
  );
}
function parseCssNumberOrPercentage(text, max) {
  const m = text.match(/^(.+)%$/);
  if (!m) {
    return Math.min(parseFloat(text), max);
  }
  return Math.min(parseFloat(m[1]) * 0.01 * max, max);
}
const ANGLE_TO_DEG_MAP = {
  deg: (angle) => angle,
  grad: (angle) => (angle * 360) / 400,
  rad: (angle) => (angle * 360) / (2 * Math.PI),
  turn: (angle) => angle * 360,
};
function parseCssNumberOrAngle(text) {
  const m = text.match(/^([0-9.]+?)(deg|grad|rad|turn)$/);
  if (!m) {
    return parseFloat(text);
  }
  const angle = parseFloat(m[1]);
  const unit = m[2];
  return ANGLE_TO_DEG_MAP[unit](angle);
}
function parseFunctionalRgbColorComponents(text) {
  const m = text.match(
    /^rgb\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage(m[1], 255),
    parseCssNumberOrPercentage(m[2], 255),
    parseCssNumberOrPercentage(m[3], 255),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbColor(text) {
  const comps = parseFunctionalRgbColorComponents(text);
  return comps ? new IntColor7(comps, "rgb") : null;
}
function parseFunctionalRgbaColorComponents(text) {
  const m = text.match(
    /^rgba\(\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrPercentage(m[1], 255),
    parseCssNumberOrPercentage(m[2], 255),
    parseCssNumberOrPercentage(m[3], 255),
    parseCssNumberOrPercentage(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalRgbaColor(text) {
  const comps = parseFunctionalRgbaColorComponents(text);
  return comps ? new IntColor7(comps, "rgb") : null;
}
function parseFunctionalHslColorComponents(text) {
  const m = text.match(
    /^hsl\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle(m[1]),
    parseCssNumberOrPercentage(m[2], 100),
    parseCssNumberOrPercentage(m[3], 100),
  ];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function parseFunctionalHslColor(text) {
  const comps = parseFunctionalHslColorComponents(text);
  return comps ? new IntColor7(comps, "hsl") : null;
}
function parseHslaColorComponents(text) {
  const m = text.match(
    /^hsla\(\s*([0-9A-Fa-f.]+(?:deg|grad|rad|turn)?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*,\s*([0-9A-Fa-f.]+%?)\s*\)$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseCssNumberOrAngle(m[1]),
    parseCssNumberOrPercentage(m[2], 100),
    parseCssNumberOrPercentage(m[3], 100),
    parseCssNumberOrPercentage(m[4], 1),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function parseFunctionalHslaColor(text) {
  const comps = parseHslaColorComponents(text);
  return comps ? new IntColor7(comps, "hsl") : null;
}
function parseHexRgbColorComponents(text) {
  const mRgb = text.match(/^#([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/);
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
    ];
  }
  return null;
}
function parseHexRgbColor(text) {
  const comps = parseHexRgbColorComponents(text);
  return comps ? new IntColor7(comps, "rgb") : null;
}
function parseHexRgbaColorComponents(text) {
  const mRgb = text.match(
    /^#?([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])$/,
  );
  if (mRgb) {
    return [
      parseInt(mRgb[1] + mRgb[1], 16),
      parseInt(mRgb[2] + mRgb[2], 16),
      parseInt(mRgb[3] + mRgb[3], 16),
      mapRange(parseInt(mRgb[4] + mRgb[4], 16), 0, 255, 0, 1),
    ];
  }
  const mRrggbb = text.match(
    /^(?:#|0x)?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/,
  );
  if (mRrggbb) {
    return [
      parseInt(mRrggbb[1], 16),
      parseInt(mRrggbb[2], 16),
      parseInt(mRrggbb[3], 16),
      mapRange(parseInt(mRrggbb[4], 16), 0, 255, 0, 1),
    ];
  }
  return null;
}
function parseHexRgbaColor(text) {
  const comps = parseHexRgbaColorComponents(text);
  return comps ? new IntColor7(comps, "rgb") : null;
}
function parseObjectRgbColorComponents(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3])];
  if (isNaN(comps[0]) || isNaN(comps[1]) || isNaN(comps[2])) {
    return null;
  }
  return comps;
}
function createObjectRgbColorParser(type) {
  return (text) => {
    const comps = parseObjectRgbColorComponents(text);
    return comps ? createColor(comps, "rgb", type) : null;
  };
}
function parseObjectRgbaColorComponents(text) {
  const m = text.match(
    /^\{\s*r\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*g\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*b\s*:\s*([0-9A-Fa-f.]+%?)\s*,\s*a\s*:\s*([0-9A-Fa-f.]+%?)\s*\}$/,
  );
  if (!m) {
    return null;
  }
  const comps = [
    parseFloat(m[1]),
    parseFloat(m[2]),
    parseFloat(m[3]),
    parseFloat(m[4]),
  ];
  if (
    isNaN(comps[0]) ||
    isNaN(comps[1]) ||
    isNaN(comps[2]) ||
    isNaN(comps[3])
  ) {
    return null;
  }
  return comps;
}
function createObjectRgbaColorParser(type) {
  return (text) => {
    const comps = parseObjectRgbaColorComponents(text);
    return comps ? createColor(comps, "rgb", type) : null;
  };
}
const PARSER_AND_RESULT = [
  {
    parser: parseHexRgbColorComponents,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseHexRgbaColorComponents,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
    },
  },
  {
    parser: parseFunctionalRgbColorComponents,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalRgbaColorComponents,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "func",
    },
  },
  {
    parser: parseFunctionalHslColorComponents,
    result: {
      alpha: false,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseHslaColorComponents,
    result: {
      alpha: true,
      mode: "hsl",
      notation: "func",
    },
  },
  {
    parser: parseObjectRgbColorComponents,
    result: {
      alpha: false,
      mode: "rgb",
      notation: "object",
    },
  },
  {
    parser: parseObjectRgbaColorComponents,
    result: {
      alpha: true,
      mode: "rgb",
      notation: "object",
    },
  },
];
function detectStringColor(text) {
  return PARSER_AND_RESULT.reduce((prev, { parser, result: detection }) => {
    if (prev) {
      return prev;
    }
    return parser(text) ? detection : null;
  }, null);
}
function detectStringColorFormat(text, type = "int") {
  const r = detectStringColor(text);
  if (!r) {
    return null;
  }
  if (r.notation === "hex" && type !== "float") {
    return Object.assign(Object.assign({}, r), { type: "int" });
  }
  if (r.notation === "func") {
    return Object.assign(Object.assign({}, r), { type });
  }
  return null;
}
function createColorStringParser(type) {
  const parsers = [
    parseHexRgbColor,
    parseHexRgbaColor,
    parseFunctionalRgbColor,
    parseFunctionalRgbaColor,
    parseFunctionalHslColor,
    parseFunctionalHslaColor,
  ];
  if (type === "int") {
    parsers.push(
      createObjectRgbColorParser("int"),
      createObjectRgbaColorParser("int"),
    );
  }
  if (type === "float") {
    parsers.push(
      createObjectRgbColorParser("float"),
      createObjectRgbaColorParser("float"),
    );
  }
  const parser = composeParsers(parsers);
  return (text) => {
    const result = parser(text);
    return result ? mapColorType(result, type) : null;
  };
}
function readIntColorString(value) {
  const parser = createColorStringParser("int");
  if (typeof value !== "string") {
    return IntColor7.black();
  }
  const result = parser(value);
  return result !== null && result !== void 0 ? result : IntColor7.black();
}
function zerofill(comp) {
  const hex = constrainRange(Math.floor(comp), 0, 255).toString(16);
  return hex.length === 1 ? `0${hex}` : hex;
}
function colorToHexRgbString(value, prefix = "#") {
  const hexes = removeAlphaComponent(value.getComponents("rgb"))
    .map(zerofill)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToHexRgbaString(value, prefix = "#") {
  const rgbaComps = value.getComponents("rgb");
  const hexes = [rgbaComps[0], rgbaComps[1], rgbaComps[2], rgbaComps[3] * 255]
    .map(zerofill)
    .join("");
  return `${prefix}${hexes}`;
}
function colorToFunctionalRgbString(value) {
  const formatter = createNumberFormatter(0);
  const ci = mapColorType(value, "int");
  const comps = removeAlphaComponent(ci.getComponents("rgb")).map((comp) =>
    formatter(comp),
  );
  return `rgb(${comps.join(", ")})`;
}
function colorToFunctionalRgbaString(value) {
  const aFormatter = createNumberFormatter(2);
  const rgbFormatter = createNumberFormatter(0);
  const ci = mapColorType(value, "int");
  const comps = ci.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return formatter(comp);
  });
  return `rgba(${comps.join(", ")})`;
}
function colorToFunctionalHslString(value) {
  const formatters = [
    createNumberFormatter(0),
    formatPercentage,
    formatPercentage,
  ];
  const ci = mapColorType(value, "int");
  const comps = removeAlphaComponent(ci.getComponents("hsl")).map(
    (comp, index) => formatters[index](comp),
  );
  return `hsl(${comps.join(", ")})`;
}
function colorToFunctionalHslaString(value) {
  const formatters = [
    createNumberFormatter(0),
    formatPercentage,
    formatPercentage,
    createNumberFormatter(2),
  ];
  const ci = mapColorType(value, "int");
  const comps = ci
    .getComponents("hsl")
    .map((comp, index) => formatters[index](comp));
  return `hsla(${comps.join(", ")})`;
}
function colorToObjectRgbString(value, type) {
  const formatter = createNumberFormatter(type === "float" ? 2 : 0);
  const names = ["r", "g", "b"];
  const cc = mapColorType(value, type);
  const comps = removeAlphaComponent(cc.getComponents("rgb")).map(
    (comp, index) => `${names[index]}: ${formatter(comp)}`,
  );
  return `{${comps.join(", ")}}`;
}
function createObjectRgbColorFormatter(type) {
  return (value) => colorToObjectRgbString(value, type);
}
function colorToObjectRgbaString(value, type) {
  const aFormatter = createNumberFormatter(2);
  const rgbFormatter = createNumberFormatter(type === "float" ? 2 : 0);
  const names = ["r", "g", "b", "a"];
  const cc = mapColorType(value, type);
  const comps = cc.getComponents("rgb").map((comp, index) => {
    const formatter = index === 3 ? aFormatter : rgbFormatter;
    return `${names[index]}: ${formatter(comp)}`;
  });
  return `{${comps.join(", ")}}`;
}
function createObjectRgbaColorFormatter(type) {
  return (value) => colorToObjectRgbaString(value, type);
}
const FORMAT_AND_STRINGIFIERS = [
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbString,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "hex",
      type: "int",
    },
    stringifier: colorToHexRgbaString,
  },
  {
    format: {
      alpha: false,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbString,
  },
  {
    format: {
      alpha: true,
      mode: "rgb",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalRgbaString,
  },
  {
    format: {
      alpha: false,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslString,
  },
  {
    format: {
      alpha: true,
      mode: "hsl",
      notation: "func",
      type: "int",
    },
    stringifier: colorToFunctionalHslaString,
  },
  ...["int", "float"].reduce((prev, type) => {
    return [
      ...prev,
      {
        format: {
          alpha: false,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbColorFormatter(type),
      },
      {
        format: {
          alpha: true,
          mode: "rgb",
          notation: "object",
          type,
        },
        stringifier: createObjectRgbaColorFormatter(type),
      },
    ];
  }, []),
];
function findColorStringifier(format) {
  return FORMAT_AND_STRINGIFIERS.reduce((prev, fas) => {
    if (prev) {
      return prev;
    }
    return equalsStringColorFormat(fas.format, format) ? fas.stringifier : null;
  }, null);
}
const cn$a = ClassName("apl");
class APaletteView7 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$a());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const barElem = doc.createElement("div");
    barElem.classList.add(cn$a("b"));
    this.element.appendChild(barElem);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$a("c"));
    barElem.appendChild(colorElem);
    this.colorElem_ = colorElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$a("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    const previewElem = doc.createElement("div");
    previewElem.classList.add(cn$a("p"));
    this.markerElem_.appendChild(previewElem);
    this.previewElem_ = previewElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const rgbaComps = c.getComponents("rgb");
    const leftColor = new IntColor7(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 0],
      "rgb",
    );
    const rightColor = new IntColor7(
      [rgbaComps[0], rgbaComps[1], rgbaComps[2], 255],
      "rgb",
    );
    const gradientComps = [
      "to right",
      colorToFunctionalRgbaString(leftColor),
      colorToFunctionalRgbaString(rightColor),
    ];
    this.colorElem_.style.background = `linear-gradient(${gradientComps.join(",")})`;
    this.previewElem_.style.backgroundColor = colorToFunctionalRgbaString(c);
    const left = mapRange(rgbaComps[3], 0, 1, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class APaletteController7 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new APaletteView7(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler7(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const alpha = d.point.x / d.bounds.width;
    const c = this.value.rawValue;
    const [h, s, v] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor7([h, s, v, alpha], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey(
      getKeyScaleForColor(true),
      getHorizontalStepKeys(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor7([h, s, v, a + step], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey(
      getKeyScaleForColor(true),
      getHorizontalStepKeys(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
}
const cn$9 = ClassName("coltxt");
function createModeSelectElement(doc) {
  const selectElem = doc.createElement("select");
  const items = [
    { text: "RGB", value: "rgb" },
    { text: "HSL", value: "hsl" },
    { text: "HSV", value: "hsv" },
    { text: "HEX", value: "hex" },
  ];
  selectElem.appendChild(
    items.reduce((frag, item) => {
      const optElem = doc.createElement("option");
      optElem.textContent = item.text;
      optElem.value = item.value;
      frag.appendChild(optElem);
      return frag;
    }, doc.createDocumentFragment()),
  );
  return selectElem;
}
class ColorTextsView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$9());
    config.viewProps.bindClassModifiers(this.element);
    const modeElem = doc.createElement("div");
    modeElem.classList.add(cn$9("m"));
    this.modeElem_ = createModeSelectElement(doc);
    this.modeElem_.classList.add(cn$9("ms"));
    modeElem.appendChild(this.modeSelectElement);
    config.viewProps.bindDisabled(this.modeElem_);
    const modeMarkerElem = doc.createElement("div");
    modeMarkerElem.classList.add(cn$9("mm"));
    modeMarkerElem.appendChild(createSvgIconElement(doc, "dropdown"));
    modeElem.appendChild(modeMarkerElem);
    this.element.appendChild(modeElem);
    const inputsElem = doc.createElement("div");
    inputsElem.classList.add(cn$9("w"));
    this.element.appendChild(inputsElem);
    this.inputsElem_ = inputsElem;
    this.inputViews_ = config.inputViews;
    this.applyInputViews_();
    bindValue(config.mode, (mode) => {
      this.modeElem_.value = mode;
    });
  }
  get modeSelectElement() {
    return this.modeElem_;
  }
  get inputViews() {
    return this.inputViews_;
  }
  set inputViews(inputViews) {
    this.inputViews_ = inputViews;
    this.applyInputViews_();
  }
  applyInputViews_() {
    removeChildElements(this.inputsElem_);
    const doc = this.element.ownerDocument;
    this.inputViews_.forEach((v) => {
      const compElem = doc.createElement("div");
      compElem.classList.add(cn$9("c"));
      compElem.appendChild(v.element);
      this.inputsElem_.appendChild(compElem);
    });
  }
}
function createFormatter$2(type) {
  return createNumberFormatter(type === "float" ? 2 : 0);
}
function createConstraint$5(mode, type, index) {
  const max = getColorMaxComponents(mode, type)[index];
  return new DefiniteRangeConstraint7({
    min: 0,
    max,
  });
}
function createComponentController(doc, config, index) {
  return new NumberTextController7(doc, {
    arrayPosition: index === 0 ? "fst" : index === 3 - 1 ? "lst" : "mid",
    parser: config.parser,
    props: ValueMap7.fromObject({
      formatter: createFormatter$2(config.colorType),
      keyScale: getKeyScaleForColor(false),
      pointerScale: config.colorType === "float" ? 0.01 : 1,
    }),
    value: createValue(0, {
      constraint: createConstraint$5(config.colorMode, config.colorType, index),
    }),
    viewProps: config.viewProps,
  });
}
function createComponentControllers(doc, config) {
  const cc = {
    colorMode: config.colorMode,
    colorType: config.colorType,
    parser: parseNumber,
    viewProps: config.viewProps,
  };
  return [0, 1, 2].map((i) => {
    const c = createComponentController(doc, cc, i);
    connectValues({
      primary: config.value,
      secondary: c.value,
      forward(p) {
        const mc = mapColorType(p, config.colorType);
        return mc.getComponents(config.colorMode)[i];
      },
      backward(p, s) {
        const pickedMode = config.colorMode;
        const mc = mapColorType(p, config.colorType);
        const comps = mc.getComponents(pickedMode);
        comps[i] = s;
        const c2 = createColor(
          appendAlphaComponent(removeAlphaComponent(comps), comps[3]),
          pickedMode,
          config.colorType,
        );
        return mapColorType(c2, "int");
      },
    });
    return c;
  });
}
function createHexController(doc, config) {
  const c = new TextController7(doc, {
    parser: createColorStringParser("int"),
    props: ValueMap7.fromObject({
      formatter: colorToHexRgbString,
    }),
    value: createValue(IntColor7.black()),
    viewProps: config.viewProps,
  });
  connectValues({
    primary: config.value,
    secondary: c.value,
    forward: (p) =>
      new IntColor7(removeAlphaComponent(p.getComponents()), p.mode),
    backward: (p, s) =>
      new IntColor7(
        appendAlphaComponent(
          removeAlphaComponent(s.getComponents(p.mode)),
          p.getComponents()[3],
        ),
        p.mode,
      ),
  });
  return [c];
}
function isColorMode(mode) {
  return mode !== "hex";
}
class ColorTextsController7 {
  constructor(doc, config) {
    this.onModeSelectChange_ = this.onModeSelectChange_.bind(this);
    this.colorType_ = config.colorType;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.colorMode = createValue(this.value.rawValue.mode);
    this.ccs_ = this.createComponentControllers_(doc);
    this.view = new ColorTextsView7(doc, {
      mode: this.colorMode,
      inputViews: [this.ccs_[0].view, this.ccs_[1].view, this.ccs_[2].view],
      viewProps: this.viewProps,
    });
    this.view.modeSelectElement.addEventListener(
      "change",
      this.onModeSelectChange_,
    );
  }
  createComponentControllers_(doc) {
    const mode = this.colorMode.rawValue;
    if (isColorMode(mode)) {
      return createComponentControllers(doc, {
        colorMode: mode,
        colorType: this.colorType_,
        value: this.value,
        viewProps: this.viewProps,
      });
    }
    return createHexController(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
  onModeSelectChange_(ev) {
    const selectElem = ev.currentTarget;
    this.colorMode.rawValue = selectElem.value;
    this.ccs_ = this.createComponentControllers_(
      this.view.element.ownerDocument,
    );
    this.view.inputViews = this.ccs_.map((cc) => cc.view);
  }
}
const cn$8 = ClassName("hpl");
class HPaletteView7 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$8());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const colorElem = doc.createElement("div");
    colorElem.classList.add(cn$8("c"));
    this.element.appendChild(colorElem);
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$8("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const c = this.value.rawValue;
    const [h] = c.getComponents("hsv");
    this.markerElem_.style.backgroundColor = colorToFunctionalRgbString(
      new IntColor7([h, 100, 100], "hsv"),
    );
    const left = mapRange(h, 0, 360, 0, 100);
    this.markerElem_.style.left = `${left}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class HPaletteController7 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new HPaletteView7(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler7(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const hue = mapRange(
      constrainRange(d.point.x, 0, d.bounds.width),
      0,
      d.bounds.width,
      0,
      360,
    );
    const c = this.value.rawValue;
    const [, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor7([hue, s, v, a], "hsv"), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    const step = getStepForKey(
      getKeyScaleForColor(false),
      getHorizontalStepKeys(ev),
    );
    if (step === 0) {
      return;
    }
    const c = this.value.rawValue;
    const [h, s, v, a] = c.getComponents("hsv");
    this.value.setRawValue(new IntColor7([h + step, s, v, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const step = getStepForKey(
      getKeyScaleForColor(false),
      getHorizontalStepKeys(ev),
    );
    if (step === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
}
const cn$7 = ClassName("svp");
const CANVAS_RESOL = 64;
class SvPaletteView7 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$7());
    config.viewProps.bindClassModifiers(this.element);
    config.viewProps.bindTabIndex(this.element);
    const canvasElem = doc.createElement("canvas");
    canvasElem.height = CANVAS_RESOL;
    canvasElem.width = CANVAS_RESOL;
    canvasElem.classList.add(cn$7("c"));
    this.element.appendChild(canvasElem);
    this.canvasElement = canvasElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$7("m"));
    this.element.appendChild(markerElem);
    this.markerElem_ = markerElem;
    this.update_();
  }
  update_() {
    const ctx = getCanvasContext(this.canvasElement);
    if (!ctx) {
      return;
    }
    const c = this.value.rawValue;
    const hsvComps = c.getComponents("hsv");
    const width = this.canvasElement.width;
    const height = this.canvasElement.height;
    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;
    for (let iy = 0; iy < height; iy++) {
      for (let ix = 0; ix < width; ix++) {
        const s = mapRange(ix, 0, width, 0, 100);
        const v = mapRange(iy, 0, height, 100, 0);
        const rgbComps = hsvToRgbInt(hsvComps[0], s, v);
        const i = (iy * width + ix) * 4;
        data[i] = rgbComps[0];
        data[i + 1] = rgbComps[1];
        data[i + 2] = rgbComps[2];
        data[i + 3] = 255;
      }
    }
    ctx.putImageData(imgData, 0, 0);
    const left = mapRange(hsvComps[1], 0, 100, 0, 100);
    this.markerElem_.style.left = `${left}%`;
    const top = mapRange(hsvComps[2], 0, 100, 100, 0);
    this.markerElem_.style.top = `${top}%`;
  }
  onValueChange_() {
    this.update_();
  }
}
class SvPaletteController7 {
  constructor(doc, config) {
    this.onKeyDown_ = this.onKeyDown_.bind(this);
    this.onKeyUp_ = this.onKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SvPaletteView7(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler7(this.view.element);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.element.addEventListener("keydown", this.onKeyDown_);
    this.view.element.addEventListener("keyup", this.onKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const saturation = mapRange(d.point.x, 0, d.bounds.width, 0, 100);
    const value = mapRange(d.point.y, 0, d.bounds.height, 100, 0);
    const [h, , , a] = this.value.rawValue.getComponents("hsv");
    this.value.setRawValue(
      new IntColor7([h, saturation, value, a], "hsv"),
      opts,
    );
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onKeyDown_(ev) {
    if (isArrowKey(ev.key)) {
      ev.preventDefault();
    }
    const [h, s, v, a] = this.value.rawValue.getComponents("hsv");
    const keyScale = getKeyScaleForColor(false);
    const ds = getStepForKey(keyScale, getHorizontalStepKeys(ev));
    const dv = getStepForKey(keyScale, getVerticalStepKeys(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(new IntColor7([h, s + ds, v + dv, a], "hsv"), {
      forceEmit: false,
      last: false,
    });
  }
  onKeyUp_(ev) {
    const keyScale = getKeyScaleForColor(false);
    const ds = getStepForKey(keyScale, getHorizontalStepKeys(ev));
    const dv = getStepForKey(keyScale, getVerticalStepKeys(ev));
    if (ds === 0 && dv === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
}
class ColorPickerController7 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.hPaletteC_ = new HPaletteController7(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.svPaletteC_ = new SvPaletteController7(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    this.alphaIcs_ = config.supportsAlpha
      ? {
          palette: new APaletteController7(doc, {
            value: this.value,
            viewProps: this.viewProps,
          }),
          text: new NumberTextController7(doc, {
            parser: parseNumber,
            props: ValueMap7.fromObject({
              pointerScale: 0.01,
              keyScale: 0.1,
              formatter: createNumberFormatter(2),
            }),
            value: createValue(0, {
              constraint: new DefiniteRangeConstraint7({ min: 0, max: 1 }),
            }),
            viewProps: this.viewProps,
          }),
        }
      : null;
    if (this.alphaIcs_) {
      connectValues({
        primary: this.value,
        secondary: this.alphaIcs_.text.value,
        forward: (p) => p.getComponents()[3],
        backward: (p, s) => {
          const comps = p.getComponents();
          comps[3] = s;
          return new IntColor7(comps, p.mode);
        },
      });
    }
    this.textsC_ = new ColorTextsController7(doc, {
      colorType: config.colorType,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorPickerView7(doc, {
      alphaViews: this.alphaIcs_
        ? {
            palette: this.alphaIcs_.palette.view,
            text: this.alphaIcs_.text.view,
          }
        : null,
      hPaletteView: this.hPaletteC_.view,
      supportsAlpha: config.supportsAlpha,
      svPaletteView: this.svPaletteC_.view,
      textsView: this.textsC_.view,
      viewProps: this.viewProps,
    });
  }
  get textsController() {
    return this.textsC_;
  }
}
const cn$6 = ClassName("colsw");
class ColorSwatchView7 {
  constructor(doc, config) {
    this.onValueChange_ = this.onValueChange_.bind(this);
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$6());
    config.viewProps.bindClassModifiers(this.element);
    const swatchElem = doc.createElement("div");
    swatchElem.classList.add(cn$6("sw"));
    this.element.appendChild(swatchElem);
    this.swatchElem_ = swatchElem;
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$6("b"));
    config.viewProps.bindDisabled(buttonElem);
    this.element.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    this.update_();
  }
  update_() {
    const value = this.value.rawValue;
    this.swatchElem_.style.backgroundColor = colorToHexRgbaString(value);
  }
  onValueChange_() {
    this.update_();
  }
}
class ColorSwatchController7 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new ColorSwatchView7(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
  }
}
class ColorController7 {
  constructor(doc, config) {
    this.onButtonBlur_ = this.onButtonBlur_.bind(this);
    this.onButtonClick_ = this.onButtonClick_.bind(this);
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable7.create(config.expanded);
    this.swatchC_ = new ColorSwatchController7(doc, {
      value: this.value,
      viewProps: this.viewProps,
    });
    const buttonElem = this.swatchC_.view.buttonElement;
    buttonElem.addEventListener("blur", this.onButtonBlur_);
    buttonElem.addEventListener("click", this.onButtonClick_);
    this.textC_ = new TextController7(doc, {
      parser: config.parser,
      props: ValueMap7.fromObject({
        formatter: config.formatter,
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new ColorView7(doc, {
      foldable: this.foldable_,
      pickerLayout: config.pickerLayout,
    });
    this.view.swatchElement.appendChild(this.swatchC_.view.element);
    this.view.textElement.appendChild(this.textC_.view.element);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController7(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const pickerC = new ColorPickerController7(doc, {
      colorType: config.colorType,
      supportsAlpha: config.supportsAlpha,
      value: this.value,
      viewProps: this.viewProps,
    });
    pickerC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = pickerC;
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(pickerC.view.element);
      connectValues({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.swatchC_.view.buttonElement &&
      !supportsTouch(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.swatchC_.view.buttonElement.focus();
      }
    }
  }
}
function colorToRgbNumber(value) {
  return removeAlphaComponent(value.getComponents("rgb")).reduce(
    (result, comp) => {
      return (result << 8) | (Math.floor(comp) & 255);
    },
    0,
  );
}
function colorToRgbaNumber(value) {
  return (
    value.getComponents("rgb").reduce((result, comp, index) => {
      const hex = Math.floor(index === 3 ? comp * 255 : comp) & 255;
      return (result << 8) | hex;
    }, 0) >>> 0
  );
}
function numberToRgbColor(num) {
  return new IntColor7([(num >> 16) & 255, (num >> 8) & 255, num & 255], "rgb");
}
function numberToRgbaColor(num) {
  return new IntColor7(
    [
      (num >> 24) & 255,
      (num >> 16) & 255,
      (num >> 8) & 255,
      mapRange(num & 255, 0, 255, 0, 1),
    ],
    "rgb",
  );
}
function colorFromRgbNumber(value) {
  if (typeof value !== "number") {
    return IntColor7.black();
  }
  return numberToRgbColor(value);
}
function colorFromRgbaNumber(value) {
  if (typeof value !== "number") {
    return IntColor7.black();
  }
  return numberToRgbaColor(value);
}
function isRgbColorComponent(obj, key2) {
  if (typeof obj !== "object" || isEmpty(obj)) {
    return false;
  }
  return key2 in obj && typeof obj[key2] === "number";
}
function isRgbColorObject(obj) {
  return (
    isRgbColorComponent(obj, "r") &&
    isRgbColorComponent(obj, "g") &&
    isRgbColorComponent(obj, "b")
  );
}
function isRgbaColorObject(obj) {
  return isRgbColorObject(obj) && isRgbColorComponent(obj, "a");
}
function isColorObject(obj) {
  return isRgbColorObject(obj);
}
function equalsColor(v1, v2) {
  if (v1.mode !== v2.mode) {
    return false;
  }
  if (v1.type !== v2.type) {
    return false;
  }
  const comps1 = v1.getComponents();
  const comps2 = v2.getComponents();
  for (let i = 0; i < comps1.length; i++) {
    if (comps1[i] !== comps2[i]) {
      return false;
    }
  }
  return true;
}
function createColorComponentsFromRgbObject(obj) {
  return "a" in obj ? [obj.r, obj.g, obj.b, obj.a] : [obj.r, obj.g, obj.b];
}
function createColorStringWriter(format) {
  const stringify = findColorStringifier(format);
  return stringify
    ? (target, value) => {
        writePrimitive(target, stringify(value));
      }
    : null;
}
function createColorNumberWriter(supportsAlpha) {
  const colorToNumber = supportsAlpha ? colorToRgbaNumber : colorToRgbNumber;
  return (target, value) => {
    writePrimitive(target, colorToNumber(value));
  };
}
function writeRgbaColorObject(target, value, type) {
  const cc = mapColorType(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
  target.writeProperty("a", obj.a);
}
function writeRgbColorObject(target, value, type) {
  const cc = mapColorType(value, type);
  const obj = cc.toRgbaObject();
  target.writeProperty("r", obj.r);
  target.writeProperty("g", obj.g);
  target.writeProperty("b", obj.b);
}
function createColorObjectWriter(supportsAlpha, type) {
  return (target, inValue) => {
    if (supportsAlpha) {
      writeRgbaColorObject(target, inValue, type);
    } else {
      writeRgbColorObject(target, inValue, type);
    }
  };
}
function shouldSupportAlpha$1(inputParams) {
  var _a;
  if (
    (_a =
      inputParams === null || inputParams === void 0
        ? void 0
        : inputParams.color) === null || _a === void 0
      ? void 0
      : _a.alpha
  ) {
    return true;
  }
  return false;
}
function createFormatter$1(supportsAlpha) {
  return supportsAlpha
    ? (v) => colorToHexRgbaString(v, "0x")
    : (v) => colorToHexRgbString(v, "0x");
}
function isForColor(params) {
  if ("color" in params) {
    return true;
  }
  if (params.view === "color") {
    return true;
  }
  return false;
}
createPlugin({
  id: "input-color-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    if (!isForColor(params)) {
      return null;
    }
    const result = parseColorInputParams(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            supportsAlpha: shouldSupportAlpha$1(params),
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => {
      return args.params.supportsAlpha
        ? colorFromRgbaNumber
        : colorFromRgbNumber;
    },
    equals: equalsColor,
    writer: (args) => {
      return createColorNumberWriter(args.params.supportsAlpha);
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController7(args.document, {
      colorType: "int",
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createFormatter$1(args.params.supportsAlpha),
      parser: createColorStringParser("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
function colorFromObject(value, type) {
  if (!isColorObject(value)) {
    return mapColorType(IntColor7.black(), type);
  }
  if (type === "int") {
    const comps = createColorComponentsFromRgbObject(value);
    return new IntColor7(comps, "rgb");
  }
  if (type === "float") {
    const comps = createColorComponentsFromRgbObject(value);
    return new FloatColor7(comps, "rgb");
  }
  return mapColorType(IntColor7.black(), "int");
}
function shouldSupportAlpha(initialValue) {
  return isRgbaColorObject(initialValue);
}
function createColorObjectBindingReader(type) {
  return (value) => {
    const c = colorFromObject(value, type);
    return mapColorType(c, "int");
  };
}
function createColorObjectFormatter(supportsAlpha, type) {
  return (value) => {
    if (supportsAlpha) {
      return colorToObjectRgbaString(value, type);
    }
    return colorToObjectRgbString(value, type);
  };
}
createPlugin({
  id: "input-color-object",
  type: "input",
  accept: (value, params) => {
    var _a;
    if (!isColorObject(value)) {
      return null;
    }
    const result = parseColorInputParams(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            colorType:
              (_a = extractColorType(params)) !== null && _a !== void 0
                ? _a
                : "int",
          }),
        }
      : null;
  },
  binding: {
    reader: (args) => createColorObjectBindingReader(args.params.colorType),
    equals: equalsColor,
    writer: (args) =>
      createColorObjectWriter(
        shouldSupportAlpha(args.initialValue),
        args.params.colorType,
      ),
  },
  controller: (args) => {
    var _a, _b;
    const supportsAlpha = isRgbaColorObject(args.initialValue);
    return new ColorController7(args.document, {
      colorType: args.params.colorType,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: createColorObjectFormatter(
        supportsAlpha,
        args.params.colorType,
      ),
      parser: createColorStringParser("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
createPlugin({
  id: "input-color-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    if (params.view === "text") {
      return null;
    }
    const format = detectStringColorFormat(value, extractColorType(params));
    if (!format) {
      return null;
    }
    const stringifier = findColorStringifier(format);
    if (!stringifier) {
      return null;
    }
    const result = parseColorInputParams(params);
    return result
      ? {
          initialValue: value,
          params: Object.assign(Object.assign({}, result), {
            format,
            stringifier,
          }),
        }
      : null;
  },
  binding: {
    reader: () => readIntColorString,
    equals: equalsColor,
    writer: (args) => {
      const writer = createColorStringWriter(args.params.format);
      if (!writer) {
        throw TpError7.notBindable();
      }
      return writer;
    },
  },
  controller: (args) => {
    var _a, _b;
    return new ColorController7(args.document, {
      colorType: args.params.format.type,
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      formatter: args.params.stringifier,
      parser: createColorStringParser("int"),
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      supportsAlpha: args.params.format.alpha,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
class PointNdConstraint7 {
  constructor(config) {
    this.components = config.components;
    this.asm_ = config.assembly;
  }
  constrain(value) {
    const comps = this.asm_.toComponents(value).map((comp, index) => {
      var _a, _b;
      return (_b =
        (_a = this.components[index]) === null || _a === void 0
          ? void 0
          : _a.constrain(comp)) !== null && _b !== void 0
        ? _b
        : comp;
    });
    return this.asm_.fromComponents(comps);
  }
}
const cn$5 = ClassName("pndtxt");
class PointNdTextView7 {
  constructor(doc, config) {
    this.textViews = config.textViews;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$5());
    this.textViews.forEach((v) => {
      const axisElem = doc.createElement("div");
      axisElem.classList.add(cn$5("a"));
      axisElem.appendChild(v.element);
      this.element.appendChild(axisElem);
    });
  }
}
function createAxisController(doc, config, index) {
  return new NumberTextController7(doc, {
    arrayPosition:
      index === 0 ? "fst" : index === config.axes.length - 1 ? "lst" : "mid",
    parser: config.parser,
    props: config.axes[index].textProps,
    value: createValue(0, {
      constraint: config.axes[index].constraint,
    }),
    viewProps: config.viewProps,
  });
}
class PointNdTextController7 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.acs_ = config.axes.map((_, index) =>
      createAxisController(doc, config, index),
    );
    this.acs_.forEach((c, index) => {
      connectValues({
        primary: this.value,
        secondary: c.value,
        forward: (p) => config.assembly.toComponents(p)[index],
        backward: (p, s) => {
          const comps = config.assembly.toComponents(p);
          comps[index] = s;
          return config.assembly.fromComponents(comps);
        },
      });
    });
    this.view = new PointNdTextView7(doc, {
      textViews: this.acs_.map((ac) => ac.view),
    });
  }
  get textControllers() {
    return this.acs_;
  }
}
class SliderInputBindingApi7 extends BindingApi7 {
  get max() {
    return this.controller.valueController.sliderController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.sliderController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.sliderController.props.get("min");
  }
  set min(max) {
    this.controller.valueController.sliderController.props.set("min", max);
  }
}
function createConstraint$4(params, initialValue) {
  const constraints = [];
  const sc = createStepConstraint(params, initialValue);
  if (sc) {
    constraints.push(sc);
  }
  const rc = createRangeConstraint(params);
  if (rc) {
    constraints.push(rc);
  }
  const lc = createListConstraint(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint7(constraints);
}
createPlugin({
  id: "input-number",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord(params, (p) =>
      Object.assign(Object.assign({}, createNumberTextInputParamsParser(p)), {
        options: p.optional.custom(parseListOptions),
        readonly: p.optional.constant(false),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => numberFromUnknown,
    constraint: (args) => createConstraint$4(args.params, args.initialValue),
    writer: (_args) => writePrimitive,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint(c, ListConstraint7);
    if (lc) {
      return new ListController7(args.document, {
        props: new ValueMap7({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    const textPropsObj = createNumberTextPropsObject(
      args.params,
      value.rawValue,
    );
    const drc = c && findConstraint(c, DefiniteRangeConstraint7);
    if (drc) {
      return new SliderTextController7(
        args.document,
        Object.assign(
          Object.assign(
            {},
            createSliderTextProps(
              Object.assign(Object.assign({}, textPropsObj), {
                keyScale: createValue(textPropsObj.keyScale),
                max: drc.values.value("max"),
                min: drc.values.value("min"),
              }),
            ),
          ),
          { parser: parseNumber, value, viewProps: args.viewProps },
        ),
      );
    }
    return new NumberTextController7(args.document, {
      parser: parseNumber,
      props: ValueMap7.fromObject(textPropsObj),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "number") {
      return null;
    }
    if (args.controller.valueController instanceof SliderTextController7) {
      return new SliderInputBindingApi7(args.controller);
    }
    if (args.controller.valueController instanceof ListController7) {
      return new ListInputBindingApi7(args.controller);
    }
    return null;
  },
});
class Point2d7 {
  constructor(x = 0, y2 = 0) {
    this.x = x;
    this.y = y2;
  }
  getComponents() {
    return [this.x, this.y];
  }
  static isObject(obj) {
    if (isEmpty(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    if (typeof x !== "number" || typeof y2 !== "number") {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
    };
  }
}
const Point2dAssembly = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point2d7(...comps),
};
const cn$4 = ClassName("p2d");
class Point2dView7 {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(cn$4());
    config.viewProps.bindClassModifiers(this.element);
    bindValue(
      config.expanded,
      valueToClassName(this.element, cn$4(void 0, "expanded")),
    );
    const headElem = doc.createElement("div");
    headElem.classList.add(cn$4("h"));
    this.element.appendChild(headElem);
    const buttonElem = doc.createElement("button");
    buttonElem.classList.add(cn$4("b"));
    buttonElem.appendChild(createSvgIconElement(doc, "p2dpad"));
    config.viewProps.bindDisabled(buttonElem);
    headElem.appendChild(buttonElem);
    this.buttonElement = buttonElem;
    const textElem = doc.createElement("div");
    textElem.classList.add(cn$4("t"));
    headElem.appendChild(textElem);
    this.textElement = textElem;
    if (config.pickerLayout === "inline") {
      const pickerElem = doc.createElement("div");
      pickerElem.classList.add(cn$4("p"));
      this.element.appendChild(pickerElem);
      this.pickerElement = pickerElem;
    } else {
      this.pickerElement = null;
    }
  }
}
const cn$3 = ClassName("p2dp");
class Point2dPickerView7 {
  constructor(doc, config) {
    this.onFoldableChange_ = this.onFoldableChange_.bind(this);
    this.onPropsChange_ = this.onPropsChange_.bind(this);
    this.onValueChange_ = this.onValueChange_.bind(this);
    this.props_ = config.props;
    this.props_.emitter.on("change", this.onPropsChange_);
    this.element = doc.createElement("div");
    this.element.classList.add(cn$3());
    if (config.layout === "popup") {
      this.element.classList.add(cn$3(void 0, "p"));
    }
    config.viewProps.bindClassModifiers(this.element);
    const padElem = doc.createElement("div");
    padElem.classList.add(cn$3("p"));
    config.viewProps.bindTabIndex(padElem);
    this.element.appendChild(padElem);
    this.padElement = padElem;
    const svgElem = doc.createElementNS(SVG_NS, "svg");
    svgElem.classList.add(cn$3("g"));
    this.padElement.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const xAxisElem = doc.createElementNS(SVG_NS, "line");
    xAxisElem.classList.add(cn$3("ax"));
    xAxisElem.setAttributeNS(null, "x1", "0");
    xAxisElem.setAttributeNS(null, "y1", "50%");
    xAxisElem.setAttributeNS(null, "x2", "100%");
    xAxisElem.setAttributeNS(null, "y2", "50%");
    this.svgElem_.appendChild(xAxisElem);
    const yAxisElem = doc.createElementNS(SVG_NS, "line");
    yAxisElem.classList.add(cn$3("ax"));
    yAxisElem.setAttributeNS(null, "x1", "50%");
    yAxisElem.setAttributeNS(null, "y1", "0");
    yAxisElem.setAttributeNS(null, "x2", "50%");
    yAxisElem.setAttributeNS(null, "y2", "100%");
    this.svgElem_.appendChild(yAxisElem);
    const lineElem = doc.createElementNS(SVG_NS, "line");
    lineElem.classList.add(cn$3("l"));
    lineElem.setAttributeNS(null, "x1", "50%");
    lineElem.setAttributeNS(null, "y1", "50%");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const markerElem = doc.createElement("div");
    markerElem.classList.add(cn$3("m"));
    this.padElement.appendChild(markerElem);
    this.markerElem_ = markerElem;
    config.value.emitter.on("change", this.onValueChange_);
    this.value = config.value;
    this.update_();
  }
  get allFocusableElements() {
    return [this.padElement];
  }
  update_() {
    const [x, y2] = this.value.rawValue.getComponents();
    const max = this.props_.get("max");
    const px2 = mapRange(x, -max, +max, 0, 100);
    const py2 = mapRange(y2, -max, +max, 0, 100);
    const ipy = this.props_.get("invertsY") ? 100 - py2 : py2;
    this.lineElem_.setAttributeNS(null, "x2", `${px2}%`);
    this.lineElem_.setAttributeNS(null, "y2", `${ipy}%`);
    this.markerElem_.style.left = `${px2}%`;
    this.markerElem_.style.top = `${ipy}%`;
  }
  onValueChange_() {
    this.update_();
  }
  onPropsChange_() {
    this.update_();
  }
  onFoldableChange_() {
    this.update_();
  }
}
function computeOffset(ev, keyScales, invertsY) {
  return [
    getStepForKey(keyScales[0], getHorizontalStepKeys(ev)),
    getStepForKey(keyScales[1], getVerticalStepKeys(ev)) * (invertsY ? 1 : -1),
  ];
}
class Point2dPickerController7 {
  constructor(doc, config) {
    this.onPadKeyDown_ = this.onPadKeyDown_.bind(this);
    this.onPadKeyUp_ = this.onPadKeyUp_.bind(this);
    this.onPointerDown_ = this.onPointerDown_.bind(this);
    this.onPointerMove_ = this.onPointerMove_.bind(this);
    this.onPointerUp_ = this.onPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new Point2dPickerView7(doc, {
      layout: config.layout,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.ptHandler_ = new PointerHandler7(this.view.padElement);
    this.ptHandler_.emitter.on("down", this.onPointerDown_);
    this.ptHandler_.emitter.on("move", this.onPointerMove_);
    this.ptHandler_.emitter.on("up", this.onPointerUp_);
    this.view.padElement.addEventListener("keydown", this.onPadKeyDown_);
    this.view.padElement.addEventListener("keyup", this.onPadKeyUp_);
  }
  handlePointerEvent_(d, opts) {
    if (!d.point) {
      return;
    }
    const max = this.props.get("max");
    const px2 = mapRange(d.point.x, 0, d.bounds.width, -max, +max);
    const py2 = mapRange(
      this.props.get("invertsY") ? d.bounds.height - d.point.y : d.point.y,
      0,
      d.bounds.height,
      -max,
      +max,
    );
    this.value.setRawValue(new Point2d7(px2, py2), opts);
  }
  onPointerDown_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerMove_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: false,
      last: false,
    });
  }
  onPointerUp_(ev) {
    this.handlePointerEvent_(ev.data, {
      forceEmit: true,
      last: true,
    });
  }
  onPadKeyDown_(ev) {
    if (isArrowKey(ev.key)) {
      ev.preventDefault();
    }
    const [dx, dy] = computeOffset(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(
      new Point2d7(this.value.rawValue.x + dx, this.value.rawValue.y + dy),
      {
        forceEmit: false,
        last: false,
      },
    );
  }
  onPadKeyUp_(ev) {
    const [dx, dy] = computeOffset(
      ev,
      [this.props.get("xKeyScale"), this.props.get("yKeyScale")],
      this.props.get("invertsY"),
    );
    if (dx === 0 && dy === 0) {
      return;
    }
    this.value.setRawValue(this.value.rawValue, {
      forceEmit: true,
      last: true,
    });
  }
}
class Point2dController7 {
  constructor(doc, config) {
    var _a, _b;
    this.onPopupChildBlur_ = this.onPopupChildBlur_.bind(this);
    this.onPopupChildKeydown_ = this.onPopupChildKeydown_.bind(this);
    this.onPadButtonBlur_ = this.onPadButtonBlur_.bind(this);
    this.onPadButtonClick_ = this.onPadButtonClick_.bind(this);
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.foldable_ = Foldable7.create(config.expanded);
    this.popC_ =
      config.pickerLayout === "popup"
        ? new PopupController7(doc, {
            viewProps: this.viewProps,
          })
        : null;
    const padC = new Point2dPickerController7(doc, {
      layout: config.pickerLayout,
      props: new ValueMap7({
        invertsY: createValue(config.invertsY),
        max: createValue(config.max),
        xKeyScale: config.axes[0].textProps.value("keyScale"),
        yKeyScale: config.axes[1].textProps.value("keyScale"),
      }),
      value: this.value,
      viewProps: this.viewProps,
    });
    padC.view.allFocusableElements.forEach((elem) => {
      elem.addEventListener("blur", this.onPopupChildBlur_);
      elem.addEventListener("keydown", this.onPopupChildKeydown_);
    });
    this.pickerC_ = padC;
    this.textC_ = new PointNdTextController7(doc, {
      assembly: Point2dAssembly,
      axes: config.axes,
      parser: config.parser,
      value: this.value,
      viewProps: this.viewProps,
    });
    this.view = new Point2dView7(doc, {
      expanded: this.foldable_.value("expanded"),
      pickerLayout: config.pickerLayout,
      viewProps: this.viewProps,
    });
    this.view.textElement.appendChild(this.textC_.view.element);
    (_a = this.view.buttonElement) === null || _a === void 0
      ? void 0
      : _a.addEventListener("blur", this.onPadButtonBlur_);
    (_b = this.view.buttonElement) === null || _b === void 0
      ? void 0
      : _b.addEventListener("click", this.onPadButtonClick_);
    if (this.popC_) {
      this.view.element.appendChild(this.popC_.view.element);
      this.popC_.view.element.appendChild(this.pickerC_.view.element);
      connectValues({
        primary: this.foldable_.value("expanded"),
        secondary: this.popC_.shows,
        forward: (p) => p,
        backward: (_, s) => s,
      });
    } else if (this.view.pickerElement) {
      this.view.pickerElement.appendChild(this.pickerC_.view.element);
      bindFoldable(this.foldable_, this.view.pickerElement);
    }
  }
  get textController() {
    return this.textC_;
  }
  onPadButtonBlur_(e) {
    if (!this.popC_) {
      return;
    }
    const elem = this.view.element;
    const nextTarget = forceCast(e.relatedTarget);
    if (!nextTarget || !elem.contains(nextTarget)) {
      this.popC_.shows.rawValue = false;
    }
  }
  onPadButtonClick_() {
    this.foldable_.set("expanded", !this.foldable_.get("expanded"));
    if (this.foldable_.get("expanded")) {
      this.pickerC_.view.allFocusableElements[0].focus();
    }
  }
  onPopupChildBlur_(ev) {
    if (!this.popC_) {
      return;
    }
    const elem = this.popC_.view.element;
    const nextTarget = findNextTarget(ev);
    if (nextTarget && elem.contains(nextTarget)) {
      return;
    }
    if (
      nextTarget &&
      nextTarget === this.view.buttonElement &&
      !supportsTouch(elem.ownerDocument)
    ) {
      return;
    }
    this.popC_.shows.rawValue = false;
  }
  onPopupChildKeydown_(ev) {
    if (this.popC_) {
      if (ev.key === "Escape") {
        this.popC_.shows.rawValue = false;
      }
    } else if (this.view.pickerElement) {
      if (ev.key === "Escape") {
        this.view.buttonElement.focus();
      }
    }
  }
}
function point2dFromUnknown(value) {
  return Point2d7.isObject(value)
    ? new Point2d7(value.x, value.y)
    : new Point2d7();
}
function writePoint2d(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
}
function createConstraint$3(params, initialValue) {
  return new PointNdConstraint7({
    assembly: Point2dAssembly,
    components: [
      createDimensionConstraint(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
    ],
  });
}
function getSuitableMaxDimensionValue(params, rawValue) {
  var _a, _b;
  if (!isEmpty(params.min) || !isEmpty(params.max)) {
    return Math.max(
      Math.abs((_a = params.min) !== null && _a !== void 0 ? _a : 0),
      Math.abs((_b = params.max) !== null && _b !== void 0 ? _b : 0),
    );
  }
  const step = getSuitableKeyScale(params);
  return Math.max(Math.abs(step) * 10, Math.abs(rawValue) * 10);
}
function getSuitableMax(params, initialValue) {
  var _a, _b;
  const xr = getSuitableMaxDimensionValue(
    deepMerge(params, (_a = params.x) !== null && _a !== void 0 ? _a : {}),
    initialValue.x,
  );
  const yr = getSuitableMaxDimensionValue(
    deepMerge(params, (_b = params.y) !== null && _b !== void 0 ? _b : {}),
    initialValue.y,
  );
  return Math.max(xr, yr);
}
function shouldInvertY(params) {
  if (!("y" in params)) {
    return false;
  }
  const yParams = params.y;
  if (!yParams) {
    return false;
  }
  return "inverted" in yParams ? !!yParams.inverted : false;
}
createPlugin({
  id: "input-point2d",
  type: "input",
  accept: (value, params) => {
    if (!Point2d7.isObject(value)) {
      return null;
    }
    const result = parseRecord(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser(p)), {
        expanded: p.optional.boolean,
        picker: p.optional.custom(parsePickerLayout),
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams),
        y: p.optional.object(
          Object.assign(Object.assign({}, createPointDimensionParser(p)), {
            inverted: p.optional.boolean,
          }),
        ),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: () => point2dFromUnknown,
    constraint: (args) => createConstraint$3(args.params, args.initialValue),
    equals: Point2d7.equals,
    writer: () => writePoint2d,
  },
  controller: (args) => {
    var _a, _b;
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y];
    return new Point2dController7(doc, {
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a2;
        return createPointAxis({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge(
            args.params,
            (_a2 = dParams[i]) !== null && _a2 !== void 0 ? _a2 : {},
          ),
        });
      }),
      expanded:
        (_a = args.params.expanded) !== null && _a !== void 0 ? _a : false,
      invertsY: shouldInvertY(args.params),
      max: getSuitableMax(args.params, value.rawValue),
      parser: parseNumber,
      pickerLayout:
        (_b = args.params.picker) !== null && _b !== void 0 ? _b : "popup",
      value,
      viewProps: args.viewProps,
    });
  },
});
class Point3d7 {
  constructor(x = 0, y2 = 0, z = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
  }
  getComponents() {
    return [this.x, this.y, this.z];
  }
  static isObject(obj) {
    if (isEmpty(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
    };
  }
}
const Point3dAssembly = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point3d7(...comps),
};
function point3dFromUnknown(value) {
  return Point3d7.isObject(value)
    ? new Point3d7(value.x, value.y, value.z)
    : new Point3d7();
}
function writePoint3d(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
}
function createConstraint$2(params, initialValue) {
  return new PointNdConstraint7({
    assembly: Point3dAssembly,
    components: [
      createDimensionConstraint(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
    ],
  });
}
createPlugin({
  id: "input-point3d",
  type: "input",
  accept: (value, params) => {
    if (!Point3d7.isObject(value)) {
      return null;
    }
    const result = parseRecord(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser(p)), {
        readonly: p.optional.constant(false),
        x: p.optional.custom(parsePointDimensionParams),
        y: p.optional.custom(parsePointDimensionParams),
        z: p.optional.custom(parsePointDimensionParams),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point3dFromUnknown,
    constraint: (args) => createConstraint$2(args.params, args.initialValue),
    equals: Point3d7.equals,
    writer: (_args) => writePoint3d,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [args.params.x, args.params.y, args.params.z];
    return new PointNdTextController7(args.document, {
      assembly: Point3dAssembly,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber,
      value,
      viewProps: args.viewProps,
    });
  },
});
class Point4d7 {
  constructor(x = 0, y2 = 0, z = 0, w = 0) {
    this.x = x;
    this.y = y2;
    this.z = z;
    this.w = w;
  }
  getComponents() {
    return [this.x, this.y, this.z, this.w];
  }
  static isObject(obj) {
    if (isEmpty(obj)) {
      return false;
    }
    const x = obj.x;
    const y2 = obj.y;
    const z = obj.z;
    const w = obj.w;
    if (
      typeof x !== "number" ||
      typeof y2 !== "number" ||
      typeof z !== "number" ||
      typeof w !== "number"
    ) {
      return false;
    }
    return true;
  }
  static equals(v1, v2) {
    return v1.x === v2.x && v1.y === v2.y && v1.z === v2.z && v1.w === v2.w;
  }
  toObject() {
    return {
      x: this.x,
      y: this.y,
      z: this.z,
      w: this.w,
    };
  }
}
const Point4dAssembly = {
  toComponents: (p) => p.getComponents(),
  fromComponents: (comps) => new Point4d7(...comps),
};
function point4dFromUnknown(value) {
  return Point4d7.isObject(value)
    ? new Point4d7(value.x, value.y, value.z, value.w)
    : new Point4d7();
}
function writePoint4d(target, value) {
  target.writeProperty("x", value.x);
  target.writeProperty("y", value.y);
  target.writeProperty("z", value.z);
  target.writeProperty("w", value.w);
}
function createConstraint$1(params, initialValue) {
  return new PointNdConstraint7({
    assembly: Point4dAssembly,
    components: [
      createDimensionConstraint(
        Object.assign(Object.assign({}, params), params.x),
        initialValue.x,
      ),
      createDimensionConstraint(
        Object.assign(Object.assign({}, params), params.y),
        initialValue.y,
      ),
      createDimensionConstraint(
        Object.assign(Object.assign({}, params), params.z),
        initialValue.z,
      ),
      createDimensionConstraint(
        Object.assign(Object.assign({}, params), params.w),
        initialValue.w,
      ),
    ],
  });
}
createPlugin({
  id: "input-point4d",
  type: "input",
  accept: (value, params) => {
    if (!Point4d7.isObject(value)) {
      return null;
    }
    const result = parseRecord(params, (p) =>
      Object.assign(Object.assign({}, createPointDimensionParser(p)), {
        readonly: p.optional.constant(false),
        w: p.optional.custom(parsePointDimensionParams),
        x: p.optional.custom(parsePointDimensionParams),
        y: p.optional.custom(parsePointDimensionParams),
        z: p.optional.custom(parsePointDimensionParams),
      }),
    );
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => point4dFromUnknown,
    constraint: (args) => createConstraint$1(args.params, args.initialValue),
    equals: Point4d7.equals,
    writer: (_args) => writePoint4d,
  },
  controller: (args) => {
    const value = args.value;
    const c = args.constraint;
    const dParams = [
      args.params.x,
      args.params.y,
      args.params.z,
      args.params.w,
    ];
    return new PointNdTextController7(args.document, {
      assembly: Point4dAssembly,
      axes: value.rawValue.getComponents().map((comp, i) => {
        var _a;
        return createPointAxis({
          constraint: c.components[i],
          initialValue: comp,
          params: deepMerge(
            args.params,
            (_a = dParams[i]) !== null && _a !== void 0 ? _a : {},
          ),
        });
      }),
      parser: parseNumber,
      value,
      viewProps: args.viewProps,
    });
  },
});
function createConstraint(params) {
  const constraints = [];
  const lc = createListConstraint(params.options);
  if (lc) {
    constraints.push(lc);
  }
  return new CompositeConstraint7(constraints);
}
createPlugin({
  id: "input-string",
  type: "input",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      readonly: p.optional.constant(false),
      options: p.optional.custom(parseListOptions),
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown,
    constraint: (args) => createConstraint(args.params),
    writer: (_args) => writePrimitive,
  },
  controller: (args) => {
    const doc = args.document;
    const value = args.value;
    const c = args.constraint;
    const lc = c && findConstraint(c, ListConstraint7);
    if (lc) {
      return new ListController7(doc, {
        props: new ValueMap7({
          options: lc.values.value("options"),
        }),
        value,
        viewProps: args.viewProps,
      });
    }
    return new TextController7(doc, {
      parser: (v) => v,
      props: ValueMap7.fromObject({
        formatter: formatString,
      }),
      value,
      viewProps: args.viewProps,
    });
  },
  api(args) {
    if (typeof args.controller.value.rawValue !== "string") {
      return null;
    }
    if (args.controller.valueController instanceof ListController7) {
      return new ListInputBindingApi7(args.controller);
    }
    return null;
  },
});
const Constants = {
  monitor: {
    defaultInterval: 200,
    defaultRows: 3,
  },
};
const cn$2 = ClassName("mll");
class MultiLogView7 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$2());
    config.viewProps.bindClassModifiers(this.element);
    const textareaElem = doc.createElement("textarea");
    textareaElem.classList.add(cn$2("i"));
    textareaElem.style.height = `calc(var(${getCssVar("containerUnitSize")}) * ${config.rows})`;
    textareaElem.readOnly = true;
    config.viewProps.bindDisabled(textareaElem);
    this.element.appendChild(textareaElem);
    this.textareaElem_ = textareaElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const elem = this.textareaElem_;
    const shouldScroll =
      elem.scrollTop === elem.scrollHeight - elem.clientHeight;
    const lines = [];
    this.value.rawValue.forEach((value) => {
      if (value !== void 0) {
        lines.push(this.formatter_(value));
      }
    });
    elem.textContent = lines.join("\n");
    if (shouldScroll) {
      elem.scrollTop = elem.scrollHeight;
    }
  }
  onValueUpdate_() {
    this.update_();
  }
}
class MultiLogController7 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new MultiLogView7(doc, {
      formatter: config.formatter,
      rows: config.rows,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
}
const cn$1 = ClassName("sgl");
class SingleLogView7 {
  constructor(doc, config) {
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.formatter_ = config.formatter;
    this.element = doc.createElement("div");
    this.element.classList.add(cn$1());
    config.viewProps.bindClassModifiers(this.element);
    const inputElem = doc.createElement("input");
    inputElem.classList.add(cn$1("i"));
    inputElem.readOnly = true;
    inputElem.type = "text";
    config.viewProps.bindDisabled(inputElem);
    this.element.appendChild(inputElem);
    this.inputElement = inputElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  update_() {
    const values = this.value.rawValue;
    const lastValue = values[values.length - 1];
    this.inputElement.value =
      lastValue !== void 0 ? this.formatter_(lastValue) : "";
  }
  onValueUpdate_() {
    this.update_();
  }
}
class SingleLogController7 {
  constructor(doc, config) {
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.view = new SingleLogView7(doc, {
      formatter: config.formatter,
      value: this.value,
      viewProps: this.viewProps,
    });
  }
}
createPlugin({
  id: "monitor-bool",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "boolean") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => boolFromUnknown,
  },
  controller: (args) => {
    var _a;
    if (args.value.rawValue.length === 1) {
      return new SingleLogController7(args.document, {
        formatter: BooleanFormatter,
        value: args.value,
        viewProps: args.viewProps,
      });
    }
    return new MultiLogController7(args.document, {
      formatter: BooleanFormatter,
      rows:
        (_a = args.params.rows) !== null && _a !== void 0
          ? _a
          : Constants.monitor.defaultRows,
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
class GraphLogMonitorBindingApi7 extends BindingApi7 {
  get max() {
    return this.controller.valueController.props.get("max");
  }
  set max(max) {
    this.controller.valueController.props.set("max", max);
  }
  get min() {
    return this.controller.valueController.props.get("min");
  }
  set min(min) {
    this.controller.valueController.props.set("min", min);
  }
}
const cn = ClassName("grl");
class GraphLogView7 {
  constructor(doc, config) {
    this.onCursorChange_ = this.onCursorChange_.bind(this);
    this.onValueUpdate_ = this.onValueUpdate_.bind(this);
    this.element = doc.createElement("div");
    this.element.classList.add(cn());
    config.viewProps.bindClassModifiers(this.element);
    this.formatter_ = config.formatter;
    this.props_ = config.props;
    this.cursor_ = config.cursor;
    this.cursor_.emitter.on("change", this.onCursorChange_);
    const svgElem = doc.createElementNS(SVG_NS, "svg");
    svgElem.classList.add(cn("g"));
    svgElem.style.height = `calc(var(${getCssVar("containerUnitSize")}) * ${config.rows})`;
    this.element.appendChild(svgElem);
    this.svgElem_ = svgElem;
    const lineElem = doc.createElementNS(SVG_NS, "polyline");
    this.svgElem_.appendChild(lineElem);
    this.lineElem_ = lineElem;
    const tooltipElem = doc.createElement("div");
    tooltipElem.classList.add(cn("t"), ClassName("tt")());
    this.element.appendChild(tooltipElem);
    this.tooltipElem_ = tooltipElem;
    config.value.emitter.on("change", this.onValueUpdate_);
    this.value = config.value;
    this.update_();
  }
  get graphElement() {
    return this.svgElem_;
  }
  update_() {
    const bounds = this.svgElem_.getBoundingClientRect();
    const maxIndex = this.value.rawValue.length - 1;
    const min = this.props_.get("min");
    const max = this.props_.get("max");
    const points = [];
    this.value.rawValue.forEach((v, index) => {
      if (v === void 0) {
        return;
      }
      const x = mapRange(index, 0, maxIndex, 0, bounds.width);
      const y2 = mapRange(v, min, max, bounds.height, 0);
      points.push([x, y2].join(","));
    });
    this.lineElem_.setAttributeNS(null, "points", points.join(" "));
    const tooltipElem = this.tooltipElem_;
    const value = this.value.rawValue[this.cursor_.rawValue];
    if (value === void 0) {
      tooltipElem.classList.remove(cn("t", "a"));
      return;
    }
    const tx = mapRange(this.cursor_.rawValue, 0, maxIndex, 0, bounds.width);
    const ty = mapRange(value, min, max, bounds.height, 0);
    tooltipElem.style.left = `${tx}px`;
    tooltipElem.style.top = `${ty}px`;
    tooltipElem.textContent = `${this.formatter_(value)}`;
    if (!tooltipElem.classList.contains(cn("t", "a"))) {
      tooltipElem.classList.add(cn("t", "a"), cn("t", "in"));
      forceReflow(tooltipElem);
      tooltipElem.classList.remove(cn("t", "in"));
    }
  }
  onValueUpdate_() {
    this.update_();
  }
  onCursorChange_() {
    this.update_();
  }
}
class GraphLogController7 {
  constructor(doc, config) {
    this.onGraphMouseMove_ = this.onGraphMouseMove_.bind(this);
    this.onGraphMouseLeave_ = this.onGraphMouseLeave_.bind(this);
    this.onGraphPointerDown_ = this.onGraphPointerDown_.bind(this);
    this.onGraphPointerMove_ = this.onGraphPointerMove_.bind(this);
    this.onGraphPointerUp_ = this.onGraphPointerUp_.bind(this);
    this.props = config.props;
    this.value = config.value;
    this.viewProps = config.viewProps;
    this.cursor_ = createValue(-1);
    this.view = new GraphLogView7(doc, {
      cursor: this.cursor_,
      formatter: config.formatter,
      rows: config.rows,
      props: this.props,
      value: this.value,
      viewProps: this.viewProps,
    });
    if (!supportsTouch(doc)) {
      this.view.element.addEventListener("mousemove", this.onGraphMouseMove_);
      this.view.element.addEventListener("mouseleave", this.onGraphMouseLeave_);
    } else {
      const ph = new PointerHandler7(this.view.element);
      ph.emitter.on("down", this.onGraphPointerDown_);
      ph.emitter.on("move", this.onGraphPointerMove_);
      ph.emitter.on("up", this.onGraphPointerUp_);
    }
  }
  importProps(state) {
    return importBladeState(
      state,
      null,
      (p) => ({
        max: p.required.number,
        min: p.required.number,
      }),
      (result) => {
        this.props.set("max", result.max);
        this.props.set("min", result.min);
        return true;
      },
    );
  }
  exportProps() {
    return exportBladeState(null, {
      max: this.props.get("max"),
      min: this.props.get("min"),
    });
  }
  onGraphMouseLeave_() {
    this.cursor_.rawValue = -1;
  }
  onGraphMouseMove_(ev) {
    const bounds = this.view.element.getBoundingClientRect();
    this.cursor_.rawValue = Math.floor(
      mapRange(ev.offsetX, 0, bounds.width, 0, this.value.rawValue.length),
    );
  }
  onGraphPointerDown_(ev) {
    this.onGraphPointerMove_(ev);
  }
  onGraphPointerMove_(ev) {
    if (!ev.data.point) {
      this.cursor_.rawValue = -1;
      return;
    }
    this.cursor_.rawValue = Math.floor(
      mapRange(
        ev.data.point.x,
        0,
        ev.data.bounds.width,
        0,
        this.value.rawValue.length,
      ),
    );
  }
  onGraphPointerUp_() {
    this.cursor_.rawValue = -1;
  }
}
function createFormatter(params) {
  return !isEmpty(params.format) ? params.format : createNumberFormatter(2);
}
function createTextMonitor(args) {
  var _a;
  if (args.value.rawValue.length === 1) {
    return new SingleLogController7(args.document, {
      formatter: createFormatter(args.params),
      value: args.value,
      viewProps: args.viewProps,
    });
  }
  return new MultiLogController7(args.document, {
    formatter: createFormatter(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants.monitor.defaultRows,
    value: args.value,
    viewProps: args.viewProps,
  });
}
function createGraphMonitor(args) {
  var _a, _b, _c;
  return new GraphLogController7(args.document, {
    formatter: createFormatter(args.params),
    rows:
      (_a = args.params.rows) !== null && _a !== void 0
        ? _a
        : Constants.monitor.defaultRows,
    props: ValueMap7.fromObject({
      max: (_b = args.params.max) !== null && _b !== void 0 ? _b : 100,
      min: (_c = args.params.min) !== null && _c !== void 0 ? _c : 0,
    }),
    value: args.value,
    viewProps: args.viewProps,
  });
}
function shouldShowGraph(params) {
  return params.view === "graph";
}
createPlugin({
  id: "monitor-number",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "number") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      format: p.optional.function,
      max: p.optional.number,
      min: p.optional.number,
      readonly: p.required.constant(true),
      rows: p.optional.number,
      view: p.optional.string,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    defaultBufferSize: (params) => (shouldShowGraph(params) ? 64 : 1),
    reader: (_args) => numberFromUnknown,
  },
  controller: (args) => {
    if (shouldShowGraph(args.params)) {
      return createGraphMonitor(args);
    }
    return createTextMonitor(args);
  },
  api: (args) => {
    if (args.controller.valueController instanceof GraphLogController7) {
      return new GraphLogMonitorBindingApi7(args.controller);
    }
    return null;
  },
});
createPlugin({
  id: "monitor-string",
  type: "monitor",
  accept: (value, params) => {
    if (typeof value !== "string") {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      multiline: p.optional.boolean,
      readonly: p.required.constant(true),
      rows: p.optional.number,
    }));
    return result
      ? {
          initialValue: value,
          params: result,
        }
      : null;
  },
  binding: {
    reader: (_args) => stringFromUnknown,
  },
  controller: (args) => {
    var _a;
    const value = args.value;
    const multiline = value.rawValue.length > 1 || args.params.multiline;
    if (multiline) {
      return new MultiLogController7(args.document, {
        formatter: formatString,
        rows:
          (_a = args.params.rows) !== null && _a !== void 0
            ? _a
            : Constants.monitor.defaultRows,
        value,
        viewProps: args.viewProps,
      });
    }
    return new SingleLogController7(args.document, {
      formatter: formatString,
      value,
      viewProps: args.viewProps,
    });
  },
});
class LinearDrawerProvider {
  constructor() {
    this.drawer = (point) => `L ${point[0]} ${point[1]}`;
  }
}
class CubicBézierDrawerProvider {
  constructor() {
    this.drawer = (point, index, points) => {
      const [cpsX, cpsY] = this.controlPoint(
        points[index - 1],
        points[index - 2],
        point,
      );
      const [cpeX, cpeY] = this.controlPoint(
        point,
        points[index - 1],
        points[index + 1],
        true,
      );
      return `C ${cpsX},${cpsY} ${cpeX},${cpeY} ${point[0]},${point[1]}`;
    };
  }
  controlPoint(current, previous, next, reverse) {
    const a = previous || current;
    const b = next || current;
    const smoothing = 0.2;
    const lenX = b[0] - a[0];
    const lenY = b[1] - a[1];
    const length = Math.sqrt(Math.pow(lenX, 2) + Math.pow(lenY, 2)) * smoothing;
    const angle = Math.atan2(lenY, lenX) + (reverse ? Math.PI : 0);
    const x = current[0] + Math.cos(angle) * length;
    const y2 = current[1] + Math.sin(angle) * length;
    return [x, y2];
  }
}
const className = ClassName("wfm");
class WaveformView {
  constructor(doc, config) {
    this.element = doc.createElement("div");
    this.element.classList.add(className());
    config.viewProps.bindClassModifiers(this.element);
    this.svgElem = doc.createElementNS(SVG_NS, "svg");
    this.svgElem.classList.add(className("g"));
    this.element.appendChild(this.svgElem);
    this.pathElem = doc.createElementNS(SVG_NS, "path");
    this.svgElem.appendChild(this.pathElem);
    this.props = config.props;
    this.value = config.value;
    this.value.emitter.on("change", this.onValueChange_.bind(this));
    switch (this.props.get("lineStyle")) {
      case "linear":
        this.lineDrawerProvider = new LinearDrawerProvider();
        break;
      case "bezier":
        this.lineDrawerProvider = new CubicBézierDrawerProvider();
        break;
      default:
        this.lineDrawerProvider = new LinearDrawerProvider();
        break;
    }
    this.refresh();
    config.viewProps.handleDispose(() => {
      this.value.emitter.off("change", this.onValueChange_);
    });
  }
  svgPath(points, drawer) {
    const d = points.reduce(
      (acc, point, i, a) =>
        i === 0 ? `M ${point[0]},${point[1]}` : `${acc} ${drawer(point, i, a)}`,
      "",
    );
    return d;
  }
  refresh() {
    var _a, _b;
    const bounds = this.svgElem.getBoundingClientRect();
    const latestValue = this.value.rawValue[0];
    if (latestValue) {
      const min =
        (_a = this.props.get("min")) !== null && _a !== void 0
          ? _a
          : Math.min(...latestValue) - 1;
      const max =
        (_b = this.props.get("max")) !== null && _b !== void 0
          ? _b
          : Math.max(...latestValue) + 1;
      const range = max - min;
      const points = [];
      const maxIndex = latestValue.length - 1;
      const gridWidth =
        latestValue.length > 32 ? 0 : bounds.width / (latestValue.length - 1);
      const gridHeight = range > 50 ? 0 : bounds.height / range;
      this.element.style.backgroundSize = `${gridWidth}px ${gridHeight}px`;
      latestValue.forEach((v, index) => {
        if (v === void 0) {
          return;
        }
        const x = mapRange(index, 0, maxIndex, 0, bounds.width);
        const y2 = mapRange(v, min, max, bounds.height, 0);
        points.push([Math.floor(x), Math.floor(y2)]);
      });
      const d = this.svgPath(points, this.lineDrawerProvider.drawer);
      this.pathElem.setAttributeNS(null, "d", d);
    }
  }
  onValueChange_() {
    this.refresh();
  }
}
class WaveformController {
  constructor(doc, config) {
    this.value = config.value;
    this.props = config.props;
    this.viewProps = config.viewProps;
    this.viewProps.handleDispose(() => {});
    this.view = new WaveformView(doc, {
      value: this.value,
      viewProps: this.viewProps,
      props: this.props,
    });
  }
}
function shouldShowWaveform(params) {
  return "view" in params && params.view === "waveform";
}
function isWaveformType(value) {
  if (typeof value === "object") {
    return "length" in value;
  }
  return false;
}
createPlugin({
  id: "monitor-waveform",
  type: "monitor",
  accept: (value, params) => {
    if (!isWaveformType(value)) {
      return null;
    }
    const result = parseRecord(params, (p) => ({
      max: p.optional.number,
      min: p.optional.number,
      style: p.optional.custom((value2) =>
        value2 === "linear" || value2 === "bezier" ? value2 : void 0,
      ),
      view: p.optional.string,
    }));
    return result ? { initialValue: value, params: result } : null;
  },
  binding: {
    defaultBufferSize: (params) => (shouldShowWaveform(params) ? 64 : 1),
    reader: (_args) => (exValue) => {
      if (isWaveformType(exValue)) {
        return exValue;
      }
      return [];
    },
  },
  controller: (args) => {
    var _a, _b, _c;
    return new WaveformController(args.document, {
      props: ValueMap7.fromObject({
        max:
          (_a = "max" in args.params ? args.params.max : null) !== null &&
          _a !== void 0
            ? _a
            : null,
        min:
          (_b = "min" in args.params ? args.params.min : null) !== null &&
          _b !== void 0
            ? _b
            : null,
        lineStyle:
          (_c = "style" in args.params ? args.params.style : null) !== null &&
          _c !== void 0
            ? _c
            : "linear",
      }),
      value: args.value,
      viewProps: args.viewProps,
    });
  },
});
let tickSpeed = writable(1);
const DEG2RAD = Math.PI / 180;
const gridSize = 20;
const Grid = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $$unsubscribe_tickSpeed;
  let $cameraPositionX, $$unsubscribe_cameraPositionX;
  let $cameraPositionY, $$unsubscribe_cameraPositionY;
  let $cameraPositionZ, $$unsubscribe_cameraPositionZ;
  $$unsubscribe_tickSpeed = subscribe(tickSpeed, (value) => value);
  let { renderer } = $$props;
  let camera;
  let cameraPositionX = tweened(-110, { duration: 2e3 });
  $$unsubscribe_cameraPositionX = subscribe(
    cameraPositionX,
    (value) => ($cameraPositionX = value),
  );
  let cameraPositionY = tweened(90, { duration: 2e3 });
  $$unsubscribe_cameraPositionY = subscribe(
    cameraPositionY,
    (value) => ($cameraPositionY = value),
  );
  let cameraPositionZ = tweened(20, { duration: 2e3 });
  $$unsubscribe_cameraPositionZ = subscribe(
    cameraPositionZ,
    (value) => ($cameraPositionZ = value),
  );
  let resizeCanvasToDisplaySize = () => {
    const canvas = renderer;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    if (canvas.width !== width || canvas.height !== height) {
      renderer.setSize(width, height, false);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      console.log("resize");
    }
  };
  const noise = createNoise3D();
  const geometry = new PlaneGeometry(gridSize, gridSize, gridSize, 30);
  let ticker = 0;
  function updateVertexHeights(time, speed) {
    const vertices = geometry.getAttribute("position").array;
    for (let i = 0; i < vertices.length; i += 3) {
      const x = vertices[i];
      const y2 = vertices[i + 1];
      vertices[i + 2];
      const nse =
        noise(x / 5, y2 / 5, time / 5) * 2 +
        noise(x / 40, y2 / 40, time / 40) * 3;
      vertices[i + 2] = nse;
    }
    geometry.computeVertexNormals();
    geometry.attributes.position.needsUpdate = true;
  }
  updateVertexHeights(ticker);
  useFrame((a) => {
    ticker += 0.01;
    updateVertexHeights(ticker);
    resizeCanvasToDisplaySize();
  });
  interactivity();
  new Vector3$1();
  tweened(0, { easing: quadOut });
  if ($$props.renderer === void 0 && $$bindings.renderer && renderer !== void 0)
    $$bindings.renderer(renderer);
  let $$settled;
  let $$rendered;
  let previous_head = $$result.head;
  do {
    $$settled = true;
    $$result.head = previous_head;
    $$rendered = `${validate_component(
      T.PerspectiveCamera,
      "T.PerspectiveCamera",
    ).$$render(
      $$result,
      {
        makeDefault: true,
        position: [$cameraPositionX, $cameraPositionY, $cameraPositionZ],
        fov: 15,
        this: camera,
      },
      {
        this: ($$value) => {
          camera = $$value;
          $$settled = false;
        },
      },
      {
        default: () => {
          return `${validate_component(
            OrbitControls2,
            "OrbitControls",
          ).$$render(
            $$result,
            {
              autoRotate: true,
              "target.y": 1.5,
              autoRotateSpeed: 0.2,
            },
            {},
            {},
          )}`;
        },
      },
    )} ${validate_component(T.AmbientLight, "T.AmbientLight").$$render($$result, { intensity: 0.5 }, {}, {})} ${validate_component(
      T.Mesh,
      "T.Mesh",
    ).$$render(
      $$result,
      { geometry, "rotation.x": DEG2RAD * -90 },
      {},
      {
        default: () => {
          return `${validate_component(
            T.LineBasicMaterial,
            "T.LineBasicMaterial",
          ).$$render(
            $$result,
            {
              color: colors.indigo[600],
              wireframe: true,
            },
            {},
            {},
          )} `;
        },
      },
    )}`;
  } while (!$$settled);
  $$unsubscribe_tickSpeed();
  $$unsubscribe_cameraPositionX();
  $$unsubscribe_cameraPositionY();
  $$unsubscribe_cameraPositionZ();
  return $$rendered;
});
const createRapierContext = (...args) => {
  const world = new RAPIER.World(...args);
  const colliderObjects = /* @__PURE__ */ new Map();
  const rigidBodyObjects = /* @__PURE__ */ new Map();
  const rigidBodyEventDispatchers = /* @__PURE__ */ new Map();
  const colliderEventDispatchers = /* @__PURE__ */ new Map();
  const addColliderToContext = (collider, object, eventDispatcher) => {
    colliderObjects.set(collider.handle, object);
    colliderEventDispatchers.set(collider.handle, eventDispatcher);
  };
  const removeColliderFromContext = (collider) => {
    colliderObjects.delete(collider.handle);
    colliderEventDispatchers.delete(collider.handle);
  };
  const addRigidBodyToContext = (rigidBody, object, eventDispatcher) => {
    rigidBodyObjects.set(rigidBody.handle, object);
    rigidBodyEventDispatchers.set(rigidBody.handle, eventDispatcher);
  };
  const removeRigidBodyFromContext = (rigidBody) => {
    rigidBodyObjects.delete(rigidBody.handle);
    rigidBodyEventDispatchers.delete(rigidBody.handle);
  };
  const pause = () => {};
  const resume = () => {};
  return {
    rapier: RAPIER,
    world,
    colliderObjects,
    rigidBodyObjects,
    rigidBodyEventDispatchers,
    colliderEventDispatchers,
    addColliderToContext,
    removeColliderFromContext,
    addRigidBodyToContext,
    removeRigidBodyFromContext,
    debug: writable(false),
    pause,
    resume,
    paused: readable(false),
  };
};
const tempObject = new Object3D();
const tempVector3 = new Vector3$1();
const tempQuaternion = new Quaternion$1();
const getEventDispatchers = (ctx, collider1, collider2) => {
  const colliderDispatcher1 = ctx.colliderEventDispatchers.get(
    collider1.handle,
  );
  const colliderDispatcher2 = ctx.colliderEventDispatchers.get(
    collider2.handle,
  );
  const rigidBody1 = collider1.parent();
  const rigidBody2 = collider2.parent();
  const rigidBodyDispatcher1 = rigidBody1
    ? ctx.rigidBodyEventDispatchers.get(rigidBody1.handle)
    : void 0;
  const rigidBodyDispatcher2 = rigidBody2
    ? ctx.rigidBodyEventDispatchers.get(rigidBody2.handle)
    : void 0;
  return {
    colliderDispatcher1,
    colliderDispatcher2,
    rigidBodyDispatcher1,
    rigidBodyDispatcher2,
  };
};
const useFrameHandler = (ctx, stage) => {
  const eventQueue = new EventQueue(false);
  const { start, started, stop } = useTask(
    (delta) => {
      const { world } = ctx;
      world.timestep = Math.min(0.1, delta);
      world.step(eventQueue);
      ctx.rigidBodyObjects.forEach((mesh, handle) => {
        const rigidBody = world.getRigidBody(handle);
        if (!rigidBody) return;
        const dispatcher = ctx.rigidBodyEventDispatchers.get(handle);
        if (!rigidBody || !rigidBody.isValid()) return;
        if (dispatcher) {
          if (rigidBody.isSleeping() && !mesh.userData.isSleeping) {
            dispatcher("sleep");
          }
          if (!rigidBody.isSleeping() && mesh.userData.isSleeping) {
            dispatcher("wake");
          }
          mesh.userData.isSleeping = rigidBody.isSleeping();
        }
        if (
          !rigidBody ||
          rigidBody.isSleeping() ||
          rigidBody.isFixed() ||
          !mesh.parent
        ) {
          return;
        }
        const { x, y: y2, z } = rigidBody.translation();
        tempObject.position.set(x, y2, z);
        const rotation = rigidBody.rotation();
        tempQuaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
        tempObject.rotation.setFromQuaternion(tempQuaternion);
        mesh.getWorldScale(tempVector3);
        tempObject.scale.copy(tempVector3);
        tempObject.updateMatrix();
        tempObject.applyMatrix4(mesh.parent.matrixWorld.clone().invert());
        tempObject.updateMatrix();
        mesh.position.setFromMatrixPosition(tempObject.matrix);
        mesh.rotation.setFromRotationMatrix(tempObject.matrix);
      });
      eventQueue.drainContactForceEvents((e) => {
        const collider1 = world.getCollider(e.collider1());
        const collider2 = world.getCollider(e.collider2());
        if (!collider1 || !collider2) {
          return;
        }
        const {
          colliderDispatcher1,
          colliderDispatcher2,
          rigidBodyDispatcher1,
          rigidBodyDispatcher2,
        } = getEventDispatchers(ctx, collider1, collider2);
        const rigidBody1 = collider1.parent();
        const rigidBody2 = collider2.parent();
        colliderDispatcher1?.("contact", {
          targetCollider: collider2,
          targetRigidBody: rigidBody2,
          maxForceDirection: e.maxForceDirection(),
          maxForceMagnitude: e.maxForceMagnitude(),
          totalForce: e.totalForce(),
          totalForceMagnitude: e.totalForceMagnitude(),
        });
        colliderDispatcher2?.("contact", {
          targetCollider: collider1,
          targetRigidBody: rigidBody1,
          maxForceDirection: e.maxForceDirection(),
          maxForceMagnitude: e.maxForceMagnitude(),
          totalForce: e.totalForce(),
          totalForceMagnitude: e.totalForceMagnitude(),
        });
        rigidBodyDispatcher1?.("contact", {
          targetCollider: collider2,
          targetRigidBody: rigidBody2,
          maxForceDirection: e.maxForceDirection(),
          maxForceMagnitude: e.maxForceMagnitude(),
          totalForce: e.totalForce(),
          totalForceMagnitude: e.totalForceMagnitude(),
        });
        rigidBodyDispatcher2?.("contact", {
          targetCollider: collider1,
          targetRigidBody: rigidBody1,
          maxForceDirection: e.maxForceDirection(),
          maxForceMagnitude: e.maxForceMagnitude(),
          totalForce: e.totalForce(),
          totalForceMagnitude: e.totalForceMagnitude(),
        });
      });
      eventQueue.drainCollisionEvents((handle1, handle2, started2) => {
        const collider1 = world.getCollider(handle1);
        const collider2 = world.getCollider(handle2);
        if (!collider1 || !collider2) {
          return;
        }
        const {
          colliderDispatcher1,
          colliderDispatcher2,
          rigidBodyDispatcher1,
          rigidBodyDispatcher2,
        } = getEventDispatchers(ctx, collider1, collider2);
        if (
          !colliderDispatcher1 &&
          !colliderDispatcher2 &&
          !rigidBodyDispatcher1 &&
          !rigidBodyDispatcher2
        ) {
          return;
        }
        const rigidBody1 = collider1.parent();
        const rigidBody2 = collider2.parent();
        if (started2) {
          const isIntersection = world.intersectionPair(collider1, collider2);
          if (isIntersection) {
            colliderDispatcher1?.("sensorenter", {
              targetCollider: collider2,
              targetRigidBody: rigidBody2,
            });
            colliderDispatcher2?.("sensorenter", {
              targetCollider: collider1,
              targetRigidBody: rigidBody1,
            });
            rigidBodyDispatcher1?.("sensorenter", {
              targetCollider: collider2,
              targetRigidBody: rigidBody2,
            });
            rigidBodyDispatcher2?.("sensorenter", {
              targetCollider: collider1,
              targetRigidBody: rigidBody1,
            });
            return;
          }
          world.contactPair(collider1, collider2, (manifold, flipped) => {
            colliderDispatcher1?.("collisionenter", {
              flipped,
              manifold,
              targetCollider: collider2,
              targetRigidBody: rigidBody2,
            });
            colliderDispatcher2?.("collisionenter", {
              flipped,
              manifold,
              targetCollider: collider1,
              targetRigidBody: rigidBody1,
            });
            rigidBodyDispatcher1?.("collisionenter", {
              flipped,
              manifold,
              targetCollider: collider2,
              targetRigidBody: rigidBody2,
            });
            rigidBodyDispatcher2?.("collisionenter", {
              flipped,
              manifold,
              targetCollider: collider1,
              targetRigidBody: rigidBody1,
            });
          });
        } else {
          const isIntersection =
            world.intersectionPair(collider1, collider2) ||
            collider1.isSensor() ||
            collider2.isSensor();
          if (isIntersection) {
            colliderDispatcher1?.("sensorexit", {
              targetCollider: collider2,
              targetRigidBody: rigidBody2,
            });
            colliderDispatcher2?.("sensorexit", {
              targetCollider: collider1,
              targetRigidBody: rigidBody1,
            });
            rigidBodyDispatcher1?.("sensorexit", {
              targetCollider: collider2,
              targetRigidBody: rigidBody2,
            });
            rigidBodyDispatcher2?.("sensorexit", {
              targetCollider: collider1,
              targetRigidBody: rigidBody1,
            });
            return;
          }
          colliderDispatcher1?.("collisionexit", {
            targetCollider: collider2,
            targetRigidBody: rigidBody2,
          });
          colliderDispatcher2?.("collisionexit", {
            targetCollider: collider1,
            targetRigidBody: rigidBody1,
          });
          rigidBodyDispatcher1?.("collisionexit", {
            targetCollider: collider2,
            targetRigidBody: rigidBody2,
          });
          rigidBodyDispatcher2?.("collisionexit", {
            targetCollider: collider1,
            targetRigidBody: rigidBody1,
          });
        }
      });
    },
    { stage },
  );
  ctx.pause = () => stop();
  ctx.resume = () => start();
  ctx.paused = derived(started, (started2) => !started2);
};
const InnerWorld = create_ssr_component(
  ($$result, $$props, $$bindings, slots) => {
    let { gravity = [0, -9.81, 0] } = $$props;
    let { rawIntegrationParameters = void 0 } = $$props;
    let { rawIslands = void 0 } = $$props;
    let { rawBroadPhase = void 0 } = $$props;
    let { rawNarrowPhase = void 0 } = $$props;
    let { rawBodies = void 0 } = $$props;
    let { rawColliders = void 0 } = $$props;
    let { rawImpulseJoints = void 0 } = $$props;
    let { rawMultibodyJoints = void 0 } = $$props;
    let { rawCCDSolver = void 0 } = $$props;
    let { rawQueryPipeline = void 0 } = $$props;
    let { rawPhysicsPipeline = void 0 } = $$props;
    let { rawSerializationPipeline = void 0 } = $$props;
    let { rawDebugRenderPipeline = void 0 } = $$props;
    let { stage = void 0 } = $$props;
    const rapierContext = createRapierContext(
      {
        x: gravity[0],
        y: gravity[1],
        z: gravity[2],
      },
      rawIntegrationParameters,
      rawIslands,
      rawBroadPhase,
      rawNarrowPhase,
      rawBodies,
      rawColliders,
      rawImpulseJoints,
      rawMultibodyJoints,
      rawCCDSolver,
      rawQueryPipeline,
      rawPhysicsPipeline,
      rawSerializationPipeline,
      rawDebugRenderPipeline,
    );
    setContext("threlte-rapier-context", rapierContext);
    useFrameHandler(rapierContext, stage);
    onDestroy(async () => {
      await tick();
      rapierContext.world.free();
    });
    if ($$props.gravity === void 0 && $$bindings.gravity && gravity !== void 0)
      $$bindings.gravity(gravity);
    if (
      $$props.rawIntegrationParameters === void 0 &&
      $$bindings.rawIntegrationParameters &&
      rawIntegrationParameters !== void 0
    )
      $$bindings.rawIntegrationParameters(rawIntegrationParameters);
    if (
      $$props.rawIslands === void 0 &&
      $$bindings.rawIslands &&
      rawIslands !== void 0
    )
      $$bindings.rawIslands(rawIslands);
    if (
      $$props.rawBroadPhase === void 0 &&
      $$bindings.rawBroadPhase &&
      rawBroadPhase !== void 0
    )
      $$bindings.rawBroadPhase(rawBroadPhase);
    if (
      $$props.rawNarrowPhase === void 0 &&
      $$bindings.rawNarrowPhase &&
      rawNarrowPhase !== void 0
    )
      $$bindings.rawNarrowPhase(rawNarrowPhase);
    if (
      $$props.rawBodies === void 0 &&
      $$bindings.rawBodies &&
      rawBodies !== void 0
    )
      $$bindings.rawBodies(rawBodies);
    if (
      $$props.rawColliders === void 0 &&
      $$bindings.rawColliders &&
      rawColliders !== void 0
    )
      $$bindings.rawColliders(rawColliders);
    if (
      $$props.rawImpulseJoints === void 0 &&
      $$bindings.rawImpulseJoints &&
      rawImpulseJoints !== void 0
    )
      $$bindings.rawImpulseJoints(rawImpulseJoints);
    if (
      $$props.rawMultibodyJoints === void 0 &&
      $$bindings.rawMultibodyJoints &&
      rawMultibodyJoints !== void 0
    )
      $$bindings.rawMultibodyJoints(rawMultibodyJoints);
    if (
      $$props.rawCCDSolver === void 0 &&
      $$bindings.rawCCDSolver &&
      rawCCDSolver !== void 0
    )
      $$bindings.rawCCDSolver(rawCCDSolver);
    if (
      $$props.rawQueryPipeline === void 0 &&
      $$bindings.rawQueryPipeline &&
      rawQueryPipeline !== void 0
    )
      $$bindings.rawQueryPipeline(rawQueryPipeline);
    if (
      $$props.rawPhysicsPipeline === void 0 &&
      $$bindings.rawPhysicsPipeline &&
      rawPhysicsPipeline !== void 0
    )
      $$bindings.rawPhysicsPipeline(rawPhysicsPipeline);
    if (
      $$props.rawSerializationPipeline === void 0 &&
      $$bindings.rawSerializationPipeline &&
      rawSerializationPipeline !== void 0
    )
      $$bindings.rawSerializationPipeline(rawSerializationPipeline);
    if (
      $$props.rawDebugRenderPipeline === void 0 &&
      $$bindings.rawDebugRenderPipeline &&
      rawDebugRenderPipeline !== void 0
    )
      $$bindings.rawDebugRenderPipeline(rawDebugRenderPipeline);
    if ($$props.stage === void 0 && $$bindings.stage && stage !== void 0)
      $$bindings.stage(stage);
    {
      if (gravity !== void 0) {
        rapierContext.world.gravity = {
          x: gravity[0],
          y: gravity[1],
          z: gravity[2],
        };
      }
    }
    return `${slots.default ? slots.default({}) : ``}`;
  },
);
const initialized = writable(false);
const World = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let $initialized, $$unsubscribe_initialized;
  $$unsubscribe_initialized = subscribe(
    initialized,
    (value) => ($initialized = value),
  );
  let { gravity = void 0 } = $$props;
  let { rawIntegrationParameters = void 0 } = $$props;
  let { rawIslands = void 0 } = $$props;
  let { rawBroadPhase = void 0 } = $$props;
  let { rawNarrowPhase = void 0 } = $$props;
  let { rawBodies = void 0 } = $$props;
  let { rawColliders = void 0 } = $$props;
  let { rawImpulseJoints = void 0 } = $$props;
  let { rawMultibodyJoints = void 0 } = $$props;
  let { rawCCDSolver = void 0 } = $$props;
  let { rawQueryPipeline = void 0 } = $$props;
  let { rawPhysicsPipeline = void 0 } = $$props;
  let { rawSerializationPipeline = void 0 } = $$props;
  let { rawDebugRenderPipeline = void 0 } = $$props;
  let { stage = void 0 } = $$props;
  if ($$props.gravity === void 0 && $$bindings.gravity && gravity !== void 0)
    $$bindings.gravity(gravity);
  if (
    $$props.rawIntegrationParameters === void 0 &&
    $$bindings.rawIntegrationParameters &&
    rawIntegrationParameters !== void 0
  )
    $$bindings.rawIntegrationParameters(rawIntegrationParameters);
  if (
    $$props.rawIslands === void 0 &&
    $$bindings.rawIslands &&
    rawIslands !== void 0
  )
    $$bindings.rawIslands(rawIslands);
  if (
    $$props.rawBroadPhase === void 0 &&
    $$bindings.rawBroadPhase &&
    rawBroadPhase !== void 0
  )
    $$bindings.rawBroadPhase(rawBroadPhase);
  if (
    $$props.rawNarrowPhase === void 0 &&
    $$bindings.rawNarrowPhase &&
    rawNarrowPhase !== void 0
  )
    $$bindings.rawNarrowPhase(rawNarrowPhase);
  if (
    $$props.rawBodies === void 0 &&
    $$bindings.rawBodies &&
    rawBodies !== void 0
  )
    $$bindings.rawBodies(rawBodies);
  if (
    $$props.rawColliders === void 0 &&
    $$bindings.rawColliders &&
    rawColliders !== void 0
  )
    $$bindings.rawColliders(rawColliders);
  if (
    $$props.rawImpulseJoints === void 0 &&
    $$bindings.rawImpulseJoints &&
    rawImpulseJoints !== void 0
  )
    $$bindings.rawImpulseJoints(rawImpulseJoints);
  if (
    $$props.rawMultibodyJoints === void 0 &&
    $$bindings.rawMultibodyJoints &&
    rawMultibodyJoints !== void 0
  )
    $$bindings.rawMultibodyJoints(rawMultibodyJoints);
  if (
    $$props.rawCCDSolver === void 0 &&
    $$bindings.rawCCDSolver &&
    rawCCDSolver !== void 0
  )
    $$bindings.rawCCDSolver(rawCCDSolver);
  if (
    $$props.rawQueryPipeline === void 0 &&
    $$bindings.rawQueryPipeline &&
    rawQueryPipeline !== void 0
  )
    $$bindings.rawQueryPipeline(rawQueryPipeline);
  if (
    $$props.rawPhysicsPipeline === void 0 &&
    $$bindings.rawPhysicsPipeline &&
    rawPhysicsPipeline !== void 0
  )
    $$bindings.rawPhysicsPipeline(rawPhysicsPipeline);
  if (
    $$props.rawSerializationPipeline === void 0 &&
    $$bindings.rawSerializationPipeline &&
    rawSerializationPipeline !== void 0
  )
    $$bindings.rawSerializationPipeline(rawSerializationPipeline);
  if (
    $$props.rawDebugRenderPipeline === void 0 &&
    $$bindings.rawDebugRenderPipeline &&
    rawDebugRenderPipeline !== void 0
  )
    $$bindings.rawDebugRenderPipeline(rawDebugRenderPipeline);
  if ($$props.stage === void 0 && $$bindings.stage && stage !== void 0)
    $$bindings.stage(stage);
  $$unsubscribe_initialized();
  return `${
    $initialized
      ? `${validate_component(InnerWorld, "InnerWorld").$$render(
          $$result,
          {
            gravity,
            rawIntegrationParameters,
            rawIslands,
            rawBroadPhase,
            rawNarrowPhase,
            rawBodies,
            rawColliders,
            rawImpulseJoints,
            rawMultibodyJoints,
            rawCCDSolver,
            rawQueryPipeline,
            rawPhysicsPipeline,
            rawSerializationPipeline,
            rawDebugRenderPipeline,
            stage,
          },
          {},
          {
            default: () => {
              return `${slots.default ? slots.default({}) : ``}`;
            },
          },
        )}`
      : ``
  } ${``}`;
});
new Vector3$1();
new Euler$1();
new Vector3$1();
({
  dynamic: RigidBodyType.Dynamic,
  fixed: RigidBodyType.Fixed,
  kinematicPosition: RigidBodyType.KinematicPositionBased,
  kinematicVelocity: RigidBodyType.KinematicVelocityBased,
});
new Euler$1();
new Vector3$1();
new Vector3$1();
new Vector3$1();
new Vector3$1();
new Vector3$1();
const Layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  let title;
  let description;
  let $metadata, $$unsubscribe_metadata;
  let $toast, $$unsubscribe_toast;
  $$unsubscribe_metadata = subscribe(metadata, (value) => ($metadata = value));
  $$unsubscribe_toast = subscribe(toast, (value) => ($toast = value));
  let renderer;
  let $$settled;
  let $$rendered;
  let previous_head = $$result.head;
  do {
    $$settled = true;
    $$result.head = previous_head;
    title = ($metadata.title ? $metadata.title + " | " : "") + site.name;
    description = site.description;
    $metadata.title;
    $$rendered = `${(($$result.head += `<!-- HEAD_svelte-1lvwc9d_START -->${(($$result.title = `<title>${escape$1(title)}</title>`), "")}<meta name="description"${add_attribute("content", description, 0)}><!-- HEAD_svelte-1lvwc9d_END -->`), "")} <div class="flex h-full flex-col"><header>${validate_component(Navbar_1, "Navbar").$$render($$result, {}, {}, {})}</header> <main class="flex grow max-h-full w-full bg-dotted-spacing-6 bg-dotted-primary-700 bg-dotted-radius-0.1"><div class="w-full md:min-w-96 md:w-2/3 lg:w-1/2" style="max-height: 100%">${slots.default ? slots.default({}) : ``} ${
      $toast?.text
        ? `${validate_component(Toast, "Toast").$$render(
            $$result,
            {
              class: "absolute bottom-2.5 left-1/2 mb-4 -translate-x-1/2",
            },
            {},
            {
              default: () => {
                return `${
                  $toast.icon === "ExclamationCircleOutline"
                    ? `${validate_component(
                        ExclamationCircleOutline,
                        "ExclamationCircleOutline",
                      ).$$render(
                        $$result,
                        {
                          slot: "icon",
                          class:
                            "h-5 w-5 bg-primary-100 text-primary-500 dark:bg-primary-800 dark:text-primary-200",
                        },
                        {},
                        {},
                      )}`
                    : `${
                        $toast.icon === "FireOutline"
                          ? `${validate_component(
                              FireOutline,
                              "FireOutline",
                            ).$$render(
                              $$result,
                              {
                                slot: "icon",
                                class:
                                  "h-5 w-5 bg-primary-100 text-primary-500 dark:bg-primary-800 dark:text-primary-200",
                              },
                              {},
                              {},
                            )}`
                          : ``
                      }`
                } ${escape$1($toast.text)}`;
              },
            },
          )}`
        : ``
    }</div> <div class="hidden md:block flex h-full flex-col items-center justify-center lg:aspect-square" style="max-width: 50%;">${validate_component(
      Canvas,
      "Canvas",
    ).$$render(
      $$result,
      { id: "canvas", this: renderer },
      {
        this: ($$value) => {
          renderer = $$value;
          $$settled = false;
        },
      },
      {
        default: () => {
          return `${validate_component(World, "World").$$render(
            $$result,
            {},
            {},
            {
              default: () => {
                return `${validate_component(Grid, "TestScene").$$render($$result, { renderer }, {}, {})}`;
              },
            },
          )}`;
        },
      },
    )}</div></main> ${validate_component(Footer, "Footer").$$render(
      $$result,
      { class: "flex justify-center" },
      {},
      {
        default: () => {
          return `${validate_component(
            FooterLinkGroup,
            "FooterLinkGroup",
          ).$$render(
            $$result,
            {
              ulClass:
                "flex flex-wrap items-center text-sm text-gray-500 dark:text-gray-400 sm:mt-0",
            },
            {},
            {
              default: () => {
                return `${validate_component(FooterLink, "FooterLink").$$render(
                  $$result,
                  { href: `${base}` },
                  {},
                  {
                    default: () => {
                      return `Home`;
                    },
                  },
                )} ${validate_component(FooterLink, "FooterLink").$$render(
                  $$result,
                  { href: `${base}/projects}` },
                  {},
                  {
                    default: () => {
                      return `Projects`;
                    },
                  },
                )} ${validate_component(FooterLink, "FooterLink").$$render(
                  $$result,
                  { href: `${base}/about}` },
                  {},
                  {
                    default: () => {
                      return `About`;
                    },
                  },
                )} ${validate_component(FooterLink, "FooterLink").$$render(
                  $$result,
                  { href: `${base}/contact}` },
                  {},
                  {
                    default: () => {
                      return `Contact`;
                    },
                  },
                )}`;
              },
            },
          )}`;
        },
      },
    )} </div>`;
  } while (!$$settled);
  $$unsubscribe_metadata();
  $$unsubscribe_toast();
  return $$rendered;
});
export { Layout as default };
